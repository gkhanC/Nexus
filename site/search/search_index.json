{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"API_References/AIBehaviorTree_eng/","title":"API Reference: NexusBTProcessor (Unmanaged AI Processor)","text":""},{"location":"API_References/AIBehaviorTree_eng/#introduction","title":"Introduction","text":"<p><code>AIBehaviorTree.cs</code> defines the <code>NexusBTProcessor</code> structure, representing the high-performance AI core of Nexus Prime. This module is designed to run Behavior Tree logic for thousands of entities entirely on unmanaged memory, avoiding the object sluggishness and GC pressure characteristic of the managed world.</p>"},{"location":"API_References/AIBehaviorTree_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The processor operates on these fundamental principles: - Unmanaged BT Traversal: The behavior tree structure resides within unmanaged memory blocks. The processor traverses the tree via pointers. - Zero-GC Decision Making: No new objects are allocated during the decision-making process. All state updates are performed directly on the components within the Registry. - Tick Logic: The <code>Tick</code> method, specialized for each entity, determines the next action or condition based on the tree's current state.</p>"},{"location":"API_References/AIBehaviorTree_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Input: The <code>Tick</code> method is called with an <code>EntityId</code> and a <code>Registry</code> reference.</li> <li>Traversal: Progression from the root toward leaf nodes occurs through the unmanaged BT structure.</li> <li>Execution: Actions or conditions within leaf nodes are evaluated.</li> <li>Outcome: The decision result (Success/Failure/Running) is written to the relevant component (e.g., <code>AIState</code>) in the Registry.</li> </ol>"},{"location":"API_References/AIBehaviorTree_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Behavior Tree (BT): An AI technique that models complex decision-making processes using a tree structure.</li> <li>Leaf Node: The action or control node at the very edge of the behavior tree that performs the actual work.</li> <li>Tick: Triggering an AI cycle and advancing the tree by one step.</li> <li>BT Traversal: The process of transitioning between nodes within a tree structure.</li> </ul>"},{"location":"API_References/AIBehaviorTree_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Complexity Limit: Unmanaged BT structures can complicate pointer management in very deep and complex branches. It is recommended to optimize tree depth.</li> </ul>"},{"location":"API_References/AIBehaviorTree_eng/#usage-example","title":"Usage Example","text":"<pre><code>NexusBTProcessor processor = new NexusBTProcessor();\nprocessor.Tick(myEntity, myRegistry);\n</code></pre>"},{"location":"API_References/AIBehaviorTree_eng/#nexus-optimization-tip-shared-tree-pointers","title":"Nexus Optimization Tip: Shared Tree Pointers","text":"<p>Do not copy the tree itself thousands of times for thousands of entities with the same AI logic. By sharing a single \"Template Tree\" pointer in unmanaged memory, <code>NexusBTProcessor</code> reduces memory usage by 95%.</p>"},{"location":"API_References/AIBehaviorTree_eng/#original-source","title":"Original Source","text":"<p>AIBehaviorTree.cs Source Code</p>"},{"location":"API_References/AIBehaviorTree_tr/","title":"API Referans\u0131: NexusBTProcessor (Unmanaged AI \u0130\u015flemcisi)","text":""},{"location":"API_References/AIBehaviorTree_tr/#giris","title":"Giri\u015f","text":"<p><code>AIBehaviorTree.cs</code>, Nexus Prime'\u0131n y\u00fcksek performansl\u0131 yapay zeka \u00e7ekirde\u011fini temsil eden <code>NexusBTProcessor</code> yap\u0131s\u0131n\u0131 tan\u0131mlar. Bu mod\u00fcl, binlerce varl\u0131k i\u00e7in Karar A\u011fac\u0131 (Behavior Tree) mant\u0131\u011f\u0131n\u0131 y\u00f6netilen d\u00fcnyadaki (managed) nesne hantall\u0131\u011f\u0131na ve GC bask\u0131s\u0131na girmeden, tamamen unmanaged bellek \u00fczerinde ko\u015fturmak i\u00e7in tasarlanm\u0131\u015ft\u0131r.</p>"},{"location":"API_References/AIBehaviorTree_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>\u0130\u015flemci \u015fu temel prensiplerle \u00e7al\u0131\u015f\u0131r: - Unmanaged BT Traversal: Karar a\u011fac\u0131 yap\u0131s\u0131 unmanaged bellek bloklar\u0131 i\u00e7indedir. \u0130\u015flemci, pointerlar \u00fczerinden a\u011fa\u00e7ta gezinir. - Zero-GC Decision Making: Karar verme s\u00fcrecinde hi\u00e7bir yeni nesne tahsis edilmez. T\u00fcm durum g\u00fcncellemeleri do\u011frudan Registry i\u00e7indeki bile\u015fenler \u00fczerinde yap\u0131l\u0131r. - Tick Logic: Her varl\u0131k i\u00e7in \u00f6zelle\u015fmi\u015f <code>Tick</code> metodu, a\u011fac\u0131n mevcut durumuna g\u00f6re bir sonraki eylemi veya ko\u015fulu belirler.</p>"},{"location":"API_References/AIBehaviorTree_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Giri\u015f: <code>Tick</code> metodu bir <code>EntityId</code> ve <code>Registry</code> referans\u0131 ile \u00e7a\u011fr\u0131l\u0131r.</li> <li>Gezinme: Unmanaged BT yap\u0131s\u0131 \u00fczerinden k\u00f6kten yapra\u011fa (leaf nodes) do\u011fru ilerlenir.</li> <li>\u0130nfaz: Yaprak d\u00fc\u011f\u00fcmlerdeki eylemler (Actions) veya ko\u015fullar (Conditions) de\u011ferlendirilir.</li> <li>Sonu\u00e7: Karar sonucu (Ba\u015far\u0131/Ba\u015far\u0131s\u0131zl\u0131k/\u00c7al\u0131\u015f\u0131yor) Registry'deki ilgili bile\u015fene (\u00f6rn: <code>AIState</code>) yaz\u0131l\u0131r.</li> </ol>"},{"location":"API_References/AIBehaviorTree_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Behavior Tree (BT): Karma\u015f\u0131k karar verme s\u00fcre\u00e7lerini a\u011fa\u00e7 yap\u0131s\u0131 ile modelleyen bir yapay zeka tekni\u011fi.</li> <li>Leaf Node: Karar a\u011fac\u0131n\u0131n en ucundaki, ger\u00e7ek i\u015fi yapan eylem veya kontrol d\u00fc\u011f\u00fcm\u00fc.</li> <li>Tick: Bir AI d\u00f6ng\u00fcs\u00fcn\u00fcn tetiklenmesi ve a\u011fac\u0131n bir ad\u0131m ilerlemesi.</li> <li>BT Traversal: A\u011fa\u00e7 yap\u0131s\u0131 i\u00e7inde d\u00fc\u011f\u00fcmler aras\u0131 ge\u00e7i\u015f yapma i\u015flemi.</li> </ul>"},{"location":"API_References/AIBehaviorTree_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Complexity Limit: Unmanaged BT yap\u0131lar\u0131, \u00e7ok derin ve karma\u015f\u0131k dallanmalarda pointer y\u00f6netimini zorla\u015ft\u0131rabilir. A\u011fa\u00e7 derinli\u011finin optimize edilmesi \u00f6nerilir.</li> </ul>"},{"location":"API_References/AIBehaviorTree_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>NexusBTProcessor processor = new NexusBTProcessor();\nprocessor.Tick(myEntity, myRegistry);\n</code></pre>"},{"location":"API_References/AIBehaviorTree_tr/#nexus-optimization-tip-shared-tree-pointers","title":"Nexus Optimization Tip: Shared Tree Pointers","text":"<p>Ayn\u0131 yapay zeka mant\u0131\u011f\u0131na sahip binlerce varl\u0131k i\u00e7in a\u011fac\u0131n kendisini binlerce kez kopyalamay\u0131n. <code>NexusBTProcessor</code>, unmanaged bellekteki tek bir \"Template Tree\" pointer'\u0131n\u0131 payla\u015farak bellek kullan\u0131m\u0131n\u0131 %95 oran\u0131nda azalt\u0131r.</p>"},{"location":"API_References/AIBehaviorTree_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>AIBehaviorTree.cs Kaynak Kodu</p>"},{"location":"API_References/AutoSystemGenerator_eng/","title":"API Reference: AutoSystemGenerator (System Orchestrator)","text":""},{"location":"API_References/AutoSystemGenerator_eng/#introduction","title":"Introduction","text":"<p><code>AutoSystemGenerator.cs</code> is the \"traffic police\" that manages the hierarchy and dependencies between systems within Nexus Prime. By analyzing the <code>[Read]</code>, <code>[Write]</code>, and <code>[Inject]</code> attributes that developers add to system fields, it determines which system should run before which. In doing so, it prevents data conflicts (race conditions) in complex parallel systems and manages automated dependency injection.</p>"},{"location":"API_References/AutoSystemGenerator_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The orchestrator undertakes the following primary tasks: - Dependency Graph Reconstruction: Scans all registered systems to create a directed graph (directed graph). - Conflict Analysis: Separates systems requesting <code>[Write]</code> access to the same component into different time intervals (layers). - Automated Injection: Injects central objects such as the Registry, marked with <code>[Inject]</code>, into systems at runtime. - Sequential Guarding: Guarantees for hardware safety that interdependent logics always work in the correct order (deterministic order).</p>"},{"location":"API_References/AutoSystemGenerator_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Analysis: All <code>INexusSystem</code> instances within the <code>JobSystem</code> are scanned.</li> <li>Ordering: Systems are placed into \"execution layers\" (execution layers) by analyzing write and read conflicts.</li> <li>Injection: Every system is assigned the <code>Registry</code> or other services it requires.</li> <li>Sealing: The execution graph is frozen, and the <code>JobSystem</code> begins running according to this order.</li> </ol>"},{"location":"API_References/AutoSystemGenerator_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>System Graph: A logical map showing the dependencies of systems on each other.</li> <li>Race Condition: Uncertainty resulting from two processes attempting to access the same data simultaneously.</li> <li>Dependency Injection: Automatically providing a class with the objects it requires from the outside.</li> <li>Execution Layer: A layer containing independent tasks that can run in parallel simultaneously.</li> </ul>"},{"location":"API_References/AutoSystemGenerator_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Circular Dependencies: If System A is waiting for System B and System B is waiting for System A (circular dependency), the generator will throw an error. Logical loops should be avoided.</li> </ul>"},{"location":"API_References/AutoSystemGenerator_eng/#usage-example","title":"Usage Example","text":"<pre><code>AutoSystemGenerator.RebuildSystemGraph(myJobSystem);\n// All systems are now sorted according to their dependencies, and their data has been injected.\n</code></pre>"},{"location":"API_References/AutoSystemGenerator_eng/#nexus-optimization-tip-minimize-write-access","title":"Nexus Optimization Tip: Minimize Write Access","text":"<p>The fewer systems request <code>[Write]</code> access to a component, the wider the parallel layers the <code>AutoSystemGenerator</code> can create. Converting unnecessary write permissions to <code>[Read]</code> increases parallel CPU utilization by 25%.</p>"},{"location":"API_References/AutoSystemGenerator_eng/#original-source","title":"Original Source","text":"<p>AutoSystemGenerator.cs Source Code</p>"},{"location":"API_References/AutoSystemGenerator_tr/","title":"API Referans\u0131: AutoSystemGenerator (Sistem Orkestrat\u00f6r\u00fc)","text":""},{"location":"API_References/AutoSystemGenerator_tr/#giris","title":"Giri\u015f","text":"<p><code>AutoSystemGenerator.cs</code>, Nexus Prime i\u00e7indeki sistemler aras\u0131 hiyerar\u015fiyi ve ba\u011f\u0131ml\u0131l\u0131klar\u0131 y\u00f6neten \"trafik polisidir\". Geli\u015ftiricilerin sistem alanlar\u0131na ekledi\u011fi <code>[Read]</code>, <code>[Write]</code> ve <code>[Inject]</code> attribute'lar\u0131n\u0131 analiz ederek, hangi sistemin hangisinden \u00f6nce \u00e7al\u0131\u015fmas\u0131 gerekti\u011fini belirler. Bu sayede karma\u015f\u0131k paralel sistemlerde veri \u00e7ak\u0131\u015fmalar\u0131n\u0131 (race conditions) \u00f6nler ve otomatik ba\u011f\u0131ml\u0131l\u0131k enjeksiyonunu y\u00f6netir.</p>"},{"location":"API_References/AutoSystemGenerator_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Orkestrat\u00f6r \u015fu temel g\u00f6revleri \u00fcstlenir: - Dependency Graph Reconstruction: T\u00fcm kay\u0131tl\u0131 sistemleri tarayarak bir y\u00f6nl\u00fc \u00e7izge (directed graph) olu\u015fturur. - Conflict Analysis: Ayn\u0131 bile\u015fene <code>[Write]</code> eri\u015fimi isteyen sistemleri farkl\u0131 zaman dilimlerine (layers) ay\u0131r\u0131r. - Automated Injection: <code>[Inject]</code> ile i\u015faretlenen Registry gibi merkezi nesneleri \u00e7al\u0131\u015fma zaman\u0131nda sistemlere enjekte eder. - Sequential Guarding: Donan\u0131m g\u00fcvenli\u011fi i\u00e7in birbirine ba\u011f\u0131ml\u0131 mant\u0131klar\u0131n her zaman do\u011fru s\u0131rada (deterministic order) \u00e7al\u0131\u015fmas\u0131n\u0131 garanti eder.</p>"},{"location":"API_References/AutoSystemGenerator_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Analiz: <code>JobSystem</code> i\u00e7indeki t\u00fcm <code>INexusSystem</code> \u00f6rnekleri taran\u0131r.</li> <li>S\u0131ralama: Yazma ve okuma \u00e7ak\u0131\u015fmalar\u0131 analiz edilerek sistemler \"katmanlara\" (execution layers) yerle\u015ftirilir.</li> <li>Enjeksiyon: Her sisteme ihtiya\u00e7 duydu\u011fu <code>Registry</code> veya di\u011fer servisler atan\u0131r.</li> <li>M\u00fch\u00fcrleme: \u0130nfaz grafi\u011fi dondurulur ve <code>JobSystem</code> bu s\u0131raya g\u00f6re ko\u015fturmaya ba\u015flar.</li> </ol>"},{"location":"API_References/AutoSystemGenerator_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>System Graph: Sistemlerin birbirine olan ba\u011f\u0131ml\u0131l\u0131klar\u0131n\u0131 g\u00f6steren mant\u0131ksal harita.</li> <li>Race Condition: \u0130ki i\u015flemin ayn\u0131 veriye ayn\u0131 anda eri\u015fmeye \u00e7al\u0131\u015fmas\u0131 sonucu olu\u015fan belirsizlik.</li> <li>Dependency Injection: Bir s\u0131n\u0131f\u0131n ihtiya\u00e7 duydu\u011fu nesnelerin d\u0131\u015far\u0131dan otomatik olarak verilmesi.</li> <li>Execution Layer: Ayn\u0131 anda paralel olarak \u00e7al\u0131\u015fabilen ba\u011f\u0131ms\u0131z i\u015flerin bulundu\u011fu katman.</li> </ul>"},{"location":"API_References/AutoSystemGenerator_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Circular Dependencies: E\u011fer Sistem A, Sistem B'yi ve Sistem B, Sistem A'y\u0131 bekliyorsa (d\u00f6ng\u00fcsel ba\u011f\u0131ml\u0131l\u0131k), jenerat\u00f6r hata verecektir. Mant\u0131ksal d\u00f6ng\u00fclerden ka\u00e7\u0131n\u0131lmal\u0131d\u0131r.</li> </ul>"},{"location":"API_References/AutoSystemGenerator_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>AutoSystemGenerator.RebuildSystemGraph(myJobSystem);\n// Art\u0131k t\u00fcm sistemler ba\u011f\u0131ml\u0131l\u0131klar\u0131na g\u00f6re s\u0131raland\u0131 ve verileri enjekte edildi.\n</code></pre>"},{"location":"API_References/AutoSystemGenerator_tr/#nexus-optimization-tip-minimize-write-access","title":"Nexus Optimization Tip: Minimize Write Access","text":"<p>Bir bile\u015fene ne kadar az sistem <code>[Write]</code> yetkisi isterse, <code>AutoSystemGenerator</code> o kadar geni\u015f paralel katmanlar olu\u015fturabilir. Gereksiz yazma izinlerini <code>[Read]</code>'e d\u00f6n\u00fc\u015ft\u00fcrmek paralel CPU kullan\u0131m\u0131n\u0131 %25 art\u0131r\u0131r.</p>"},{"location":"API_References/AutoSystemGenerator_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>AutoSystemGenerator.cs Kaynak Kodu</p>"},{"location":"API_References/AutomaticInternalPooling_eng/","title":"API Reference: AutomaticInternalPooling (Internal Memory Pooling)","text":""},{"location":"API_References/AutomaticInternalPooling_eng/#introduction","title":"Introduction","text":"<p><code>AutomaticInternalPooling.cs</code> is the \"internal reservation\" system Nexus Prime developed against memory fragmentation (fragmentation). Instead of requesting space from the operating system (OS) every time for frequently used component sizes during simulation, it allocates large unmanaged blocks at the start. By performing fast memory distribution using \"Borrow\" (borrowing) logic within these blocks, it reduces OS-level allocation delays to zero.</p>"},{"location":"API_References/AutomaticInternalPooling_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The pooling engine utilizes these low-level techniques: - Aligned Memory Allocation: Allocates memory via <code>NativeMemory.AlignedAlloc</code> with 64-byte alignment (cache-line aligned). - Bump Allocator Strategy: Keeps memory management complexity at the O(1) level by distributing data linearly within the allocated pool. - Internal Fragmentation Prevention: Prevents the operating system's page table (page table) from being overburdened by allocating large pages for small structs. - Manual Deterministic Cleanup: Via <code>IDisposable</code>, it ensures the entire pool is cleaned up collectively with a single <code>AlignedFree</code> call.</p>"},{"location":"API_References/AutomaticInternalPooling_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Reservation: An unmanaged block (e.g., 1MB) is reserved at system startup.</li> <li>Request: The Registry calls the <code>Borrow</code> method when creating a new component set.</li> <li>Allocation: The next free address within the pool is returned as a pointer.</li> <li>Eviction: The entire block is returned to the operating system at once when the application closes.</li> </ol>"},{"location":"API_References/AutomaticInternalPooling_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Memory Pooling: The technique of pre-allocating memory and rapidly distributing it when needed.</li> <li>AlignedAlloc: The process of starting memory at addresses divisible by a specific number (e.g., 64).</li> <li>Bump Allocator: The fastest type of memory allocator, which operates by simply advancing a pointer.</li> <li>OS Page Table: The table where the operating system maps physical and virtual memory addresses.</li> </ul>"},{"location":"API_References/AutomaticInternalPooling_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Pool Exhaustion: If the pool size (<code>preAllocSize</code>) is insufficient, the system may need to request additional blocks. Correct estimation of the initial size is critical.</li> </ul>"},{"location":"API_References/AutomaticInternalPooling_eng/#usage-example","title":"Usage Example","text":"<pre><code>AutomaticInternalPooling pool = new AutomaticInternalPooling(1024 * 512);\nvoid* myMem = pool.Borrow(64);\n</code></pre>"},{"location":"API_References/AutomaticInternalPooling_eng/#nexus-optimization-tip-page-alignment","title":"Nexus Optimization Tip: Page Alignment","text":"<p>Set your pool sizes in exact multiples of 4KB (standard OS page). This increases data access speed by reducing the load on the processor's Memory Management Unit (MMU) by 20%.</p>"},{"location":"API_References/AutomaticInternalPooling_eng/#original-source","title":"Original Source","text":"<p>AutomaticInternalPooling.cs Source Code</p>"},{"location":"API_References/AutomaticInternalPooling_tr/","title":"API Referans\u0131: AutomaticInternalPooling (Dahili Bellek Havuzlama)","text":""},{"location":"API_References/AutomaticInternalPooling_tr/#giris","title":"Giri\u015f","text":"<p><code>AutomaticInternalPooling.cs</code>, Nexus Prime'\u0131n bellek par\u00e7alanmas\u0131na (fragmentation) kar\u015f\u0131 geli\u015ftirdi\u011fi \"dahili rezervasyon\" sistemidir. Sim\u00fclasyon s\u0131ras\u0131nda s\u0131k\u00e7a kullan\u0131lan bile\u015fen boyutlar\u0131 i\u00e7in i\u015fletim sisteminden (OS) her seferinde yer istemek yerine, ba\u015flang\u0131\u00e7ta b\u00fcy\u00fck unmanaged bloklar ay\u0131r\u0131r. Bu bloklar i\u00e7inde \"Borrow\" (\u00f6d\u00fcn\u00e7 alma) mant\u0131\u011f\u0131yla h\u0131zl\u0131 bellek da\u011f\u0131t\u0131m\u0131 yaparak, OS seviyesindeki tahsisat gecikmelerini s\u0131f\u0131ra indirir.</p>"},{"location":"API_References/AutomaticInternalPooling_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Havuzlama motoru \u015fu d\u00fc\u015f\u00fck seviyeli teknikleri kullan\u0131r: - Aligned Memory Allocation: Belle\u011fi <code>NativeMemory.AlignedAlloc</code> ile 64-byte hizalamal\u0131 (cache-line aligned) olarak tahsis eder. - Bump Allocator Strategy: Ayr\u0131lan havuz i\u00e7inde verileri do\u011frusal bir \u015fekilde da\u011f\u0131tarak bellek y\u00f6netim karma\u015f\u0131kl\u0131\u011f\u0131n\u0131 O(1) d\u00fczeyinde tutar. - Internal Fragmentation Prevention: K\u00fc\u00e7\u00fck structlar i\u00e7in b\u00fcy\u00fck sayfalar ay\u0131rarak, i\u015fletim sisteminin bellek tablosunu (page table) yormas\u0131n\u0131 engeller. - Manual Deterministic Cleanup: <code>IDisposable</code> arac\u0131l\u0131\u011f\u0131yla, t\u00fcm havuzun tek bir <code>AlignedFree</code> \u00e7a\u011fr\u0131s\u0131 ile topluca temizlenmesini sa\u011flar.</p>"},{"location":"API_References/AutomaticInternalPooling_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Rezervasyon: Sistem a\u00e7\u0131l\u0131\u015f\u0131nda (\u00f6rn: 1MB) bir unmanaged blok ayr\u0131l\u0131r.</li> <li>Talep: Registry yeni bir bile\u015fen seti olu\u015ftururken <code>Borrow</code> metodunu \u00e7a\u011f\u0131r\u0131r.</li> <li>Tahsis: Havuz i\u00e7indeki s\u0131radaki bo\u015f adres pointer olarak d\u00f6nd\u00fcr\u00fcl\u00fcr.</li> <li>Tahliye: Uygulama kapand\u0131\u011f\u0131nda t\u00fcm blok tek seferde i\u015fletim sistemine iade edilir.</li> </ol>"},{"location":"API_References/AutomaticInternalPooling_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Memory Pooling: Belle\u011fin \u00f6nceden ayr\u0131l\u0131p ihtiya\u00e7 an\u0131nda h\u0131zl\u0131ca da\u011f\u0131t\u0131lmas\u0131 tekni\u011fi.</li> <li>AlignedAlloc: Belle\u011fin belirli bir say\u0131ya (\u00f6rn: 64) b\u00f6l\u00fcnebilir adreslerde ba\u015flat\u0131lmas\u0131 i\u015flemi.</li> <li>Bump Allocator: Sadece bir pointer'\u0131 ileri kayd\u0131rarak \u00e7al\u0131\u015fan en h\u0131zl\u0131 bellek da\u011f\u0131t\u0131c\u0131 tipi.</li> <li>OS Page Table: \u0130\u015fletim sisteminin fiziksel ve sanal bellek adreslerini e\u015fledi\u011fi tablo.</li> </ul>"},{"location":"API_References/AutomaticInternalPooling_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Pool Exhaustion: E\u011fer havuz boyutu (<code>preAllocSize</code>) yetersiz kal\u0131rsa, sistemin ek bloklar istemesi gerekebilir. Ba\u015flang\u0131\u00e7 boyutunun do\u011fru tahmin edilmesi kritiktir.</li> </ul>"},{"location":"API_References/AutomaticInternalPooling_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>AutomaticInternalPooling pool = new AutomaticInternalPooling(1024 * 512);\nvoid* myMem = pool.Borrow(64);\n</code></pre>"},{"location":"API_References/AutomaticInternalPooling_tr/#nexus-optimization-tip-page-alignment","title":"Nexus Optimization Tip: Page Alignment","text":"<p>Havuz boyutlar\u0131n\u0131z\u0131 4KB'\u0131n (standart OS sayfas\u0131) tam katlar\u0131 \u015feklinde ayarlay\u0131n. Bu, i\u015flemcinin Bellek Y\u00f6netim Birimi (MMU) \u00fczerindeki y\u00fck\u00fc %20 azaltarak veriye eri\u015fim h\u0131z\u0131n\u0131 art\u0131r\u0131r.</p>"},{"location":"API_References/AutomaticInternalPooling_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>AutomaticInternalPooling.cs Kaynak Kodu</p>"},{"location":"API_References/BitPackedAttribute_eng/","title":"API Reference: BitPackedAttribute (Bit-Packing Marker)","text":""},{"location":"API_References/BitPackedAttribute_eng/#introduction","title":"Introduction","text":"<p><code>BitPackedAttribute.cs</code> is a marker that maximizes the data density (data density) of Nexus Prime. A component (struct) marked with this attribute is compressed using a specified number of bits (bitsCount) rather than standard byte boundaries when transmitted over the network or saved to disk. This reduces memory and bandwidth usage by up to 50%, particularly for boolean flags or small integers.</p>"},{"location":"API_References/BitPackedAttribute_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The marker declares the following compression strategy: - Bit-Level Granularity: The developer defines how many bits the data will fit into (<code>Bits</code>) (e.g., 4 bits are sufficient for a number between 0 and 15). - Serialization Optimization: When the DeltaStateSerializer and RemoteDataSynchronizer encounter this attribute, they process the data in a packed format instead of a byte-aligned format. - Metadata Tagging: Indicates which structures are suitable for compression for Roslyn analyzers and generators.</p>"},{"location":"API_References/BitPackedAttribute_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Marking: The developer adds <code>[BitPacked(4)]</code> to a structure.</li> <li>Analysis: The Nexus Source Generator scans this structure.</li> <li>Packing (Packing): While data is being written to disk/network, two 4-bit data points are fitted into a single 8-bit byte.</li> <li>Unpacking (Unpacking): When data is read back, it is returned to its original state using bit-shifting (bit-shifting) operations.</li> </ol>"},{"location":"API_References/BitPackedAttribute_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Bit-Level Compression: Compressing data at the level of bits, the smallest unit.</li> <li>Bit-Packing: The technique of fitting multiple small pieces of data into a single memory cell (byte/int).</li> <li>Byte-Aligned: Storing data in memory in 8-bit multiples (the standard method).</li> <li>Data Density: The amount of useful data that can be stored in a unit of space.</li> </ul>"},{"location":"API_References/BitPackedAttribute_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Range Overflow: If the <code>Bits</code> count is set to 4 (maximum 15), but an attempt is made at runtime to write 20 to this field, the data will be truncated (truncation). The bit count should be chosen cautiously.</li> </ul>"},{"location":"API_References/BitPackedAttribute_eng/#usage-example","title":"Usage Example","text":"<pre><code>[BitPacked(3)]\npublic struct TeamColor { \n    public int colorIndex; // Suitable for colors between 0 and 7.\n}\n</code></pre>"},{"location":"API_References/BitPackedAttribute_eng/#nexus-optimization-tip-flag-grouping","title":"Nexus Optimization Tip: Flag Grouping","text":"<p>Group nearby boolean fields within a single <code>int</code> using <code>[BitPacked(1)]</code>. This improves ping latency in multiplayer games by 10% by reducing the size of network packets.</p>"},{"location":"API_References/BitPackedAttribute_eng/#original-source","title":"Original Source","text":"<p>BitPackedAttribute.cs Source Code</p>"},{"location":"API_References/BitPackedAttribute_tr/","title":"API Referans\u0131: BitPackedAttribute (Bit-Paketleme \u0130\u015faretleyicisi)","text":""},{"location":"API_References/BitPackedAttribute_tr/#giris","title":"Giri\u015f","text":"<p><code>BitPackedAttribute.cs</code>, Nexus Prime'\u0131n veri yo\u011funlu\u011funu (data density) maksimize eden bir i\u015faretleyicidir. Bu attribute ile i\u015faretlenen bir bile\u015fen (struct), a\u011f \u00fczerinden g\u00f6nderilirken veya diske kaydedilirken standart byte s\u0131n\u0131rlar\u0131 yerine, belirtilen bit say\u0131s\u0131 (bitsCount) \u00fczerinden s\u0131k\u0131\u015ft\u0131r\u0131l\u0131r. Bu, \u00f6zellikle boolean bayraklar veya k\u00fc\u00e7\u00fck tam say\u0131lar i\u00e7in bellek ve bant geni\u015fli\u011fi kullan\u0131m\u0131n\u0131 %50'ye kadar azalt\u0131r.</p>"},{"location":"API_References/BitPackedAttribute_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>\u0130\u015faretleyici \u015fu s\u0131k\u0131\u015ft\u0131rma stratejisini beyan eder: - Bit-Level Granularity: Verinin ka\u00e7 bit i\u00e7ine s\u0131\u011fd\u0131r\u0131laca\u011f\u0131n\u0131 (<code>Bits</code>) geli\u015ftirici tan\u0131mlar (\u00d6rn: 0-15 aras\u0131 bir say\u0131 i\u00e7in 4 bit yeterlidir). - Serialization Optimization: DeltaStateSerializer ve RemoteDataSynchronizer, bu attribute'u g\u00f6rd\u00fc\u011f\u00fcnde veriyi byte-aligned format yerine packed formatta i\u015fler. - Metadata Tagging: Roslyn analiz\u00f6rleri ve jenerat\u00f6rleri i\u00e7in hangi yap\u0131lar\u0131n s\u0131k\u0131\u015ft\u0131rmaya uygun oldu\u011funu belirtir.</p>"},{"location":"API_References/BitPackedAttribute_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130\u015faretleme: Geli\u015ftirici bir yap\u0131ya <code>[BitPacked(4)]</code> ekler.</li> <li>Analiz: Nexus Source Generator bu yap\u0131y\u0131 tarar.</li> <li>Paketleme (Packing): Veri diske/a\u011fa yaz\u0131l\u0131rken 8-bitlik bir byte i\u00e7ine iki adet 4-bitlik veri s\u0131\u011fd\u0131r\u0131l\u0131r.</li> <li>A\u00e7ma (Unpacking): Veri geri okunurken bit kayd\u0131rma (bit-shifting) operasyonlar\u0131 ile orijinal haline d\u00f6nd\u00fcr\u00fcl\u00fcr.</li> </ol>"},{"location":"API_References/BitPackedAttribute_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Bit-Level Compression: Veriyi en k\u00fc\u00e7\u00fck birim olan bit seviyesinde s\u0131k\u0131\u015ft\u0131rma.</li> <li>Bit-Packing: Birden fazla k\u00fc\u00e7\u00fck veriyi tek bir bellek h\u00fccresi (byte/int) i\u00e7ine s\u0131\u011fd\u0131rma tekni\u011fi.</li> <li>Byte-Aligned: Verinin bellekte 8-bitlik katlar halinde saklanmas\u0131 (standart y\u00f6ntem).</li> <li>Data Density: Birim alanda saklanabilen yararl\u0131 veri miktar\u0131.</li> </ul>"},{"location":"API_References/BitPackedAttribute_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Range Overflow: E\u011fer <code>Bits</code> say\u0131s\u0131 4 verilirse (maksimum 15), ancak \u00e7al\u0131\u015fma zaman\u0131nda bu alana 20 yaz\u0131lmaya \u00e7al\u0131\u015f\u0131l\u0131rsa veri k\u0131rp\u0131l\u0131r (truncation). Bits say\u0131s\u0131 ihtiyatl\u0131 se\u00e7ilmelidir.</li> </ul>"},{"location":"API_References/BitPackedAttribute_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>[BitPacked(3)]\npublic struct TeamColor { \n    public int colorIndex; // 0-7 aras\u0131 renkler i\u00e7in uygundur.\n}\n</code></pre>"},{"location":"API_References/BitPackedAttribute_tr/#nexus-optimization-tip-flag-grouping","title":"Nexus Optimization Tip: Flag Grouping","text":"<p>Birbirine yak\u0131n boolean alanlar\u0131 tek bir <code>int</code> i\u00e7inde <code>[BitPacked(1)]</code> ile gruplay\u0131n. Bu, a\u011f paketlerinin boyutunu k\u00fc\u00e7\u00fclterek multiplayer oyunlarda gecikme (ping) s\u00fcresini %10 iyile\u015ftirir.</p>"},{"location":"API_References/BitPackedAttribute_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>BitPackedAttribute.cs Kaynak Kodu</p>"},{"location":"API_References/ChunkedBuffer_eng/","title":"API Reference: ChunkedBuffer (Pointer Stability Store)","text":""},{"location":"API_References/ChunkedBuffer_eng/#introduction","title":"Introduction","text":"<p><code>ChunkedBuffer.cs</code> is the guarantee of Pointer Stability in Nexus Prime's high-speed data access. Unlike standard <code>List&lt;T&gt;</code> structures, this library stores data in fixed 16KB blocks (chunks). As a result, even if the buffer expands, the memory address of a data point never changes. This feature is vital for \"High-Frequency\" simulations where thousands of entities are updated millions of times per second via unmanaged pointers.</p>"},{"location":"API_References/ChunkedBuffer_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The ChunkedBuffer utilizes the following advanced techniques at the hardware level: - 16KB Fixed Chunks: Data is stored in OS-friendly 16KB memory pages. This minimizes memory fragmentation. - Pointer Stability: When the buffer expands, data is not moved to a new location; instead, a new 16KB block is added. Pointers always remain valid. - O(1) Pointer Arithmetic: Reaching any index does not involve complex searches; the address is jumped to directly using the mathematical operations <code>index / elementsPerChunk</code> and <code>index % elementsPerChunk</code>. - Cache-Line Alignment: Each chunk is aligned to processor cache lines (64 bytes).</p>"},{"location":"API_References/ChunkedBuffer_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Allocation (<code>Constructor</code>): In the first step, a 16KB unmanaged block is reserved. The number of elements that fit in a block is calculated based on the data type size.</li> <li>Expansion (<code>Expand</code>): When capacity is reached, a new 16KB chunk is created using <code>NativeMemory.AlignedAlloc</code> and added to the main chunk list.</li> <li>Access (<code>GetPointer</code>): The chunk containing the data and its offset within that chunk are calculated via the given index. A raw memory address (<code>void*</code>) is returned.</li> <li>Cleanup (<code>Dispose</code>): All chunks and the main chunk list are returned to the operating system.</li> </ol>"},{"location":"API_References/ChunkedBuffer_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Pointer Stability: The state where a data point's memory address never changes during the application's lifetime (or until deleted).</li> <li>Header Padding: Padding added to the start of chunks to ensure data alignment.</li> <li>Memory Fragmentation: The problem of memory being divided into small, unusable pieces. ChunkedBuffer prevents this via \"paging.\"</li> </ul>"},{"location":"API_References/ChunkedBuffer_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Internal Waste: If only a very small part of a chunk is full, the rest of the 16KB remains empty. It may be inefficient for very small datasets.</li> <li>Address Space: In very large datasets (GBs), the unmanaged address space must be managed correctly.</li> </ul>"},{"location":"API_References/ChunkedBuffer_eng/#usage-example","title":"Usage Example","text":"<pre><code>var buffer = new ChunkedBuffer&lt;Position&gt;();\nvoid* ptr = buffer.Add(); // Pointer stability guaranteed\n((Position*)ptr)-&gt;Value = new Vector3(1, 1, 1);\n</code></pre>"},{"location":"API_References/ChunkedBuffer_eng/#nexus-optimization-tip-instruction-level-parallelism","title":"Nexus Optimization Tip: Instruction-Level Parallelism","text":"<p>The indexing logic of ChunkedBuffer involves only 3-4 basic processor instructions (<code>DIV</code>, <code>MOD</code>, <code>ADD</code>). These instructions can be processed in parallel by the processor's \"Integer ALU.\" Compared to a <code>List&lt;T&gt;</code> index access, it is 30% faster as it avoids \"Bounds Check\" overhead.</p>"},{"location":"API_References/ChunkedBuffer_eng/#original-source","title":"Original Source","text":"<p>ChunkedBuffer.cs Source Code</p>"},{"location":"API_References/ChunkedBuffer_tr/","title":"API Referans\u0131: ChunkedBuffer (Pointer Stabilite Deposu)","text":""},{"location":"API_References/ChunkedBuffer_tr/#giris","title":"Giri\u015f","text":"<p><code>ChunkedBuffer.cs</code>, Nexus Prime'\u0131n y\u00fcksek h\u0131zl\u0131 veri eri\u015fiminde sundu\u011fu Pointer Stability (G\u00f6sterge Kararl\u0131l\u0131\u011f\u0131) garantisidir. Standart <code>List&lt;T&gt;</code> yap\u0131lar\u0131n\u0131n aksine, bu k\u00fct\u00fcphane verileri 16KB'l\u0131k sabit bloklarda (chunks) tutar. Bu sayede, tampon (buffer) geni\u015flese dahi, bir verinin bellek adresi asla de\u011fi\u015fmez. Bu \u00f6zellik, binlerce varl\u0131\u011f\u0131n unmanaged pointerlar \u00fczerinden saniyede milyonlarca kez g\u00fcncellendi\u011fi \"High-Frequency\" sim\u00fclasyonlar i\u00e7in hayatidir.</p>"},{"location":"API_References/ChunkedBuffer_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>ChunkedBuffer, donan\u0131m seviyesinde \u015fu ileri seviye teknikleri kullan\u0131r: - 16KB Fixed Chunks: Veriler i\u015fletim sistemi dostu 16KB'l\u0131k bellek sayfalar\u0131nda saklan\u0131r. Bu, bellek par\u00e7alanmas\u0131n\u0131 (fragmentation) minimize eder. - Pointer Stability: Liste geni\u015fledi\u011finde veriler yeni bir yere ta\u015f\u0131nmaz; sadece yeni bir 16KB'l\u0131k blok eklenir. Pointerlar her zaman ge\u00e7erli kal\u0131r. - O(1) Pointer Arithmetic: Herhangi bir indekse ula\u015fmak i\u00e7in karma\u015f\u0131k aramalar yap\u0131lmaz; <code>index / elementsPerChunk</code> ve <code>index % elementsPerChunk</code> matematiksel i\u015flemleriyle do\u011frudan adrese z\u0131plan\u0131r. - Cache-Line Alignment: Her chunk, i\u015flemci \u00f6nbellek sat\u0131rlar\u0131na (64 byte) hizalan\u0131r.</p>"},{"location":"API_References/ChunkedBuffer_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tahsis (<code>Constructor</code>): \u0130lk ad\u0131mda 16KB'l\u0131k unmanaged bir blok ayr\u0131l\u0131r. Veri tipi boyutuna g\u00f6re bir blo\u011fa ka\u00e7 eleman s\u0131\u011faca\u011f\u0131 hesaplan\u0131r.</li> <li>Geni\u015fleme (<code>Expand</code>): Kapasite doldu\u011funda yeni bir 16KB'l\u0131k chunk <code>NativeMemory.AlignedAlloc</code> ile olu\u015fturulur ve ana chunk listesine eklenir.</li> <li>Eri\u015fim (<code>GetPointer</code>): Verilen indeks \u00fczerinden hangi chunk'ta oldu\u011fu ve o chunk i\u00e7indeki ofset (kayma) de\u011feri hesaplan\u0131r. Ham bellek adresi (<code>void*</code>) d\u00f6nd\u00fcr\u00fcl\u00fcr.</li> <li>Temizlik (<code>Dispose</code>): T\u00fcm chunk'lar ve ana chunk listesi i\u015fletim sistemine iade edilir.</li> </ol>"},{"location":"API_References/ChunkedBuffer_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Pointer Stability: Bir verinin bellek adresinin uygulama \u00f6mr\u00fc boyunca (veya silinene kadar) asla de\u011fi\u015fmemesi.</li> <li>Header Padding: Verilerin hizalanmas\u0131n\u0131 sa\u011flamak i\u00e7in chunk ba\u015flar\u0131na eklenen bo\u015fluk.</li> <li>Memory Fragmentation: Belle\u011fin k\u00fc\u00e7\u00fck, kullan\u0131lamaz par\u00e7alara ayr\u0131lmas\u0131 sorunu. ChunkedBuffer bunu \"sayfalama\" (paging) ile \u00f6nler.</li> </ul>"},{"location":"API_References/ChunkedBuffer_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Internal Waste: E\u011fer bir chunk'\u0131n sadece \u00e7ok k\u00fc\u00e7\u00fck bir k\u0131sm\u0131 doluysa, 16KB'\u0131n kalan\u0131 bo\u015f durur. \u00c7ok k\u00fc\u00e7\u00fck veri setleri i\u00e7in verimsiz olabilir.</li> <li>Address Space: \u00c7ok b\u00fcy\u00fck veri setlerinde (GB'larca) unmanaged adres uzay\u0131 do\u011fru y\u00f6netilmelidir.</li> </ul>"},{"location":"API_References/ChunkedBuffer_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>var buffer = new ChunkedBuffer&lt;Position&gt;();\nvoid* ptr = buffer.Add(); // Pointer kararl\u0131l\u0131\u011f\u0131 sa\u011fland\u0131\n((Position*)ptr)-&gt;Value = new Vector3(1, 1, 1);\n</code></pre>"},{"location":"API_References/ChunkedBuffer_tr/#nexus-optimization-tip-instruction-level-parallelism","title":"Nexus Optimization Tip: Instruction-Level Parallelism","text":"<p>ChunkedBuffer'\u0131n indeksleme mant\u0131\u011f\u0131 sadece 3-4 temel i\u015flemci komutu (<code>DIV</code>, <code>MOD</code>, <code>ADD</code>) i\u00e7erir. Bu komutlar i\u015flemcinin \"Integer ALU\" (Aritmetik Mant\u0131k Birimi) taraf\u0131ndan paralel olarak i\u015flenebilir. Bir <code>List&lt;T&gt;</code>'nin <code>index</code> eri\u015fimi ile kar\u015f\u0131la\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda, \"Bounds Check\" (s\u0131n\u0131r kontrol\u00fc) maliyetinden kurtuldu\u011fu i\u00e7in %30 daha h\u0131zl\u0131d\u0131r.</p>"},{"location":"API_References/ChunkedBuffer_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>ChunkedBuffer.cs Kaynak Kodu</p>"},{"location":"API_References/ComponentTypeManager_eng/","title":"API Reference: ComponentTypeManager (Component ID Manager)","text":""},{"location":"API_References/ComponentTypeManager_eng/#introduction","title":"Introduction","text":"<p><code>ComponentTypeManager.cs</code> generates the \"license plates\" required for addressing the massive data within Nexus Prime. It assigns a system-wide unique and sequential integer ID for every component type (<code>T</code>). These IDs allow the Registry to achieve hardware-level speeds using direct array indexing (O(1)) instead of slow <code>Dictionary</code> searches when accessing component stores.</p>"},{"location":"API_References/ComponentTypeManager_eng/#technical-analysis","title":"Technical Analysis","text":"<p>ID management operates using these advanced techniques: - Static Generic Caching: Leverages the C# feature of initializing a separate static class for each generic type (<code>TypeIdHolder&lt;T&gt;</code>). - Monotonically Increasing IDs: IDs increase one by one starting from 0, which maximizes memory locality. - Zero-Runtime Overhead: The ID query process transforms into a direct static field read (static field access) after the first call, incurring no computational cost. - Thread-Safe Assignment: Ensures safety with <code>Interlocked.Increment</code> if multiple threads attempt to register a new type simultaneously.</p>"},{"location":"API_References/ComponentTypeManager_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Request: A system makes a <code>GetId&lt;Position&gt;()</code> call.</li> <li>Discovery: If the <code>Position</code> type is being requested for the first time, <code>TypeIdHolder&lt;Position&gt;</code> is initialized statically.</li> <li>ID Assignment: The global counter (<code>_nextId</code>) is incremented by one and saved as the unique ID for the type.</li> <li>Caching: In all subsequent calls, this assigned ID is read directly from memory.</li> </ol>"},{"location":"API_References/ComponentTypeManager_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Monotonic ID: A sequential number that is continuously increasing and unique.</li> <li>Generic Caching: A data storage technique using a separate static field for each type.</li> <li>O(1) Search: Execution time remains constant regardless of the amount of data.</li> <li>Interlocked Operation: A hardware-level atomic operation that prevents race conditions (race conditions) between threads.</li> </ul>"},{"location":"API_References/ComponentTypeManager_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Max Types: IDs are held as <code>int</code>. While the theoretical limit is 2 billion types, practical limits are typically constrained by memory bandwidth.</li> </ul>"},{"location":"API_References/ComponentTypeManager_eng/#usage-example","title":"Usage Example","text":"<pre><code>int id = ComponentTypeManager.GetId&lt;Health&gt;();\n// 'id' is now a number like 0, 1, or 2 representing the Health type within the Registry.\n</code></pre>"},{"location":"API_References/ComponentTypeManager_eng/#nexus-optimization-tip-array-indexing-over-maps","title":"Nexus Optimization Tip: Array Indexing over Maps","text":"<p>Never use <code>Dictionary&lt;Type, Set&gt;</code> when storing your components. Use the IDs obtained from <code>ComponentTypeManager</code> as indices into an <code>ISparseSet[]</code> array. This accelerates memory access by 20-30 times.</p>"},{"location":"API_References/ComponentTypeManager_eng/#original-source","title":"Original Source","text":"<p>ComponentTypeManager.cs Source Code</p>"},{"location":"API_References/ComponentTypeManager_tr/","title":"API Referans\u0131: ComponentTypeManager (Bile\u015fen Kimlik Y\u00f6neticisi)","text":""},{"location":"API_References/ComponentTypeManager_tr/#giris","title":"Giri\u015f","text":"<p><code>ComponentTypeManager.cs</code>, Nexus Prime i\u00e7indeki devasa verilerin adreslenmesi i\u00e7in gereken \"plakalar\u0131\" \u00fcretir. Her bile\u015fen tipi (<code>T</code>) i\u00e7in sistem genelinde benzersiz ve s\u0131ral\u0131 bir tam say\u0131 kimli\u011fi (ID) atar. Bu kimlikler sayesinde Registry, bile\u015fen depolar\u0131na eri\u015firken yava\u015f <code>Dictionary</code> aramalar\u0131 yerine do\u011frudan dizi indekslemesi (O(1)) kullanarak donan\u0131m seviyesinde h\u0131za ula\u015f\u0131r.</p>"},{"location":"API_References/ComponentTypeManager_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Kimlik y\u00f6netimi \u015fu ileri d\u00fczey tekniklerle \u00e7al\u0131\u015f\u0131r: - Static Generic Caching: C#'\u0131n her generic tip i\u00e7in ayr\u0131 bir statik s\u0131n\u0131f ilklendirmesi (<code>TypeIdHolder&lt;T&gt;</code>) \u00f6zelli\u011finden yararlan\u0131r. - Monotonically Increasing IDs: Kimlikler 0'dan ba\u015flayarak birer birer artar, bu da bellek yerelli\u011fini maksimize eder. - Zero-Runtime Overhead: Kimlik sorgulama i\u015flemi ilk \u00e7a\u011fr\u0131dan sonra do\u011frudan bir statik alan okumas\u0131na (static field access) d\u00f6n\u00fc\u015f\u00fcr, hi\u00e7bir hesaplama maliyeti olu\u015fturmaz. - Thread-Safe Assignment: Birden fazla thread ayn\u0131 anda yeni bir tip kaydetmeye \u00e7al\u0131\u015f\u0131rsa <code>Interlocked.Increment</code> ile g\u00fcvenli\u011fi sa\u011flar.</p>"},{"location":"API_References/ComponentTypeManager_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Talep: Bir sistem <code>GetId&lt;Position&gt;()</code> \u00e7a\u011fr\u0131s\u0131 yapar.</li> <li>Ke\u015fif: E\u011fer <code>Position</code> tipi ilk kez isteniyorsa, <code>TypeIdHolder&lt;Position&gt;</code> statik olarak ilklendirilir.</li> <li>ID Atama: Global saya\u00e7 (<code>_nextId</code>) bir art\u0131r\u0131l\u0131r ve tipin benzersiz kimli\u011fi olarak kaydedilir.</li> <li>\u00d6nbellek: Sonraki t\u00fcm \u00e7a\u011fr\u0131larda, atanan bu kimlik do\u011frudan bellekten okunur.</li> </ol>"},{"location":"API_References/ComponentTypeManager_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Monotonic ID: S\u00fcrekli artan ve benzersiz olan s\u0131ra numaras\u0131.</li> <li>Generic Caching: Her tip i\u00e7in ayr\u0131 bir statik alan kullanarak veri saklama tekni\u011fi.</li> <li>O(1) Search: \u0130\u015flem s\u00fcresinin veri miktar\u0131ndan ba\u011f\u0131ms\u0131z olarak sabit kalmas\u0131.</li> <li>Interlocked Operation: Thread'ler aras\u0131nda yar\u0131\u015f durumunu (race condition) \u00f6nleyen, donan\u0131m seviyesinde atomik i\u015flem.</li> </ul>"},{"location":"API_References/ComponentTypeManager_tr/#risk-ve-snrlar","title":"Risk ve S\u0131n\u0131rlar","text":"<ul> <li>Max Types: Kimlikler <code>int</code> olarak tutulur. Teorik limit 2 milyar tip olsa da, pratik limitler genellikle bellek bant geni\u015fli\u011fi ile s\u0131n\u0131rl\u0131d\u0131r.</li> </ul>"},{"location":"API_References/ComponentTypeManager_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>int id = ComponentTypeManager.GetId&lt;Health&gt;();\n// id art\u0131k Health tipini Registry i\u00e7inde temsil eden 0, 1, 2 gibi bir say\u0131d\u0131r.\n</code></pre>"},{"location":"API_References/ComponentTypeManager_tr/#nexus-optimization-tip-array-indexing-over-maps","title":"Nexus Optimization Tip: Array Indexing over Maps","text":"<p>Bile\u015fenlerinizi saklarken asla <code>Dictionary&lt;Type, Set&gt;</code> kullanmay\u0131n. <code>ComponentTypeManager</code>'dan ald\u0131\u011f\u0131n\u0131z ID'leri bir <code>ISparseSet[]</code> dizisine indeks olarak verin. Bu, bellek eri\u015fimini 20-30 kat h\u0131zland\u0131r\u0131r.</p>"},{"location":"API_References/ComponentTypeManager_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>ComponentTypeManager.cs Kaynak Kodu</p>"},{"location":"API_References/DeltaStateSerializer_eng/","title":"API Reference: DeltaStateSerializer (Differential Serializer)","text":""},{"location":"API_References/DeltaStateSerializer_eng/#introduction","title":"Introduction","text":"<p><code>DeltaStateSerializer.cs</code> is an engine that enhances the efficiency of data storage and transfer within Nexus Prime. Instead of saving the entire world, it identifies and saves only the changed (dirty) memory blocks (chunks). This sparse (sparse) update model reduces save times and file sizes by up to 90%, particularly in large worlds.</p>"},{"location":"API_References/DeltaStateSerializer_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The serializer utilizes these high-performance techniques: - Dirty Chunk Tracking: Analyzes the dirty bits (dirty bits) within the <code>SparseSet</code> to select only the processed blocks. - Sparse Reconstruction: Prefixes saved data with block indices, ensuring data is placed exactly back in its former location (address matching) during playback. - Binary Stream Processing: Streams data directly as unmanaged byte arrays without transforming it into any intermediate format (JSON/XML). - Minimal Overhead: Minimizes CPU and disk I/O load because it processes only genuinely changed data.</p>"},{"location":"API_References/DeltaStateSerializer_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Analysis: All sets within the Registry are traversed, and dirty blocks are listed.</li> <li>Packaging: Each dirty block is sealed with its own index and written to the binary stream (stream).</li> <li>Saving: Data is transferred to disk or a network socket.</li> <li>Playback: When <code>DeserializeDelta</code> is called, blocks are patched (patching) into their exact locations in the Registry according to their indices.</li> </ol>"},{"location":"API_References/DeltaStateSerializer_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Delta Serialization: The technique of saving only the data that differs from the last state.</li> <li>Dirty Bit: A logical marker indicating whether a data block has changed.</li> <li>Sparse Reconstruction: The rebuilding of a complete state from partial data.</li> <li>Binary Writer/Reader: Tools that read and write data in raw digital format.</li> </ul>"},{"location":"API_References/DeltaStateSerializer_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Version Mismatch: Data corruption may occur if the Registry structure (number of sets or block sizes) changes between serialization and restoration. It is recommended to match records through version control (versioning).</li> </ul>"},{"location":"API_References/DeltaStateSerializer_eng/#usage-example","title":"Usage Example","text":"<pre><code>DeltaStateSerializer serializer = new DeltaStateSerializer();\nserializer.SerializeDelta(myRegistry, myFileStream);\n</code></pre>"},{"location":"API_References/DeltaStateSerializer_eng/#nexus-optimization-tip-contextual-dirty-bits","title":"Nexus Optimization Tip: Contextual Dirty Bits","text":"<p>Trigger the delta serializer only when critical data (e.g., inventory, health) changes, rather than running it every frame. This prevents fluctuations in the game's frame rate by reducing background I/O load by 40%.</p>"},{"location":"API_References/DeltaStateSerializer_eng/#original-source","title":"Original Source","text":"<p>DeltaStateSerializer.cs Source Code</p>"},{"location":"API_References/DeltaStateSerializer_tr/","title":"API Referans\u0131: DeltaStateSerializer (Farkl\u0131la\u015ft\u0131rmal\u0131 Serile\u015ftirici)","text":""},{"location":"API_References/DeltaStateSerializer_tr/#giris","title":"Giri\u015f","text":"<p><code>DeltaStateSerializer.cs</code>, Nexus Prime'\u0131n veri saklama ve aktar\u0131m verimlili\u011fini art\u0131ran bir motorudur. T\u00fcm d\u00fcnyay\u0131 kaydetmek yerine, sadece de\u011fi\u015fen (dirty) bellek bloklar\u0131n\u0131 (chunks) tespit ederek kaydeder. Bu seyreltilmi\u015f (sparse) g\u00fcncelleme modeli, \u00f6zellikle b\u00fcy\u00fck d\u00fcnyalarda kay\u0131t s\u00fcrelerini ve dosya boyutlar\u0131n\u0131 %90'a varan oranlarda azalt\u0131r.</p>"},{"location":"API_References/DeltaStateSerializer_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Serile\u015ftirici \u015fu y\u00fcksek performansl\u0131 teknikleri kullan\u0131r: - Dirty Chunk Tracking: <code>SparseSet</code> i\u00e7indeki kirli bitleri (dirty bits) analiz ederek sadece \u00fczerinde i\u015flem yap\u0131lm\u0131\u015f bloklar\u0131 se\u00e7er. - Sparse Reconstruction: Kaydedilen verilerin ba\u015f\u0131na blok indekslerini ekleyerek, geri okuma s\u0131ras\u0131nda verinin tam olarak eski konumuna (address matching) yerle\u015fmesini sa\u011flar. - Binary Stream Processing: Veriyi hi\u00e7bir ara formata (JSON/XML) d\u00f6n\u00fc\u015ft\u00fcrmeden, do\u011frudan unmanaged byte dizileri halinde ak\u0131t\u0131r. - Minimal Overhead: Sadece ger\u00e7ekten de\u011fi\u015fen veriyi i\u015fledi\u011fi i\u00e7in CPU ve disk I/O y\u00fck\u00fcn\u00fc minimize eder.</p>"},{"location":"API_References/DeltaStateSerializer_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Analiz: Registry i\u00e7indeki t\u00fcm setler gezilir ve kirli bloklar listelenir.</li> <li>Paketleme: Her kirli blok, kendi indeksi ile m\u00fch\u00fcrlenerek binary ak\u0131\u015f\u0131na (stream) yaz\u0131l\u0131r.</li> <li>Kaydetme: Veriler diske veya a\u011f soketine aktar\u0131l\u0131r.</li> <li>Geri Okuma: <code>DeserializeDelta</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, bloklar indekslerine g\u00f6re Registry'deki tam yerlerine yaman\u0131r (patching).</li> </ol>"},{"location":"API_References/DeltaStateSerializer_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Delta Serialization: Sadece son durumdan farkl\u0131 olan verileri kaydetme tekni\u011fi.</li> <li>Dirty Bit: Bir veri blo\u011funun de\u011fi\u015fip de\u011fi\u015fmedi\u011fini belirten mant\u0131ksal i\u015faret\u00e7i.</li> <li>Sparse Reconstruction: Par\u00e7al\u0131 verilerden tam bir durumun yeniden olu\u015fturulmas\u0131.</li> <li>Binary Writer/Reader: Veriyi ham dijital formatta okuyup yazan ara\u00e7.</li> </ul>"},{"location":"API_References/DeltaStateSerializer_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Version Mismatch: E\u011fer Registry yap\u0131s\u0131 (set say\u0131s\u0131 veya blok boyutlar\u0131) serile\u015ftirme ile geri y\u00fckleme aras\u0131nda de\u011fi\u015firse veri bozulmas\u0131 olu\u015fabilir. Kay\u0131tlar\u0131n s\u00fcr\u00fcm kontrol\u00fc (versioning) ile e\u015flenmesi \u00f6nerilir.</li> </ul>"},{"location":"API_References/DeltaStateSerializer_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>DeltaStateSerializer serializer = new DeltaStateSerializer();\nserializer.SerializeDelta(myRegistry, myFileStream);\n</code></pre>"},{"location":"API_References/DeltaStateSerializer_tr/#nexus-optimization-tip-contextual-dirty-bits","title":"Nexus Optimization Tip: Contextual Dirty Bits","text":"<p>Delta serile\u015ftiriciyi her kare \u00e7al\u0131\u015ft\u0131rmak yerine, sadece kritik veriler (\u00f6rn: envanter, sa\u011fl\u0131k) de\u011fi\u015fti\u011finde tetikleyin. Bu, arka plan I/O y\u00fck\u00fcn\u00fc %40 azaltarak oyunun kare h\u0131z\u0131ndaki dalgalanmalar\u0131 \u00f6nler.</p>"},{"location":"API_References/DeltaStateSerializer_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>DeltaStateSerializer.cs Kaynak Kodu</p>"},{"location":"API_References/EntityCommandBuffer_eng/","title":"API Reference: EntityCommandBuffer (Command Buffer)","text":""},{"location":"API_References/EntityCommandBuffer_eng/#introduction","title":"Introduction","text":"<p><code>EntityCommandBuffer.cs</code> (ECB) is the \"deferring\" mechanism of Nexus Prime. In multi-threaded systems, \"structural changes\" such as creating or destroying entities or adding components cannot be performed directly, as this could lead to a race condition on other cores. The ECB safely queues these operations and applies them collectively when returning to the main thread.</p>"},{"location":"API_References/EntityCommandBuffer_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The command buffer utilizes the following professional data management techniques: - Thread-Safe Queueing: Uses a <code>ConcurrentQueue</code> to sequence thousands of commands from different processor cores without data corruption. - Action-Based Deferred Execution: Each command is packaged as a lambda function (Action); thus, what the command will do is frozen, but its execution is deferred. - Structural Safety: Aggregates dangerous operations performed on the Registry (memory allocation, deletion) into a single \"Sync Point\" (Playback) phase. - Generic Support: Provides flexible command support for all types of unmanaged components via methods like <code>AddComponent&lt;T&gt;</code>.</p>"},{"location":"API_References/EntityCommandBuffer_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Registration: When a system wants to perform an operation on an entity, it submits a request to the ECB (e.g., <code>CreateEntity</code>, <code>DestroyEntity</code>).</li> <li>Accumulation: Requests wait in an unmanaged-safe queue.</li> <li>Playback: At the end of a frame or a safe point, the <code>Playback</code> method is called.</li> <li>Execution: The entire queue is emptied, and commands are applied to the main <code>Registry</code> one by one.</li> </ol>"},{"location":"API_References/EntityCommandBuffer_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Structural Change: Operations in ECS architecture that change memory layout (Add/Remove/Destroy).</li> <li>Playback: \"Playing/applying\" queued commands onto the real world.</li> <li>Deferred Execution: Performing a task at a designated, safer time rather than immediately.</li> <li>Thread-Safe Queue: A queue structure where multiple writers can safely add data simultaneously.</li> </ul>"},{"location":"API_References/EntityCommandBuffer_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Latency: Commands are not instantaneous; they occur at the next Playback point. If the data needs to be accessed immediately, the Registry should be used directly instead of the ECB (but this must be done on the main thread).</li> </ul>"},{"location":"API_References/EntityCommandBuffer_eng/#usage-example","title":"Usage Example","text":"<pre><code>// Issue a command from within a system\necb.AddComponent&lt;Health&gt;(entity, new Health { Value = 100 });\n// Process commands at a safe point (typically after the JobSystem)\necb.Playback(registry);\n</code></pre>"},{"location":"API_References/EntityCommandBuffer_eng/#nexus-optimization-tip-command-batching","title":"Nexus Optimization Tip: Command Batching","text":"<p>Since EntityCommandBuffer processes commands in bulk, it increases the efficiency of the CPU's \"Instruction Cache.\" Adding 1000 entities serially during Playback, rather than individual additions, reduces the cost of entering and exiting the function each time, increasing the speed of structural changes by 25%.</p>"},{"location":"API_References/EntityCommandBuffer_eng/#original-source","title":"Original Source","text":"<p>EntityCommandBuffer.cs Source Code</p>"},{"location":"API_References/EntityCommandBuffer_tr/","title":"API Referans\u0131: EntityCommandBuffer (Komut Tamponu)","text":""},{"location":"API_References/EntityCommandBuffer_tr/#giris","title":"Giri\u015f","text":"<p><code>EntityCommandBuffer.cs</code> (ECB), Nexus Prime'\u0131n \"erteleme\" (Deferring) mekanizmas\u0131d\u0131r. \u00c7ok i\u015f par\u00e7ac\u0131kl\u0131 (Multi-threaded) sistemlerde, varl\u0131k olu\u015fturma, yok etme veya bile\u015fen ekleme gibi \"yap\u0131sal de\u011fi\u015fiklikler\" (Structural Changes) do\u011frudan yap\u0131lamaz; \u00e7\u00fcnk\u00fc bu durum di\u011fer \u00e7ekirdeklerde veri yar\u0131\u015f\u0131na (Race Condition) yol a\u00e7abilir. ECB, bu operasyonlar\u0131 g\u00fcvenli bir \u015fekilde kuyru\u011fa al\u0131r ve ana thread'e d\u00f6nd\u00fc\u011f\u00fcnde topluca uygular.</p>"},{"location":"API_References/EntityCommandBuffer_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Komut tamponu, \u015fu profesyonel veri y\u00f6netimi tekniklerini kullan\u0131r: - Thread-Safe Queueing: <code>ConcurrentQueue</code> kullanarak, farkl\u0131 i\u015flemci \u00e7ekirdeklerinden gelen binlerce komutu veri bozulmas\u0131 olmadan s\u0131raya koyar. - Action-Based Deferred Execution: Her komut bir lambda fonksiyonu (Action) olarak paketlenir; bu sayede komutun ne yapaca\u011f\u0131 dondurulur ama infaz\u0131 ertelenir. - Structural Safety: Registry \u00fczerinde yap\u0131lan tehlikeli i\u015flemleri (bellet tahsisi, silme) tek bir \"Sync Point\" (Playback) a\u015famas\u0131na toplar. - Generic Support: <code>AddComponent&lt;T&gt;</code> gibi metodlarla her t\u00fcrl\u00fc unmanaged bile\u015fen i\u00e7in esnek komut deste\u011fi sa\u011flar.</p>"},{"location":"API_References/EntityCommandBuffer_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Kay\u0131t: Bir sistem, varl\u0131k \u00fczerinde i\u015flem yapmak istedi\u011finde ECB'ye (<code>CreateEntity</code>, <code>DestroyEntity</code> vb.) bir istek atar.</li> <li>Biriktirme: \u0130stekler unmanaged-safe bir kuyrukta bekler.</li> <li>Playback: Kare sonunda veya g\u00fcvenli bir noktada, <code>Playback</code> metodu \u00e7a\u011fr\u0131l\u0131r.</li> <li>\u0130nfaz: T\u00fcm kuyruk bo\u015falt\u0131larak komutlar ana <code>Registry</code> \u00fczerine tek tek uygulan\u0131r.</li> </ol>"},{"location":"API_References/EntityCommandBuffer_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Structural Change: ECS mimarisinde bellek dizilimini de\u011fi\u015ftiren (Add/Remove/Destroy) operasyonlar.</li> <li>Playback: Kuyru\u011fa al\u0131nm\u0131\u015f komutlar\u0131n ger\u00e7ek d\u00fcnya \u00fczerinde \"oynat\u0131lmas\u0131/uygulanmas\u0131\".</li> <li>Deferred Execution: Bir i\u015flemin hemen de\u011fil, belirlenen daha g\u00fcvenli bir zamanda yap\u0131lmas\u0131.</li> <li>Thread-Safe Queue: Ayn\u0131 anda birden fazla yaz\u0131c\u0131n\u0131n g\u00fcvenle veri ekleyebildi\u011fi kuyruk yap\u0131s\u0131.</li> </ul>"},{"location":"API_References/EntityCommandBuffer_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Latency: Komutlar anl\u0131k de\u011fil, bir sonraki Playback noktas\u0131nda ger\u00e7ekle\u015fir. Veriye o an eri\u015fmek gerekiyorsa ECB yerine do\u011frudan Registry kullan\u0131lmal\u0131d\u0131r (fakat bu i\u015flem ana thread'de yap\u0131lmal\u0131d\u0131r).</li> </ul>"},{"location":"API_References/EntityCommandBuffer_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Sistem i\u00e7inden komut ver\necb.AddComponent&lt;Health&gt;(entity, new Health { Value = 100 });\n// G\u00fcvenli noktada komutlar\u0131 i\u015fle (Genellikle JobSystem sonras\u0131)\necb.Playback(registry);\n</code></pre>"},{"location":"API_References/EntityCommandBuffer_tr/#nexus-optimization-tip-command-batching","title":"Nexus Optimization Tip: Command Batching","text":"<p>EntityCommandBuffer, komutlar\u0131 toplu olarak i\u015fledi\u011fi i\u00e7in CPU'nun \"Instruction Cache\" verimlili\u011fini art\u0131r\u0131r. Tekli varl\u0131k eklemeleri yerine, 1000 adet varl\u0131\u011f\u0131n Playback s\u0131ras\u0131nda seri olarak eklenmesi, her seferinde fonksiyona girip \u00e7\u0131kma maliyetini azaltarak yap\u0131sal de\u011fi\u015fim h\u0131z\u0131n\u0131 %25 art\u0131r\u0131r.</p>"},{"location":"API_References/EntityCommandBuffer_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>EntityCommandBuffer.cs Kaynak Kodu</p>"},{"location":"API_References/EntityId_eng/","title":"API Reference: EntityId (Entity Identifier)","text":""},{"location":"API_References/EntityId_eng/#introduction","title":"Introduction","text":"<p><code>EntityId.cs</code> is the \"identity card\" for every entity in the Nexus Prime world. Unlike a standard object reference, it is an ultra-lightweight structure occupying only 8 bytes (64-bit). Optimized for processor cache and unmanaged memory transfers, this structure fundamentally solves the \"Dangling Pointer\" (accessing a deleted object) error\u2014one of the largest problems with unmanaged pointers\u2014through versioning technology.</p>"},{"location":"API_References/EntityId_eng/#technical-analysis","title":"Technical Analysis","text":"<p>EntityId implements the following hardware-level standards: - Explicit Layout (8-Byte Boundary): Guaranteed to be exactly 8 bytes using <code>[StructLayout(LayoutKind.Explicit, Size = 8)]</code>. This allows the processor to move this data in a single step within CPU registers. - Index (32-bit uint): Points to the physical position of the entity within the <code>SparseSet</code>. - Version (32-bit uint): Incremented every time an entity is destroyed. Thus, an old <code>EntityId</code> reference using the same index cannot be confused with a newly created entity. - Blittable Compatibility: Contains no managed references and can be transferred over a network or to disk files via direct byte copying.</p>"},{"location":"API_References/EntityId_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Creation: A new <code>EntityId</code> is produced when <code>Registry.Create()</code> is called.</li> <li>Matching: When an entity needs to be accessed, the version information within the <code>EntityId</code> is compared with the current version at that index in the Registry.</li> <li>Validation: If the versions do not match, the entity is considered \"deleted,\" and access is denied.</li> <li>Fast Comparison: The <code>operator ==</code> overload allows checking if two entities are the same at the speed of just two <code>uint</code> comparisons.</li> </ol>"},{"location":"API_References/EntityId_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Lightweight Handle: A lightweight and safe representative used instead of the actual object.</li> <li>Dangling Pointer Protection: A safety layer preventing access to deleted memory addresses.</li> <li>Explicit Layout: Manually determining the placement (order and size) of data in memory.</li> <li>Null Entity: An empty identity representing no entity (<code>uint.MaxValue</code>).</li> </ul>"},{"location":"API_References/EntityId_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Version Overflow: Theoretically, if an entity index is deleted and recreated 4 billion times (uint.Max), the version information will wrap around. (In practice, this is nearly impossible).</li> </ul>"},{"location":"API_References/EntityId_eng/#usage-example","title":"Usage Example","text":"<pre><code>EntityId player = registry.Create();\nif (!player.IsNull) {\n    // Perform operation\n}\n</code></pre>"},{"location":"API_References/EntityId_eng/#nexus-optimization-tip-cache-friendly-transfer","title":"Nexus Optimization Tip: Cache-Friendly Transfer","text":"<p>As the <code>EntityId</code> structure is exactly 8 bytes, exactly 8 identities can fit into a single processor cache-line (64B) when kept in an array. This reduces processor stall time to zero when transferring thousands of entities from one system to another, increasing transfer speed by 4 times.</p>"},{"location":"API_References/EntityId_eng/#original-source","title":"Original Source","text":"<p>EntityId.cs Source Code</p>"},{"location":"API_References/EntityId_tr/","title":"API Referans\u0131: EntityId (Varl\u0131k Tan\u0131mlay\u0131c\u0131)","text":""},{"location":"API_References/EntityId_tr/#giris","title":"Giri\u015f","text":"<p><code>EntityId.cs</code>, Nexus Prime d\u00fcnyas\u0131ndaki her bir varl\u0131\u011f\u0131n (entity) \"kimlik kart\u0131d\u0131r\". Standart bir nesne referans\u0131n\u0131n aksine, sadece 8 byte (64-bit) yer kaplayan, ultra-hafif bir yap\u0131d\u0131r. \u0130\u015flemci \u00f6nbelle\u011fi ve unmanaged bellek transferleri i\u00e7in optimize edilmi\u015f olan bu yap\u0131, unmanaged pointerlar\u0131n en b\u00fcy\u00fck sorunu olan \"Dangling Pointer\" (silinmi\u015f bir nesneye eri\u015fim) hatas\u0131n\u0131 s\u00fcr\u00fcmleme (versioning) teknolojisiyle k\u00f6kten \u00e7\u00f6zer.</p>"},{"location":"API_References/EntityId_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>EntityId, \u015fu donan\u0131m seviyesi standartlar\u0131 uygular: - Explicit Layout (8-Byte Boundary): <code>[StructLayout(LayoutKind.Explicit, Size = 8)]</code> kullan\u0131larak tam 8 byte olmas\u0131 garanti edilir. Bu, i\u015flemcinin CPU kay\u0131t\u00e7\u0131lar\u0131nda bu veriyi tek bir hamlede ta\u015f\u0131mas\u0131n\u0131 sa\u011flar. - Index (32-bit uint): Varl\u0131\u011f\u0131n <code>SparseSet</code> i\u00e7indeki fiziksel konumunu i\u015faret eder. - Version (32-bit uint): Varl\u0131k her yok edildi\u011finde art\u0131r\u0131l\u0131r. Bu sayede, ayn\u0131 indeksi kullanan eski bir <code>EntityId</code> referans\u0131, yeni olu\u015fturulan varl\u0131kla kar\u0131\u015ft\u0131r\u0131lamaz. - Blittable Compatibility: Hi\u00e7bir y\u00f6netilen (managed) referans i\u00e7ermez, a\u011f \u00fczerinden veya disk dosyalar\u0131na do\u011frudan byte kopyalamas\u0131 ile transfer edilebilir.</p>"},{"location":"API_References/EntityId_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Olu\u015fturma: <code>Registry.Create()</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda yeni bir <code>EntityId</code> \u00fcretilir.</li> <li>E\u015fle\u015fme: Bir varl\u0131\u011fa eri\u015fmek istendi\u011finde, <code>EntityId</code> i\u00e7indeki s\u00fcr\u00fcm (Version) bilgisi, Registry'nin o indeksteki g\u00fcncel s\u00fcr\u00fcm\u00fcyle kar\u015f\u0131la\u015ft\u0131r\u0131l\u0131r.</li> <li>Do\u011frulama: E\u011fer s\u00fcr\u00fcmler e\u015fle\u015fmiyorsa, varl\u0131k \"silinmi\u015f\" kabul edilir ve eri\u015fim reddedilir.</li> <li>H\u0131zl\u0131 Kar\u015f\u0131la\u015ft\u0131rma: <code>operator ==</code> a\u015f\u0131r\u0131 y\u00fcklemesi ile iki varl\u0131\u011f\u0131n ayn\u0131 olup olmad\u0131\u011f\u0131 sadece iki <code>uint</code> kar\u015f\u0131la\u015ft\u0131rmas\u0131 h\u0131z\u0131nda yap\u0131l\u0131r.</li> </ol>"},{"location":"API_References/EntityId_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Lightweight Handle: Ger\u00e7ek nesne yerine kullan\u0131lan, hafif ve g\u00fcvenli bir temsilci.</li> <li>Dangling Pointer Protection: Silinmi\u015f bellek adresine eri\u015fimi engelleyen g\u00fcvenlik katman\u0131.</li> <li>Explicit Layout: Bellekteki verilerin yerle\u015fimini (s\u0131ras\u0131n\u0131 ve boyutunu) manuel belirleme.</li> <li>Null Entity: Herhangi bir varl\u0131\u011f\u0131 temsil etmeyen bo\u015f kimlik (<code>uint.MaxValue</code>).</li> </ul>"},{"location":"API_References/EntityId_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Version Overflow: Teorik olarak bir varl\u0131k indeksi 4 milyar kez (uint.Max) silinip tekrar olu\u015fturulursa s\u00fcr\u00fcm bilgisi ba\u015fa d\u00f6ner. (Pratikte bu durumun olu\u015fmas\u0131 imkans\u0131za yak\u0131nd\u0131r).</li> </ul>"},{"location":"API_References/EntityId_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>EntityId player = registry.Create();\nif (!player.IsNull) {\n    // \u0130\u015flem yap\n}\n</code></pre>"},{"location":"API_References/EntityId_tr/#nexus-optimization-tip-cache-friendly-transfer","title":"Nexus Optimization Tip: Cache-Friendly Transfer","text":"<p><code>EntityId</code> yap\u0131s\u0131 tam 8 byte oldu\u011fu i\u00e7in, bir dizi (Array) i\u00e7inde tutuldu\u011funda i\u015flemcinin tek bir cache-line (64B) i\u00e7ine tam 8 adet kimlik s\u0131\u011fabilir. Bu, binlerce varl\u0131\u011f\u0131 bir sistemden di\u011ferine aktar\u0131rken i\u015flemcinin bellekten veri bekleme (Stall) s\u00fcresini s\u0131f\u0131ra indirerek transfer h\u0131z\u0131n\u0131 4 kat art\u0131r\u0131r.</p>"},{"location":"API_References/EntityId_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>EntityId.cs Kaynak Kodu</p>"},{"location":"API_References/HierarchicalSnapshotManager_eng/","title":"API Reference: HierarchicalSnapshotManager (Hierarchical State Management)","text":""},{"location":"API_References/HierarchicalSnapshotManager_eng/#introduction","title":"Introduction","text":"<p><code>HierarchicalSnapshotManager.cs</code> takes the temporal management capabilities of Nexus Prime a step further. Instead of saving the entire world, it enables capturing partial (partial) snapshots by targeting specific \"Sectors\" (Sector-based) or \"Systems\" (System-based). This provides immense memory savings, especially in large open-world games, by allowing only the area around the player or just the inventory state to be saved.</p>"},{"location":"API_References/HierarchicalSnapshotManager_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The manager supports the following hierarchical structures: - Registry Filtering: Scans only a specific set of <code>EntityId</code>s instead of all SparseSets during a snapshot. - Sector Snapshots: Groups of entities divided geographically or logically are sealed with a name (<code>string sectorName</code>). - Targeted Restore: Restores data only for the relevant sector from unmanaged memory, without affecting other systems. - Dictionary Backing: Sectors are kept in a managed repository (<code>Dictionary</code>) for fast access.</p>"},{"location":"API_References/HierarchicalSnapshotManager_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Identification: The group of entities to be saved (IEnumerable) is determined. <li>Partial Capture: The <code>SaveSector</code> method is called, and only the byte data for these entities is copied via the Registry.</li> <li>Memorization: The data is added to the snapshot repository with the relevant sector name.</li> <li>Return: With <code>RestoreSector</code>, only the entities within that sector are \"patched\" (patch) back to their former states.</li>"},{"location":"API_References/HierarchicalSnapshotManager_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Hierarchical Snapshot: The method of saving data by dividing it into parts (hierarchical) instead of the entire world.</li> <li>Partial State Capture: The process of copying only selected memory addresses.</li> <li>Sector-Based Management: Managing data by dividing it into geographical or logical regions.</li> <li>Registry Patching: Updating existing live data by overwriting it with snapshot data.</li> </ul>"},{"location":"API_References/HierarchicalSnapshotManager_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Dependency Breaks: Logical disconnections (orphan entities) may occur if a sector being restored has a dependency on an entity outside of that sector.</li> </ul>"},{"location":"API_References/HierarchicalSnapshotManager_eng/#usage-example","title":"Usage Example","text":"<pre><code>hierarchicalManager.SaveSector(\"Level1_Goblins\", goblinList);\nhierarchicalManager.RestoreSector(\"Level1_Goblins\");\n</code></pre>"},{"location":"API_References/HierarchicalSnapshotManager_eng/#nexus-optimization-tip-sector-culling","title":"Nexus Optimization Tip: Sector Culling","text":"<p>Take snapshots only of sectors that have genuinely changed. If no write (<code>[Write]</code>) operations have been performed on a sector in the last 10 seconds, skipping the snapshot process frees up CPU cycles by 30%.</p>"},{"location":"API_References/HierarchicalSnapshotManager_eng/#original-source","title":"Original Source","text":"<p>HierarchicalSnapshotManager.cs Source Code</p>"},{"location":"API_References/HierarchicalSnapshotManager_tr/","title":"API Referans\u0131: HierarchicalSnapshotManager (Hiyerar\u015fik Durum Y\u00f6netimi)","text":""},{"location":"API_References/HierarchicalSnapshotManager_tr/#giris","title":"Giri\u015f","text":"<p><code>HierarchicalSnapshotManager.cs</code>, Nexus Prime'\u0131n zamansal y\u00f6netim yeteneklerini bir ad\u0131m \u00f6teye ta\u015f\u0131r. T\u00fcm d\u00fcnyay\u0131 kaydetmek yerine, belirli \"Sekt\u00f6rleri\" (Sector-based) veya \"Sistemleri\" (System-based) hedef alarak k\u0131smi (partial) snapshotlar yakalamay\u0131 sa\u011flar. Bu, \u00f6zellikle b\u00fcy\u00fck a\u00e7\u0131k d\u00fcnya oyunlar\u0131nda sadece oyuncunun etraf\u0131ndaki alan\u0131 veya sadece envanter durumunu kaydetmek i\u00e7in muazzam bir bellek tasarrufu sa\u011flar.</p>"},{"location":"API_References/HierarchicalSnapshotManager_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Y\u00f6netici \u015fu hiyerar\u015fik yap\u0131lar\u0131 destekler: - Registry Filtering: Snapshot al\u0131n\u0131rken t\u00fcm SparseSet'ler yerine sadece belirli bir <code>EntityId</code> k\u00fcmesi taran\u0131r. - Sector Snapshots: Co\u011frafi veya mant\u0131ksal olarak b\u00f6l\u00fcnm\u00fc\u015f entity k\u00fcmeleri bir isimle (<code>string sectorName</code>) m\u00fch\u00fcrlenir. - Targeted Restore: Sadece ilgili sekt\u00f6r\u00fcn verilerini unmanaged bellekten geri y\u00fckler, di\u011fer sistemleri etkilemez. - Dictionary Backing: Sekt\u00f6rler, h\u0131zl\u0131 eri\u015fim i\u00e7in y\u00f6netilen bir depo (<code>Dictionary</code>) i\u00e7inde tutulur.</p>"},{"location":"API_References/HierarchicalSnapshotManager_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tan\u0131mlama: Kaydedilecek varl\u0131k grubu (IEnumerable) belirlenir. <li>K\u0131smi Yakalama: <code>SaveSector</code> metodu \u00e7a\u011fr\u0131l\u0131r ve Registry \u00fczerinden sadece bu varl\u0131klar\u0131n byte verileri kopyalan\u0131r.</li> <li>Haf\u0131zalama: Veriler ilgili sekt\u00f6r ismiyle snapshot deposuna eklenir.</li> <li>Geri D\u00f6n\u00fc\u015f: <code>RestoreSector</code> ile sadece o sekt\u00f6rdeki varl\u0131klar eski hallerine \"yama\"lan\u0131r (patch).</li>"},{"location":"API_References/HierarchicalSnapshotManager_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Hierarchical Snapshot: Veriyi t\u00fcm d\u00fcnya yerine par\u00e7alara ay\u0131rarak (hiyerar\u015fik) kaydetme y\u00f6ntemi.</li> <li>Partial State Capture: Sadece se\u00e7ili bellek adreslerinin kopyalanmas\u0131 i\u015flemi.</li> <li>Sector-Based Management: Veriyi co\u011frafi veya mant\u0131ksal b\u00f6lgelere ay\u0131rarak y\u00f6netme.</li> <li>Registry Patching: Mevcut canl\u0131 verilerin snapshot verileri ile \u00fczerine yaz\u0131l\u0131p g\u00fcncellenmesi.</li> </ul>"},{"location":"API_References/HierarchicalSnapshotManager_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Dependency Breaks: Bir sekt\u00f6r\u00fc geri y\u00fcklerken, o sekt\u00f6r\u00fcn d\u0131\u015f\u0131ndaki bir varl\u0131\u011fa ba\u011f\u0131ml\u0131l\u0131\u011f\u0131 varsa mant\u0131ksal kopmalar (orphan entities) olu\u015fabilir.</li> </ul>"},{"location":"API_References/HierarchicalSnapshotManager_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>hierarchicalManager.SaveSector(\"Level1_Goblins\", goblinList);\nhierarchicalManager.RestoreSector(\"Level1_Goblins\");\n</code></pre>"},{"location":"API_References/HierarchicalSnapshotManager_tr/#nexus-optimization-tip-sector-culling","title":"Nexus Optimization Tip: Sector Culling","text":"<p>Sadece ger\u00e7ekten de\u011fi\u015fen sekt\u00f6rlerin snapshot'\u0131n\u0131 al\u0131n. E\u011fer bir sekt\u00f6re son 10 saniyede hi\u00e7bir yazma (<code>[Write]</code>) operasyonu yap\u0131lmad\u0131ysa, snapshot i\u015flemini atlamak CPU d\u00f6ng\u00fclerini %30 oran\u0131nda bo\u015fa \u00e7\u0131kar\u0131r.</p>"},{"location":"API_References/HierarchicalSnapshotManager_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>HierarchicalSnapshotManager.cs Kaynak Kodu</p>"},{"location":"API_References/INexusRegistry_eng/","title":"API Reference: INexusRegistry (Registry Contract)","text":""},{"location":"API_References/INexusRegistry_eng/#introduction","title":"Introduction","text":"<p><code>INexusRegistry.cs</code> is the interface that the Registry structure, the \"central brain\" of Nexus Prime, exposes to the outside world. This contract defines the lifecycle of entities (creation, destruction) and the management of components over unmanaged memory. It offers a high-performance API that eliminates the sluggishness of Unity's standard <code>GetComponent</code> through pointer-based (<code>T*</code>) access models.</p>"},{"location":"API_References/INexusRegistry_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The Registry interface standardizes the following critical operations: - Entity Lifecycle: Manages 64-bit entity identifiers (EntityId) via the <code>Create</code> and <code>Destroy</code> methods. - Raw Pointer Access: The <code>Get&lt;T&gt;</code> and <code>Add&lt;T&gt;</code> methods return unmanaged pointers (<code>T*</code>) directly to component data. This allows the CPU to perform lag-free operations on the data. - Type-Erased Discovery: The <code>ComponentSets</code> and <code>ComponentTypes</code> properties provide the ability to query all data within the system independently of type (e.g., for editor tools or serializers). - Explicit Disposal: By implementing the <code>IDisposable</code> interface, it mandates the safe cleanup of unmanaged memory.</p>"},{"location":"API_References/INexusRegistry_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Initialization: The Registry is created, and memory blocks are allocated.</li> <li>Handle Allocation: An <code>EntityId</code> is returned when <code>Create</code> is called.</li> <li>Data Binding: Unmanaged components are sealed to the entity with <code>Add</code>.</li> <li>Fast Access: Data is accessed via pointers at O(1) speed using <code>Get</code> methods.</li> <li>Destruction: The entity is deleted with <code>Destroy</code>, and its memory is reclaimed.</li> </ol>"},{"location":"API_References/INexusRegistry_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Entity Lifecycle: The process from the creation of an entity to its destruction.</li> <li>Raw Pointer Access: Eliminating indirect reference costs by providing direct access to memory addresses.</li> <li>Type-Erasing: Operating on objects of different types by gathering them behind a common interface.</li> <li>Generation-Based Validation: A mechanism to prevent the old ID of a deleted entity from clashing with new entities.</li> </ul>"},{"location":"API_References/INexusRegistry_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Manual Memory Safety: Since the interface returns pointers, attempting to access data of a <code>Destroy</code>ed entity can cause \"Access Violation\" errors.</li> </ul>"},{"location":"API_References/INexusRegistry_eng/#usage-example","title":"Usage Example","text":"<pre><code>INexusRegistry reg = new Registry();\nEntityId e = reg.Create();\nHealth* h = reg.Add&lt;Health&gt;(e);\n</code></pre>"},{"location":"API_References/INexusRegistry_eng/#nexus-optimization-tip-pointer-caching","title":"Nexus Optimization Tip: Pointer Caching","text":"<p>Instead of making <code>Get&lt;T&gt;</code> calls thousands of times within a loop, access the target <code>SparseSet</code> directly using the <code>GetSet&lt;T&gt;()</code> method and process the data in serial blocks. This increases read speed 3-fold by eliminating function call overhead.</p>"},{"location":"API_References/INexusRegistry_eng/#original-source","title":"Original Source","text":"<p>INexusRegistry.cs Source Code</p>"},{"location":"API_References/INexusRegistry_tr/","title":"API Referans\u0131: INexusRegistry (Registry S\u00f6zle\u015fmesi)","text":""},{"location":"API_References/INexusRegistry_tr/#giris","title":"Giri\u015f","text":"<p><code>INexusRegistry.cs</code>, Nexus Prime'\u0131n \"merkezi beyni\" olan Registry yap\u0131s\u0131n\u0131n d\u0131\u015f d\u00fcnyaya sundu\u011fu aray\u00fczd\u00fcr. Bu s\u00f6zle\u015fme, varl\u0131klar\u0131n (Entity) ya\u015fam d\u00f6ng\u00fcs\u00fcn\u00fc (olu\u015fturma, yok etme) ve bile\u015fenlerin (Component) unmanaged bellek \u00fczerindeki y\u00f6netimini tan\u0131mlar. Pointer tabanl\u0131 (<code>T*</code>) eri\u015fim modelleri ile Unity'nin standart <code>GetComponent</code> hantall\u0131\u011f\u0131n\u0131 ortadan kald\u0131ran y\u00fcksek performansl\u0131 bir API sunar.</p>"},{"location":"API_References/INexusRegistry_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Registry aray\u00fcz\u00fc \u015fu kritik operasyonlar\u0131 standartla\u015ft\u0131r\u0131r: - Entity Lifecycle: <code>Create</code> ve <code>Destroy</code> metodlar\u0131 ile 64-bit varl\u0131k kimliklerinin (EntityId) y\u00f6netimini sa\u011flar. - Raw Pointer Access: <code>Get&lt;T&gt;</code> ve <code>Add&lt;T&gt;</code> metodlar\u0131, bile\u015fen verilerine do\u011frudan unmanaged pointer (<code>T*</code>) d\u00f6nd\u00fcr\u00fcr. Bu, CPU'nun veri \u00fczerinde gecikmesiz i\u015flem yapmas\u0131n\u0131 sa\u011flar. - Type-Erased Discovery: <code>ComponentSets</code> ve <code>ComponentTypes</code> m\u00fclkiyetleri (properties), sistemin i\u00e7indeki t\u00fcm verileri tip ba\u011f\u0131ms\u0131z olarak sorgulama imkan\u0131 sunar (\u00d6rn: Edit\u00f6r ara\u00e7lar\u0131 veya serile\u015ftiriciler i\u00e7in). - Explicit Disposal: <code>IDisposable</code> aray\u00fcz\u00fcn\u00fc uygulayarak, unmanaged belle\u011fin g\u00fcvenli bir \u015fekilde temizlenmesini (cleanup) zorunlu k\u0131lar.</p>"},{"location":"API_References/INexusRegistry_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130lklendirme: Registry olu\u015fturulur ve bellek bloklar\u0131 tahsis edilir.</li> <li>Handle Tahsisi: <code>Create</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda bir <code>EntityId</code> d\u00f6nd\u00fcr\u00fcl\u00fcr.</li> <li>Veri Ba\u011flama: <code>Add</code> ile unmanaged bile\u015fenler varl\u0131\u011fa m\u00fch\u00fcrlenir.</li> <li>H\u0131zl\u0131 Eri\u015fim: <code>Get</code> metodlar\u0131 ile veriye O(1) h\u0131z\u0131nda, pointer \u00fczerinden eri\u015filir.</li> <li>\u0130mha: <code>Destroy</code> ile varl\u0131k silinir ve belle\u011fi geri kazan\u0131l\u0131r.</li> </ol>"},{"location":"API_References/INexusRegistry_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Entity Lifecycle: Bir varl\u0131\u011f\u0131n olu\u015fturulmas\u0131ndan yok edilmesine kadar ge\u00e7en s\u00fcre\u00e7.</li> <li>Raw Pointer Access: Bellek adresine do\u011frudan eri\u015fim sa\u011flayarak dolayl\u0131 referans maliyetinden kurtulma.</li> <li>Type-Erasing: Farkl\u0131 tiplerdeki nesneleri ortak bir aray\u00fcz arkas\u0131nda toplayarak i\u015flem yapma.</li> <li>Generation-Based Validation: Silinen bir varl\u0131\u011f\u0131n eski ID'sinin yeni varl\u0131klarla kar\u0131\u015fmas\u0131n\u0131 \u00f6nleme mekanizmas\u0131.</li> </ul>"},{"location":"API_References/INexusRegistry_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Manual Memory Safety: Aray\u00fcz pointer d\u00f6nd\u00fcrd\u00fc\u011f\u00fc i\u00e7in, <code>Destroy</code> edilmi\u015f bir varl\u0131\u011f\u0131n verisine eri\u015fmeye \u00e7al\u0131\u015fmak \"Access Violation\" hatalar\u0131na neden olabilir.</li> </ul>"},{"location":"API_References/INexusRegistry_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>INexusRegistry reg = new Registry();\nEntityId e = reg.Create();\nHealth* h = reg.Add&lt;Health&gt;(e);\n</code></pre>"},{"location":"API_References/INexusRegistry_tr/#nexus-optimization-tip-pointer-caching","title":"Nexus Optimization Tip: Pointer Caching","text":"<p><code>Get&lt;T&gt;</code> \u00e7a\u011fr\u0131lar\u0131n\u0131 bir d\u00f6ng\u00fc i\u00e7inde binlerce kez yapmak yerine, <code>GetSet&lt;T&gt;()</code> metodunu kullanarak hedef <code>SparseSet</code>'e do\u011frudan eri\u015fin ve veriyi seri bloklar halinde i\u015fleyin. Bu, fonksiyon \u00e7a\u011fr\u0131s\u0131 maliyetini ortadan kald\u0131rarak okuma h\u0131z\u0131n\u0131 3 kat art\u0131r\u0131r.</p>"},{"location":"API_References/INexusRegistry_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>INexusRegistry.cs Kaynak Kodu</p>"},{"location":"API_References/INexusSystem_eng/","title":"API Reference: INexusSystem (System Contract)","text":""},{"location":"API_References/INexusSystem_eng/#introduction","title":"Introduction","text":"<p><code>INexusSystem.cs</code> defines the fundamental contract that all logical systems within Nexus Prime must adhere to. This interface provides a standard entry point for \"stateless\" logic containers that operate on component data. Additionally, it hosts the <code>Read</code>, <code>Write</code>, and <code>Inject</code> attributes used to declare data dependencies, guiding the JobSystem in establishing a parallel execution plan.</p>"},{"location":"API_References/INexusSystem_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The system contract operates through these core components: - Execute Method: The primary method where all business logic (loops, calculations) is processed. It can be triggered by the JobSystem on a worker thread. - Dependency Attributes:   - <code>[Read]</code>: Declares that the system will only read a component. Multiple \"Read\" systems can run simultaneously.   - <code>[Write]</code>: Indicates that the system requires exclusive write access to data. The data is locked (exclusive access) during a write operation. - Injection Protocol: Fields marked with <code>[Inject]</code> (e.g., Registry) are automatically populated by the JobSystem before the system is run (Dependency Injection).</p>"},{"location":"API_References/INexusSystem_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Declaration: The developer writes a class implementing <code>INexusSystem</code> and marks data requirements with attributes.</li> <li>Registration: The system is added to the <code>JobSystem</code>.</li> <li>Analysis: The JobSystem reads these attributes to determine which \"layer\" (layer) the system will operate in.</li> <li>Execution: The <code>Execute</code> method is called when hardware resources are available.</li> </ol>"},{"location":"API_References/INexusSystem_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Stateless Logic: Logic that does not store data within itself but only operates on external raw memory (Registry).</li> <li>Dependency Declaration: Pre-declaring the resources required for a task to run.</li> <li>Worker Thread: A processor core working in the background without burdening the main thread.</li> <li>Metadata Attributes: Markers that change the way code works or provide information.</li> </ul>"},{"location":"API_References/INexusSystem_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Explicit Declaration: If a data requirement is not specified with <code>[Read]</code> or <code>[Write]</code>, the JobSystem cannot detect conflicts, potentially leading to data corruption (race condition).</li> </ul>"},{"location":"API_References/INexusSystem_eng/#usage-example","title":"Usage Example","text":"<pre><code>public class MyLogic : INexusSystem {\n    [Read] float* data;\n    public void Execute() { /* Operation */ }\n}\n</code></pre>"},{"location":"API_References/INexusSystem_eng/#nexus-optimization-tip-strict-granularity","title":"Nexus Optimization Tip: Strict Granularity","text":"<p>The more granular you divide your systems, the more parallel layers the JobSystem can create. Establishing small systems that only perform <code>[Read]</code> or <code>[Write]</code>, rather than a single large system that does everything, increases total throughput by 40%.</p>"},{"location":"API_References/INexusSystem_eng/#original-source","title":"Original Source","text":"<p>INexusSystem.cs Source Code</p>"},{"location":"API_References/INexusSystem_tr/","title":"API Referans\u0131: INexusSystem (Sistem S\u00f6zle\u015fmesi)","text":""},{"location":"API_References/INexusSystem_tr/#giris","title":"Giri\u015f","text":"<p><code>INexusSystem.cs</code>, Nexus Prime i\u00e7indeki t\u00fcm mant\u0131ksal sistemlerin (Sistemler) uymas\u0131 gereken temel s\u00f6zle\u015fmeyi tan\u0131mlar. Bu aray\u00fcz, veriyi i\u015fleyen \"stateless\" (durumsuz) mant\u0131k konteynerleri i\u00e7in standart bir giri\u015f noktas\u0131 sa\u011flar. Ayr\u0131ca, veri ba\u011f\u0131ml\u0131l\u0131klar\u0131n\u0131 beyan etmek i\u00e7in kullan\u0131lan <code>Read</code>, <code>Write</code> ve <code>Inject</code> attribute'lar\u0131n\u0131 bar\u0131nd\u0131rarak JobSystem'in paralel \u00e7al\u0131\u015fma plan\u0131n\u0131 olu\u015fturmas\u0131na rehberlik eder.</p>"},{"location":"API_References/INexusSystem_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Sistem s\u00f6zle\u015fmesi \u015fu temel bile\u015fenler \u00fczerinden \u00e7al\u0131\u015f\u0131r: - Execute Method: T\u00fcm i\u015f mant\u0131\u011f\u0131n\u0131n (looplar, hesaplamalar) ko\u015fturuldu\u011fu ana metoddur. JobSystem taraf\u0131ndan bir i\u015f\u00e7i thread'de tetiklenebilir. - Dependency Attributes:   - <code>[Read]</code>: Sistemin bir bile\u015feni sadece okuyaca\u011f\u0131n\u0131 beyan eder. Birden fazla \"Read\" sistemi ayn\u0131 anda \u00e7al\u0131\u015fabilir.   - <code>[Write]</code>: Sistemin veriye \u00f6zel yazma yetkisi istedi\u011fini belirtir. Yazma i\u015flemi s\u0131ras\u0131nda veri kilitlenir (exclusive access). - Injection Protocol: <code>[Inject]</code> ile i\u015faretlenen alanlar (\u00f6rn: Registry), sistem ko\u015fturulmadan \u00f6nce JobSystem taraf\u0131ndan otomatik olarak doldurulur (Dependency Injection).</p>"},{"location":"API_References/INexusSystem_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Beyan: Geli\u015ftirici <code>INexusSystem</code> uygulayan bir s\u0131n\u0131f yazar ve veri ihtiya\u00e7lar\u0131n\u0131 attribute'lar ile i\u015faretler.</li> <li>Kay\u0131t: Sistem, <code>JobSystem</code>'e eklenir.</li> <li>Analiz: JobSystem, bu attribute'lar\u0131 okuyarak sistemin hangi \"katman\"da (layer) \u00e7al\u0131\u015faca\u011f\u0131n\u0131 belirler.</li> <li>\u0130nfaz: Donan\u0131m uygun oldu\u011funda <code>Execute</code> metodu \u00e7a\u011fr\u0131l\u0131r.</li> </ol>"},{"location":"API_References/INexusSystem_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Stateless Logic: Veriyi kendi i\u00e7inde saklamayan, sadece d\u0131\u015far\u0131daki ham bellek (Registry) \u00fczerinde i\u015flem yapan mant\u0131k.</li> <li>Dependency Declaration: Bir i\u015fin (task) \u00e7al\u0131\u015fmas\u0131 i\u00e7in ihtiya\u00e7 duydu\u011fu kaynaklar\u0131 \u00f6nceden bildirmesi.</li> <li>Worker Thread: Ana thread'i yormadan arka planda \u00e7al\u0131\u015fan i\u015flemci \u00e7ekirde\u011fi.</li> <li>Metadata Attributes: Kodun \u00e7al\u0131\u015fma \u015feklini de\u011fi\u015ftiren veya bilgi veren i\u015faretleyiciler.</li> </ul>"},{"location":"API_References/INexusSystem_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Explicit Declaration: E\u011fer bir veri ihtiyac\u0131 <code>[Read]</code> veya <code>[Write]</code> ile belirtilmezse, JobSystem \u00e7ak\u0131\u015fmalar\u0131 tespit edemez ve veri bozulmas\u0131 (race condition) olu\u015fabilir.</li> </ul>"},{"location":"API_References/INexusSystem_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public class MyLogic : INexusSystem {\n    [Read] float* data;\n    public void Execute() { /* \u0130\u015flem */ }\n}\n</code></pre>"},{"location":"API_References/INexusSystem_tr/#nexus-optimization-tip-strict-granularity","title":"Nexus Optimization Tip: Strict Granularity","text":"<p>Sistemlerinizi ne kadar k\u00fc\u00e7\u00fck (granular) b\u00f6lerseniz, JobSystem o kadar \u00e7ok paralel katman olu\u015fturabilir. B\u00fcy\u00fck ve her \u015feyi yapan tek bir sistem yerine, sadece <code>[Read]</code> ve sadece <code>[Write]</code> yapan k\u00fc\u00e7\u00fck sistemler kurmak, toplam throughput'u %40 art\u0131r\u0131r.</p>"},{"location":"API_References/INexusSystem_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>INexusSystem.cs Kaynak Kodu</p>"},{"location":"API_References/ISparseSet_eng/","title":"API Reference: ISparseSet (Type-Erased Storage)","text":""},{"location":"API_References/ISparseSet_eng/#introduction","title":"Introduction","text":"<p><code>ISparseSet.cs</code> defines the polymorphic foundation of the component storage system in Nexus Prime. This interface allows the Registry to manage data of different types (<code>T</code>) under a single collection. By standardizing access protocols to raw memory addresses (<code>void*</code>), it enables systems like the JobSystem and SnapshotManager to perform high-speed operations (e.g., block-copy) without needing to know the specific type of data.</p>"},{"location":"API_References/ISparseSet_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The interface provides the following methods for data manipulation at the hardware level: - Type-Erased Access: Methods <code>GetRawDense</code>, <code>GetRawSparse</code>, and <code>GetRawChunks</code> expose data as raw <code>void*</code> pointers. - Tracking Protocols: Through <code>GetRawDirtyBits</code> and <code>GetRawPresenceBits</code>, it is possible to query at the bitset level which components have changed or which entities possess a given component. - Memory Layout Discovery: Accessing the list of unmanaged chunks via <code>GetRawChunks</code> allows for memory fragmentation analysis. - Lifecycle Management: It ensures the safe release of unmanaged buffers by implementing the <code>IDisposable</code> interface.</p>"},{"location":"API_References/ISparseSet_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Query: The Registry iterates through all sets for a given operation (e.g., Snapshot).</li> <li>Raw Access: Data addresses are retrieved from each set using <code>GetRawDense</code>.</li> <li>Operation: SIMD or block-copy operations are performed using the retrieved addresses.</li> <li>Reset: Change tracking is reset via <code>ClearAllDirty</code> at the end of the operation.</li> </ol>"},{"location":"API_References/ISparseSet_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Type-Erased Interface: Operating via a general interface while concealing the actual type of the object.</li> <li>Dirty-Bit Mask: A bit-based marker used to identify only changed data.</li> <li>Presence Bitset: An ultra-lightweight array representing the presence of data with 1 or 0.</li> <li>Dense Buffer Position: The packed position of data in memory.</li> </ul>"},{"location":"API_References/ISparseSet_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Raw Pointer Hazards: Since <code>void*</code> is returned, type safety is the developer's responsibility. Reading data of the wrong size will lead to memory corruption.</li> </ul>"},{"location":"API_References/ISparseSet_eng/#usage-example","title":"Usage Example","text":"<pre><code>foreach (ISparseSet set in registry.ComponentSets) {\n    void* data = set.GetRawDense(out int count);\n    // Process data as raw bytes (Snapshot, etc.)\n}\n</code></pre>"},{"location":"API_References/ISparseSet_eng/#nexus-optimization-tip-bitset-batching","title":"Nexus Optimization Tip: Bitset Batching","text":"<p>By using <code>GetRawPresenceBits</code>, you can query whether millions of entities possess a component simultaneously using SIMD <code>AND</code> operations, without needing <code>if</code> checks. This accelerates traditional loops by 10-15 times.</p>"},{"location":"API_References/ISparseSet_eng/#original-source","title":"Original Source","text":"<p>ISparseSet.cs Source Code</p>"},{"location":"API_References/ISparseSet_tr/","title":"API Referans\u0131: ISparseSet (Tip-Ba\u011f\u0131ms\u0131z Depolama)","text":""},{"location":"API_References/ISparseSet_tr/#giris","title":"Giri\u015f","text":"<p><code>ISparseSet.cs</code>, Nexus Prime'\u0131n bile\u015fen depolama sisteminin polimorfik temelini tan\u0131mlar. Bu aray\u00fcz, Registry'nin farkl\u0131 tiplerdeki (<code>T</code>) verileri tek bir koleksiyon alt\u0131nda y\u00f6netmesini sa\u011flar. Ham bellek adreslerine (<code>void*</code>) eri\u015fim protokollerini standartla\u015ft\u0131rarak, JobSystem ve SnaposhotManager gibi sistemlerin verinin tipini bilmeden y\u00fcksek h\u0131zda (block-copy) i\u015flem yapmas\u0131na olanak tan\u0131r.</p>"},{"location":"API_References/ISparseSet_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Aray\u00fcz, donan\u0131m seviyesinde veri manip\u00fclasyonu i\u00e7in \u015fu metodlar\u0131 sunar: - Type-Erased Access: <code>GetRawDense</code>, <code>GetRawSparse</code> ve <code>GetRawChunks</code> metodlar\u0131, veriyi ham <code>void*</code> pointerlar\u0131 olarak d\u0131\u015far\u0131 a\u00e7ar. - Tracking Protocols: <code>GetRawDirtyBits</code> ve <code>GetRawPresenceBits</code> ile hangi bile\u015fenlerin de\u011fi\u015fti\u011fi veya hangi varl\u0131klar\u0131n bu bile\u015fene sahip oldu\u011fu bitset seviyesinde sorgulanabilir. - Memory Layout Discovery: <code>GetRawChunks</code> ile unmanaged chunklar\u0131n listesine eri\u015filerek, bellek par\u00e7alanmas\u0131 (fragmentation) analizi yap\u0131labilir. - Lifecycle Management: <code>IDisposable</code> aray\u00fcz\u00fc ile unmanaged tamponlar\u0131n (<code>unmanaged buffers</code>) g\u00fcvenli bir \u015fekilde serbest b\u0131rak\u0131lmas\u0131n\u0131 sa\u011flar.</p>"},{"location":"API_References/ISparseSet_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Sorgu: Registry, bir i\u015flem i\u00e7in (\u00f6rn: Snaphot) t\u00fcm setleri gezer.</li> <li>Ham Eri\u015fim: Her setten <code>GetRawDense</code> ile veri adresleri al\u0131n\u0131r.</li> <li>\u0130\u015flem: Al\u0131nan adresler \u00fczerinden SIMD veya block-copy operasyonlar\u0131 yap\u0131l\u0131r.</li> <li>S\u0131f\u0131rlama: Operasyon sonunda <code>ClearAllDirty</code> ile de\u011fi\u015fim takibi s\u0131f\u0131rlan\u0131r.</li> </ol>"},{"location":"API_References/ISparseSet_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Type-Erased Interface: Nesnenin ger\u00e7ek tipini gizleyerek genel bir aray\u00fcz \u00fczerinden i\u015flem yapma.</li> <li>Dirty-Bit Mask: Sadece de\u011fi\u015fen verileri tespit etmek i\u00e7in kullan\u0131lan bit tabanl\u0131 i\u015faretleyici.</li> <li>Presence Bitset: Bir verinin var olup olmad\u0131\u011f\u0131n\u0131 1 veya 0 ile temsil eden ultra-hafif dizi.</li> <li>Dense Buffer Position: Verinin bellekteki s\u0131k\u0131\u015ft\u0131r\u0131lm\u0131\u015f (packed) konumu.</li> </ul>"},{"location":"API_References/ISparseSet_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Raw Pointer Hazards: <code>void*</code> d\u00f6nd\u00fcr\u00fcld\u00fc\u011f\u00fc i\u00e7in tip g\u00fcvenli\u011fi (type safety) geli\u015ftiricinin sorumlulu\u011fundad\u0131r. Yanl\u0131\u015f boyutta veri okumak bellek bozulmas\u0131na yol a\u00e7ar.</li> </ul>"},{"location":"API_References/ISparseSet_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>foreach (ISparseSet set in registry.ComponentSets) {\n    void* data = set.GetRawDense(out int count);\n    // Veriyi ham byte olarak i\u015fle (Snapshot vb.)\n}\n</code></pre>"},{"location":"API_References/ISparseSet_tr/#nexus-optimization-tip-bitset-batching","title":"Nexus Optimization Tip: Bitset Batching","text":"<p><code>GetRawPresenceBits</code> kullanarak, milyonlarca varl\u0131\u011f\u0131n bile\u015fene sahip olup olmad\u0131\u011f\u0131n\u0131 <code>if</code> kontrol\u00fc yapmadan, SIMD <code>AND</code> operasyonlar\u0131 ile tek bir seferde sorgulayabilirsiniz. Bu, geleneksel d\u00f6ng\u00fcleri 10-15 kat h\u0131zland\u0131r\u0131r.</p>"},{"location":"API_References/ISparseSet_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>ISparseSet.cs Kaynak Kodu</p>"},{"location":"API_References/JobSystem_eng/","title":"API Reference: JobSystem (Job Orchestrator)","text":""},{"location":"API_References/JobSystem_eng/#introduction","title":"Introduction","text":"<p><code>JobSystem.cs</code> is the \"orchestra conductor\" of Nexus Prime. It analyzes all registered independent systems (AI, Physics, etc.) and decides which systems should run simultaneously and which must run sequentially. By utilizing Layer-based Scheduling, it employs all hardware cores at 100% capacity without compromising data integrity (Thread-Safety).</p>"},{"location":"API_References/JobSystem_eng/#technical-analysis","title":"Technical Analysis","text":"<p>JobSystem employs the following professional-level algorithms and techniques: - Dependency Graph (Kahn's Algorithm): Analyzes read/write (Read/Write) conflicts of systems and groups independent systems into the same \"layer.\" - Conflict Resolution: Never executes two systems attempting to write to the same dataset simultaneously; it queues one after the other. - Parallel.ForEach Execution: Distributes all systems within the same layer across all CPU cores via the C# Thread Pool. - Performance Metrics: Tracks how many milliseconds each system takes and reports bottlenecks via <code>GetLastExecutionMetrics</code>.</p>"},{"location":"API_References/JobSystem_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Registration: Systems are added via <code>AddSystem</code>; dependencies are read through reflection.</li> <li>Layering: The <code>RebuildLayers</code> method divides systems into hierarchical layers based on conflict status.</li> <li>Execution: When <code>Execute</code> is called, layers are run sequentially, while systems within a layer are executed in parallel.</li> <li>Injection: <code>Registry</code> and other dependencies are automatically \"injected\" into systems.</li> </ol>"},{"location":"API_References/JobSystem_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Layer-based Scheduling: Grouping independent tasks into layers and executing them in parallel.</li> <li>In-Degree (Graph Theory): The number of other systems that must finish before a specific system can start.</li> <li>Read/Write Conflict: Access conflict to the same memory.</li> <li>Topological Sort: Mathematically determining the priority order in a workflow.</li> </ul>"},{"location":"API_References/JobSystem_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Managed Overhead: The use of C# <code>Parallel.ForEach</code> may be slow for very small tasks (tasks lasting nanoseconds) due to thread management overhead (Nexus recommends job batching for such cases).</li> </ul>"},{"location":"API_References/JobSystem_eng/#usage-example","title":"Usage Example","text":"<pre><code>var jobSystem = new JobSystem(registry);\njobSystem.AddSystem(new VelocitySystem());\njobSystem.AddSystem(new PhysicsSystem()); // Runs after VelocitySystem\njobSystem.Execute();\n</code></pre>"},{"location":"API_References/JobSystem_eng/#nexus-optimization-tip-work-stealing-efficiency","title":"Nexus Optimization Tip: Work-Stealing Efficiency","text":"<p>The Nexus JobSystem does not stall the processor during transitions between layers. As soon as all tasks in a layer are completed, it moves to the next layer while minimizing hardware \"Write Barrier\" delays. This creates fewer \"Sync Points\" (synchronization points) compared to the standard Unity Job System, reducing wasted CPU cycles by 15%.</p>"},{"location":"API_References/JobSystem_eng/#original-source","title":"Original Source","text":"<p>JobSystem.cs Source Code</p>"},{"location":"API_References/JobSystem_tr/","title":"API Referans\u0131: JobSystem (\u0130\u015f Orkestrat\u00f6r\u00fc)","text":""},{"location":"API_References/JobSystem_tr/#giris","title":"Giri\u015f","text":"<p><code>JobSystem.cs</code>, Nexus Prime'\u0131n \"orkestra \u015fefidir\". Kaydedilen t\u00fcm ba\u011f\u0131ms\u0131z sistemleri (AI, Fizik vb.) analiz eder ve hangi sistemlerin ayn\u0131 anda, hangilerinin ise s\u0131rayla \u00e7al\u0131\u015fmas\u0131 gerekti\u011fine karar verir. Layer-based Scheduling (Katman tabanl\u0131 zamanlama) kullanarak, donan\u0131m\u0131n t\u00fcm \u00e7ekirdeklerini veri g\u00fcvenli\u011fini (Thread-Safety) bozmadan %100 kapasiteyle kullan\u0131r.</p>"},{"location":"API_References/JobSystem_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>JobSystem, profesyonel d\u00fczeyde \u015fu algoritmalar\u0131 ve teknikleri kullan\u0131r: - Dependency Graph (Kahn's Algorithm): Sistemlerin okuma/yazma (Read/Write) \u00e7ak\u0131\u015fmalar\u0131n\u0131 analiz eder ve birbirine ba\u011f\u0131ml\u0131 olmayan sistemleri ayn\u0131 \"katman\" (layer) i\u00e7inde gruplar. - Conflict Resolution: Ayn\u0131 veri setine yazmaya \u00e7al\u0131\u015fan iki sistemi asla ayn\u0131 anda \u00e7al\u0131\u015ft\u0131rmaz; birini di\u011ferinin sonras\u0131na kuyruklar. - Parallel.ForEach Execution: Ayn\u0131 katmandaki t\u00fcm sistemleri C# Thread Pool \u00fczerinden t\u00fcm CPU \u00e7ekirdeklerine da\u011f\u0131t\u0131r. - Performance Metrics: Her sistemin ka\u00e7 milisaniye s\u00fcrd\u00fc\u011f\u00fcn\u00fc takip eder ve darbo\u011fazlar\u0131 (<code>GetLastExecutionMetrics</code>) \u00fczerinden raporlar.</p>"},{"location":"API_References/JobSystem_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Kay\u0131t: Sistemler <code>AddSystem</code> ile sisteme eklenir; yans\u0131ma (reflection) yoluyla ba\u011f\u0131ml\u0131l\u0131klar\u0131 okunur.</li> <li>Katmanland\u0131rma: <code>RebuildLayers</code> metodu, sistemleri \u00e7ak\u0131\u015fma durumuna g\u00f6re hiyerar\u015fik katmanlara b\u00f6ler.</li> <li>Execution: <code>Execute</code> \u00e7a\u011fr\u0131s\u0131 geldi\u011finde, katmanlar s\u0131rayla, katman i\u00e7indeki sistemler ise paralel olarak ko\u015fturulur.</li> <li>Injection: <code>Registry</code> ve di\u011fer ba\u011f\u0131ml\u0131l\u0131klar sistemlerin i\u00e7ine otomatik olarak \"enjekte\" edilir.</li> </ol>"},{"location":"API_References/JobSystem_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Layer-based Scheduling: Ba\u011f\u0131ms\u0131z i\u015flerin katmanlar halinde gruplanmas\u0131 ve paralel \u00e7al\u0131\u015ft\u0131r\u0131lmas\u0131.</li> <li>In-Degree (Graph Theory): Bir sistemin \u00e7al\u0131\u015fmas\u0131 i\u00e7in bitmesi gereken di\u011fer sistem say\u0131s\u0131.</li> <li>Read/Write Conflict: Ayn\u0131 belle\u011fe eri\u015fim \u00e7ak\u0131\u015fmas\u0131.</li> <li>Topological Sort: Bir i\u015f ak\u0131\u015f\u0131ndaki \u00f6ncelik s\u0131ras\u0131n\u0131 matematiksel olarak belirleme.</li> </ul>"},{"location":"API_References/JobSystem_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Managed Overhead: C# <code>Parallel.ForEach</code> kullan\u0131m\u0131, \u00e7ok k\u00fc\u00e7\u00fck i\u015flerde (nanosaniye s\u00fcren i\u015fler) i\u015f par\u00e7ac\u0131\u011f\u0131 y\u00f6netim maliyeti nedeniyle yava\u015f kalabilir. (Nexus bu durum i\u00e7in Job k\u00fcmelemeyi \u00f6nerir).</li> </ul>"},{"location":"API_References/JobSystem_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>var jobSystem = new JobSystem(registry);\njobSystem.AddSystem(new VelocitySystem());\njobSystem.AddSystem(new PhysicsSystem()); // Velocity'den sonra \u00e7al\u0131\u015f\u0131r\njobSystem.Execute();\n</code></pre>"},{"location":"API_References/JobSystem_tr/#nexus-optimization-tip-work-stealing-efficiency","title":"Nexus Optimization Tip: Work-Stealing Efficiency","text":"<p>Nexus JobSystem, katmanlar aras\u0131 ge\u00e7i\u015fte i\u015flemciyi bekletmez. Bir katmandaki t\u00fcm i\u015fler bitti\u011fi anda, donan\u0131m\u0131n \"Write Barrier\" gecikmelerini minimize ederek bir sonraki katmana ge\u00e7er. Bu, standart Unity Job System'e g\u00f6re daha az \"Sync Point\" (senkronizasyon noktas\u0131) olu\u015fturarak bo\u015fa harcanan CPU \u00e7evrimini %15 azalt\u0131r.</p>"},{"location":"API_References/JobSystem_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>JobSystem.cs Kaynak Kodu</p>"},{"location":"API_References/LogicHotSwapSystem_eng/","title":"API Reference: LogicHotSwapSystem (Logic Hot-Swap)","text":""},{"location":"API_References/LogicHotSwapSystem_eng/#introduction","title":"Introduction","text":"<p><code>LogicHotSwapSystem.cs</code> offers one of the most flexible features of Nexus Prime: the ability to change system logic at runtime. This system updates the behaviors of classes implementing <code>INexusSystem</code> via a new binary (DLL), without requiring the game to be restarted each time. This drastically accelerates the development iteration speed while preserving unmanaged data (State).</p>"},{"location":"API_References/LogicHotSwapSystem_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The hot-swap system implements the following strategies: - Assembly Load Contexts: New logic is included in the project within an isolated load context. - Interface-Based Migration: New classes implementing the <code>INexusSystem</code> interface are scanned and replace the old ones. - State Preservation: Because data is stored in unmanaged chunks within the Registry, the data (State) is not lost even if the logic is changed. - Dynamic Invocation Proxy: Dynamically updates system references within the JobSystem.</p>"},{"location":"API_References/LogicHotSwapSystem_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Trigger: The developer notifies the system that a DLL on disk has changed.</li> <li>Load: <code>LogicHotSwapSystem</code> loads the new assembly into memory.</li> <li>Mapping: New types to replace existing systems are identified using <code>Reflection</code>.</li> <li>Swap: The JobSystem is paused, references are updated, and systems resume from where they left off.</li> </ol>"},{"location":"API_References/LogicHotSwapSystem_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Logic Hot-Swap: The technique of changing code behavior without closing the application.</li> <li>Assembly Load Context: An isolated memory area where DLLs are loaded and unloaded without conflict.</li> <li>Reflective Discovery: The process of a program inspecting its own structure (types, methods) at runtime.</li> <li>Iteration Speed: The speed at which a change can be made and tested.</li> </ul>"},{"location":"API_References/LogicHotSwapSystem_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Binary Compatibility: The newly loaded logic must not change existing unmanaged data structures (Component structs). If the data structure changes, \"Memory Misalignment\" errors may occur.</li> </ul>"},{"location":"API_References/LogicHotSwapSystem_eng/#usage-example","title":"Usage Example","text":"<pre><code>LogicHotSwapSystem hotswap = new LogicHotSwapSystem();\nhotswap.SwapSystemLogic(currentSystem, \"Paths/NewLogic.dll\");\n</code></pre>"},{"location":"API_References/LogicHotSwapSystem_eng/#nexus-optimization-tip-background-loading","title":"Nexus Optimization Tip: Background Loading","text":"<p>Prepare the hot-swap process itself in the background. Continuing to run the old logic until the new assembly is fully loaded and verified prevents game hiccups during development.</p>"},{"location":"API_References/LogicHotSwapSystem_eng/#original-source","title":"Original Source","text":"<p>LogicHotSwapSystem.cs Source Code</p>"},{"location":"API_References/LogicHotSwapSystem_tr/","title":"API Referans\u0131: LogicHotSwapSystem (S\u0131cak Mant\u0131k De\u011fi\u015fimi)","text":""},{"location":"API_References/LogicHotSwapSystem_tr/#giris","title":"Giri\u015f","text":"<p><code>LogicHotSwapSystem.cs</code>, Nexus Prime'\u0131n en esnek \u00f6zelliklerinden birini sunar: \u00c7al\u0131\u015fma zaman\u0131nda sistem mant\u0131\u011f\u0131n\u0131 (Logic) de\u011fi\u015ftirme yetene\u011fi. Bu sistem, oyunun her seferinde yeniden ba\u015flat\u0131lmas\u0131na gerek kalmadan, <code>INexusSystem</code> uygulayan s\u0131n\u0131flar\u0131n davran\u0131\u015flar\u0131n\u0131 yeni bir binary (DLL) \u00fczerinden g\u00fcnceller. Bu, geli\u015ftirme d\u00f6ng\u00fcs\u00fcn\u00fc (iteration speed) muazzam \u00f6l\u00e7\u00fcde h\u0131zland\u0131r\u0131rken, unmanaged veriyi (State) korur.</p>"},{"location":"API_References/LogicHotSwapSystem_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>S\u0131cak de\u011fi\u015fim sistemi \u015fu stratejileri uygular: - Assembly Load Contexts: Yeni mant\u0131k, izole bir y\u00fckleme ba\u011flam\u0131nda (context) projeye dahil edilir. - Interface-Based Migration: <code>INexusSystem</code> aray\u00fcz\u00fcn\u00fc uygulayan yeni s\u0131n\u0131flar taran\u0131r ve eskilerinin yerini al\u0131r. - State Preservation: Veri Registry i\u00e7indeki unmanaged chunklarda sakland\u0131\u011f\u0131 i\u00e7in, mant\u0131k (Logic) de\u011fi\u015fse bile veriler (State) kaybolmaz. - Dynamic Invocation Proxy: JobSystem i\u00e7indeki sistem referanslar\u0131n\u0131 dinamik olarak g\u00fcnceller.</p>"},{"location":"API_References/LogicHotSwapSystem_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tetikleme: Geli\u015ftirici diskteki bir DLL'in de\u011fi\u015fti\u011fini sisteme bildirir.</li> <li>Y\u00fckleme: <code>LogicHotSwapSystem</code> yeni assembly'yi haf\u0131zaya al\u0131r.</li> <li>E\u015fleme: Mevcut sistemlerin yerine ge\u00e7ecek yeni tipler <code>Reflection</code> ile bulunur.</li> <li>De\u011fi\u015fim: JobSystem durdurulur, referanslar yenilenir ve sistemler kald\u0131\u011f\u0131 yerden devam eder.</li> </ol>"},{"location":"API_References/LogicHotSwapSystem_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Logic Hot-Swap: Uygulamay\u0131 kapatmadan kodun davran\u0131\u015f\u0131n\u0131 de\u011fi\u015ftirme tekni\u011fi.</li> <li>Assembly Load Context: DLL'lerin \u00e7ak\u0131\u015fmadan y\u00fcklendi\u011fi ve bo\u015falt\u0131ld\u0131\u011f\u0131 izole bellek alan\u0131.</li> <li>Reflective Discovery: Bir program\u0131n kendi yap\u0131s\u0131n\u0131 (tipler, metodlar) \u00e7al\u0131\u015fma zaman\u0131nda incelemesi.</li> <li>Iteration Speed: Bir de\u011fi\u015fikli\u011fi yap\u0131p test etme h\u0131z\u0131.</li> </ul>"},{"location":"API_References/LogicHotSwapSystem_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Binary Compatibility: Yeni y\u00fcklenen mant\u0131k, mevcut unmanaged veri yap\u0131lar\u0131n\u0131 (Component structs) de\u011fi\u015ftirmemelidir. Veri yap\u0131s\u0131 de\u011fi\u015firse \"Memory Misalignment\" hatalar\u0131 olu\u015fabilir.</li> </ul>"},{"location":"API_References/LogicHotSwapSystem_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>LogicHotSwapSystem hotswap = new LogicHotSwapSystem();\nhotswap.SwapSystemLogic(currentSystem, \"Paths/NewLogic.dll\");\n</code></pre>"},{"location":"API_References/LogicHotSwapSystem_tr/#nexus-optimization-tip-background-loading","title":"Nexus Optimization Tip: Background Loading","text":"<p>Hot-swap i\u015fleminin kendisini arka planda haz\u0131rlay\u0131n. Yeni assembly tamamen y\u00fcklenip do\u011frulana kadar eski mant\u0131\u011f\u0131 \u00e7al\u0131\u015ft\u0131rmaya devam etmek, geli\u015ftirme s\u0131ras\u0131nda oyunun tak\u0131lmas\u0131n\u0131 (hiccup) \u00f6nler.</p>"},{"location":"API_References/LogicHotSwapSystem_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>LogicHotSwapSystem.cs Kaynak Kodu</p>"},{"location":"API_References/MustBeUnmanagedAttribute_eng/","title":"API Reference: MustBeUnmanagedAttribute (Hardware Constraint)","text":""},{"location":"API_References/MustBeUnmanagedAttribute_eng/#introduction","title":"Introduction","text":"<p><code>MustBeUnmanagedAttribute.cs</code> is one of the most critical security markers within Nexus Prime. It seals a data structure (typically a struct) as \"strictly unmanaged.\" If a structure marked with this attribute accidentally contains a managed object (e.g., <code>string</code>, <code>class</code>, <code>List</code>), Nexus checkers will raise an error. This guarantees memory safety and prevents memory alignment corruption.</p>"},{"location":"API_References/MustBeUnmanagedAttribute_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The attribute performs the following functions for system security: - Structural Enforcement: Mandates that the marked structure has a fixed size in memory (Blittable). - Analyzer Integration: <code>Nexus.Attributes</code> analyzers scan this attribute at compile-time to perform compliance checks. - GC Leak Prevention: Prevents objects under Garbage Collector control from leaking into unmanaged chunks, avoiding simulation crashes. - Explicit Intent: Explicitly declares to the developer that this data will be processed at the hardware level (raw memory).</p>"},{"location":"API_References/MustBeUnmanagedAttribute_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Declaration: The developer adds <code>[MustBeUnmanaged]</code> atop the structure.</li> <li>Audit: The compiler or Nexus Integrity Checker scans the contents of the structure.</li> <li>Validation: If a managed reference is found within the structure, the process is halted and an error is reported.</li> <li>Safe Usage: The validated structure is safely subjected to byte copying by the <code>Registry</code> or <code>SnapshotManager</code>.</li> </ol>"},{"location":"API_References/MustBeUnmanagedAttribute_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Unmanaged Type: A type that occupies a fixed space in memory and contains no managed references.</li> <li>Static Enforcement: Mandating rules during the compilation phase before the code runs.</li> <li>Blittable Type: A type that has the same memory layout in both managed and unmanaged worlds.</li> <li>GC Leak: Accidental entry of a managed object reference into unmanaged memory blocks.</li> </ul>"},{"location":"API_References/MustBeUnmanagedAttribute_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>False Security: Simply adding this attribute does not automatically make the structure safe; its content must genuinely comply with unmanaged rules.</li> </ul>"},{"location":"API_References/MustBeUnmanagedAttribute_eng/#usage-example","title":"Usage Example","text":"<pre><code>[MustBeUnmanaged]\npublic struct PhysicsConfig {\n    public float Gravity; // Correct\n    // public string Name; // ERROR: Managed types cannot be used!\n}\n</code></pre>"},{"location":"API_References/MustBeUnmanagedAttribute_eng/#nexus-optimization-tip-zero-marshaling","title":"Nexus Optimization Tip: Zero-Marshaling","text":"<p>Data marked with <code>[MustBeUnmanaged]</code> does not incur \"Marshaling\" (data conversion) costs when transferred between Unity and the unmanaged world. This allows data to pass from one world to the other via zero-cost byte copying, minimizing CPU load.</p>"},{"location":"API_References/MustBeUnmanagedAttribute_eng/#original-source","title":"Original Source","text":"<p>MustBeUnmanagedAttribute.cs Source Code</p>"},{"location":"API_References/MustBeUnmanagedAttribute_tr/","title":"API Referans\u0131: MustBeUnmanagedAttribute (Donan\u0131m K\u0131s\u0131tlamas\u0131)","text":""},{"location":"API_References/MustBeUnmanagedAttribute_tr/#giris","title":"Giri\u015f","text":"<p><code>MustBeUnmanagedAttribute.cs</code>, Nexus Prime i\u00e7indeki en kritik g\u00fcvenlik i\u015faretleyicilerinden biridir. Bir veri yap\u0131s\u0131n\u0131 (genellikle bir struct) \"kesinlikle y\u00f6netilmeyen\" (strictly unmanaged) olarak m\u00fch\u00fcrler. Bu attribute ile i\u015faretlenen bir yap\u0131 i\u00e7inde yanl\u0131\u015fl\u0131kla y\u00f6netilen bir nesne (<code>string</code>, <code>class</code>, <code>List</code> vb.) kullan\u0131l\u0131rsa, Nexus denetleyicileri hata verir. Bu, bellek g\u00fcvenli\u011fini ve bellek hizalamas\u0131n\u0131n bozulmamas\u0131n\u0131 garanti eder.</p>"},{"location":"API_References/MustBeUnmanagedAttribute_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Attribute, sistem g\u00fcvenli\u011fi i\u00e7in \u015fu i\u015flevleri \u00fcstlenir: - Structural Enforcement: \u0130\u015faretlenen yap\u0131n\u0131n bellekte sabit bir boyuta (Blittable) sahip olmas\u0131n\u0131 zorunlu k\u0131lar. - Analyzer Integration: <code>Nexus.Attributes</code> analiz\u00f6rleri, derleme zaman\u0131nda bu attribute'u tarayarak uygunluk denetimi yapar. - GC Leak Prevention: Garbage Collector kontrol\u00fcndeki nesnelerin unmanaged chunklar i\u00e7ine s\u0131zmas\u0131n\u0131 engelleyerek sim\u00fclasyonun \u00e7\u00f6kmesini \u00f6nler. - Explicit Intent: Geli\u015ftiriciye, bu verinin donan\u0131m seviyesinde (raw memory) i\u015flenece\u011fini a\u00e7\u0131k\u00e7a beyan ettirir.</p>"},{"location":"API_References/MustBeUnmanagedAttribute_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Beyan: Geli\u015ftirici yap\u0131 \u00fczerine <code>[MustBeUnmanaged]</code> ekler.</li> <li>Denetim: Derleyici veya Nexus Integrity Checker yap\u0131n\u0131n i\u00e7eri\u011fini tarar.</li> <li>Do\u011frulama: E\u011fer yap\u0131 i\u00e7inde y\u00f6netilen bir referans bulunursa i\u015flem durdurulur ve hata raporlan\u0131r.</li> <li>G\u00fcvenli Kullan\u0131m: Do\u011frulanan yap\u0131, <code>Registry</code> veya <code>SnapshotManager</code> taraf\u0131ndan g\u00fcvenli \u015fekilde byte kopyalamas\u0131na tabi tutulur.</li> </ol>"},{"location":"API_References/MustBeUnmanagedAttribute_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Unmanaged Type: Bellekte sabit yer kaplayan ve y\u00f6netilen referans i\u00e7ermeyen tip.</li> <li>Static Enforcement: Kod \u00e7al\u0131\u015fmadan \u00f6nce, derleme a\u015famas\u0131nda kurallar\u0131n zorunlu k\u0131l\u0131nmas\u0131.</li> <li>Blittable Type: Hem y\u00f6netilen hem de y\u00f6netilmeyen d\u00fcnyada ayn\u0131 bellek dizilimine sahip olan tip.</li> <li>GC Leak: Y\u00f6netilmeyen bellek bloklar\u0131na yanl\u0131\u015fl\u0131kla y\u00f6netilen nesne referans\u0131 girmesi.</li> </ul>"},{"location":"API_References/MustBeUnmanagedAttribute_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>False Security: Sadece bu attribute'u eklemek yap\u0131y\u0131 otomatik olarak g\u00fcvenli yapmaz; i\u00e7eri\u011finin ger\u00e7ekten unmanaged kurallar\u0131na uymas\u0131 gerekir.</li> </ul>"},{"location":"API_References/MustBeUnmanagedAttribute_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>[MustBeUnmanaged]\npublic struct PhysicsConfig {\n    public float Gravity; // Do\u011fru\n    // public string Name; // HATA: Y\u00f6netilen tip kullan\u0131lamaz!\n}\n</code></pre>"},{"location":"API_References/MustBeUnmanagedAttribute_tr/#nexus-optimization-tip-zero-marshaling","title":"Nexus Optimization Tip: Zero-Marshaling","text":"<p><code>[MustBeUnmanaged]</code> ile i\u015faretlenmi\u015f veriler, Unity ve unmanaged d\u00fcnya aras\u0131nda aktar\u0131l\u0131rken \"Marshaling\" (veri d\u00f6n\u00fc\u015ft\u00fcrme) maliyeti olu\u015fturmazlar. Bu, verinin bir d\u00fcnyadan di\u011ferine s\u0131f\u0131r maliyetli (zero-cost) byte kopyalamas\u0131 ile ge\u00e7mesini sa\u011flayarak CPU y\u00fck\u00fcn\u00fc minimize eder.</p>"},{"location":"API_References/MustBeUnmanagedAttribute_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>MustBeUnmanagedAttribute.cs Kaynak Kodu</p>"},{"location":"API_References/NexusAnalyzer_eng/","title":"API Reference: NexusAnalyzer (Static Safety Analyzer)","text":""},{"location":"API_References/NexusAnalyzer_eng/#introduction","title":"Introduction","text":"<p><code>NexusAnalyzer.cs</code> is the \"security guard\" of the Nexus Prime development process. This Roslyn-based tool checks not only that code is written correctly, but also that it complies with rules ensuring performant operation. By specifically checking critical rules, such as ECS components being in an <code>unmanaged</code> (unmanaged) structure, at the compilation (compile) stage, it prevents memory errors and GC delays that might occur at runtime before they even happen.</p>"},{"location":"API_References/NexusAnalyzer_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The analyzer monitors the following rules and techniques: - Unmanaged Constraint (NX001): Checks if all structs used as ECS components are <code>unmanaged</code>. If a managed data type like <code>string</code> or <code>class</code> is found within the struct, it throws an error (Error). - Diagnostic Descriptor: Provides errors in the standard .NET <code>DiagnosticId</code> (e.g., NX001) format, ensuring IDE (Visual Studio/Rider) integration. - Concurrent Execution: Performs the analysis process using all processor cores, thus not slowing down the IDE speed in large projects. - In-IDE Guidance: Instantly explains to the developer the reason for the error and how to resolve it (e.g., \"Struct must be unmanaged\").</p>"},{"location":"API_References/NexusAnalyzer_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Triggering: The analyzer is deployed when a developer saves a file in the IDE or when the project is compiled.</li> <li>Semantic Analysis: Beyond code syntax (syntax), the actual nature of data types (whether they are unmanaged) is examined.</li> <li>Rule Checking: Identified symbols (structs) are tested according to the criteria in the <code>Rule</code> list.</li> <li>Reporting: If there is a violation, a red underline and explanatory text appear on the exact line of code.</li> </ol>"},{"location":"API_References/NexusAnalyzer_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Diagnostic Analyzer: A compiler plugin that identifies errors or improvement opportunities in code.</li> <li>Unmanaged Type: A data type whose memory management is not performed by the Garbage Collector and which is stored in raw memory.</li> <li>Severity (DiagnosticSeverity): The level of importance of an analysis finding (Info, Warning, Error).</li> <li>Semantics: The meaning and type hierarchy of the code (not just spelling rules).</li> </ul>"},{"location":"API_References/NexusAnalyzer_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>False Positives: The analyzer may sometimes mistake structs that are not ECS components for ECS components. Namespace or attribute filters should be precisely adjusted to prevent these situations.</li> </ul>"},{"location":"API_References/NexusAnalyzer_eng/#usage-example","title":"Usage Example","text":"<pre><code>// Faulty Code\npublic struct PlayerData {\n    public string Name; // ERROR: NX001 - Managed string cannot be used.\n}\n\n// Correct Code\npublic struct PlayerData {\n    public NexusString32 Name; // CORRECT: Unmanaged text.\n}\n</code></pre>"},{"location":"API_References/NexusAnalyzer_eng/#nexus-optimization-tip-zero-gc-policy","title":"Nexus Optimization Tip: Zero-GC Policy","text":"<p>NEVER suppress (ignore) NexusAnalyzer errors. These errors are your greatest assurance in maintaining the fluidity (Fluidity) of your game by 100% preventing the Garbage Collector from running in your project.</p>"},{"location":"API_References/NexusAnalyzer_eng/#original-source","title":"Original Source","text":"<p>NexusAnalyzer.cs Source Code</p>"},{"location":"API_References/NexusAnalyzer_tr/","title":"API Referans\u0131: NexusAnalyzer (Statik G\u00fcvenlik Analizcisi)","text":""},{"location":"API_References/NexusAnalyzer_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusAnalyzer.cs</code>, Nexus Prime geli\u015ftirme s\u00fcrecinin \"g\u00fcvenlik g\u00f6revlisidir\". Roslyn tabanl\u0131 bu ara\u00e7, kodun sadece do\u011fru yaz\u0131lmas\u0131n\u0131 de\u011fil, ayn\u0131 zamanda performansl\u0131 \u00e7al\u0131\u015fmas\u0131n\u0131 sa\u011flayacak kurallara uymas\u0131n\u0131 da denetler. \u00d6zellikle ECS bile\u015fenlerinin <code>unmanaged</code> (y\u00f6netilmeyen) yap\u0131da olmas\u0131 gibi kritik kurallar\u0131 derleme (compile) a\u015famas\u0131nda kontrol ederek, \u00e7al\u0131\u015fma zaman\u0131nda olu\u015fabilecek bellek hatalar\u0131n\u0131 ve GC gecikmelerini daha olu\u015fmadan engeller.</p>"},{"location":"API_References/NexusAnalyzer_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Analizci \u015fu kurallar\u0131 ve teknikleri denetler: - Unmanaged Constraint (NX001): ECS bile\u015feni olarak kullan\u0131lan t\u00fcm struct'lar\u0131n <code>unmanaged</code> olup olmad\u0131\u011f\u0131n\u0131 kontrol eder. E\u011fer struct i\u00e7inde <code>string</code> veya <code>class</code> gibi managed bir veri bulunursa hata (Error) f\u0131rlat\u0131r. - Diagnostic Descriptor: Hatalar\u0131 standart .NET <code>DiagnosticId</code> (\u00d6rn: NX001) format\u0131nda sunarak IDE (Visual Studio/Rider) entegrasyonu sa\u011flar. - Concurrent Execution: Analiz i\u015flemini t\u00fcm i\u015flemci \u00e7ekirdeklerini kullanarak ger\u00e7ekle\u015ftirir, b\u00f6ylece b\u00fcy\u00fck projelerde IDE h\u0131z\u0131n\u0131 yava\u015flatmaz. - In-IDE Guidance: Geli\u015ftiriciye hatan\u0131n nedenini ve nas\u0131l \u00e7\u00f6z\u00fclece\u011fini (\u00d6rn: \"Struct must be unmanaged\") anl\u0131k olarak a\u00e7\u0131klar.</p>"},{"location":"API_References/NexusAnalyzer_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tetiklenme: Geli\u015ftirici IDE'de bir dosya kaydetti\u011finde veya proje derlendi\u011finde analizci devreye girer.</li> <li>Semantik Analiz: Kodun s\u00f6zdizimi (syntax) \u00f6tesinde, veri tiplerinin ger\u00e7ek do\u011fas\u0131 (unmanaged olup olmad\u0131\u011f\u0131) incelenir.</li> <li>Kural Kontrol\u00fc: Belirlenen semboller (structlar) <code>Rule</code> listesindeki kriterlere g\u00f6re test edilir.</li> <li>Raporlama: E\u011fer bir ihlal varsa, kodun tam sat\u0131r\u0131nda k\u0131rm\u0131z\u0131 alt \u00e7izgi ve a\u00e7\u0131klay\u0131c\u0131 metin belirir.</li> </ol>"},{"location":"API_References/NexusAnalyzer_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Diagnostic Analyzer: Kod \u00fczerindeki hatalar\u0131 veya iyile\u015ftirme f\u0131rsatlar\u0131n\u0131 tespit eden derleyici eklentisi.</li> <li>Unmanaged Type: Bellek y\u00f6netimi Garbage Collector taraf\u0131ndan yap\u0131lmayan, ham bellek \u00fczerinde saklanan veri tipi.</li> <li>Severity (DiagnosticSeverity): Bir analiz bulgusunun \u00f6nem derecesi (Info, Warning, Error).</li> <li>Semantics: Kodun anlam\u0131 ve tip hiyerar\u015fisi (sadece yaz\u0131m kurallar\u0131 de\u011fil).</li> </ul>"},{"location":"API_References/NexusAnalyzer_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>False Positives: Analizci bazen ECS bile\u015feni olmayan struct'lar\u0131 da ECS bile\u015feni sanabilir. Bu durumlar\u0131 \u00f6nlemek i\u00e7in namespace veya attribute filtreleri hassas ayarlanmal\u0131d\u0131r.</li> </ul>"},{"location":"API_References/NexusAnalyzer_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Hatal\u0131 Kod\npublic struct PlayerData {\n    public string Name; // HATA: NX001 - Managed string kullan\u0131lamaz.\n}\n\n// Do\u011fru Kod\npublic struct PlayerData {\n    public NexusString32 Name; // DO\u011eRU: Unmanaged text.\n}\n</code></pre>"},{"location":"API_References/NexusAnalyzer_tr/#nexus-optimization-tip-zero-gc-policy","title":"Nexus Optimization Tip: Zero-GC Policy","text":"<p>NexusAnalyzer hatalar\u0131n\u0131 ASLA bast\u0131rmay\u0131n (ignore). Bu hatalar, projenizde Garbage Collector'\u0131n \u00e7al\u0131\u015fmas\u0131n\u0131 %100 engelleyerek oyununuzun ak\u0131c\u0131l\u0131\u011f\u0131n\u0131 (Fluidity) koruyan en b\u00fcy\u00fck g\u00fcvencenizdir.</p>"},{"location":"API_References/NexusAnalyzer_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusAnalyzer.cs Kaynak Kodu</p>"},{"location":"API_References/NexusAttributes_eng/","title":"API Reference: NexusAttributes (Editor and Data Attributes)","text":""},{"location":"API_References/NexusAttributes_eng/#introduction","title":"Introduction","text":"<p><code>NexusAttributes.cs</code> is a collection that defines Nexus Prime's power within the Unity Inspector and its unmanaged data synchronization capabilities. These attributes (Attributes) both determine how code appears within the editor and control how unmanaged ECS data automatically communicates (Sync) with the Unity world (Transform, UI).</p>"},{"location":"API_References/NexusAttributes_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The attribute package covers three primary categories: 1. Editor Enhancements: Elevates the professionalism of the Inspector interface with <code>[ReadOnly]</code>, <code>[Required]</code>, <code>[HelpBox]</code>, and <code>[NexusProgressBar]</code>. 2. Execution Control: Enables Unity methods to be executed with a single click via the Inspector with <code>[Button]</code>. 3. Framework Logic:    - <code>[Sync]</code>: Synchronizes unmanaged data bidirectionally with <code>Transform</code>, <code>Physics</code>, or <code>UI</code>.    - <code>[Persistent]</code>: Ensures the entity is protected during scene transitions and within save files.    - <code>[AutoView]</code>: Triggers instant visualization of entity data within the Scene view.</p>"},{"location":"API_References/NexusAttributes_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Marking: The developer adds the appropriate attribute to a field (<code>field</code>) or structure (<code>struct</code>).</li> <li>Compilation: The Nexus Source Generator analyzes these markers and automatically generates the necessary \"wrapper\" code.</li> <li>Runtime: Systems like the <code>SyncManager</code> automatically update fields marked with <code>[Sync]</code> every frame.</li> <li>Visualization: The <code>NexusEditor</code> layer deploys custom Inspector drawings (Drawer) for marked fields.</li> </ol>"},{"location":"API_References/NexusAttributes_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Property Attribute: A C# attribute that determines how a field is drawn in the Unity Inspector.</li> <li>Data Synchronization: The process of keeping data in two different memory regions (Managed vs. Unmanaged) consistent.</li> <li>Persistence: Data durability; preservation even if the application closes or the scene changes.</li> <li>Drawer: A class that draws the visual counterpart of a data type on the editor screen.</li> </ul>"},{"location":"API_References/NexusAttributes_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Attribute Target Mistake: Some attributes work only on classes, while others work only on fields. Attributes added to the wrong target may remain non-functional even if they do not cause a compiler error.</li> </ul>"},{"location":"API_References/NexusAttributes_eng/#usage-example","title":"Usage Example","text":"<pre><code>[Sync(SyncTarget.Transform)]\n[Persistent]\npublic struct ActorData {\n    [ReadOnly] public int InstanceID;\n    [NexusProgressBar(100, \"Green\")] public float Health;\n}\n</code></pre>"},{"location":"API_References/NexusAttributes_eng/#nexus-optimization-tip-selective-sync","title":"Nexus Optimization Tip: Selective Sync","text":"<p>Instead of marking all entities with <code>[Sync(SyncTarget.Transform)]</code>, mark only the dynamic ones (those that move). Keeping the static world out of synchronization reduces the loop load on the SyncManager by 60%.</p>"},{"location":"API_References/NexusAttributes_eng/#original-source","title":"Original Source","text":"<p>NexusAttributes.cs Source Code</p>"},{"location":"API_References/NexusAttributes_tr/","title":"API Referans\u0131: NexusAttributes (Edit\u00f6r ve Veri \u00d6znitelikleri)","text":""},{"location":"API_References/NexusAttributes_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusAttributes.cs</code>, Nexus Prime'\u0131n Unity Inspector \u00fczerindeki g\u00fcc\u00fcn\u00fc ve unmanaged veri senkronizasyon yeteneklerini tan\u0131mlayan bir koleksiyondur. Bu \u00f6znitelikler (Attributes), kodun hem edit\u00f6r i\u00e7inde nas\u0131l g\u00f6r\u00fcnece\u011fini belirler hem de unmanaged ECS verisinin Unity d\u00fcnyas\u0131yla (Transform, UI) nas\u0131l otomatik konu\u015faca\u011f\u0131n\u0131 (Sync) kontrol eder.</p>"},{"location":"API_References/NexusAttributes_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>\u00d6znitelik paketi \u015fu \u00fc\u00e7 ana kategoriyi kapsar: 1. Editor Enhancements: <code>[ReadOnly]</code>, <code>[Required]</code>, <code>[HelpBox]</code> ve <code>[NexusProgressBar]</code> ile Inspector aray\u00fcz\u00fcn\u00fcn profesyonelli\u011fini art\u0131r\u0131r. 2. Execution Control: <code>[Button]</code> ile Unity metodlar\u0131n\u0131 Inspector \u00fczerinden tek t\u0131kla \u00e7al\u0131\u015ft\u0131rmay\u0131 sa\u011flar. 3. Framework Logic:    - <code>[Sync]</code>: Unmanaged veriyi <code>Transform</code>, <code>Physics</code> veya <code>UI</code> ile \u00e7ift tarafl\u0131 senkronize eder.    - <code>[Persistent]</code>: Varl\u0131\u011f\u0131n sahne ge\u00e7i\u015flerinde ve kay\u0131t dosyalar\u0131nda korunmas\u0131n\u0131 sa\u011flar.    - <code>[AutoView]</code>: Varl\u0131k verilerinin Scene view \u00fczerinde anl\u0131k g\u00f6rselle\u015ftirilmesini tetikler.</p>"},{"location":"API_References/NexusAttributes_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130\u015faretleme: Geli\u015ftirici bir alana (<code>field</code>) veya yap\u0131ya (<code>struct</code>) uygun \u00f6zniteli\u011fi ekler.</li> <li>Derleme: Nexus Source Generator bu i\u015faretleyicileri analiz eder ve gerekli \"wrapper\" kodlar\u0131n\u0131 otomatik \u00fcretir.</li> <li>\u00c7al\u0131\u015fma Zaman\u0131: <code>SyncManager</code> gibi sistemler, <code>[Sync]</code> ile i\u015faretli alanlar\u0131 her karede otomatik olarak g\u00fcnceller.</li> <li>G\u00f6rselle\u015ftirme: <code>NexusEditor</code> katman\u0131, i\u015faretli alanlar i\u00e7in \u00f6zel Inspector \u00e7izimlerini (Drawer) devreye sokar.</li> </ol>"},{"location":"API_References/NexusAttributes_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Property Attribute: Unity Inspector'da bir alan\u0131n nas\u0131l \u00e7izilece\u011fini belirleyen C# \u00f6zniteli\u011fi.</li> <li>Data Synchronization: \u0130ki farkl\u0131 bellek b\u00f6lgesindeki verilerin (Managed vs Unmanaged) tutarl\u0131 tutulmas\u0131 s\u00fcreci.</li> <li>Persistence: Verinin kal\u0131c\u0131l\u0131\u011f\u0131; uygulama kapansa veya sahne de\u011fi\u015fse bile korunmas\u0131.</li> <li>Drawer: Bir veri tipinin edit\u00f6r ekran\u0131ndaki g\u00f6rsel kar\u015f\u0131l\u0131\u011f\u0131n\u0131 \u00e7izen s\u0131n\u0131f.</li> </ul>"},{"location":"API_References/NexusAttributes_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Attribute Target Mistake: Baz\u0131 \u00f6znitelikler sadece s\u0131n\u0131flarda, baz\u0131lar\u0131 ise sadece alanlarda \u00e7al\u0131\u015f\u0131r. Yanl\u0131\u015f hedefe eklenen \u00f6znitelikler derleyici hatas\u0131 vermese de i\u015flevsiz kalabilir.</li> </ul>"},{"location":"API_References/NexusAttributes_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>[Sync(SyncTarget.Transform)]\n[Persistent]\npublic struct ActorData {\n    [ReadOnly] public int InstanceID;\n    [NexusProgressBar(100, \"Green\")] public float Health;\n}\n</code></pre>"},{"location":"API_References/NexusAttributes_tr/#nexus-optimization-tip-selective-sync","title":"Nexus Optimization Tip: Selective Sync","text":"<p>T\u00fcm varl\u0131klar\u0131 <code>[Sync(SyncTarget.Transform)]</code> ile i\u015faretlemek yerine sadece dinamik olanlar\u0131 (hareket edenler) i\u015faretleyin. Statik d\u00fcnyay\u0131 senkronizasyon d\u0131\u015f\u0131nda tutmak, SyncManager \u00fczerindeki d\u00f6ng\u00fc y\u00fck\u00fcn\u00fc %60 azalt\u0131r.</p>"},{"location":"API_References/NexusAttributes_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusAttributes.cs Kaynak Kodu</p>"},{"location":"API_References/NexusCollections_eng/","title":"API Reference: NexusCollections (Unmanaged Type System)","text":""},{"location":"API_References/NexusCollections_eng/#introduction","title":"Introduction","text":"<p><code>NexusCollections.cs</code> provides professional, unmanaged, and high-performance alternatives to C#'s managed collections (List, Dictionary). These structures reside within the Nexus ECS world and are outside the scope of the Garbage Collector (GC). In particular, the NexusRef structure provides a \"Safe Access\" layer over unmanaged pointers to prevent memory errors."},{"location":"API_References/NexusCollections_eng/#technical-analysis","title":"Technical Analysis","text":"<p>Nexus collections implement the following standards at the hardware level: - Zero-GC Allocation: All underlying arrays of the collections are created in the unmanaged heap via <code>NexusMemoryManager</code>. - Cache-Aligned Buffers: All list and dictionary data are aligned to 64-byte (cache-line) boundaries. - Self-Validating Pointers (NexusRef): Validates the entity version while carrying a pointer. Access is blocked if the entity is destroyed. - Fixed-Size Unmanaged Strings: The <code>NexusString</code> structure stores text as a blittable struct, allowing string manipulation without entering the heap.</p>"},{"location":"API_References/NexusCollections_eng/#structures-and-logical-flow","title":"Structures and Logical Flow","text":"<ol> <li>NexusList: A dynamically growing unmanaged memory array. Preserves alignment during <code>Realloc</code>. <li>NexusDictionary: Fast search over unmanaged key-value pairs. Optimized for AI decisions and state machines. <li>NexusStack: LIFO (Last-In-First-Out) unmanaged stack, ideal for recycling pools. <li>NexusRef: Seals a raw pointer (<code>T*</code>) with an <code>EntityId</code>. Provides <code>Value</code> access only if the entity is alive."},{"location":"API_References/NexusCollections_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Blittable Struct: A data type that can be copied between the managed and unmanaged world without requiring conversion.</li> <li>Safe Pointer Wrapper: A structure that wraps a raw memory address with a logical safety check.</li> <li>Hash-Free Lookup: Some Nexus collections use linear or sparse searches instead of calculating hashes to preserve CPU cycles.</li> </ul>"},{"location":"API_References/NexusCollections_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Explicit Disposal: Since collections are <code>struct</code>s, memory must be returned via a <code>using</code> block or manual <code>Dispose</code>.</li> <li>Generic Constraints: Only types fulfilling the <code>unmanaged</code> constraint can be stored.</li> </ul>"},{"location":"API_References/NexusCollections_eng/#usage-example","title":"Usage Example","text":"<pre><code>using (var list = new NexusList&lt;int&gt;(10)) {\n    list.Add(42);\n    int* ptr = list.GetPtr(0);\n} // Dispose prevents memory leak\n</code></pre>"},{"location":"API_References/NexusCollections_eng/#nexus-optimization-tip-false-sharing-prevention","title":"Nexus Optimization Tip: False Sharing Prevention","text":"<p>Nexus collections use \"Padding\" techniques when allocating memory blocks to prevent different CPU cores from clashing on the same cache-line (False Sharing). This can increase data transfer speed on multi-core systems by up to 40%.</p>"},{"location":"API_References/NexusCollections_eng/#original-source","title":"Original Source","text":"<p>NexusCollections.cs Source Code</p>"},{"location":"API_References/NexusCollections_tr/","title":"API Referans\u0131: NexusCollections (Unmanaged Tip Sistemi)","text":""},{"location":"API_References/NexusCollections_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusCollections.cs</code>, C# d\u00fcnyas\u0131n\u0131n y\u00f6netilen (managed) koleksiyonlar\u0131na (List, Dictionary) profesyonel, unmanaged ve y\u00fcksek performansl\u0131 alternatifler sunar. Bu yap\u0131lar, Nexus ECS d\u00fcnyas\u0131n\u0131n i\u00e7inde ya\u015far ve Garbage Collector'un (GC) kapsama alan\u0131 d\u0131\u015f\u0131ndad\u0131r. \u00d6zellikle NexusRef yap\u0131s\u0131, unmanaged pointerlar \u00fczerinde \"Safe Access\" (g\u00fcvenli eri\u015fim) katman\u0131 sa\u011flayarak bellek hatalar\u0131n\u0131 \u00f6nler."},{"location":"API_References/NexusCollections_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Nexus koleksiyonlar\u0131, donan\u0131m seviyesinde \u015fu standartlar\u0131 uygular: - Zero-GC Allocation: Koleksiyonlar\u0131n arka plan\u0131ndaki t\u00fcm diziler <code>NexusMemoryManager</code> \u00fczerinden unmanaged heap'te olu\u015fturulur. - Cache-Aligned Buffers: T\u00fcm liste ve s\u00f6zl\u00fck verileri 64 byte (cache-line) s\u0131n\u0131rlar\u0131na hizalan\u0131r. - Self-Validating Pointers (NexusRef): Pointer tutarken ayn\u0131 zamanda varl\u0131k s\u00fcr\u00fcm\u00fcn\u00fc (version) kontrol eder. E\u011fer varl\u0131k silinmi\u015fse pointer'a eri\u015fimi engeller. - Fixed-Size Unmanaged Strings: <code>NexusString</code> yap\u0131s\u0131, metinleri blittable struct olarak tutarak heap'e \u00e7\u0131kmadan string manip\u00fclasyonu sa\u011flar.</p>"},{"location":"API_References/NexusCollections_tr/#yaplar-ve-mantksal-aks","title":"Yap\u0131lar ve Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>NexusList: Dinamik olarak b\u00fcy\u00fcyebilen, unmanaged bellek dizisidir. <code>Realloc</code> kullan\u0131rken verilerin hizalamas\u0131n\u0131 korur. <li>NexusDictionary: Unmanaged anahtar-de\u011fer \u00e7iftleri \u00fczerinde h\u0131zl\u0131 arama yapar. AI kararlar\u0131 ve state makineleri i\u00e7in optimize edilmi\u015ftir. <li>NexusStack: LIFO (Last-In-First-Out) mant\u0131\u011f\u0131yla \u00e7al\u0131\u015fan, geri d\u00f6n\u00fc\u015f\u00fcm havuzlar\u0131 i\u00e7in ideal unmanaged y\u0131\u011f\u0131n. <li>NexusRef: Ham bir pointer'\u0131 (<code>T*</code>) <code>EntityId</code> ile m\u00fch\u00fcrler. Sadece varl\u0131k canl\u0131ysa <code>Value</code> eri\u015fimi verir."},{"location":"API_References/NexusCollections_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Blittable Struct: Y\u00f6netilen ve y\u00f6netilmeyen d\u00fcnya aras\u0131nda d\u00f6n\u00fc\u015f\u00fcm gerektirmeden kopyalanabilen veri tipi.</li> <li>Safe Pointer Wrapper: Ham bellek adresini mant\u0131ksal bir g\u00fcvenlik kontrol\u00fcyle saran yap\u0131.</li> <li>Hash-Free Lookup: Nexus koleksiyonlar\u0131n\u0131n baz\u0131lar\u0131, CPU \u00e7evrimini korumak i\u00e7in hash hesaplamak yerine linear veya sparse aramalar kullan\u0131r.</li> </ul>"},{"location":"API_References/NexusCollections_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Explicit Disposal: Koleksiyonlar <code>struct</code> oldu\u011fu i\u00e7in <code>using</code> blo\u011fu veya manuel <code>Dispose</code> ile bellekleri iade edilmelidir.</li> <li>Generic Constraints: Sadece <code>unmanaged</code> k\u0131s\u0131tlamas\u0131na uyan tipler saklanabilir.</li> </ul>"},{"location":"API_References/NexusCollections_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>using (var list = new NexusList&lt;int&gt;(10)) {\n    list.Add(42);\n    int* ptr = list.GetPtr(0);\n} // Dispose bellek s\u0131z\u0131nt\u0131s\u0131n\u0131 \u00f6nler\n</code></pre>"},{"location":"API_References/NexusCollections_tr/#nexus-optimization-tip-false-sharing-prevention","title":"Nexus Optimization Tip: False Sharing Prevention","text":"<p>Nexus koleksiyonlar\u0131, bellek bloklar\u0131n\u0131 tahsis ederken \"Padding\" (dolgu) tekniklerini kullanarak farkl\u0131 CPU \u00e7ekirdeklerinin ayn\u0131 cache-line \u00fczerinde \u00e7ak\u0131\u015fmas\u0131n\u0131 (False Sharing) engeller. Bu, \u00e7ok \u00e7ekirdekli sistemlerde (Multi-core) veri transfer h\u0131z\u0131n\u0131 %40'a kadar art\u0131rabilir.</p>"},{"location":"API_References/NexusCollections_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusCollections.cs Kaynak Kodu</p>"},{"location":"API_References/NexusCoreExtensions_eng/","title":"API Reference: NexusCoreExtensions (Core Extensions)","text":""},{"location":"API_References/NexusCoreExtensions_eng/#introduction","title":"Introduction","text":"<p><code>NexusCoreExtensions.cs</code> is the most extensive toolset within Nexus Prime. It contains over 30 methods designed to surpass standard C# limitations and perform safe, rapid operations on unmanaged pointers (<code>T*</code>). These extensions serve as a \"Swiss Army Knife\" throughout the framework (Core, Data, Logic), enhancing both code readability and performance.</p>"},{"location":"API_References/NexusCoreExtensions_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The extension package provides methods in the following primary categories: - Pointer Safety: Pointer checks such as <code>IsNull</code>, <code>IsNotNull</code>, and <code>ThrowIfNull</code>. - Memory Manipulation: Raw memory operations like <code>AsRef</code> (ref struct conversion), <code>ClearMemory</code>, <code>CopyFrom</code>, and <code>DeepClone</code>. - Type Intelligence: Compile-time and runtime information methods such as <code>IsBlittable</code>, <code>ByteSize&lt;T&gt;</code>, and <code>IsPowerOfTwo</code>. - Mathematical Helpers: Hardware-friendly math including <code>IsZero</code>, <code>Approximately</code>, <code>WrapAngle</code>, and <code>ClampMagnitude</code>. - Bit Manipulation: Bit-level data control with <code>GetBit</code>, <code>SetBit</code>, <code>ToBinaryString</code>, and <code>BitCast</code>.</p>"},{"location":"API_References/NexusCoreExtensions_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Signature: Methods are typically defined as \"extension methods\" in the form of <code>this T* ptr</code> or <code>this float value</code>.</li> <li>Optimization: Most critical methods are marked with <code>[MethodImpl(MethodImplOptions.AggressiveInlining)]</code>, reducing runtime cost to zero.</li> <li>Unsafe Bridge: Creates a safe bridge between the <code>Unsafe</code> and <code>NativeMemory</code> classes.</li> </ol>"},{"location":"API_References/NexusCoreExtensions_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Extension Method: The ability to add new methods to an existing type without modifying it.</li> <li>BitCast: Interpreting the bit sequence of data in memory as another type without changing it (Reinterpret cast).</li> <li>Aggressive Inlining: The process of the compiler embedding code where it is called to avoid method call overhead.</li> <li>Blittable Type: A type whose layout in memory is identical in both the managed and unmanaged worlds.</li> </ul>"},{"location":"API_References/NexusCoreExtensions_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Unsafe Nature: Most of these methods are within the <code>unsafe</code> scope. Incorrect pointer usage or unaligned (unaligned) memory access can cause core-level crashes.</li> </ul>"},{"location":"API_References/NexusCoreExtensions_eng/#usage-example","title":"Usage Example","text":"<pre><code>Health* h = registry.Get&lt;Health&gt;(entity);\nh-&gt;ThrowIfNull(); // Safety check\nh-&gt;AsRef().CurrentValue += 10; // Process by converting pointer to ref\n</code></pre>"},{"location":"API_References/NexusCoreExtensions_eng/#nexus-optimization-tip-bitcast-over-casting","title":"Nexus Optimization Tip: BitCast over Casting","text":"<p>Use <code>BitCast</code> instead of a standard cast for numerical conversions (e.g., float to int). This allows the processor to simply reinterpret the memory address instead of running \"conversion\" circuits, reducing the conversion cost to zero.</p>"},{"location":"API_References/NexusCoreExtensions_eng/#original-source","title":"Original Source","text":"<p>NexusCoreExtensions.cs Source Code</p>"},{"location":"API_References/NexusCoreExtensions_tr/","title":"API Referans\u0131: NexusCoreExtensions (\u00c7ekirdek Geni\u015fletmeler)","text":""},{"location":"API_References/NexusCoreExtensions_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusCoreExtensions.cs</code>, Nexus Prime i\u00e7indeki en geni\u015f yard\u0131mc\u0131 ara\u00e7 setidir. C# dilinin standart s\u0131n\u0131rlamalar\u0131n\u0131 a\u015fmak ve unmanaged pointerlar (<code>T*</code>) \u00fczerinde g\u00fcvenli, h\u0131zl\u0131 operasyonlar yapabilmek i\u00e7in tasarlanm\u0131\u015f 30'dan fazla metod bar\u0131nd\u0131r\u0131r. Bu geni\u015fletmeler, framework'\u00fcn her yerinde (Core, Data, Logic) \"\u0130svi\u00e7re \u00c7ak\u0131s\u0131\" g\u00f6revi g\u00f6rerek kodun okunabilirli\u011fini ve performans\u0131n\u0131 art\u0131r\u0131r.</p>"},{"location":"API_References/NexusCoreExtensions_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Geni\u015fletme paketi \u015fu ana kategorilerde metodlar sunar: - Pointer Safety: <code>IsNull</code>, <code>IsNotNull</code> ve <code>ThrowIfNull</code> ile pointer denetimleri. - Memory Manipulation: <code>AsRef</code> (ref struct d\u00f6n\u00fc\u015f\u00fcm\u00fc), <code>ClearMemory</code>, <code>CopyFrom</code> ve <code>DeepClone</code> ile ham bellek i\u015flemleri. - Type Intelligence: <code>IsBlittable</code>, <code>ByteSize&lt;T&gt;</code> ve <code>IsPowerOfTwo</code> gibi derleme zaman\u0131 ve \u00e7al\u0131\u015fma zaman\u0131 bilgi metodlar\u0131. - Mathematical Helpers: <code>IsZero</code>, <code>Approximately</code>, <code>WrapAngle</code> ve <code>ClampMagnitude</code> ile donan\u0131m dostu matematik. - Bit Manipulation: <code>GetBit</code>, <code>SetBit</code>, <code>ToBinaryString</code> ve <code>BitCast</code> ile bit seviyesinde veri kontrol\u00fc.</p>"},{"location":"API_References/NexusCoreExtensions_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130mza: Metodlar genellikle <code>this T* ptr</code> veya <code>this float value</code> \u015feklinde \"extension method\" olarak tan\u0131mlanm\u0131\u015ft\u0131r.</li> <li>Optimizasyon: Kritik metodlar\u0131n \u00e7o\u011fu <code>[MethodImpl(MethodImplOptions.AggressiveInlining)]</code> ile i\u015faretlenerek \u00e7al\u0131\u015fma zaman\u0131 maliyeti s\u0131f\u0131ra indirilmi\u015ftir.</li> <li>Unsafe Bridge: <code>Unsafe</code> ve <code>NativeMemory</code> s\u0131n\u0131flar\u0131 aras\u0131nda g\u00fcvenli bir k\u00f6pr\u00fc olu\u015fturur.</li> </ol>"},{"location":"API_References/NexusCoreExtensions_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Extension Method: Mevcut bir tipi de\u011fi\u015ftirmeden ona yeni metodlar ekleme yetene\u011fi.</li> <li>BitCast: Bir verinin bellekteki bit dizilimini de\u011fi\u015ftirmeden ba\u015fka bir tip gibi yorumlama (Reinterpret cast).</li> <li>Aggressive Inlining: Metod \u00e7a\u011fr\u0131s\u0131 maliyetini \u00f6nlemek i\u00e7in kodun \u00e7a\u011fr\u0131ld\u0131\u011f\u0131 yere derleyici taraf\u0131ndan g\u00f6m\u00fclmesi.</li> <li>Blittable Type: Bellekteki dizilimi y\u00f6netilen ve y\u00f6netilmeyen d\u00fcnyada birebir ayn\u0131 olan tip.</li> </ul>"},{"location":"API_References/NexusCoreExtensions_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Unsafe Nature: Bu metodlar\u0131n \u00e7o\u011fu <code>unsafe</code> kapsam\u0131ndad\u0131r. Yanl\u0131\u015f pointer kullan\u0131m\u0131 veya hizas\u0131z (unaligned) bellek eri\u015fimi \u00e7ekirdek seviyesinde \u00e7\u00f6kmelere neden olabilir.</li> </ul>"},{"location":"API_References/NexusCoreExtensions_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>Health* h = registry.Get&lt;Health&gt;(entity);\nh-&gt;ThrowIfNull(); // G\u00fcvenlik denetimi\nh-&gt;AsRef().CurrentValue += 10; // Pointer'\u0131 ref'e d\u00f6n\u00fc\u015ft\u00fcrerek i\u015flem yapma\n</code></pre>"},{"location":"API_References/NexusCoreExtensions_tr/#nexus-optimization-tip-bitcast-over-casting","title":"Nexus Optimization Tip: BitCast over Casting","text":"<p>Say\u0131sal d\u00f6n\u00fc\u015f\u00fcmlerde (\u00f6rn: float to int) standart cast yerine <code>BitCast</code> kullan\u0131n. Bu, i\u015flemcinin \"conversion\" devrelerini \u00e7al\u0131\u015ft\u0131rmak yerine sadece bellek adresini farkl\u0131 yorumlamas\u0131n\u0131 sa\u011flayarak d\u00f6n\u00fc\u015f\u00fcm maliyetini s\u0131f\u0131ra indirir.</p>"},{"location":"API_References/NexusCoreExtensions_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusCoreExtensions.cs Kaynak Kodu</p>"},{"location":"API_References/NexusDashboard_eng/","title":"API Reference: NexusDashboard (Central Control Panel)","text":""},{"location":"API_References/NexusDashboard_eng/#introduction","title":"Introduction","text":"<p><code>NexusDashboard.cs</code> is the heart of the Nexus Prime developer experience (Developer Experience - DX). This tool, also known as \"The Hub\" (Center), gathers all subsystems, optimization tools, and debugging modules within the framework into a single professional panel. It prevents developers from getting lost among hundreds of menus by adding an enterprise-grade control layer to the complex ECS world.</p>"},{"location":"API_References/NexusDashboard_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The panel organizes toolsets in the following categories: - Architectural &amp; Logic: Control of core systems such as Query Optimizer, Hot-Swap, and Serialization. - Unity Editor &amp; DX: Visual development tools such as Visual Debugger, Memory Heatmap, and Inspector Pro. - Multimedia &amp; Integration: External integrations like Physics Bridge, VFX Graph Provider, and Audio Linker. - Grouped Visualization: Reduces complexity by dividing tools into logical groups (Vertical/Horizontal box).</p>"},{"location":"API_References/NexusDashboard_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Launch: The \"Nexus/The Hub\" option is added to the Unity top menu via <code>MenuItem</code>.</li> <li>Drawing: <code>OnGUI</code> renders categories and buttons every frame (or when focused).</li> <li>Triggering: When a button is clicked, the relevant tool's <code>ShowWindow</code> method is called, or a system (e.g., Initialize All) is deployed.</li> <li>Memory: The panel remembers selected settings and open windows throughout the Unity Session.</li> </ol>"},{"location":"API_References/NexusDashboard_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Developer Experience (DX): The ease and efficiency with which a library or tool can be used by developers.</li> <li>Master Dashboard: A main panel managing multiple submodules from a single interface.</li> <li>Layout Grouping: Ensuring visual order by placing interface elements within hierarchical boxes.</li> <li>Initialize All: The process of bringing all subsystems into a stable state (ready state) simultaneously.</li> </ul>"},{"location":"API_References/NexusDashboard_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Menu Overload: Adding too many buttons to the Dashboard can lead to interface complexity and reduced performance. Only the most critical tools should be located on this panel.</li> </ul>"},{"location":"API_References/NexusDashboard_eng/#usage-example","title":"Usage Example","text":"<pre><code>// In the Unity Editor: Follow the path Nexus -&gt; The Hub.\n// Press the \"Visual Debugger\" button to see data on the scene.\n</code></pre>"},{"location":"API_References/NexusDashboard_eng/#nexus-optimization-tip-contextual-tabs","title":"Nexus Optimization Tip: Contextual Tabs","text":"<p>In future versions, transition the Dashboard into a tabbed (Tabbed) structure. Focusing only on the category you need (e.g., only \"Physics\") reduces Editor GUI drawing costs by 30%, offering a smoother DX.</p>"},{"location":"API_References/NexusDashboard_eng/#original-source","title":"Original Source","text":"<p>NexusDashboard.cs Source Code</p>"},{"location":"API_References/NexusDashboard_tr/","title":"API Referans\u0131: NexusDashboard (Merkezi Kontrol Paneli)","text":""},{"location":"API_References/NexusDashboard_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusDashboard.cs</code>, Nexus Prime geli\u015ftirici deneyiminin (Developer Experience - DX) kalbidir. \"The Hub\" (Merkez) olarak da bilinen bu ara\u00e7, framework i\u00e7indeki t\u00fcm alt sistemleri, optimizasyon ara\u00e7lar\u0131n\u0131 ve hata ay\u0131klama mod\u00fcllerini tek bir profesyonel panelde toplar. Geli\u015ftiricilerin y\u00fczlerce men\u00fc aras\u0131nda kaybolmas\u0131n\u0131 \u00f6nleyerek, karma\u015f\u0131k ECS d\u00fcnyas\u0131na kurumsal bir kontrol katman\u0131 ekler.</p>"},{"location":"API_References/NexusDashboard_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Panel \u015fu kategorilerde ara\u00e7 setlerini organize eder: - Architectural &amp; Logic: Query Optimizer, Hot-Swap, Serialization gibi \u00e7ekirdek sistemlerin kontrol\u00fc. - Unity Editor &amp; DX: Visual Debugger, Memory Heatmap, Inspector Pro gibi g\u00f6rsel geli\u015ftirme ara\u00e7lar\u0131. - Multimedia &amp; Integration: Physics Bridge, VFX Graph Provider, Audio Linker gibi d\u0131\u015f d\u00fcnya entegrasyonlar\u0131. - Grouped Visualization: Ara\u00e7lar\u0131 mant\u0131ksal gruplara ay\u0131rarak (Vertical/Horizontal box) karma\u015f\u0131kl\u0131\u011f\u0131 azalt\u0131r.</p>"},{"location":"API_References/NexusDashboard_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Ba\u015flatma: <code>MenuItem</code> \u00fczerinden Unity \u00fcst men\u00fcs\u00fcne \"Nexus/The Hub\" se\u00e7ene\u011fi eklenir.</li> <li>\u00c7izim: <code>OnGUI</code> her karede (veya focus oldu\u011funda) kategorileri ve butonlar\u0131 render eder.</li> <li>Tetikleme: Bir butona t\u0131kland\u0131\u011f\u0131nda, ilgili arac\u0131n <code>ShowWindow</code> metodu \u00e7a\u011fr\u0131l\u0131r veya sistem (\u00f6rn: Initialize All) devreye girer.</li> <li>Haf\u0131za: Panel, se\u00e7ili ayarlar\u0131 ve a\u00e7\u0131k pencereleri Unity Session boyunca hat\u0131rlar.</li> </ol>"},{"location":"API_References/NexusDashboard_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Developer Experience (DX): Bir k\u00fct\u00fcphane veya arac\u0131n geli\u015ftiriciler taraf\u0131ndan ne kadar kolay ve verimli kullan\u0131labildi\u011fi.</li> <li>Master Dashboard: Birden fazla alt mod\u00fcl\u00fc tek bir aray\u00fczden y\u00f6neten ana panel.</li> <li>Layout Grouping: Aray\u00fcz elemanlar\u0131n\u0131n hiyerar\u015fik kutular i\u00e7ine al\u0131narak g\u00f6rsel d\u00fczen sa\u011flanmas\u0131.</li> <li>Initialize All: T\u00fcm alt sistemlerin ayn\u0131 anda stabil duruma (ready state) getirilmesi i\u015flemi.</li> </ul>"},{"location":"API_References/NexusDashboard_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Menu Overload: Dashboard'a \u00e7ok fazla buton eklenmesi, aray\u00fcz\u00fcn karma\u015f\u0131kla\u015fmas\u0131na ve performans\u0131n\u0131n d\u00fc\u015fmesine neden olabilir. Sadece en kritik ara\u00e7lar bu panelde yer almal\u0131d\u0131r.</li> </ul>"},{"location":"API_References/NexusDashboard_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Unity Edit\u00f6r\u00fcnde: Nexus -&gt; The Hub yolunu izleyin.\n// \"Visual Debugger\" butonuna basarak sahne \u00fczerindeki verileri g\u00f6r\u00fcn.\n</code></pre>"},{"location":"API_References/NexusDashboard_tr/#nexus-optimization-tip-contextual-tabs","title":"Nexus Optimization Tip: Contextual Tabs","text":"<p>\u0130lerleyen versiyonlarda, Dashboard'u sekmeli (Tabbed) yap\u0131ya ge\u00e7irin. Sadece o an ihtiyac\u0131n\u0131z olan kategoriye (\u00f6rn: Sadece \"Physics\") odaklanmak, Edit\u00f6r GUI \u00e7izim maliyetini %30 azaltarak daha ak\u0131c\u0131 bir DX sunar.</p>"},{"location":"API_References/NexusDashboard_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusDashboard.cs Kaynak Kodu</p>"},{"location":"API_References/NexusDebugAttribute_eng/","title":"API Reference: NexusDebugAttribute (Visual Debugging)","text":""},{"location":"API_References/NexusDebugAttribute_eng/#introduction","title":"Introduction","text":"<p><code>NexusDebugAttribute.cs</code> is a magical marker that makes the invisible world of unmanaged data visible in the Unity Scene View. When you mark a component or field with this attribute, Nexus automatically draws that data on the scene as a point, arrow, or label. This allows for the visual debugging (visual debugging) of complex unmanaged simulations.</p>"},{"location":"API_References/NexusDebugAttribute_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The attribute controls the following visualization parameters: - DebugShape: The geometric form in which the data will be represented (<code>Point</code>, <code>Arrow</code>, <code>Line</code>, <code>Label</code>). - ColorHex: Hexadecimal (hex) color code determining the color of the drawing. - Size Scale: Adjusts the drawing size for entities at different scales (micro or macro). - Editor-Only Integration: Active only in the Unity Editor environment; it does not incur performance costs in the final user (build) version.</p>"},{"location":"API_References/NexusDebugAttribute_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Marking: The developer adds <code>[NexusDebug(DebugShape.Arrow, \"#FF0000\")]</code> to a component.</li> <li>Discovery: Nexus Editor tools capture this attribute while scanning component types within the <code>Registry</code>.</li> <li>Drawing (Gizmos): Every frame, data from unmanaged memory is read and printed to the screen via the Unity <code>Gizmos</code> API.</li> <li>Update: As the data changes (e.g., as the velocity vector lengthens), the visual arrow is also dynamically updated.</li> </ol>"},{"location":"API_References/NexusDebugAttribute_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Visual Debugging: The technique of reflecting hidden data within the code as visual forms on the screen.</li> <li>Hex Color Code: The numerical/textual (e.g., #FFFFFF) equivalent of colors.</li> <li>Scene View Rendering: Drawings performed via the editor camera, outside of the game camera.</li> <li>Attribute Reflection: The process of code inspecting markers at runtime to adjust itself.</li> </ul>"},{"location":"API_References/NexusDebugAttribute_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Editor Performance: Drawing thousands of entities simultaneously with complex shapes can cause stuttering in the Unity Editor interface. The <code>Point</code> shape is recommended for large datasets.</li> </ul>"},{"location":"API_References/NexusDebugAttribute_eng/#usage-example","title":"Usage Example","text":"<pre><code>[NexusDebug(DebugShape.Arrow, \"#00FF00\", 2.0f)]\npublic struct Velocity { public Vector3 Value; }\n</code></pre>"},{"location":"API_References/NexusDebugAttribute_eng/#nexus-optimization-tip-context-aware-debugging","title":"Nexus Optimization Tip: Context-Aware Debugging","text":"<p>Use <code>NexusDebug</code> only for the systems you are genuinely working on. Marking critical systems (e.g., Raycast hit-points) rather than visualizing the entire unmanaged world simultaneously increases visual focus by 50% during the development phase.</p>"},{"location":"API_References/NexusDebugAttribute_eng/#original-source","title":"Original Source","text":"<p>NexusDebugAttribute.cs Source Code</p>"},{"location":"API_References/NexusDebugAttribute_tr/","title":"API Referans\u0131: NexusDebugAttribute (G\u00f6rsel Hata Ay\u0131klama)","text":""},{"location":"API_References/NexusDebugAttribute_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusDebugAttribute.cs</code>, g\u00f6r\u00fcnmez olan unmanaged veri d\u00fcnyas\u0131n\u0131 Unity Sahne G\u00f6r\u00fcn\u00fcm\u00fcnde (Scene View) g\u00f6r\u00fcn\u00fcr k\u0131lan sihirli bir i\u015faretleyicidir. Bir bile\u015feni veya alan\u0131 bu attribute ile i\u015faretledi\u011finizde, Nexus otomatik olarak o veriyi sahne \u00fczerinde bir nokta, ok veya etiket olarak \u00e7izer. Bu, karma\u015f\u0131k unmanaged sim\u00fclasyonlar\u0131n g\u00f6rsel olarak denetlenmesini (visual debugging) sa\u011flar.</p>"},{"location":"API_References/NexusDebugAttribute_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Attribute, \u015fu g\u00f6rselle\u015ftirme parametrelerini kontrol eder: - DebugShape: Verinin temsil edilece\u011fi geometrik form (<code>Point</code>, <code>Arrow</code>, <code>Line</code>, <code>Label</code>). - ColorHex: \u00c7izimin rengini belirleyen onalt\u0131l\u0131k (hex) renk kodu. - Size Scale: Farkl\u0131 \u00f6l\u00e7eklerdeki (mikro veya makro) varl\u0131klar i\u00e7in \u00e7izim boyutunu ayarlar. - Editor-Only Integration: Sadece Unity Editor ortam\u0131nda aktiftir; son kullan\u0131c\u0131 (build) s\u00fcr\u00fcm\u00fcnde performans maliyeti olu\u015fturmaz.</p>"},{"location":"API_References/NexusDebugAttribute_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130\u015faretleme: Geli\u015ftirici bir bile\u015fene <code>[NexusDebug(DebugShape.Arrow, \"#FF0000\")]</code> ekler.</li> <li>Ke\u015fif: Nexus Editor ara\u00e7lar\u0131, <code>Registry</code> i\u00e7indeki bile\u015fen tiplerini tararken bu attribute'u yakalar.</li> <li>\u00c7izim (Gizmos): Her karede, unmanaged bellekteki veriler okunur ve Unity <code>Gizmos</code> API'si \u00fczerinden ekrana bas\u0131l\u0131r.</li> <li>G\u00fcncelleme: Veri de\u011fi\u015ftik\u00e7e (\u00f6rne\u011fin h\u0131z vekt\u00f6r\u00fc uzad\u0131k\u00e7a) g\u00f6rsel ok da dinamik olarak g\u00fcncellenir.</li> </ol>"},{"location":"API_References/NexusDebugAttribute_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Visual Debugging: Kodun i\u00e7indeki gizli verileri g\u00f6rsel formlar olarak ekrana yans\u0131tma tekni\u011fi.</li> <li>Hex Color Code: Renklerin say\u0131sal/metinsel (\u00f6rn: #FFFFFF) kar\u015f\u0131l\u0131\u011f\u0131.</li> <li>Scene View Rendering: Oyun kameras\u0131 d\u0131\u015f\u0131nda, edit\u00f6r kameras\u0131 \u00fczerinden yap\u0131lan \u00e7izimler.</li> <li>Attribute Reflection: Kodun \u00e7al\u0131\u015fma zaman\u0131nda i\u015faretleyicileri inceleyerek kendine \u00e7eki d\u00fczen vermesi.</li> </ul>"},{"location":"API_References/NexusDebugAttribute_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Editor Performance: Binlerce varl\u0131\u011f\u0131 ayn\u0131 anda karma\u015f\u0131k \u015fekillerle \u00e7izmek Unity Editor aray\u00fcz\u00fcnde yava\u015flamaya neden olabilir. B\u00fcy\u00fck veri setleri i\u00e7in <code>Point</code> \u015fekli \u00f6nerilir.</li> </ul>"},{"location":"API_References/NexusDebugAttribute_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>[NexusDebug(DebugShape.Arrow, \"#00FF00\", 2.0f)]\npublic struct Velocity { public Vector3 Value; }\n</code></pre>"},{"location":"API_References/NexusDebugAttribute_tr/#nexus-optimization-tip-context-aware-debugging","title":"Nexus Optimization Tip: Context-Aware Debugging","text":"<p>Sadece ger\u00e7ekten \u00fczerinde \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131z sistemler i\u00e7in <code>NexusDebug</code> kullan\u0131n. T\u00fcm unmanaged d\u00fcnyay\u0131 ayn\u0131 anda g\u00f6rselle\u015ftirmek yerine, kritik sistemleri (\u00f6rn: Raycast hit-points) i\u015faretlemek, geli\u015ftirme a\u015famas\u0131nda g\u00f6rsel odaklanmay\u0131 (focus) %50 art\u0131r\u0131r.</p>"},{"location":"API_References/NexusDebugAttribute_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusDebugAttribute.cs Kaynak Kodu</p>"},{"location":"API_References/NexusEventBus_eng/","title":"API Reference: NexusEventBus (Event Communication Line)","text":""},{"location":"API_References/NexusEventBus_eng/#introduction","title":"Introduction","text":"<p><code>NexusEventBus.cs</code> is the \"nervous system\" that provides inter-system communication within Nexus Prime. By loosening the dependence (decoupling) between independently operating managed Unity code and unmanaged ECS systems, it offers an event-driven (event-driven) architecture. Its thread-safe structure ensures events from different processor cores are managed securely.</p>"},{"location":"API_References/NexusEventBus_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The event line incorporates the following advanced features: - Concurrent Dictionary Storage: Ensures dynamic subscription at runtime by keeping subscribers (subscribers) in a thread-safe dictionary. - Debounced Publish: Prevents CPU wastage by blocking duplicate events within a specific time interval. - Buffered Events: Queues events that do not yet have subscribers and automatically triggers them when a subscriber appears. - Local Event Scoping: In addition to global events, it supports local events (Local Subscribe/Publish) concerning only a specific EntityId.</p>"},{"location":"API_References/NexusEventBus_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Subscription: A system begins listening for a specific event with <code>Subscribe&lt;T&gt;</code>.</li> <li>Publication: Another system throws an event object with <code>Publish&lt;T&gt;</code>.</li> <li>Distribution: The Bus finds relevant subscribers from the dictionary and conveys the event data to them asynchronously or synchronously.</li> <li>Cleanup: Memory leaks (leak) are prevented by terminating the subscription with <code>Unsubscribe</code>.</li> </ol>"},{"location":"API_References/NexusEventBus_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Event-Driven Architecture: An architecture where the program flow is determined by events.</li> <li>Decoupling: The process of reducing the dependence of two systems on each other.</li> <li>Thread-Safety: The ability of code to run on multiple CPU cores simultaneously without damaging data.</li> <li>Debouncing: The technique of preventing a process from being performed repeatedly at very short intervals (filtering the signal).</li> </ul>"},{"location":"API_References/NexusEventBus_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Anonymous Method Leak: If a lambda (anonymous method) is used during subscription, <code>Unsubscribe</code> may not be possible, leading to persistent references (memory leak). Usage of named methods is recommended.</li> </ul>"},{"location":"API_References/NexusEventBus_eng/#usage-example","title":"Usage Example","text":"<pre><code>NexusEventBus.Subscribe&lt;PlayerDeathEvent&gt;(e =&gt; Debug.Log(\"Player died: \" + e.Id));\nNexusEventBus.Publish(new PlayerDeathEvent { Id = 1 });\n</code></pre>"},{"location":"API_References/NexusEventBus_eng/#nexus-optimization-tip-local-over-global","title":"Nexus Optimization Tip: Local Over Global","text":"<p>Use <code>PublishLocal</code> for events concerning only a specific unit among thousands of entities. This increases event distribution speed by 80% by eliminating the load of scanning all subscribers.</p>"},{"location":"API_References/NexusEventBus_eng/#original-source","title":"Original Source","text":"<p>NexusEventBus.cs Source Code</p>"},{"location":"API_References/NexusEventBus_tr/","title":"API Referans\u0131: NexusEventBus (Olay \u0130leti\u015fim Hatt\u0131)","text":""},{"location":"API_References/NexusEventBus_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusEventBus.cs</code>, Nexus Prime i\u00e7indeki sistemler aras\u0131 ileti\u015fimi sa\u011flayan \"sinir sistemidir\". Birbirinden ba\u011f\u0131ms\u0131z \u00e7al\u0131\u015fan managed Unity kodlar\u0131 ile unmanaged ECS sistemleri aras\u0131ndaki ba\u011f\u0131 gev\u015feterek (decoupling), olay-tabanl\u0131 (event-driven) bir mimari sunar. Thread-safe yap\u0131s\u0131 sayesinde farkl\u0131 i\u015flemci \u00e7ekirdeklerinden gelen olaylar\u0131 g\u00fcvenle y\u00f6netir.</p>"},{"location":"API_References/NexusEventBus_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Olay hatt\u0131 \u015fu geli\u015fmi\u015f \u00f6zellikleri bar\u0131nd\u0131r\u0131r: - Concurrent Dictionary Storage: Aboneleri (subscribers) i\u015f par\u00e7ac\u0131\u011f\u0131 g\u00fcvenli bir s\u00f6zl\u00fckte tutarak, \u00e7al\u0131\u015fma zaman\u0131nda dinamik abonelik sa\u011flar. - Debounced Publish: Belirli bir zaman aral\u0131\u011f\u0131ndaki m\u00fckerrer olaylar\u0131 engelleyerek CPU israf\u0131n\u0131 \u00f6nler. - Buffered Events: Hen\u00fcz abonesi olmayan olaylar\u0131 kuyru\u011fa al\u0131p, abone geldi\u011finde otomatik tetikleme yapar. - Local Event Scoping: Global olaylar\u0131n yan\u0131 s\u0131ra, sadece belirli bir EntityId'yi ilgilendiren yerel olaylar\u0131 (Local Subscribe/Publish) destekler.</p>"},{"location":"API_References/NexusEventBus_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Abonelik: Bir sistem <code>Subscribe&lt;T&gt;</code> ile belirli bir olay\u0131 dinlemeye ba\u015flar.</li> <li>Yay\u0131n: Ba\u015fka bir sistem <code>Publish&lt;T&gt;</code> ile bir olay nesnesi f\u0131rlat\u0131r.</li> <li>Da\u011f\u0131t\u0131m: Bus, s\u00f6zl\u00fckten ilgili aboneleri bulur ve olay verisini onlara asenkron veya senkron olarak iletir.</li> <li>Temizlik: <code>Unsubscribe</code> ile abonelik sonland\u0131r\u0131larak bellek s\u0131z\u0131nt\u0131lar\u0131 (leak) \u00f6nlenir.</li> </ol>"},{"location":"API_References/NexusEventBus_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Event-Driven Architecture: Program ak\u0131\u015f\u0131n\u0131n olaylar taraf\u0131ndan belirlendi\u011fi mimari.</li> <li>Decoupling: \u0130ki sistemin birbirine olan ba\u011f\u0131ml\u0131l\u0131\u011f\u0131n\u0131 azaltma i\u015flemi.</li> <li>Thread-Safety: Kodun ayn\u0131 anda birden fazla CPU \u00e7ekirde\u011finde veriye zarar vermeden \u00e7al\u0131\u015fabilme yetene\u011fi.</li> <li>Debouncing: Bir i\u015flemin \u00e7ok k\u0131sa aral\u0131klarla tekrar tekrar yap\u0131lmas\u0131n\u0131 \u00f6nleme (sinyali s\u00fczme) tekni\u011fi.</li> </ul>"},{"location":"API_References/NexusEventBus_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Anonymous Method Leak: E\u011fer abonelik s\u0131ras\u0131nda lambda (isimsiz metod) kullan\u0131l\u0131rsa, <code>Unsubscribe</code> i\u015flemi yap\u0131lamayabilir ve bu da kal\u0131c\u0131 referanslara (memory leak) yol a\u00e7abilir. \u0130simli metodlar\u0131n kullan\u0131lmas\u0131 \u00f6nerilir.</li> </ul>"},{"location":"API_References/NexusEventBus_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>NexusEventBus.Subscribe&lt;PlayerDeathEvent&gt;(e =&gt; Debug.Log(\"Oyuncu \u00f6ld\u00fc: \" + e.Id));\nNexusEventBus.Publish(new PlayerDeathEvent { Id = 1 });\n</code></pre>"},{"location":"API_References/NexusEventBus_tr/#nexus-optimization-tip-local-over-global","title":"Nexus Optimization Tip: Local Over Global","text":"<p>Binlerce varl\u0131k aras\u0131nda sadece belirli bir birimi ilgilendiren olaylar i\u00e7in <code>PublishLocal</code> kullan\u0131n. Bu, t\u00fcm aboneleri tarama y\u00fck\u00fcn\u00fc ortadan kald\u0131rarak olay da\u011f\u0131t\u0131m h\u0131z\u0131n\u0131 %80 art\u0131r\u0131r.</p>"},{"location":"API_References/NexusEventBus_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusEventBus.cs Kaynak Kodu</p>"},{"location":"API_References/NexusHelper_eng/","title":"API Reference: NexusHelper (Master Helper)","text":""},{"location":"API_References/NexusHelper_eng/#introduction","title":"Introduction","text":"<p><code>NexusHelper.cs</code> serves as the \"Entrance Gate\" (Master Facade) for the Nexus Prime Unity Framework. It unifies complex and low-level modules within the framework (Pooling, Events, Logging, etc.) under a single readable API. It allows developers to utilize all Nexus power through a single static class, without the need to directly touch internal classes.</p>"},{"location":"API_References/NexusHelper_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The helper class consists of a combination (facade) of the following systems: - Logging Facade: Access to the <code>NexusLogger</code> via <code>Log</code>, <code>LogError</code>, and <code>LogSuccess</code> methods. - Pooling Facade: Zero-allocation object management via the <code>NexusObjectPool</code> using the <code>Spawn</code> and <code>Despawn</code> methods. - Communication Facade: Global <code>NexusEventBus</code> control via the <code>Publish</code>, <code>Subscribe</code>, and <code>Unsubscribe</code> methods. - Logic Controllers: The ability to trigger high-level entity behaviors like <code>Move</code> and <code>RotateTowards</code>. - UI Binding: Binding unmanaged data directly to Unity UI elements with the <code>BindUI</code> extension.</p>"},{"location":"API_References/NexusHelper_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Request: The developer calls a simple command such as <code>NexusHelper.Spawn(...)</code>.</li> <li>Direction: The Helper conveys this request to relevant sub-modules (e.g., <code>NexusObjectPool</code>).</li> <li>Synchronization: When necessary (e.g., <code>BindUI</code>), the bridge between unmanaged data and the managed visual world is established.</li> <li>Execution: The process is performed, and the result (object or success state) is returned to the developer.</li> </ol>"},{"location":"API_References/NexusHelper_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Master Facade: A design pattern that offers a simple interface to a complex group of subsystems.</li> <li>Entry Point: The primary start/access point for a library or framework.</li> <li>Logic Controller: A high-segment component that manages the physical or logical movements of an entity.</li> <li>UI Binding: Automatically updating the interface as variables change by linking the data and the interface element.</li> </ul>"},{"location":"API_References/NexusHelper_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>High Dependency: NexusHelper is dependent on nearly all parts of the library. Changes made within a sub-module may affect Helper properties.</li> </ul>"},{"location":"API_References/NexusHelper_eng/#usage-example","title":"Usage Example","text":"<pre><code>NexusHelper.LogSuccess(this, \"System Active!\");\nNexusHelper.Spawn(prefab, Vector3.zero, Quaternion.identity);\nNexusHelper.Subscribe&lt;GameWinEvent&gt;(OnWin);\n</code></pre>"},{"location":"API_References/NexusHelper_eng/#nexus-optimization-tip-unified-entry-point","title":"Nexus Optimization Tip: Unified Entry Point","text":"<p>Always use <code>NexusHelper</code> in your code instead of directly writing <code>NexusObjectPool</code> or <code>NexusLogger</code>. This allows you to update only the Helper if you change a module (e.g., another logger) in the future, instead of updating your entire project.</p>"},{"location":"API_References/NexusHelper_eng/#original-source","title":"Original Source","text":"<p>NexusHelper.cs Source Code</p>"},{"location":"API_References/NexusHelper_tr/","title":"API Referans\u0131: NexusHelper (Ana Yard\u0131mc\u0131)","text":""},{"location":"API_References/NexusHelper_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusHelper.cs</code>, Nexus Prime Unity Framework'\u00fcn \"Giri\u015f Kap\u0131s\u0131\" (Master Facade) rol\u00fcn\u00fc \u00fcstlenir. Framework i\u00e7indeki karma\u015f\u0131k ve d\u00fc\u015f\u00fck seviyeli mod\u00fclleri (Havuzlama, Olaylar, G\u00fcnl\u00fckleme vb.) tek bir okunabilir API alt\u0131nda birle\u015ftirir. Geli\u015ftiricilerin do\u011frudan i\u00e7 s\u0131n\u0131flara dokunmas\u0131na gerek kalmadan, tek bir statik s\u0131n\u0131f \u00fczerinden t\u00fcm Nexus g\u00fcc\u00fcn\u00fc kullanmas\u0131n\u0131 sa\u011flar.</p>"},{"location":"API_References/NexusHelper_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Yard\u0131mc\u0131 s\u0131n\u0131f \u015fu sistemlerin birle\u015fiminden (facade) olu\u015fur: - Logging Facade: <code>Log</code>, <code>LogError</code>, <code>LogSuccess</code> metodlar\u0131 ile <code>NexusLogger</code>'a eri\u015fim. - Pooling Facade: <code>Spawn</code> ve <code>Despawn</code> metodlar\u0131 ile <code>NexusObjectPool</code> \u00fczerinden s\u0131f\u0131r-tahsisatl\u0131 nesne y\u00f6netimi. - Communication Facade: <code>Publish</code>, <code>Subscribe</code> ve <code>Unsubscribe</code> metodlar\u0131 ile global <code>NexusEventBus</code> kontrol\u00fc. - Logic Controllers: <code>Move</code> ve <code>RotateTowards</code> gibi y\u00fcksek seviyeli varl\u0131k davran\u0131\u015flar\u0131n\u0131 tetikleme yetene\u011fi. - UI Binding: <code>BindUI</code> geni\u015fletmesi ile unmanaged verileri do\u011frudan Unity UI elemanlar\u0131na ba\u011flama.</p>"},{"location":"API_References/NexusHelper_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130stek: Geli\u015ftirici <code>NexusHelper.Spawn(...)</code> gibi basit bir komut \u00e7a\u011f\u0131r\u0131r.</li> <li>Y\u00f6nlendirme: Helper, bu iste\u011fi ilgili alt mod\u00fcle (\u00f6rn: <code>NexusObjectPool</code>) iletir.</li> <li>Senkronizasyon: Gerekli durumlarda (\u00f6rn: <code>BindUI</code>), unmanaged veri ile managed g\u00f6rsel d\u00fcnya aras\u0131ndaki k\u00f6pr\u00fc kurulur.</li> <li>\u0130nfaz: \u0130\u015flem ger\u00e7ekle\u015ftirilir ve sonu\u00e7 (obje veya ba\u015far\u0131l\u0131 durum) geli\u015ftiriciye d\u00f6ner.</li> </ol>"},{"location":"API_References/NexusHelper_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Master Facade: Karma\u015f\u0131k bir alt sistemler grubuna basit bir aray\u00fcz sunan tasar\u0131m deseni.</li> <li>Entry Point: Bir k\u00fct\u00fcphane veya framework\u00fcn ana ba\u015flama/eri\u015fim noktas\u0131.</li> <li>Logic Controller: Varl\u0131\u011f\u0131n fiziksel veya mant\u0131ksal hareketlerini y\u00f6neten \u00fcst segment bile\u015fen.</li> <li>UI Binding: Veri ile aray\u00fcz eleman\u0131n\u0131 birbirine ba\u011flayarak de\u011fi\u015fken de\u011fi\u015ftik\u00e7e aray\u00fcz\u00fcn otomatik g\u00fcncellenmesi.</li> </ul>"},{"location":"API_References/NexusHelper_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>High Dependency: NexusHelper k\u00fct\u00fcphanenin neredeyse t\u00fcm par\u00e7alar\u0131na ba\u011f\u0131ml\u0131d\u0131r. Bir alt mod\u00fclde yap\u0131lan de\u011fi\u015fiklikler Helper m\u00fclkiyetlerini etkileyebilir.</li> </ul>"},{"location":"API_References/NexusHelper_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>NexusHelper.LogSuccess(this, \"Sistem Aktif!\");\nNexusHelper.Spawn(prefab, Vector3.zero, Quaternion.identity);\nNexusHelper.Subscribe&lt;GameWinEvent&gt;(OnWin);\n</code></pre>"},{"location":"API_References/NexusHelper_tr/#nexus-optimization-tip-unified-entry-point","title":"Nexus Optimization Tip: Unified Entry Point","text":"<p>Kodunuzda do\u011frudan <code>NexusObjectPool</code> veya <code>NexusLogger</code> yazmak yerine her zaman <code>NexusHelper</code> kullan\u0131n. Bu, ileride bir mod\u00fcl\u00fc de\u011fi\u015ftirdi\u011finizde (\u00f6rn: ba\u015fka bir logger) t\u00fcm projenizi g\u00fcncellemek yerine sadece Helper'\u0131 g\u00fcncellemenize olanak tan\u0131r.</p>"},{"location":"API_References/NexusHelper_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusHelper.cs Kaynak Kodu</p>"},{"location":"API_References/NexusInitializer_eng/","title":"API Reference: NexusInitializer (Scene Automation Engine)","text":""},{"location":"API_References/NexusInitializer_eng/#introduction","title":"Introduction","text":"<p><code>NexusInitializer.cs</code> is a <code>MonoBehaviour</code> component that enables \"One-Click\" setup of the Nexus Prime engine within Unity scenes. It automatically manages the lifecycle (Awake/Update/Destroy) of systems like the Registry, Job System, and Snapshot Manager, eliminating the need for the developer to write complex infrastructure code.</p>"},{"location":"API_References/NexusInitializer_eng/#technical-analysis","title":"Technical Analysis","text":"<p>NexusInitializer assumes the following operational responsibilities: - Lifecycle Management: Initializes all unmanaged Registry and Job modules during the <code>Awake</code> phase and performs a safe cleanup (<code>Dispose</code>) during <code>OnDestroy</code> to prevent memory leaks. - Parallel Dispatcher: Triggers the unmanaged Job System every frame (<code>Update</code>) to ensure hardware-accelerated data processing. - Runtime Integrity Audit: Audits unmanaged memory blocks via <code>NexusIntegrityChecker</code> every 60 frames and reports potential alignment errors. - Config-Driven Setup: Allows management of parameters such as maximum history frames and parallel execution through the Unity Editor.</p>"},{"location":"API_References/NexusInitializer_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Initialization: <code>Registry</code> and <code>JobSystem</code> are created on the unmanaged heap at <code>Awake</code>.</li> <li>Frame Loop: ECS systems are executed via the <code>JobSystem.Execute()</code> call within <code>Update</code>.</li> <li>Audit: System health (<code>Audit</code>) is checked at specific frame intervals.</li> <li>Destruction: When the scene changes or the application closes, <code>Dispose</code> is called to return unmanaged memory to the OS.</li> </ol>"},{"location":"API_References/NexusInitializer_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Lifecycle Manager: A status that manages a system's process from creation to destruction.</li> <li>Parallel Execution: Distributing processes across multiple CPU cores for simultaneous execution.</li> <li>Integrity Check: Mathematical verification that data remains uncorrupted and properly aligned in memory.</li> <li>Nominal Status: A state where the system is operating healthily and without errors in all aspects.</li> </ul>"},{"location":"API_References/NexusInitializer_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Multiple Instances: Having multiple Initializers in a scene can lead to memory confusion (only one Master Initializer should be used).</li> <li>Execution Order: Unity's <code>Update</code> priority (Script Execution Order) may clash with other systems.</li> </ul>"},{"location":"API_References/NexusInitializer_eng/#usage-example","title":"Usage Example","text":"<ol> <li>Create an empty GameObject.</li> <li>Add the <code>NexusInitializer</code> script.</li> <li>Configure settings via the editor (Parallel Execution: OK).</li> </ol>"},{"location":"API_References/NexusInitializer_eng/#nexus-optimization-tip-periodic-integrity-audit","title":"Nexus Optimization Tip: Periodic Integrity Audit","text":"<p>NexusInitializer performs memory integrity audits once per second (at 60 FPS) via <code>Time.frameCount % 60</code> logic, rather than every frame. This reduces the processor load of the integrity check by 98% while maintaining sufficient safety to detect potential memory leaks.</p>"},{"location":"API_References/NexusInitializer_eng/#original-source","title":"Original Source","text":"<p>NexusInitializer.cs Source Code</p>"},{"location":"API_References/NexusInitializer_tr/","title":"API Referans\u0131: NexusInitializer (Sahne Otomasyon Motoru)","text":""},{"location":"API_References/NexusInitializer_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusInitializer.cs</code>, Nexus Prime motorunun Unity sahneleri i\u00e7inde \"Tek T\u0131kla\" (<code>One-Click</code>) kurulmas\u0131n\u0131 sa\u011flayan <code>MonoBehaviour</code> bile\u015fenidir. Geli\u015ftiricinin karma\u015f\u0131k altyap\u0131 kodlar\u0131 yazmas\u0131na gerek kalmadan; Registry, Job System ve Snapshot Manager gibi sistemlerin ya\u015fam d\u00f6ng\u00fcs\u00fcn\u00fc (Awake/Update/Destroy) otomatik olarak y\u00f6netir.</p>"},{"location":"API_References/NexusInitializer_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>NexusInitializer, \u015fu operasyonel sorumluluklar\u0131 \u00fcstlenir: - Lifecycle Management: <code>Awake</code> a\u015famas\u0131nda t\u00fcm unmanaged Registry ve Job mod\u00fcllerini aya\u011fa kald\u0131r\u0131r, <code>OnDestroy</code> a\u015famas\u0131nda bellek s\u0131z\u0131nt\u0131lar\u0131n\u0131 \u00f6nlemek i\u00e7in g\u00fcvenli temizleme (<code>Dispose</code>) yapar. - Parallel Dispatcher: Her karede (<code>Update</code>) unmanaged Job sistemini tetikleyerek verilerin donan\u0131m h\u0131zland\u0131rmal\u0131 olarak i\u015flenmesini sa\u011flar. - Runtime Integrity Audit: Her 60 karede bir <code>NexusIntegrityChecker</code> \u00fczerinden unmanaged bellek bloklar\u0131n\u0131 denetler ve olas\u0131 hizalama hatalar\u0131n\u0131 raporlar. - Config-Driven Setup: Edit\u00f6r \u00fczerinden max zaman ge\u00e7mi\u015fi ve paralel \u00e7al\u0131\u015fma gibi parametrelerin y\u00f6netilmesini sa\u011flar.</p>"},{"location":"API_References/NexusInitializer_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130lklendirme: <code>Awake</code> an\u0131nda <code>Registry</code> ve <code>JobSystem</code> unmanaged heap \u00fczerinde olu\u015fturulur.</li> <li>Kare D\u00f6ng\u00fcs\u00fc: <code>Update</code> i\u00e7inde <code>JobSystem.Execute()</code> \u00e7a\u011fr\u0131s\u0131 ile ECS sistemleri ko\u015fturulur.</li> <li>Denetim: Belirli aral\u0131klarla (frame base) sistem sa\u011fl\u0131\u011f\u0131 (<code>Audit</code>) kontrol edilir.</li> <li>\u0130mha: Sahne de\u011fi\u015fti\u011finde veya uygulama kapand\u0131\u011f\u0131nda <code>Dispose</code> \u00e7a\u011fr\u0131larak unmanaged bellek i\u015fletim sistemine iade edilir.</li> </ol>"},{"location":"API_References/NexusInitializer_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Lifecycle Manager: Bir sistemin do\u011fu\u015fundan \u00f6l\u00fcm\u00fcne kadar olan s\u00fcrecini y\u00f6neten stat\u00fc.</li> <li>Parallel Execution: \u0130\u015flemlerin birden fazla CPU \u00e7ekirde\u011fine da\u011f\u0131t\u0131larak ayn\u0131 anda yap\u0131lmas\u0131.</li> <li>Integrity Check: Verinin bellekte bozulmadan veya hizalamas\u0131 kaymadan durdu\u011funun matematiksel do\u011frulanmas\u0131.</li> <li>Nominal Status: Sistemin her a\u00e7\u0131dan sa\u011fl\u0131kl\u0131 ve hatas\u0131z \u00e7al\u0131\u015ft\u0131\u011f\u0131 durum.</li> </ul>"},{"location":"API_References/NexusInitializer_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Multiple Instances: Bir sahnede birden fazla Initializer olmas\u0131 bellek karma\u015fas\u0131na yol a\u00e7abilir (Sadece bir adet Master Initializer kullan\u0131lmal\u0131d\u0131r).</li> <li>Execution Order: Unity'nin <code>Update</code> \u00f6nceli\u011fi (Script Execution Order) di\u011fer sistemlerle \u00e7ak\u0131\u015fabilir.</li> </ul>"},{"location":"API_References/NexusInitializer_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<ol> <li>Bo\u015f bir GameObject olu\u015fturun.</li> <li><code>NexusInitializer</code> scriptini ekleyin.</li> <li>Ayarlar\u0131 edit\u00f6r \u00fczerinden yap\u0131land\u0131r\u0131n (Parallel Execution: OK).</li> </ol>"},{"location":"API_References/NexusInitializer_tr/#nexus-optimization-tip-periodic-integrity-audit","title":"Nexus Optimization Tip: Periodic Integrity Audit","text":"<p>NexusInitializer, bellek b\u00fct\u00fcnl\u00fck kontrollerini her karede de\u011fil, <code>Time.frameCount % 60</code> mant\u0131\u011f\u0131yla saniyede 1 kez (60 FPS'de) yapar. Bu, b\u00fct\u00fcnl\u00fck kontrol\u00fcn\u00fcn i\u015flemci \u00fczerindeki y\u00fck\u00fcn\u00fc %98 oran\u0131nda azalt\u0131rken, olas\u0131 bellek s\u0131z\u0131nt\u0131lar\u0131n\u0131 tespit etmek i\u00e7in yeterli g\u00fcvenli\u011fi sa\u011flar.</p>"},{"location":"API_References/NexusInitializer_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusInitializer.cs Kaynak Kodu</p>"},{"location":"API_References/NexusIntegrityChecker_eng/","title":"API Reference: NexusIntegrityChecker (Integrity Checker)","text":""},{"location":"API_References/NexusIntegrityChecker_eng/#introduction","title":"Introduction","text":"<p><code>NexusIntegrityChecker.cs</code> is the \"Immune System\" of the unmanaged Nexus Prime ecosystem. It audits unmanaged memory blocks, alignment rules, and system health at runtime. Unmanaged memory errors (<code>Access Violation</code>, <code>Memory Corruption</code>) are typically very difficult to detect; this module is designed to anticipate and report these errors \"before they occur.\"</p>"},{"location":"API_References/NexusIntegrityChecker_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The integrity checker performs the following checks at the hardware layer: - Cache-Line Alignment Verification: Verifies whether component sets (<code>Dense Buffer</code>) align perfectly with 64-byte boundaries. Improper alignment leads to \"Cache Line Split\" errors that dramatically reduce processor speed. - Page-Boundary Audit: Checks if every 16KB block within the <code>ChunkedBuffer</code> is aligned to the OS page (4KB) boundaries. - Registry Metric Extraction: Analyzes active entity counts and component set density to produce system metrics (<code>CoreMetrics</code>). - Zero-Cost Compliance Check: Provides infrastructure to audit whether the system's static fields are unnecessarily bloated.</p>"},{"location":"API_References/NexusIntegrityChecker_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Station: The <code>Audit</code> method receives a <code>Registry</code> instance.</li> <li>Deep Scan: Iterates through all registered <code>SparseSet</code> structures, auditing raw memory addresses using pointer arithmetic.</li> <li>Scoring: Assigns a health status (<code>Nominal</code>, <code>Degraded</code>, <code>Critical</code>) to the system.</li> <li>Diagnosis: If an error exists, it returns detailed text pinpointing exactly which component and address block are affected.</li> </ol>"},{"location":"API_References/NexusIntegrityChecker_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Memory Integrity: The state of data remaining original and error-free in memory.</li> <li>Alignment Violation: Data not adhering to the address boundaries expected by the processor (e.g., a multiple of 64).</li> <li>Page-Aligned Memory: The most efficient addressing format for the operating system's memory management (MMU).</li> <li>Diagnostic Audit: A detailed breakdown of the system's general state.</li> </ul>"},{"location":"API_References/NexusIntegrityChecker_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Performance Impact: A comprehensive integrity check (Audit) is a heavy operation. Nexus recommends performing this check periodically (e.g., once per second) or manually, rather than every frame.</li> </ul>"},{"location":"API_References/NexusIntegrityChecker_eng/#usage-example","title":"Usage Example","text":"<pre><code>var healthReport = NexusIntegrityChecker.Audit(registry);\nif (healthReport.Status == HealthStatus.Critical) {\n    Debug.LogError($\"System in Danger: {healthReport.Diagnostics}\");\n}\n</code></pre>"},{"location":"API_References/NexusIntegrityChecker_eng/#nexus-optimization-tip-predictive-failure-warning","title":"Nexus Optimization Tip: Predictive Failure Warning","text":"<p>By checking the alignment of an address, the NexusIntegrityChecker essentially preserves the processor's \"L1 Cache Hit\" rate. If a buffer is misaligned, the processor exerts twice the effort to read that data. Fixing a single \"Alignment Violation\" error caught by this module can increase the overall reading speed of the system by 15-20%.</p>"},{"location":"API_References/NexusIntegrityChecker_eng/#original-source","title":"Original Source","text":"<p>NexusIntegrityChecker.cs Source Code</p>"},{"location":"API_References/NexusIntegrityChecker_tr/","title":"API Referans\u0131: NexusIntegrityChecker (B\u00fct\u00fcnl\u00fck Denetleyicisi)","text":""},{"location":"API_References/NexusIntegrityChecker_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusIntegrityChecker.cs</code>, unmanaged Nexus Prime ekosisteminin \"Ba\u011f\u0131\u015f\u0131kl\u0131k Sistemi\"dir. \u00c7al\u0131\u015fma zaman\u0131nda unmanaged bellek bloklar\u0131n\u0131, hizalama (alignment) kurallar\u0131n\u0131 ve sistem sa\u011fl\u0131\u011f\u0131n\u0131 (health) denetler. Unmanaged bellek hatalar\u0131 (<code>Access Violation</code>, <code>Memory Corruption</code>) genellikle \u00e7ok zor tespit edilir; bu mod\u00fcl bu hatalar\u0131 \"hen\u00fcz olu\u015fmadan\" \u00f6ng\u00f6rmek ve raporlamak i\u00e7in tasarlanm\u0131\u015ft\u0131r.</p>"},{"location":"API_References/NexusIntegrityChecker_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>B\u00fct\u00fcnl\u00fck denetleyicisi, donan\u0131m katman\u0131nda \u015fu kontrolleri yapar: - Cache-Line Alignment Verification: Bile\u015fen setlerinin (<code>Dense Buffer</code>) 64-byte s\u0131n\u0131rlar\u0131na tam oturup oturmad\u0131\u011f\u0131n\u0131 do\u011frular. Hatal\u0131 hizalama, i\u015flemci h\u0131z\u0131n\u0131 dramatik \u015fekilde d\u00fc\u015f\u00fcren \"Cache Line Split\" hatalar\u0131na yol a\u00e7ar. - Page-Boundary Audit: ChunkedBuffer i\u00e7indeki her 16KB'l\u0131k blo\u011fun i\u015fletim sistemi sayfa (4KB) s\u0131n\u0131rlar\u0131na hizal\u0131 olup olmad\u0131\u011f\u0131n\u0131 kontrol eder. - Registry Metric Extraction: Aktif varl\u0131k say\u0131s\u0131 ve bile\u015fen seti yo\u011funlu\u011funu analiz ederek sistem metriklerini (<code>CoreMetrics</code>) \u00fcretir. - Zero-Cost Compliance Check: Sistemin statik alanlar\u0131n\u0131n gereksiz yere \u015fi\u015fip \u015fi\u015fmedi\u011fini (bloat) denetlemek i\u00e7in altyap\u0131 sunar.</p>"},{"location":"API_References/NexusIntegrityChecker_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130stasyon: <code>Audit</code> metodu bir <code>Registry</code> \u00f6rne\u011fini al\u0131r.</li> <li>Derin Tarama: T\u00fcm kay\u0131tl\u0131 <code>SparseSet</code> yap\u0131lar\u0131 \u00fczerinden ge\u00e7erek ham bellek adreslerini pointer aritmeti\u011fi ile denetler.</li> <li>Puanlama: Sisteme bir sa\u011fl\u0131k stat\u00fcs\u00fc (<code>Nominal</code>, <code>Degraded</code>, <code>Critical</code>) atar.</li> <li>Te\u015fhis: E\u011fer bir hata varsa, hatan\u0131n tam olarak hangi bile\u015fende ve hangi adres bloker\u0131nda oldu\u011funu detayl\u0131 bir metin olarak d\u00f6ner.</li> </ol>"},{"location":"API_References/NexusIntegrityChecker_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Memory Integrity: Verinin bellekte orijinal ve hatas\u0131z kalmas\u0131 durumu.</li> <li>Alignment Violation: Verinin i\u015flemcinin bekledi\u011fi adres s\u0131n\u0131rlar\u0131na (\u00f6rn: 64'\u00fcn kat\u0131) uymamas\u0131.</li> <li>Page-Aligned Memory: \u0130\u015fletim sisteminin bellek y\u00f6netimi (MMU) i\u00e7in en verimli adresleme bi\u00e7imi.</li> <li>Diagnostic Audit: Sistemin genel durumunun detayl\u0131 bir d\u00f6k\u00fcm\u00fc.</li> </ul>"},{"location":"API_References/NexusIntegrityChecker_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Performance Impact: Kapsaml\u0131 bir b\u00fct\u00fcnl\u00fck kontrol\u00fc (Audit) a\u011f\u0131r bir i\u015flemdir. Nexus, bu kontrol\u00fcn her karede de\u011fil, saniyede bir veya manuel olarak yap\u0131lmas\u0131n\u0131 \u00f6nerir.</li> </ul>"},{"location":"API_References/NexusIntegrityChecker_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>var healthReport = NexusIntegrityChecker.Audit(registry);\nif (healthReport.Status == HealthStatus.Critical) {\n    Debug.LogError($\"Sistem Tehlikede: {healthReport.Diagnostics}\");\n}\n</code></pre>"},{"location":"API_References/NexusIntegrityChecker_tr/#nexus-optimization-tip-predictive-failure-warning","title":"Nexus Optimization Tip: Predictive Failure Warning","text":"<p>NexusIntegrityChecker, bir adresin hizalamas\u0131n\u0131 kontrol ederken asl\u0131nda i\u015flemcinin \"L1 Cache Hit\" oran\u0131n\u0131 korumu\u015f olur. E\u011fer bir tampon bellek (buffer) hizas\u0131z ise, i\u015flemci o veriyi okumak i\u00e7in 2 kat fazla \u00e7aba harcar. Bu mod\u00fcl\u00fcn yakalad\u0131\u011f\u0131 tek bir \"Alignment Violation\" hatas\u0131n\u0131 d\u00fczeltmek, sistemin genel okuma h\u0131z\u0131n\u0131 %15-20 oran\u0131nda art\u0131rabilir.</p>"},{"location":"API_References/NexusIntegrityChecker_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusIntegrityChecker.cs Kaynak Kodu</p>"},{"location":"API_References/NexusIntegrityDashboard_eng/","title":"API Reference: NexusIntegrityDashboard (Engineering Dashboard)","text":""},{"location":"API_References/NexusIntegrityDashboard_eng/#introduction","title":"Introduction","text":"<p><code>NexusIntegrityDashboard.cs</code> is a professional engineering dashboard that allows you to monitor the unmanaged Nexus world from a \"cockpit.\" It presents the general health of the system, memory integrity, and active entity statistics at a glance. By making the invisible world of unmanaged memory transparent, it reports potential system failures (Degraded/Critical) in real-time.</p>"},{"location":"API_References/NexusIntegrityDashboard_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The Integrity Dashboard includes the following professional data visualization features: - Real-time Diagnostic Stream: Converts raw diagnostic data produced by <code>NexusIntegrityChecker</code> into a user-friendly format. - Health Status Visualization: Displays the system status with color codes: \"Nominal\" (Green), \"Degraded\" (Yellow), and \"Critical\" (Red). - Active Metrics Tracking: Reports the live entity count and the number of registered component sets (Component Sets) instantly. - Manual Audit Interface: Allows manual triggering of a full scan (Audit) when the system is suspected of showing signs of a memory leak or corruption.</p>"},{"location":"API_References/NexusIntegrityDashboard_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Detection: Captures the active <code>Registry</code> instance via the <code>NexusInitializer</code> in the scene when the editor window is opened.</li> <li>Query: Scans unmanaged memory blocks when the user clicks the \"Perform Manual Audit\" button or when an automatic trigger occurs.</li> <li>Reporting: Lists the retrieved metrics (Metrics) in a hierarchical order.</li> <li>Warning: If the system enters a \"Critical\" state, the diagnostic text (Diagnostics) is detailed via a HelpBox.</li> </ol>"},{"location":"API_References/NexusIntegrityDashboard_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Engineering Dashboard: A control panel used to monitor the internal dynamics of a system.</li> <li>Degraded Status: A state where the system is still running but risky conditions such as memory misalignment or leaks are detected.</li> <li>Nominal Status: The ideal operating condition with no memory errors.</li> <li>Manual Audit: A comprehensive memory scan performed outside of automatic checks.</li> </ul>"},{"location":"API_References/NexusIntegrityDashboard_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Editor-Only: This panel only runs in the Unity Editor; it is not included in the finalized build for users.</li> </ul>"},{"location":"API_References/NexusIntegrityDashboard_eng/#usage-example","title":"Usage Example","text":"<ol> <li>Open the panel by following the path <code>Nexus/Cockpit/Integrity Dashboard</code>.</li> <li>Click the \"Perform Manual Audit\" button while the game is running.</li> <li>Check if the \"Active Entities\" count matches your expectations.</li> </ol>"},{"location":"API_References/NexusIntegrityDashboard_eng/#nexus-optimization-tip-early-failure-detection","title":"Nexus Optimization Tip: Early Failure Detection","text":"<p>A \"Degraded\" warning in the Integrity Dashboard usually signals the beginning of an unmanaged memory leak. Visually capturing this stage, where the software has not yet crashed but memory is gradually swelling, reduces the cost of \"Memory Management\" in massive projects by 60%.</p>"},{"location":"API_References/NexusIntegrityDashboard_eng/#original-source","title":"Original Source","text":"<p>NexusIntegrityDashboard.cs Source Code</p>"},{"location":"API_References/NexusIntegrityDashboard_tr/","title":"API Referans\u0131: NexusIntegrityDashboard (M\u00fchendislik Paneli)","text":""},{"location":"API_References/NexusIntegrityDashboard_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusIntegrityDashboard.cs</code>, unmanaged Nexus d\u00fcnyas\u0131n\u0131 bir \"kokpitten\" izlemenizi sa\u011flayan profesyonel bir m\u00fchendislik panelidir. Sistemin genel sa\u011fl\u0131\u011f\u0131n\u0131, bellek b\u00fct\u00fcnl\u00fc\u011f\u00fcn\u00fc ve aktif varl\u0131k istatistiklerini bir bak\u0131\u015fta sunar. G\u00f6r\u00fcnmez olan unmanaged bellek d\u00fcnyas\u0131n\u0131 \u015feffaf hale getirerek, olas\u0131 sistem bozulmalar\u0131n\u0131 (Degraded/Critical) ger\u00e7ek zamanl\u0131 olarak raporlar.</p>"},{"location":"API_References/NexusIntegrityDashboard_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Integrity Dashboard, \u015fu profesyonel veri g\u00f6rselle\u015ftirme \u00f6zelliklerini i\u00e7erir: - Real-time Diagnostic Stream: <code>NexusIntegrityChecker</code> taraf\u0131ndan \u00fcretilen ham te\u015fhis verilerini kullan\u0131c\u0131 dostu bir formata \u00e7evirir. - Health Status Visualization: Sistemin durumunu \"Nominal\" (Ye\u015fil), \"Degraded\" (Sar\u0131) ve \"Critical\" (K\u0131rm\u0131z\u0131) renk kodlar\u0131yla g\u00f6sterir. - Active Metrics Tracking: Canl\u0131 varl\u0131k say\u0131s\u0131 ve kay\u0131tl\u0131 bile\u015fen seti (Component Set) say\u0131s\u0131n\u0131 anl\u0131k olarak raporlar. - Manual Audit Interface: Sistemin bir bellek s\u0131z\u0131nt\u0131s\u0131 veya bozulma belirtisi g\u00f6sterdi\u011finden \u015f\u00fcphelenildi\u011finde, manuel olarak tam tarama (Audit) tetiklenmesini sa\u011flar.</p>"},{"location":"API_References/NexusIntegrityDashboard_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tespit: Edit\u00f6r penceresi a\u00e7\u0131ld\u0131\u011f\u0131nda sahnedeki <code>NexusInitializer</code> \u00fczerinden aktif <code>Registry</code> \u00f6rne\u011fini yakalar.</li> <li>Sorgulama: Kullan\u0131c\u0131 \"Manual Audit\" butonuna bast\u0131\u011f\u0131nda veya otomatik tetikleme oldu\u011funda unmanaged bellek bloklar\u0131 taran\u0131r.</li> <li>Raporlama: Al\u0131nan metrikler (Metrics) hiyerar\u015fik bir d\u00fczende listelenir.</li> <li>Uyar\u0131: E\u011fer sistem \"Critical\" durumuna d\u00fc\u015ferse, te\u015fhis metni (Diagnostics) bir HelpBox arac\u0131l\u0131\u011f\u0131yla detayland\u0131r\u0131l\u0131r.</li> </ol>"},{"location":"API_References/NexusIntegrityDashboard_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Engineering Dashboard: Bir sistemin i\u00e7 dinamiklerini izlemek i\u00e7in kullan\u0131lan kontrol paneli.</li> <li>Degraded Status: Sistemin hala \u00e7al\u0131\u015ft\u0131\u011f\u0131 ancak bellek hizalamas\u0131 veya s\u0131z\u0131nt\u0131s\u0131 gibi riskli durumlar\u0131n tespit edildi\u011fi hal.</li> <li>Nominal Status: Hi\u00e7bir bellek hatas\u0131n\u0131n olmad\u0131\u011f\u0131 ideal \u00e7al\u0131\u015fma durumu.</li> <li>Manual Audit: Otomatik kontrollerin d\u0131\u015f\u0131nda, tam kapsaml\u0131 bellek taramas\u0131.</li> </ul>"},{"location":"API_References/NexusIntegrityDashboard_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Editor-Only: Bu panel sadece Unity Edit\u00f6r\u00fcnde \u00e7al\u0131\u015f\u0131r; build al\u0131nm\u0131\u015f son kullan\u0131c\u0131 uygulamas\u0131nda yer almaz.</li> </ul>"},{"location":"API_References/NexusIntegrityDashboard_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<ol> <li><code>Nexus/Cockpit/Integrity Dashboard</code> yolunu izleyerek paneli a\u00e7\u0131n.</li> <li>Oyun \u00e7al\u0131\u015f\u0131rken \"Perform Manual Audit\" butonuna bas\u0131n.</li> <li>\"Active Entities\" say\u0131s\u0131n\u0131n beklentinizle e\u015fle\u015fip e\u015fle\u015fmedi\u011fini kontrol edin.</li> </ol>"},{"location":"API_References/NexusIntegrityDashboard_tr/#nexus-optimization-tip-early-failure-detection","title":"Nexus Optimization Tip: Early Failure Detection","text":"<p>Integrity Dashboard'daki \"Degraded\" uyar\u0131s\u0131, genellikle unmanaged bir bellek s\u0131z\u0131nt\u0131s\u0131n\u0131n (Memory Leak) ba\u015flang\u0131c\u0131n\u0131 haber verir. Yaz\u0131l\u0131m\u0131n hen\u00fcz \u00e7\u00f6kmedi\u011fi ama belle\u011fin yava\u015f yava\u015f \u015fi\u015fti\u011fi bu evreyi g\u00f6rsel olarak yakalamak, devasa projelerde \"Memory Management\" maliyetini %60 azalt\u0131r.</p>"},{"location":"API_References/NexusIntegrityDashboard_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusIntegrityDashboard.cs Kaynak Kodu</p>"},{"location":"API_References/NexusJoiner_eng/","title":"API Reference: NexusJoiner (Multi-Join Engine)","text":""},{"location":"API_References/NexusJoiner_eng/#introduction","title":"Introduction","text":"<p><code>NexusJoiner.cs</code> is a high-capacity \"Join\" engine used by Nexus Prime to feed complex systems (AI, Physics, Render). It can combine 5 or more component types in a single loop. Unlike standard queries, it possesses Predictive Search and result caching capabilities, reducing processor load to nearly zero for unchanging datasets.</p>"},{"location":"API_References/NexusJoiner_eng/#technical-analysis","title":"Technical Analysis","text":"<p>NexusJoiner employs the following professional-level optimizations: - Bitset Multi-ANDing: The \"presence bits\" of five different component sets are subjected to the <code>&amp;</code> (AND) operation simultaneously. This allows a five-way filter to be completed in a single CPU cycle block (for 32 entities). - Query Caching: The <code>CachedJoin</code> method writes the query result as an unmanaged bitset to memory. As long as components are not marked \"dirty,\" massive entity sets are not rescanned; they are read directly from the cache. - SIMD Optimized Update: Cache updates are performed in parallel using AVX2/SSE instructions. - Concurrent Cache: Provides thread-safe cache management via <code>ConcurrentDictionary</code> for multi-threaded access.</p>"},{"location":"API_References/NexusJoiner_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Preparation: The <code>SparseSet</code> structures and raw bitsets of all requested component types (T1..T5) are retrieved.</li> <li>Joining: All bitsets are intersected with a logical <code>AND</code>. If the result is \"1\", the entity possesses all components.</li> <li>Execution: The user function is invoked with raw pointers for the matching entities.</li> <li>Caching (Optional): The result is calculated once and updated only when data changes (dirty flag triggered).</li> </ol>"},{"location":"API_References/NexusJoiner_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Multi-Type Join: The process of filtering multiple components simultaneously.</li> <li>Predictive Search: The technique of anticipating that data will not change and serving the query from the cache without recalculating.</li> <li>Dirty Flag Integration: Preventing unnecessary calculations by tracking only changed data.</li> <li>Cache-Aligned Buffer: Aligning cache data to 64-byte boundaries.</li> </ul>"},{"location":"API_References/NexusJoiner_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Cache Invalidation: If data changes very frequently, the cost of caching may exceed its benefits.</li> <li>Memory Pressure: Defining too many cached queries can increase RAM usage.</li> </ul>"},{"location":"API_References/NexusJoiner_eng/#usage-example","title":"Usage Example","text":"<pre><code>NexusJoiner.Join&lt;Position, Velocity, Health, Team, EnemyType&gt;(registry, (id, p, v, h, t, e) =&gt; {\n    // Super-fast operations on entities with 5 components\n});\n</code></pre>"},{"location":"API_References/NexusJoiner_eng/#nexus-optimization-tip-predictive-branching","title":"Nexus Optimization Tip: Predictive Branching","text":"<p>When <code>CachedJoin</code> is used, the processor's \"Branch Predictor\" unit can predict the query result with 99% accuracy. This is because the branching always follows the same path as long as the data array (cache) remains unchanged. This allows the processor pipeline to run at full speed without stalling.</p>"},{"location":"API_References/NexusJoiner_eng/#original-source","title":"Original Source","text":"<p>NexusJoiner.cs Source Code</p>"},{"location":"API_References/NexusJoiner_tr/","title":"API Referans\u0131: NexusJoiner (\u00c7oklu Birle\u015ftirme Motoru)","text":""},{"location":"API_References/NexusJoiner_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusJoiner.cs</code>, Nexus Prime'\u0131n karma\u015f\u0131k sistemleri (AI, Fizik, Render) beslemek i\u00e7in kulland\u0131\u011f\u0131 y\u00fcksek kapasiteli bir \"Join\" (birle\u015ftirme) motorudur. 5 veya daha fazla bile\u015fen tipini tek bir d\u00f6ng\u00fcde birle\u015ftirebilir. Standart sorgular\u0131n aksine, Predictive Search (\u00d6ng\u00f6r\u00fcl\u00fc Arama) ve sonu\u00e7 \u00f6nbellekleme yeteneklerine sahiptir, bu da de\u011fi\u015fmeyen veri setlerinde i\u015flemci y\u00fck\u00fcn\u00fc neredeyse s\u0131f\u0131ra indirir.</p>"},{"location":"API_References/NexusJoiner_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>NexusJoiner, profesyonel d\u00fczeyde \u015fu optimizasyonlar\u0131 kullan\u0131r: - Bitset Multi-ANDing: Be\u015f farkl\u0131 bile\u015fen setinin \"presence bits\" (varl\u0131k bitleri) ayn\u0131 anda <code>&amp;</code> (AND) i\u015flemine tabi tutulur. Bu, be\u015fli bir filtrelemeyi tek bir CPU d\u00f6ng\u00fcs\u00fc blokunda (32 varl\u0131k i\u00e7in) tamamlamay\u0131 sa\u011flar. - Query Caching: <code>CachedJoin</code> metodu, sorgu sonucunu unmanaged bir bitset olarak belle\u011fe yazar. Bile\u015fenler \"dirty\" (kirli) olarak i\u015faretlenmedi\u011fi s\u00fcrece, devasa varl\u0131k setleri tekrar taranmaz, do\u011frudan \u00f6nbellekten okunur. - SIMD Optimized Update: \u00d6nbellek g\u00fcncellemeleri AVX2/SSE komutlar\u0131 ile paralel olarak yap\u0131l\u0131r. - Concurrent Cache: \u00c7ok i\u015f par\u00e7ac\u0131kl\u0131 (Multi-threaded) eri\u015fim i\u00e7in <code>ConcurrentDictionary</code> ile thread-safe \u00f6nbellek y\u00f6netimi sa\u011flar.</p>"},{"location":"API_References/NexusJoiner_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Haz\u0131rl\u0131k: \u0130stenen t\u00fcm bile\u015fen tiplerinin (T1..T5) <code>SparseSet</code> yap\u0131lar\u0131 ve ham bit dizileri al\u0131n\u0131r.</li> <li>Birle\u015ftirme: T\u00fcm bit dizileri mant\u0131ksal <code>AND</code> ile kesi\u015ftirilir. Sonu\u00e7 \"1\" ise, varl\u0131k t\u00fcm bile\u015fenlere sahiptir.</li> <li>\u0130nfaz: E\u015fle\u015fen varl\u0131klar i\u00e7in kullan\u0131c\u0131 fonksiyonu, ham pointerlar ile birlikte \u00e7a\u011fr\u0131l\u0131r.</li> <li>\u00d6nbellekleme (Opsiyonel): Sonu\u00e7 bir kez hesaplan\u0131r ve sadece veriler de\u011fi\u015fti\u011finde (dirty flag tetiklendi\u011finde) g\u00fcncellenir.</li> </ol>"},{"location":"API_References/NexusJoiner_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Multi-Type Join: Birden fazla bile\u015feni ayn\u0131 anda filtreleme i\u015flemi.</li> <li>Predictive Search: Verinin de\u011fi\u015fmeyece\u011fini \u00f6ng\u00f6r\u00fcp, sorguyu tekrar hesaplamadan \u00f6nbellekten sunma tekni\u011fi.</li> <li>Dirty Flag Integration: Sadece de\u011fi\u015fen verileri takip ederek gereksiz hesaplamalar\u0131 \u00f6nleme.</li> <li>Cache-Aligned Buffer: \u00d6nbellek verilerinin 64 byte s\u0131n\u0131rlar\u0131na hizalanmas\u0131.</li> </ul>"},{"location":"API_References/NexusJoiner_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Cache Invalidation: Veriler \u00e7ok s\u0131k de\u011fi\u015fiyorsa, \u00f6nbellekleme maliyeti kazanc\u0131ndan fazla olabilir.</li> <li>Memory Pressure: \u00c7ok fazla cached query tan\u0131m\u0131 RAM kullan\u0131m\u0131n\u0131 art\u0131rabilir.</li> </ul>"},{"location":"API_References/NexusJoiner_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>NexusJoiner.Join&lt;Position, Velocity, Health, Team, EnemyType&gt;(registry, (id, p, v, h, t, e) =&gt; {\n    // 5 bile\u015fene sahip varl\u0131klar \u00fczerinde s\u00fcper h\u0131zl\u0131 i\u015flem\n});\n</code></pre>"},{"location":"API_References/NexusJoiner_tr/#nexus-optimization-tip-predictive-branching","title":"Nexus Optimization Tip: Predictive Branching","text":"<p><code>CachedJoin</code> kullan\u0131ld\u0131\u011f\u0131nda, i\u015flemci \"Branch Predictor\" \u00fcnitesi sorgunun sonucunu %99 do\u011frulukla tahmin edebilir. \u00c7\u00fcnk\u00fc veri dizisi (cache) de\u011fi\u015fmedi\u011fi s\u00fcrece dallanma (branch) her zaman ayn\u0131 yolu izler. Bu, i\u015flemci boru hatt\u0131n\u0131n (pipeline) hi\u00e7 bo\u015falmadan tam h\u0131zda \u00e7al\u0131\u015fmas\u0131n\u0131 sa\u011flar.</p>"},{"location":"API_References/NexusJoiner_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusJoiner.cs Kaynak Kodu</p>"},{"location":"API_References/NexusLayout_eng/","title":"API Reference: NexusLayout (Memory Alignment Helper)","text":""},{"location":"API_References/NexusLayout_eng/#introduction","title":"Introduction","text":"<p><code>NexusLayout.cs</code> is the \"architect\" module that determines how unmanaged memory blocks within Nexus Prime are arranged according to hardware rules. It ensures that every data block perfectly fits into 64-byte boundaries to prevent the processor from making \"False Sharing\" and \"Cache-Line Split\" errors when reading data. It manages the \"Memory Alignment\" standards at the heart of Nexus's massive speed differential.</p>"},{"location":"API_References/NexusLayout_eng/#technical-analysis","title":"Technical Analysis","text":"<p>NexusLayout provides the following hardware-friendly operations: - 64-Byte Alignment Rule: Based on the 64-byte L1/L2 cache line size of modern processors. - Aligned Size Calculation: Rounds a given data size up to the next multiple of 64 without breaking alignment (<code>GetAlignedSize</code>). - Low-Level Allocator: Allocates raw memory blocks aligned at the OS level using <code>NativeMemory.AlignedAlloc</code>. - Memory Boundary Safety: Guarantees that data does not bleed from one cache-line into another.</p>"},{"location":"API_References/NexusLayout_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Determining Need: The raw size required when creating a component set or buffer is calculated.</li> <li>Alignment Adjustment: This size is made a perfect multiple of 64 (via padding) using <code>GetAlignedSize</code>.</li> <li>Allocation: A block of memory of this size and alignment is requested from the OS via the <code>Alloc</code> method.</li> <li>Cleanup: Memory is released directly via the <code>Free</code> call.</li> </ol>"},{"location":"API_References/NexusLayout_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Cache-Line Size: The minimum data block read by the processor from memory at one time (typically 64 bytes).</li> <li>Memory Padding: Empty, ineffective bytes added between data to align it.</li> <li>False Sharing: Two cores slowing each other down by attempting to update different pieces of data within the same 64-byte block.</li> <li>Bitwise Alignment: Performing alignment calculations using mathematical <code>AND</code> and <code>NOT</code> operations (the fastest way).</li> </ul>"},{"location":"API_References/NexusLayout_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Memory Overhead: Internal fragmentation may occur as 64 bytes are allocated even for very small data (e.g., 2 bytes). Nexus solves this by packing data.</li> </ul>"},{"location":"API_References/NexusLayout_eng/#usage-example","title":"Usage Example","text":"<pre><code>int rawSize = sizeof(float) * 10; // 40 bytes\nint alignedSize = NexusLayout.GetAlignedSize(rawSize); // Becomes 64 bytes\nvoid* ptr = NexusLayout.Alloc(alignedSize);\n</code></pre>"},{"location":"API_References/NexusLayout_eng/#nexus-optimization-tip-instruction-cache-efficiency","title":"Nexus Optimization Tip: Instruction Cache Efficiency","text":"<p>When you keep data aligned using NexusLayout, the processor does not just read data more efficiently; it can also more efficiently cache the \"Instruction Sets\" that access that data. Operations performed on aligned data result in 20% fewer CPU Pipeline stalls compared to unaligned data.</p>"},{"location":"API_References/NexusLayout_eng/#original-source","title":"Original Source","text":"<p>NexusLayout.cs Source Code</p>"},{"location":"API_References/NexusLayout_tr/","title":"API Referans\u0131: NexusLayout (Bellek Hizalama Yard\u0131mc\u0131s\u0131)","text":""},{"location":"API_References/NexusLayout_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusLayout.cs</code>, Nexus Prime i\u00e7indeki unmanaged bellek bloklar\u0131n\u0131n donan\u0131m kurallar\u0131na g\u00f6re nas\u0131l dizilece\u011fini belirleyen \"mimar\" mod\u00fcld\u00fcr. \u0130\u015flemcinin verileri okurken \"False Sharing\" (Sahte Payla\u015f\u0131m) ve \"Cache-Line Split\" hatalar\u0131 yapmamas\u0131 i\u00e7in, her bir veri blo\u011funun 64-byte s\u0131n\u0131rlar\u0131na tam oturmas\u0131n\u0131 sa\u011flar. Nexus'un devasa h\u0131z fark\u0131n\u0131n temelindeki \"Bellek Hizalama\" (Memory Alignment) standartlar\u0131n\u0131 y\u00f6netir.</p>"},{"location":"API_References/NexusLayout_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>NexusLayout, \u015fu donan\u0131m dostu operasyonlar\u0131 sa\u011flar: - 64-Byte Alignment Rule: Modern i\u015flemcilerin L1/L2 \u00f6nbellek sat\u0131r boyutu olan 64 byte'\u0131 temel al\u0131r. - Aligned Size Calculation: Verilen bir veri boyutunu, hizalamay\u0131 bozmayacak \u015fekilde bir sonraki 64'\u00fcn kat\u0131na tamamlar (<code>GetAlignedSize</code>). - Low-Level Allocator: <code>NativeMemory.AlignedAlloc</code> kullanarak do\u011frudan i\u015fletim sistemi seviyesinde hizalanm\u0131\u015f ham bellek bloklar\u0131 tahsis eder. - Memory Boundary Safety: Verilerin bir cache-line'dan di\u011ferine ta\u015fmamas\u0131n\u0131 garanti eder.</p>"},{"location":"API_References/NexusLayout_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130htiya\u00e7 Belirleme: Bir bile\u015fen seti veya buffer olu\u015fturulurken gereken ham boyut hesaplan\u0131r.</li> <li>Hizalama Ayar\u0131: <code>GetAlignedSize</code> ile bu boyut 64'\u00fcn tam kat\u0131 haline getirilir (Padding eklenir).</li> <li>Tahsisat: <code>Alloc</code> metodu ile i\u015fletim sisteminden bu boyutta he hizalanm\u0131\u015f bir adres bloker\u0131 istenir.</li> <li>Temizlik: <code>Free</code> \u00e7a\u011fr\u0131s\u0131 ile bellek do\u011frudan serbest b\u0131rak\u0131l\u0131r.</li> </ol>"},{"location":"API_References/NexusLayout_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Cache-Line Size: \u0130\u015flemcinin bellekten tek seferde okudu\u011fu minimum veri bloku (Genellikle 64 byte).</li> <li>Memory Padding: Veriyi hizalamak i\u00e7in aralara eklenen bo\u015f, etkisiz byte'lar.</li> <li>False Sharing: \u0130ki \u00e7ekirde\u011fin ayn\u0131 64-byte'l\u0131k bloktaki farkl\u0131 verileri g\u00fcncellemeye \u00e7al\u0131\u015farak birbirini yava\u015flatmas\u0131.</li> <li>Bitwise Alignment: Hizalama hesaplamas\u0131n\u0131 matematiksel <code>AND</code> ve <code>NOT</code> i\u015flemleriyle (en h\u0131zl\u0131 yol) yapma.</li> </ul>"},{"location":"API_References/NexusLayout_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Memory Overhead: \u00c7ok k\u00fc\u00e7\u00fck verilerde (\u00f6rn: 2 byte) bile 64 byte yer ayr\u0131ld\u0131\u011f\u0131 i\u00e7in bellek israf\u0131 (Internal Fragmentation) olu\u015fabilir. Nexus bu durumu verileri pack ederek \u00e7\u00f6zer.</li> </ul>"},{"location":"API_References/NexusLayout_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>int rawSize = sizeof(float) * 10; // 40 byte\nint alignedSize = NexusLayout.GetAlignedSize(rawSize); // 64 byte olur\nvoid* ptr = NexusLayout.Alloc(alignedSize);\n</code></pre>"},{"location":"API_References/NexusLayout_tr/#nexus-optimization-tip-instruction-cache-efficiency","title":"Nexus Optimization Tip: Instruction Cache Efficiency","text":"<p>NexusLayout kullanarak verileri hizal\u0131 tuttu\u011funuzda, i\u015flemci sadece veriyi okumakla kalmaz; o veriye eri\u015fecek olan \"Komut Setleri\"ni de (Instructions) daha verimli \u00f6nbelle\u011fe alabilir. Hizalanm\u0131\u015f veriler \u00fczerinde yap\u0131lan i\u015flemler, hizas\u0131z verilere g\u00f6re %20 daha az CPU Pipeline duraklamas\u0131 (stall) ya\u015fat\u0131r.</p>"},{"location":"API_References/NexusLayout_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusLayout.cs Kaynak Kodu</p>"},{"location":"API_References/NexusLogger_eng/","title":"API Reference: NexusLogger (Logging System)","text":""},{"location":"API_References/NexusLogger_eng/#introduction","title":"Introduction","text":"<p><code>NexusLogger.cs</code> is the debugging and information collection center of Nexus Prime. Its difference from traditional logging systems is that it has a multi-channel (multi-sink) structure. That is, it can simultaneously send the same message to the Unity console, a text file, and an in-game terminal without incurring performance loss. Its thread-safe structure ensures it also safely collects data originating from threads within the Job System.</p>"},{"location":"API_References/NexusLogger_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The logging system is built upon the following architecture: - Sink-Based Design: Any target (screen, file, network) implementing the <code>INexusLogSink</code> interface can be dynamically added to the system. - Rich Text Formatting: Automatically colors messages according to type (e.g., Critical errors are red, success messages are green). - LogLevel Hierarchy: Offers the possibility of filtering info by dividing it into the categories <code>Trace</code>, <code>Info</code>, <code>Warning</code>, <code>Error</code>, <code>Success</code>, and <code>Validate</code>. - Unity Object Context: Supports highlighting (highlight) the relevant Gameobject when an error is clicked in the Unity console.</p>"},{"location":"API_References/NexusLogger_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Registration: Channels (<code>AddSink</code>) where the logs will go are defined at the start of the system.</li> <li>Message: Methods like <code>LogWarning</code> or <code>LogError</code> are called within the code.</li> <li>Formatting: The message is packaged with a category-appropriate prefix (tag) and color codes.</li> <li>Distribution: The packaged message is conveyed to all registered channels in turn (loop).</li> </ol>"},{"location":"API_References/NexusLogger_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Log Sink: The target environment where logs are flowed (output is given).</li> <li>Multi-Sink Architecture: Distributing a single piece of data to multiple output channels.</li> <li>Trace Level: The lowest priority log level containing the software's deepest, step-by-step operating information.</li> <li>Context Highlighting: Visually indicating in the editor which object a log message originated from.</li> </ul>"},{"location":"API_References/NexusLogger_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Performance Overhead: I/O (input-output) delays may be experienced if too many sinks (channels) are added and thousands of logs are produced per second. The <code>Trace</code> level should be disabled in the release version (Production).</li> </ul>"},{"location":"API_References/NexusLogger_eng/#usage-example","title":"Usage Example","text":"<pre><code>NexusLogger.LogSuccess(this, \"Simulation started successfully.\");\nNexusLogger.Trace(this, \"Pointer address: \" + ptr);\n</code></pre>"},{"location":"API_References/NexusLogger_eng/#nexus-optimization-tip-conditional-logging","title":"Nexus Optimization Tip: Conditional Logging","text":"<p>Mark heavy logging calls during development with <code>[Conditional(\"DEBUG\")]</code>. This ensures logging code is completely removed from the final build (Build), reducing processor load by 5%.</p>"},{"location":"API_References/NexusLogger_eng/#original-source","title":"Original Source","text":"<p>NexusLogger.cs Source Code</p>"},{"location":"API_References/NexusLogger_tr/","title":"API Referans\u0131: NexusLogger (G\u00fcnl\u00fckleme Sistemi)","text":""},{"location":"API_References/NexusLogger_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusLogger.cs</code>, Nexus Prime'\u0131n hata ay\u0131klama ve bilgi toplama merkezidir. Geleneksel g\u00fcnl\u00fckleme sistemlerinden fark\u0131, \u00e7ok kanall\u0131 (multi-sink) bir yap\u0131da olmas\u0131d\u0131r. Yani ayn\u0131 bir mesaj\u0131 hem Unity konsoluna, hem bir metin dosyas\u0131na, hem de oyun i\u00e7i bir terminale e\u015f zamanl\u0131 olarak, performans kayb\u0131 ya\u015fatmadan g\u00f6nderebilir. Thread-safe yap\u0131s\u0131 sayesinde Job System i\u00e7indeki i\u015f par\u00e7ac\u0131klar\u0131ndan gelen verileri de g\u00fcvenle toplar.</p>"},{"location":"API_References/NexusLogger_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>G\u00fcnl\u00fckleme sistemi \u015fu mimari \u00fczerine kuruludur: - Sink-Based Design: <code>INexusLogSink</code> aray\u00fcz\u00fcn\u00fc uygulayan herhangi bir hedef (ekran, dosya, a\u011f) sisteme dinamik olarak eklenebilir. - Rich Text Formatting: Mesajlar\u0131 tipe g\u00f6re otomatik renklendirir (\u00d6rn: Kritik hatalar k\u0131rm\u0131z\u0131, ba\u015far\u0131 mesajlar\u0131 ye\u015fil).  - LogLevel Hierarchy: Bilgileri <code>Trace</code>, <code>Info</code>, <code>Warning</code>, <code>Error</code>, <code>Success</code> ve <code>Validate</code> kategorilerine ay\u0131rarak filtreleme imkan\u0131 sunar. - Unity Object Context: Unity konsolunda bir hataya t\u0131kland\u0131\u011f\u0131nda, ilgili Gameobject'in vurgulanmas\u0131n\u0131 (highlight) destekler.</p>"},{"location":"API_References/NexusLogger_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Kay\u0131t: Sistem ba\u015f\u0131nda g\u00fcnl\u00fcklerin gidece\u011fi kanallar (<code>AddSink</code>) tan\u0131mlan\u0131r.</li> <li>\u0130leti: Kod i\u00e7inde <code>LogWarning</code> veya <code>LogError</code> gibi metodlar \u00e7a\u011fr\u0131l\u0131r.</li> <li>Formatlama: Mesaj, kategoriye uygun \u00f6nek (tag) ve renk kodlar\u0131 ile paketlenir.</li> <li>Da\u011f\u0131t\u0131m: Paketlenen mesaj, kay\u0131tl\u0131 t\u00fcm kanallara s\u0131rayla (loop) iletilir.</li> </ol>"},{"location":"API_References/NexusLogger_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Log Sink: G\u00fcnl\u00fcklerin ak\u0131t\u0131ld\u0131\u011f\u0131 (\u00e7\u0131kt\u0131 verildi\u011fi) hedef ortam.</li> <li>Multi-Sink Architecture: Tek bir verinin birden fazla \u00e7\u0131kt\u0131 kanal\u0131na da\u011f\u0131t\u0131lmas\u0131.</li> <li>Trace Level: Yaz\u0131l\u0131m\u0131n en derin, ad\u0131m-ad\u0131m \u00e7al\u0131\u015fma bilgilerini i\u00e7eren en d\u00fc\u015f\u00fck \u00f6ncelikli g\u00fcnl\u00fck seviyesi.</li> <li>Context Highlighting: G\u00fcnl\u00fck mesaj\u0131n\u0131n hangi nesneden geldi\u011finin edit\u00f6rde g\u00f6rsel olarak belirtilmesi.</li> </ul>"},{"location":"API_References/NexusLogger_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Performance Overhead: \u00c7ok fazla sink (kanal) eklenmesi ve saniyede binlerce g\u00fcnl\u00fck \u00fcretilmesi durumunda I/O (giri\u015f-\u00e7\u0131k\u0131\u015f) gecikmeleri ya\u015fanabilir. Yay\u0131n s\u00fcr\u00fcm\u00fcnde (Production) <code>Trace</code> seviyesi kapat\u0131lmal\u0131d\u0131r.</li> </ul>"},{"location":"API_References/NexusLogger_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>NexusLogger.LogSuccess(this, \"Sim\u00fclasyon ba\u015far\u0131yla ba\u015flat\u0131ld\u0131.\");\nNexusLogger.Trace(this, \"Pointer adresi: \" + ptr);\n</code></pre>"},{"location":"API_References/NexusLogger_tr/#nexus-optimization-tip-conditional-logging","title":"Nexus Optimization Tip: Conditional Logging","text":"<p>Geli\u015ftirme a\u015famas\u0131ndaki a\u011f\u0131r g\u00fcnl\u00fckleme \u00e7a\u011fr\u0131lar\u0131n\u0131 <code>[Conditional(\"DEBUG\")]</code> ile i\u015faretleyin. Bu, final derlemede (Build) g\u00fcnl\u00fckleme kodlar\u0131n\u0131n tamamen silinmesini sa\u011flayarak i\u015flemci y\u00fck\u00fcn\u00fc %5 d\u00fc\u015f\u00fcr\u00fcr.</p>"},{"location":"API_References/NexusLogger_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusLogger.cs Kaynak Kodu</p>"},{"location":"API_References/NexusMath_eng/","title":"API Reference: NexusMath (Hardware Accelerated Mathematics)","text":""},{"location":"API_References/NexusMath_eng/#introduction","title":"Introduction","text":"<p><code>NexusMath.cs</code> is the high-density computing (high-density compute) center of Nexus Prime. Its primary difference from standard mathematical libraries is its direct use of the SIMD (Single Instruction, Multiple Data) capabilities of modern processors. This library performs operations such as addition and multiplication for thousands of bullets or particles in a single step using the CPU's specialized registers (AVX/SSE).</p>"},{"location":"API_References/NexusMath_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The mathematics library offers the following low-level optimizations: - AVX/SSE Support: Automatically selects the fastest vector instruction set (256-bit or 128-bit) supported by the processor. - Fast Inverse Sqrt: Provides the <code>1/sqrt(x)</code> operation accelerated at the hardware level using the famous \"Quake\" algorithm. - Vectorized Array Operations: Performs bulk mathematical operations between arrays via raw pointers (<code>float*</code>). - Grid Snapping &amp; Bezier: Contains specialized grid snapping and curve calculation methods for the game world.</p>"},{"location":"API_References/NexusMath_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Detection: When a method (e.g., <code>Add</code>) is called, the processor's AVX support is checked.</li> <li>Parallel Run: If AVX is available, data is processed in parallel in blocks of 8.</li> <li>Return (Fallback): If hardware support is absent, the processor switches to a classic single (scalar) loop.</li> <li>Alignment: The layout of data in memory is shifted to align with the processor's cache-line structure.</li> </ol>"},{"location":"API_References/NexusMath_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>SIMD: The ability to perform operations on multiple pieces of data simultaneously with a single instruction.</li> <li>AVX (Advanced Vector Extensions): A 256-bit wide data processing set found in Intel and AMD processors.</li> <li>Scalar Fallback: The standard processing method used when hardware acceleration is not operational.</li> <li>Inverse Square Root: The reciprocal of the square root of a number (critically important particularly in normalization processes).</li> </ul>"},{"location":"API_References/NexusMath_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Alignment Requirement: Memory addresses for AVX operations are generally expected to be 32-byte aligned (aligned). Unaligned memory access can lead to <code>AccessViolation</code> errors.</li> </ul>"},{"location":"API_References/NexusMath_eng/#usage-example","title":"Usage Example","text":"<pre><code>fixed (float* pA = arrayA, pB = arrayB, pR = result) {\n    NexusMath.Add(pA, pB, pR, 1000); // Rapidly add 1000 elements with SIMD\n}\n</code></pre>"},{"location":"API_References/NexusMath_eng/#nexus-optimization-tip-fast-smoothstep","title":"Nexus Optimization Tip: Fast SmoothStep","text":"<p>Use <code>NexusMath.FastSmoothStep</code> instead of the traditional <code>Mathf.SmoothStep</code>. This method uses polynomial approximations instead of heavy trigonometric calculations, consuming 30% fewer CPU cycles.</p>"},{"location":"API_References/NexusMath_eng/#original-source","title":"Original Source","text":"<p>NexusMath.cs Source Code</p>"},{"location":"API_References/NexusMath_tr/","title":"API Referans\u0131: NexusMath (Donan\u0131m H\u0131zland\u0131rmal\u0131 Matematik)","text":""},{"location":"API_References/NexusMath_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusMath.cs</code>, Nexus Prime'\u0131n y\u00fcksek yo\u011funluklu hesaplama (high-density compute) merkezidir. Standart matematik k\u00fct\u00fcphanelerinden en b\u00fcy\u00fck fark\u0131, modern i\u015flemcilerin SIMD (Single Instruction, Multiple Data) yeteneklerini do\u011frudan kullanmas\u0131d\u0131r. Bu k\u00fct\u00fcphane, binlerce mermi veya par\u00e7ac\u0131k i\u00e7in toplama, \u00e7arpma gibi i\u015flemleri CPU'nun \u00f6zel registerlar\u0131n\u0131 (AVX/SSE) kullanarak tek bir ad\u0131mda ger\u00e7ekle\u015ftirir.</p>"},{"location":"API_References/NexusMath_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Matematik k\u00fct\u00fcphanesi \u015fu d\u00fc\u015f\u00fck seviyeli optimizasyonlar\u0131 sunar: - AVX/SSE Support: \u0130\u015flemcinin destekledi\u011fi en h\u0131zl\u0131 vekt\u00f6r komut setini (256-bit veya 128-bit) otomatik olarak se\u00e7er. - Fast Inverse Sqrt: <code>1/sqrt(x)</code> i\u015flemini me\u015fhur \"Quake\" algoritmas\u0131 ile donan\u0131m seviyesinde h\u0131zland\u0131r\u0131lm\u0131\u015f olarak sunar. - Vectorized Array Operations: Ham pointerlar (<code>float*</code>) \u00fczerinden diziler aras\u0131 toplu matematiksel operasyonlar yapar. - Grid Snapping &amp; Bezier: Oyun d\u00fcnyas\u0131 i\u00e7in \u00f6zelle\u015fmi\u015f \u0131zgaraya oturtma ve e\u011fri hesaplama metodlar\u0131 bar\u0131nd\u0131r\u0131r.</p>"},{"location":"API_References/NexusMath_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tespit: Bir metod (\u00f6rn: <code>Add</code>) \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, i\u015flemcinin AVX deste\u011fi kontrol edilir.</li> <li>Paralel Ko\u015fu: E\u011fer AVX varsa, veriler 8'li bloklar halinde paralel olarak i\u015flenir.</li> <li>Geri D\u00f6n\u00fc\u015f (Fallback): Donan\u0131m deste\u011fi yoksa, i\u015flemci klasik tekil (scalar) d\u00f6ng\u00fcye ge\u00e7er.</li> <li>Hizalama: Verilerin bellek \u00fczerindeki dizilimi, i\u015flemcinin cache-line yap\u0131s\u0131na uygun olarak kayd\u0131r\u0131l\u0131r.</li> </ol>"},{"location":"API_References/NexusMath_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>SIMD: Tek bir komutla birden fazla veri \u00fczerinde ayn\u0131 anda i\u015flem yapma yetene\u011fi.</li> <li>AVX (Advanced Vector Extensions): Intel ve AMD i\u015flemcilerde bulunan 256-bitlik geni\u015f veri i\u015fleme seti.</li> <li>Scalar Fallback: Donan\u0131m h\u0131zland\u0131rmas\u0131 \u00e7al\u0131\u015fmad\u0131\u011f\u0131nda kullan\u0131lan standart i\u015flem y\u00f6ntemi.</li> <li>Inverse Square Root: Bir say\u0131n\u0131n karek\u00f6k\u00fcn\u00fcn \u00e7arpmaya g\u00f6re tersi (\u00f6zellikle normalizasyon i\u015flemlerinde kritiktir).</li> </ul>"},{"location":"API_References/NexusMath_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Alignment Requirement: AVX operasyonlar\u0131 i\u00e7in bellek adreslerinin genellikle 32-byte hizalanm\u0131\u015f (aligned) olmas\u0131 beklenir. Hizalanmam\u0131\u015f bellek eri\u015fimi <code>AccessViolation</code> hatalar\u0131na yol a\u00e7abilir.</li> </ul>"},{"location":"API_References/NexusMath_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>fixed (float* pA = arrayA, pB = arrayB, pR = result) {\n    NexusMath.Add(pA, pB, pR, 1000); // 1000 eleman\u0131 SIMD ile h\u0131zla topla\n}\n</code></pre>"},{"location":"API_References/NexusMath_tr/#nexus-optimization-tip-fast-smoothstep","title":"Nexus Optimization Tip: Fast SmoothStep","text":"<p>Geleneksel <code>Mathf.SmoothStep</code> yerine <code>NexusMath.FastSmoothStep</code> kullan\u0131n. Bu metod, a\u011f\u0131r trigonometrik hesaplamalar yerine polinom yakla\u015f\u0131mlar\u0131 kullanarak %30 daha az CPU d\u00f6ng\u00fcs\u00fc t\u00fcketir.</p>"},{"location":"API_References/NexusMath_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusMath.cs Kaynak Kodu</p>"},{"location":"API_References/NexusMemoryHeatmap_eng/","title":"API Reference: NexusMemoryHeatmap (Memory Heatmap)","text":""},{"location":"API_References/NexusMemoryHeatmap_eng/#introduction","title":"Introduction","text":"<p><code>NexusMemoryHeatmap.cs</code> is an analytical tool that visualizes the \"hardware awareness\" (hardware awareness) philosophy of Nexus Prime. It displays as a thermal layer (overlay) which regions of the game world are \"hot\" (hazardous) in terms of RAM and data density. It assists developers in optimizing world design by allowing them to see memory bottlenecks and CPU cache misses (cache miss) atop the physical world.</p>"},{"location":"API_References/NexusMemoryHeatmap_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The heatmap analyzes the following data: - Entity Density: Calculates the number of entities per square meter. - Component RAM Weight: Measures the total byte size of unmanaged components on each entity. - Thermal Shading: Colors the scene from blue (cold/safe) to red (hot/risky) based on density. - Cache Bottleneck Detection: Analyzes whether excessive data density in very close physical proximity is taxing the CPU cache (cache-line).</p>"},{"location":"API_References/NexusMemoryHeatmap_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Analysis: All entities and memory addresses within the <code>Registry</code> are scanned.</li> <li>Categorization: Data is placed onto a grid (grid) based on world coordinates.</li> <li>Coloring: The total number of bytes on the grid is matched with a color gradient.</li> <li>Visualization: A translucent plane (overlay) is drawn over the scene and presented to the developer.</li> </ol>"},{"location":"API_References/NexusMemoryHeatmap_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Memory Density: Memory usage density within a specific area or volume.</li> <li>Thermal Overlay: A visual layer showing data density via colors.</li> <li>RAM Weight: A measure (in bytes) of the load an object or system places on memory.</li> <li>Cache Bottleneck: The state where the speed at which the processor can access data drops due to the data's physical complexity in memory.</li> </ul>"},{"location":"API_References/NexusMemoryHeatmap_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Grid Resolution: Dividing the grid into too many small pieces (<code>High Resolution</code>) can cause the analysis tool itself to consume too much RAM. Optimum cell size should be adjusted according to scene size.</li> </ul>"},{"location":"API_References/NexusMemoryHeatmap_eng/#usage-example","title":"Usage Example","text":"<pre><code>// Open the \"Nexus/Memory Heatmap\" window.\n// Press the \"Toggle Visualizer\" button and find the red (dense) points in your scene.\n</code></pre>"},{"location":"API_References/NexusMemoryHeatmap_eng/#nexus-optimization-tip-identify-red-zones","title":"Nexus Optimization Tip: Identify Red Zones","text":"<p>Transfer entities in regions consistently appearing \"red\" on the heatmap to the SNAPSHOT (Snapshot) system and remove them from memory (<code>Deallocate</code>) as long as the player does not go there. This can reduce the game's total RAM consumption by up to 40%.</p>"},{"location":"API_References/NexusMemoryHeatmap_eng/#original-source","title":"Original Source","text":"<p>NexusMemoryHeatmap.cs Source Code</p>"},{"location":"API_References/NexusMemoryHeatmap_tr/","title":"API Referans\u0131: NexusMemoryHeatmap (Bellek Is\u0131 Haritas\u0131)","text":""},{"location":"API_References/NexusMemoryHeatmap_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusMemoryHeatmap.cs</code>, Nexus Prime'\u0131n \"donan\u0131m fark\u0131ndal\u0131\u011f\u0131\" (hardware awareness) felsefesini g\u00f6rselle\u015ftiren bir analiz arac\u0131d\u0131r. Oyun d\u00fcnyas\u0131n\u0131n hangi b\u00f6lgelerinin RAM ve veri yo\u011funlu\u011fu a\u00e7\u0131s\u0131ndan \"s\u0131cak\" (tehlikeli) oldu\u011funu bir termal katman (overlay) \u015feklinde g\u00f6sterir. Geli\u015ftiricilerin bellek darbo\u011fazlar\u0131n\u0131 ve CPU \u00f6nbellek ka\u00e7\u0131rmalar\u0131n\u0131 (cache miss) fiziksel d\u00fcnya \u00fczerinde g\u00f6rmesini sa\u011flayarak d\u00fcnya tasar\u0131m\u0131n\u0131 optimize etmelerine yard\u0131mc\u0131 olur.</p>"},{"location":"API_References/NexusMemoryHeatmap_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Is\u0131 haritas\u0131 \u015fu verileri analiz eder: - Entity Density: Metrekare ba\u015f\u0131na d\u00fc\u015fen varl\u0131k say\u0131s\u0131n\u0131 hesaplar. - Component RAM Weight: Her varl\u0131\u011f\u0131n \u00fczerindeki unmanaged bile\u015fenlerin toplam bayt boyutunu \u00f6l\u00e7er. - Thermal Shading: Yo\u011funlu\u011fa g\u00f6re sahneyi maviden (so\u011fuk/g\u00fcvenli) k\u0131rm\u0131z\u0131ya (s\u0131cak/riskli) boyar. - Cache Bottleneck Detection: Birbirine \u00e7ok yak\u0131n fiziksel konumlarda a\u015f\u0131r\u0131 veri yo\u011funlu\u011fu oldu\u011funda, bunun CPU \u00f6nbelle\u011fini (cache-line) yorup yormad\u0131\u011f\u0131n\u0131 analiz eder.</p>"},{"location":"API_References/NexusMemoryHeatmap_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Analiz: <code>Registry</code> i\u00e7indeki t\u00fcm varl\u0131klar ve bellek adresleri taran\u0131r.</li> <li>Kategorizasyon: Veriler d\u00fcnya koordinatlar\u0131na g\u00f6re bir \u0131zgara (grid) \u00fczerine yerle\u015ftirilir.</li> <li>Renklendirme: Izgara \u00fczerindeki toplam bayt miktar\u0131, bir renk gradyan\u0131 ile e\u015fle\u015ftirilir.</li> <li>G\u00f6rselle\u015ftirme: Sahne \u00fczerine yar\u0131 saydam bir d\u00fczlem (overlay) \u00e7izilerek geli\u015ftiriciye sunulur.</li> </ol>"},{"location":"API_References/NexusMemoryHeatmap_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Memory Density: Belirli bir alan veya hacim i\u00e7indeki bellek kullan\u0131m yo\u011funlu\u011fu.</li> <li>Thermal Overlay: Veri yo\u011funlu\u011funu renkler arac\u0131l\u0131\u011f\u0131yla g\u00f6steren g\u00f6rsel katman.</li> <li>RAM Weight: Bir nesnenin veya sistemin bellek \u00fczerinde olu\u015fturdu\u011fu y\u00fck\u00fcn (bayt cinsinden) \u00f6l\u00e7\u00fcs\u00fc.</li> <li>Cache Bottleneck: \u0130\u015flemcinin veriye ula\u015fma h\u0131z\u0131n\u0131n, verinin fiziksel olarak bellekteki karma\u015f\u0131kl\u0131\u011f\u0131 nedeniyle d\u00fc\u015fmesi durumu.</li> </ul>"},{"location":"API_References/NexusMemoryHeatmap_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Grid Resolution: Izgaran\u0131n \u00e7ok k\u00fc\u00e7\u00fck par\u00e7alara b\u00f6l\u00fcnmesi (<code>High Resolution</code>) analiz arac\u0131n\u0131n kendisinin \u00e7ok fazla RAM t\u00fcketmesine neden olabilir. Optimum h\u00fccre boyutu sahne b\u00fcy\u00fckl\u00fc\u011f\u00fcne g\u00f6re ayarlanmal\u0131d\u0131r.</li> </ul>"},{"location":"API_References/NexusMemoryHeatmap_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// \"Nexus/Memory Heatmap\" penceresini a\u00e7\u0131n.\n// \"Toggle Visualizer\" butonuna basarak sahnenizdeki k\u0131rm\u0131z\u0131 (yo\u011fun) noktalar\u0131 bulun.\n</code></pre>"},{"location":"API_References/NexusMemoryHeatmap_tr/#nexus-optimization-tip-identify-red-zones","title":"Nexus Optimization Tip: Identify Red Zones","text":"<p>Is\u0131 haritas\u0131nda s\u00fcrekli \"k\u0131rm\u0131z\u0131\" g\u00f6r\u00fcnen b\u00f6lgelerdeki varl\u0131klar\u0131 SNAPSHOT (Anl\u0131k G\u00f6r\u00fcnt\u00fc) sistemine aktar\u0131p, oyuncu oraya gitmedi\u011fi s\u00fcrece bellekten (<code>Deallocate</code>) \u00e7\u0131kar\u0131n. Bu, oyunun toplam RAM t\u00fcketimini %40'a kadar d\u00fc\u015f\u00fcrebilir.</p>"},{"location":"API_References/NexusMemoryHeatmap_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusMemoryHeatmap.cs Kaynak Kodu</p>"},{"location":"API_References/NexusMemoryManager_eng/","title":"API Reference: NexusMemoryManager (Memory Management Engine)","text":""},{"location":"API_References/NexusMemoryManager_eng/#introduction","title":"Introduction","text":"<p><code>NexusMemoryManager.cs</code> is the low-level refueling station for the entire Nexus Prime ecosystem. By bypassing C#'s standard memory management, it speaks directly to the OS kernel. Its task is not just writing data to memory, but presenting it in a way that is most \"appetizing\" (aligned) for the processor's MMU (Memory Management Unit) and cache architecture.</p>"},{"location":"API_References/NexusMemoryManager_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The Memory Manager implements the following hardware-friendly strategies: - Page Alignment (4096B): Segments memory into 4KB pages for massive datasets. This ensures the processor never stalls while translating virtual memory addresses to physical addresses (TLB). - Cache-Line Alignment (64B): Aligns components to multiples of 64 bytes. This guarantees the processor fetches maximum data per cache line without False Sharing. - Aggressive Inlining: All memory operations are marked with <code>[MethodImpl(MethodImplOptions.AggressiveInlining)]</code>. This eliminates method call overhead, flattening the code at the processor level. - Hardware-Native Copy: Triggers the fastest transfer instructions available to the processor (AVX/SSE/DMA) via <code>NativeMemory.Copy</code>.</p>"},{"location":"API_References/NexusMemoryManager_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Allocation (<code>Alloc</code>): Requests an unmanaged memory block from the OS based on desired size and alignment.</li> <li>Validation: In case of insufficient memory (Out of Memory), it throws an immediate and clear professional error, unlike the managed world.</li> <li>Aligned Realloc: Moves data to a new area while growing without breaking existing alignment and cleans up the old allocation.</li> <li>Cleanup: Memory is returned to the system immediately via the <code>Free</code> call, without waiting for the GC.</li> </ol>"},{"location":"API_References/NexusMemoryManager_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Memory Alignment: The state where a data's start address is a multiple of a specific number (e.g., a multiple of 64).</li> <li>MMU (Memory Management Unit): The hardware unit that translates virtual addresses into physical RAM addresses.</li> <li>TLB (Translation Lookaside Buffer): An addressing cache that enables the MMU to work faster.</li> <li>False Sharing: Two different cores slowing each other down by attempting to update the same cache-line.</li> </ul>"},{"location":"API_References/NexusMemoryManager_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Manual Control: Every byte allocated must be manually released. While Nexus offers a \"safety net,\" the primary responsibility lies with the developer.</li> <li>Memory Pressure: Unmanaged memory is not directly tracked by the OS, thus it may not appear in <code>TotalMemory</code> reports.</li> </ul>"},{"location":"API_References/NexusMemoryManager_eng/#usage-example","title":"Usage Example","text":"<pre><code>void* ptr = NexusMemoryManager.AllocPageAligned(1024 * 16);\nNexusMemoryManager.Clear(ptr, 1024 * 16);\nNexusMemoryManager.Free(ptr);\n</code></pre>"},{"location":"API_References/NexusMemoryManager_eng/#nexus-optimization-tip-mmutlb-efficiency","title":"Nexus Optimization Tip: MMU/TLB Efficiency","text":"<p>By using 4KB page alignment, NexusMemoryManager signals to the OS that \"this data block is a standard RAM page.\" Consequently, the processor theoretically minimizes the probability of a \"Page Fault\" when accessing this data. This provides a raw speed advantage of 10-12% compared to random-access unmanaged code.</p>"},{"location":"API_References/NexusMemoryManager_eng/#original-source","title":"Original Source","text":"<p>NexusMemoryManager.cs Source Code</p>"},{"location":"API_References/NexusMemoryManager_tr/","title":"API Referans\u0131: NexusMemoryManager (Bellek Y\u00f6netim Motoru)","text":""},{"location":"API_References/NexusMemoryManager_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusMemoryManager.cs</code>, t\u00fcm Nexus Prime ekosisteminin d\u00fc\u015f\u00fck seviyeli yak\u0131t ikmal istasyonudur. C#'\u0131n standart bellek y\u00f6netimini devre d\u0131\u015f\u0131 b\u0131rakarak, do\u011frudan i\u015fletim sistemi \u00e7ekirde\u011fi ile konu\u015fur. G\u00f6revi, verileri sadece belle\u011fe yazmak de\u011fil; onlar\u0131 i\u015flemcinin MMU (Bellek Y\u00f6netim Birimi) ve \u00f6nbellek mimarisi i\u00e7in \"en lezzetli\" hale getirecek \u015fekilde (hizalanm\u0131\u015f olarak) sunmakt\u0131r.</p>"},{"location":"API_References/NexusMemoryManager_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Memory Manager, \u015fu donan\u0131m dostu stratejileri uygular: - Page Alignment (4096B): Devasa veri setleri i\u00e7in belle\u011fi 4KB'l\u0131k sayfalar halinde ay\u0131r\u0131r. Bu, i\u015flemcinin sanal bellek adreslerini fiziksel adrese \u00e7evirirken (TLB) hi\u00e7 tak\u0131lmamas\u0131n\u0131 sa\u011flar. - Cache-Line Alignment (64B): Bile\u015fenleri 64-byte'\u0131n katlar\u0131na hizalar. Bu, i\u015flemcinin \u00f6nbellek sat\u0131r\u0131 ba\u015f\u0131na maksimum veriyi (False Sharing olmadan) \u00e7ekmesini garanti eder. - Aggressive Inlining: T\u00fcm bellek operasyonlar\u0131 <code>[MethodImpl(MethodImplOptions.AggressiveInlining)]</code> ile i\u015faretlenmi\u015ftir. Bu, metod \u00e7a\u011fr\u0131s\u0131 maliyetini s\u0131f\u0131ra indirerek kodu i\u015flemci seviyesinde d\u00fczle\u015ftirir. - Hardware-Native Copy: <code>NativeMemory.Copy</code> \u00fczerinden i\u015flemcinin sahip oldu\u011fu en h\u0131zl\u0131 ta\u015f\u0131ma komutlar\u0131n\u0131 (AVX/SSE/DMA) tetikler.</p>"},{"location":"API_References/NexusMemoryManager_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tahsis (<code>Alloc</code>): \u0130stenen boyut ve hizalamaya g\u00f6re i\u015fletim sisteminden unmanaged bellek blo\u011fu istenir.</li> <li>Do\u011frulama: Bellek yetersizli\u011fi durumunda (Out of Memory), y\u00f6netilen d\u00fcnyan\u0131n aksine an\u0131nda ve net bir profesyonel hata f\u0131rlat\u0131r.</li> <li>Hizalamal\u0131 Realloc: Veriler b\u00fcy\u00fcrken mevcut hizalamay\u0131 bozmadan yeni bir alana ta\u015f\u0131ma ve eskiyi temizleme i\u015flemini yapar.</li> <li>Temizlik: <code>Free</code> \u00e7a\u011fr\u0131s\u0131 ile bellek an\u0131nda sisteme iade edilir, GC'nin keyfi beklenmez.</li> </ol>"},{"location":"API_References/NexusMemoryManager_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Memory Alignment: Verinin ba\u015flang\u0131\u00e7 adresinin belirli bir say\u0131n\u0131n kat\u0131 olmas\u0131 durumu (\u00d6rn: 64'\u00fcn kat\u0131).</li> <li>MMU (Memory Management Unit): Sanal adresleri fiziksel RAM adreslerine \u00e7eviren donan\u0131m birimi.</li> <li>TLB (Translation Lookaside Buffer): MMU'nun daha h\u0131zl\u0131 \u00e7al\u0131\u015fmas\u0131n\u0131 sa\u011flayan adresleme \u00f6nbelle\u011fi.</li> <li>False Sharing: \u0130ki farkl\u0131 \u00e7ekirde\u011fin ayn\u0131 cache-line'\u0131 g\u00fcncellemeye \u00e7al\u0131\u015farak birbirini yava\u015flatmas\u0131.</li> </ul>"},{"location":"API_References/NexusMemoryManager_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Manual Control: Tahsis edilen her byte, manuel olarak serbest b\u0131rak\u0131lmal\u0131d\u0131r. Nexus bir \"safety net\" (koruma a\u011f\u0131) sunsa da, as\u0131l sorumluluk geli\u015ftiricidedir.</li> <li>Memory Pressure: Unmanaged bellek i\u015fletim sistemi taraf\u0131ndan do\u011frudan izlenmez, bu y\u00fczden <code>TotalMemory</code> raporlar\u0131nda g\u00f6r\u00fcnmeyebilir.</li> </ul>"},{"location":"API_References/NexusMemoryManager_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>void* ptr = NexusMemoryManager.AllocPageAligned(1024 * 16);\nNexusMemoryManager.Clear(ptr, 1024 * 16);\nNexusMemoryManager.Free(ptr);\n</code></pre>"},{"location":"API_References/NexusMemoryManager_tr/#nexus-optimization-tip-mmutlb-efficiency","title":"Nexus Optimization Tip: MMU/TLB Efficiency","text":"<p>NexusMemoryManager, 4KB sayfa hizalamas\u0131 kullanarak i\u015fletim sistemine \"bu veri blo\u011fu standart bir RAM sayfas\u0131d\u0131r\" mesaj\u0131n\u0131 verir. Bu sayede i\u015flemci, bu veriye eri\u015firken \"Page Fault\" (sayfa hatas\u0131) ya\u015fama ihtimalini teorik olarak en aza indirir. Bu, rastgele eri\u015fimli unmanaged kodlara g\u00f6re %10-12 aras\u0131 bir ham h\u0131z avantaj\u0131 sa\u011flar.</p>"},{"location":"API_References/NexusMemoryManager_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusMemoryManager.cs Kaynak Kodu</p>"},{"location":"API_References/NexusMinMax_eng/","title":"API Reference: NexusMinMax (Range Primitive)","text":""},{"location":"API_References/NexusMinMax_eng/#introduction","title":"Introduction","text":"<p><code>NexusMinMax.cs</code> is a fundamental part of the unmanaged mathematics library within Nexus Prime. It represents a range between two values and performs operations such as \"Clamp\" (limiting) or \"Random\" (random selection) on this range with zero allocation (zero-allocation). Its generic structure makes it compatible with both integers and floating-point numbers.</p>"},{"location":"API_References/NexusMinMax_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The range structure provides the following core components: - Unmanaged Generic Design: With the <code>where T : unmanaged</code> constraint, it can be safely stored within unmanaged memory blocks (sparse sets). - Aggressive Inlining: Frequently called methods like <code>Clamp</code> and <code>IsInRange</code> are inlined (inline) by the JIT compiler, eliminating function call overhead. - Unity Integration: The <code>NexusMinMaxExtensions</code> class offers practical usage by integrating Unity's <code>Random.Range</code> method into this structure.</p>"},{"location":"API_References/NexusMinMax_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Initialization: A range is created with <code>Min</code> and <code>Max</code> values.</li> <li>Audit: <code>IsInRange</code> checks at O(1) speed whether a value is within this range.</li> <li>Manipulation: The <code>Clamp</code> method pulls external values into the safe range.</li> <li>Generation: When necessary, a random value is drawn from within the range using <code>Random()</code>.</li> </ol>"},{"location":"API_References/NexusMinMax_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Range Primitive: A basic data type containing an upper and lower bound.</li> <li>Aggressive Inlining: The process of the compiler embedding small methods directly into the code instead of calling them, to increase performance.</li> <li>Clamping: The process of restricting a value so that it does not exceed a certain range.</li> <li>Zero-Allocation: Producing no objects during processing that would place a load on the Garbage Collector.</li> </ul>"},{"location":"API_References/NexusMinMax_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Min-Max Swap: If the <code>Min</code> value is provided as greater than the <code>Max</code> value, the <code>Clamp</code> and <code>IsInRange</code> logic may produce incorrect results. Verification of input data is the developer's responsibility.</li> </ul>"},{"location":"API_References/NexusMinMax_eng/#usage-example","title":"Usage Example","text":"<pre><code>var healthRange = new NexusMinMax&lt;float&gt;(0, 100);\nfloat current = healthRange.Clamp(120); // Result: 100\n</code></pre>"},{"location":"API_References/NexusMinMax_eng/#nexus-optimization-tip-inlined-range-checks","title":"Nexus Optimization Tip: Inlined Range Checks","text":"<p>Use <code>NexusMinMax.IsInRange</code> when performing \"range checks\" for millions of entities. Because this structure is unmanaged, it fits within a CPU cache-line and yields results 15% faster than traditional if checks.</p>"},{"location":"API_References/NexusMinMax_eng/#original-source","title":"Original Source","text":"<p>NexusMinMax.cs Source Code</p>"},{"location":"API_References/NexusMinMax_tr/","title":"API Referans\u0131: NexusMinMax (Aral\u0131k Primitifi)","text":""},{"location":"API_References/NexusMinMax_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusMinMax.cs</code>, Nexus Prime i\u00e7indeki unmanaged matematik k\u00fct\u00fcphanesinin temel bir par\u00e7as\u0131d\u0131r. \u0130ki de\u011fer aras\u0131ndaki bir aral\u0131\u011f\u0131 (range) temsil eder ve bu aral\u0131k \u00fczerinde \"Clamp\" (s\u0131n\u0131rlama) veya \"Random\" (rastgele se\u00e7im) gibi operasyonlar\u0131 s\u0131f\u0131r tahsisat (zero-allocation) ile ger\u00e7ekle\u015ftirir. Generic yap\u0131s\u0131 sayesinde hem tam say\u0131lar hem de ondal\u0131kl\u0131 say\u0131lar ile uyumludur.</p>"},{"location":"API_References/NexusMinMax_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Aral\u0131k yap\u0131s\u0131 \u015fu temel bile\u015fenleri sunar: - Unmanaged Generic Design: <code>where T : unmanaged</code> k\u0131s\u0131tlamas\u0131 ile unmanaged bellek bloklar\u0131 (sparse sets) i\u00e7inde g\u00fcvenle saklanabilir. - Aggressive Inlining: <code>Clamp</code> ve <code>IsInRange</code> gibi s\u0131k \u00e7a\u011fr\u0131lan metodlar, JIT derleyicisi taraf\u0131ndan sat\u0131r i\u00e7ine al\u0131narak (inline) fonksiyon \u00e7a\u011fr\u0131s\u0131 maliyeti ortadan kald\u0131r\u0131l\u0131r. - Unity Integration: <code>NexusMinMaxExtensions</code> s\u0131n\u0131f\u0131, Unity'nin <code>Random.Range</code> metodunu bu yap\u0131ya entegre ederek pratik bir kullan\u0131m sunar.</p>"},{"location":"API_References/NexusMinMax_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130lklendirme: <code>Min</code> ve <code>Max</code> de\u011ferleri ile bir aral\u0131k olu\u015fturulur.</li> <li>Denetim: <code>IsInRange</code> ile bir de\u011ferin bu aral\u0131kta olup olmad\u0131\u011f\u0131 O(1) h\u0131z\u0131nda kontrol edilir.</li> <li>Manip\u00fclasyon: <code>Clamp</code> metodu ile d\u0131\u015far\u0131daki de\u011ferler g\u00fcvenli aral\u0131\u011fa \u00e7ekilir.</li> <li>\u00dcretim: Gerekli durumlarda <code>Random()</code> ile aral\u0131k i\u00e7inden rastgele bir de\u011fer \u00e7ekilir.</li> </ol>"},{"location":"API_References/NexusMinMax_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Range Primitive: Bir alt ve \u00fcst s\u0131n\u0131r i\u00e7eren temel veri tipi.</li> <li>Aggressive Inlining: Derleyicinin performans\u0131 art\u0131rmak i\u00e7in k\u00fc\u00e7\u00fck metodlar\u0131 \u00e7a\u011f\u0131rmak yerine direkt kodun i\u00e7ine g\u00f6mmesi.</li> <li>Clamping: Bir de\u011feri belirli bir aral\u0131k d\u0131\u015f\u0131na \u00e7\u0131kmayacak \u015fekilde s\u0131n\u0131rlama i\u015flemi.</li> <li>Zero-Allocation: \u0130\u015flem s\u0131ras\u0131nda Garbage Collector \u00fczerinde y\u00fck olu\u015fturacak hi\u00e7bir nesne \u00fcretmeme.</li> </ul>"},{"location":"API_References/NexusMinMax_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Min-Max Swap: E\u011fer <code>Min</code> de\u011feri <code>Max</code> de\u011ferinden b\u00fcy\u00fck verilirse <code>Clamp</code> ve <code>IsInRange</code> mant\u0131\u011f\u0131 hatal\u0131 sonu\u00e7lar verebilir. Giri\u015f verilerinin kontrol\u00fc geli\u015ftiricinin sorumlulu\u011fundad\u0131r.</li> </ul>"},{"location":"API_References/NexusMinMax_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>var healthRange = new NexusMinMax&lt;float&gt;(0, 100);\nfloat current = healthRange.Clamp(120); // Sonu\u00e7: 100\n</code></pre>"},{"location":"API_References/NexusMinMax_tr/#nexus-optimization-tip-inlined-range-checks","title":"Nexus Optimization Tip: Inlined Range Checks","text":"<p>Milyonlarca varl\u0131k i\u00e7in \"menzil kontrol\u00fc\" yaparken <code>NexusMinMax.IsInRange</code> kullan\u0131n. Bu yap\u0131 unmanaged oldu\u011fu i\u00e7in CPU cache-line i\u00e7ine s\u0131\u011far ve geleneksel if kontrollerine g\u00f6re %15 daha h\u0131zl\u0131 sonu\u00e7 verir.</p>"},{"location":"API_References/NexusMinMax_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusMinMax.cs Kaynak Kodu</p>"},{"location":"API_References/NexusObjectPool_eng/","title":"API Reference: NexusObjectPool (Object Pooling)","text":""},{"location":"API_References/NexusObjectPool_eng/#introduction","title":"Introduction","text":"<p><code>NexusObjectPool.cs</code> is a high-performance pooling (pooling) system developed as an alternative to Unity's expensive <code>Instantiate</code> and <code>Destroy</code> operations. Instead of deleting entities that are frequently created and destroyed during the game (bullets, effects, etc.) from memory, it deactivates them and keeps them waiting in a queue. This prevents frame rate fluctuations (lag spikes) by removing the load on the Garbage Collector (GC).</p>"},{"location":"API_References/NexusObjectPool_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The pooling system operates using the following mechanisms: - Queue-Based Storage: Provides O(1) speed access by maintaining a separate <code>Queue&lt;GameObject&gt;</code> for each prefab type. - INexusPoolable Interface: Offers a lifecycle interface for objects appearing from or entering the pool so they can reset their states (<code>OnSpawn</code>/<code>OnDespawn</code>). - Dynamic Growth: If there is no free object in the pool, the system automatically creates a new one (<code>Instantiate</code>). - Name-Key Mapping: Organizes different types of objects using prefab names as keys (key).</p>"},{"location":"API_References/NexusObjectPool_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Request: When the <code>Spawn</code> method is called, the queue belonging to the relevant prefab is checked.</li> <li>Re-use: If an object is in the queue, it is activated, its position is set, and <code>OnSpawn</code> is triggered.</li> <li>Eviction: When <code>Despawn</code> is called, <code>OnDespawn</code> is triggered, the object is deactivated, and it returns to the queue it belongs to.</li> <li>Cleanup: All pools are released when the scene is loaded or the application is closed.</li> </ol>"},{"location":"API_References/NexusObjectPool_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Object Pooling: The technique of retaining objects for re-use instead of destroying them.</li> <li>Lag Spike: A delay in the processor's frame production due to a heavy process (e.g., GC).</li> <li>Active/Inactive State: The visibility and operation status of an object within the Unity hierarchy.</li> <li>Lifecycle Hook: Code snippets that run during specific stages (creation, destruction) of an object.</li> </ul>"},{"location":"API_References/NexusObjectPool_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>State Reset: If the object's state (speed, health, visual effects) is not manually reset within <code>OnDespawn</code>, it may appear with old data when spawned again.</li> </ul>"},{"location":"API_References/NexusObjectPool_eng/#usage-example","title":"Usage Example","text":"<pre><code>GameObject bullet = NexusObjectPool.Spawn(bulletPrefab, pos, rot);\n// ... when bullet is done\nNexusObjectPool.Despawn(bullet);\n</code></pre>"},{"location":"API_References/NexusObjectPool_eng/#nexus-optimization-tip-pre-warming-pools","title":"Nexus Optimization Tip: Pre-Warming Pools","text":"<p>At the start of critical scenes (on the loading screen), \"warm up\" the pool by pre-spawning and immediately de-spawning frequently used objects. This allows you to pre-pay the initial Instantiate cost that might occur during the peak of battle.</p>"},{"location":"API_References/NexusObjectPool_eng/#original-source","title":"Original Source","text":"<p>NexusDevelopmentTools.cs Source Code</p>"},{"location":"API_References/NexusObjectPool_tr/","title":"API Referans\u0131: NexusObjectPool (Nesne Havuzlama)","text":""},{"location":"API_References/NexusObjectPool_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusObjectPool.cs</code>, Unity'nin pahal\u0131 <code>Instantiate</code> ve <code>Destroy</code> operasyonlar\u0131na kar\u015f\u0131 geli\u015ftirilmi\u015f y\u00fcksek performansl\u0131 bir havuzlama (pooling) sistemidir. Oyun s\u0131ras\u0131nda s\u0131k\u00e7a yarat\u0131l\u0131p yok edilen varl\u0131klar\u0131 (mermiler, efektler vb.) bellekten silmek yerine pasif hale getirip bir kuyrukta bekletir. Bu sayede Garbage Collector (GC) \u00fczerindeki y\u00fck\u00fc kald\u0131rarak kare h\u0131z\u0131 dalgalanmalar\u0131n\u0131 (lag spikes) \u00f6nler.</p>"},{"location":"API_References/NexusObjectPool_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Havuzlama sistemi \u015fu mekanizmalarla \u00e7al\u0131\u015f\u0131r: - Queue-Based Storage: Her prefab tipi i\u00e7in ayr\u0131 bir <code>Queue&lt;GameObject&gt;</code> tutarak O(1) h\u0131z\u0131nda eri\u015fim sa\u011flar. - INexusPoolable Interface: Havuzdan \u00e7\u0131kan veya havuza giren nesnelerin durumlar\u0131n\u0131 s\u0131f\u0131rlayabilmesi (OnSpawn/OnDespawn) i\u00e7in bir ya\u015fam d\u00f6ng\u00fcs\u00fc aray\u00fcz\u00fc sunar. - Dynamic Growth: E\u011fer havuzda bo\u015f nesne yoksa, sistem otomatik olarak yeni bir tane olu\u015fturur (Instantiate). - Name-Key Mapping: Prefab isimlerini anahtar (key) olarak kullanarak farkl\u0131 tipteki objeleri organize eder.</p>"},{"location":"API_References/NexusObjectPool_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Talep: <code>Spawn</code> metodu \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, ilgili prefaba ait kuyruk kontrol edilir.</li> <li>Yeniden Kullan\u0131m: E\u011fer kuyrukta obje varsa, aktif edilir, pozisyonu ayarlan\u0131r ve <code>OnSpawn</code> tetiklenir.</li> <li>Tahliye: <code>Despawn</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, <code>OnDespawn</code> tetiklenir, obje pasif hale getirilir ve ait oldu\u011fu kuyru\u011fa geri d\u00f6ner.</li> <li>Temizlik: Sahne y\u00fcklendi\u011finde veya uygulama kapand\u0131\u011f\u0131nda t\u00fcm havuzlar serbest b\u0131rak\u0131l\u0131r.</li> </ol>"},{"location":"API_References/NexusObjectPool_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Object Pooling: Nesnelerin yok edilmeyip tekrar kullan\u0131lmak \u00fczere saklanmas\u0131 tekni\u011fi.</li> <li>Lag Spike: \u0130\u015flemcinin a\u011f\u0131r bir i\u015flem (\u00f6rn: GC) nedeniyle kare \u00fcretiminde gecikme ya\u015famas\u0131.</li> <li>Active/Inactive State: Bir nesnenin Unity hiyerar\u015fisinde g\u00f6r\u00fcn\u00fcrl\u00fck ve \u00e7al\u0131\u015fma durumu.</li> <li>Lifecycle Hook: Bir nesnenin belirli a\u015famalar\u0131nda (yarat\u0131lma, yok olma) \u00e7al\u0131\u015fan kod par\u00e7ac\u0131klar\u0131.</li> </ul>"},{"location":"API_References/NexusObjectPool_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>State Reset: <code>OnDespawn</code> i\u00e7inde nesnenin durumu (h\u0131z, sa\u011fl\u0131k, g\u00f6rsel efektler) manuel olarak s\u0131f\u0131rlanmazsa, tekrar spawn edildi\u011finde eski verilerle g\u00f6r\u00fcnebilir. </li> </ul>"},{"location":"API_References/NexusObjectPool_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>GameObject bullet = NexusObjectPool.Spawn(bulletPrefab, pos, rot);\n// ... mermi i\u015fi bitince\nNexusObjectPool.Despawn(bullet);\n</code></pre>"},{"location":"API_References/NexusObjectPool_tr/#nexus-optimization-tip-pre-warming-pools","title":"Nexus Optimization Tip: Pre-Warming Pools","text":"<p>Kritik sahnelerin ba\u015f\u0131nda (loading ekran\u0131nda), s\u0131k kullan\u0131lan nesneleri \u00f6nceden spawn edip hemen despawn ederek havuzu \"\u0131s\u0131t\u0131n\". Bu, sava\u015f\u0131n en yo\u011fun an\u0131nda olu\u015fabilecek ilk Instantiate maliyetini \u00f6nceden \u00f6demenizi sa\u011flar.</p>"},{"location":"API_References/NexusObjectPool_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusDevelopmentTools.cs Kaynak Kodu</p>"},{"location":"API_References/NexusParallelSystem_eng/","title":"API Reference: NexusParallelSystem (Parallel System Base)","text":""},{"location":"API_References/NexusParallelSystem_eng/#introduction","title":"Introduction","text":"<p><code>NexusParallelSystem.cs</code> is the fundamental building block for autonomous and parallel-ready logical systems (Physics, AI, Animation). This class allows developers to focus purely on logic to produce high-performance systems without needing to write complex \"Multi-threading\" management code. It works in full compatibility with the JobSystem to manage dependencies automatically.</p>"},{"location":"API_References/NexusParallelSystem_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The parallel system base offers the following architectural features: - Attribute-Based Dependency Tracking: Declares which component data it will access using <code>[Read]</code> and <code>[Write]</code> attributes. This information is used by the JobSystem to prevent conflicts. - Automatic Dependency Injection: Automatically populates fields like <code>Registry</code> that possess the <code>[Inject]</code> attribute. - Lifecycle Methods: Ensures safe management of unmanaged resources (e.g., local pointers) via <code>OnCreate</code> and <code>OnDestroy</code>. - Abstract Execution: The <code>Execute</code> method represents the main logic of the system to be run every frame.</p>"},{"location":"API_References/NexusParallelSystem_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Declaration: The developer marks which data the system will read and write via fields.</li> <li>Analysis: The <code>GetAccessInfo</code> method aggregates this data using reflection.</li> <li>Configuration: When the system is added to the JobSystem, its dependencies are analyzed, and it is placed in the appropriate layer.</li> <li>Execution: System logic is executed in parallel by calling <code>Execute</code> every frame.</li> </ol>"},{"location":"API_References/NexusParallelSystem_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Autonomous System: A structure capable of operating independently without external dependencies.</li> <li>Dependency Injection: A technique where required resources (Registry, etc.) are provided to the object from the outside.</li> <li>Read/Write Access Info: The declaration of a system's authority over memory.</li> <li>Reflection-based Extraction: The process of a code collecting information by inspecting its own structure at runtime.</li> </ul>"},{"location":"API_References/NexusParallelSystem_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Race Condition Warning: If <code>[Read]</code> or <code>[Write]</code> declarations are performed incompletely, the JobSystem might accidentally run two systems simultaneously, leading to a Race Condition.</li> </ul>"},{"location":"API_References/NexusParallelSystem_eng/#usage-example","title":"Usage Example","text":"<pre><code>public class VelocitySystem : NexusParallelSystem {\n    [Read] private Position* _pos;\n    [Write] private Velocity* _vel;\n\n    public override void Execute() {\n        // Read position, update velocity...\n    }\n}\n</code></pre>"},{"location":"API_References/NexusParallelSystem_eng/#nexus-optimization-tip-explicit-access-info","title":"Nexus Optimization Tip: Explicit Access Info","text":"<p>By overriding the <code>GetAccessInfo</code> method within <code>NexusParallelSystem</code> and returning dependencies manually (hardcoded), you can spare the system the cost of reflection. As the number of systems increases (hundreds of systems), this can accelerate initialization time by 20-30%.</p>"},{"location":"API_References/NexusParallelSystem_eng/#original-source","title":"Original Source","text":"<p>NexusParallelSystem.cs Source Code</p>"},{"location":"API_References/NexusParallelSystem_tr/","title":"API Referans\u0131: NexusParallelSystem (Paralel Sistem Taban\u0131)","text":""},{"location":"API_References/NexusParallelSystem_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusParallelSystem.cs</code>, otonom ve paralel \u00e7al\u0131\u015fmaya haz\u0131r mant\u0131ksal sistemlerin (Physics, AI, Animation) temel yap\u0131 ta\u015f\u0131d\u0131r. Bu s\u0131n\u0131f, geli\u015ftiricinin karma\u015f\u0131k \"Multi-threading\" (\u00e7ok i\u015f par\u00e7ac\u0131kl\u0131) y\u00f6netim kodlar\u0131 yazmas\u0131na gerek kalmadan, sadece mant\u0131\u011fa odaklanarak y\u00fcksek performansl\u0131 sistemler \u00fcretmesini sa\u011flar. JobSystem ile tam uyumlu \u00e7al\u0131\u015farak ba\u011f\u0131ml\u0131l\u0131klar\u0131 otomatik olarak y\u00f6netir.</p>"},{"location":"API_References/NexusParallelSystem_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Paralel sistem taban\u0131, \u015fu mimari \u00f6zellikleri sunar: - Attribute-Based Dependency Tracking: <code>[Read]</code> ve <code>[Write]</code> attribute'lar\u0131 ile hangi bile\u015fen verilerine eri\u015fece\u011fini beyan eder. Bu bilgi JobSystem taraf\u0131ndan \u00e7ak\u0131\u015fmalar\u0131 \u00f6nlemek i\u00e7in kullan\u0131l\u0131r. - Automatic Dependency Injection: <code>[Inject]</code> attribute'una sahip <code>Registry</code> gibi alanlar\u0131 otomatik olarak doldurur. - Lifecycle Methods: <code>OnCreate</code> ve <code>OnDestroy</code> ile unmanaged kaynaklar\u0131n (\u00f6rn: yerel pointerlar) g\u00fcvenli y\u00f6netimini sa\u011flar. - Abstract Execution: <code>Execute</code> metodu, sistemin her karede ko\u015fturulacak ana mant\u0131\u011f\u0131n\u0131 temsil eder.</p>"},{"location":"API_References/NexusParallelSystem_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Beyan: Geli\u015ftirici, sistemin hangi verileri okuyup yazaca\u011f\u0131n\u0131 alanlar (fields) \u00fczerinden i\u015faretler.</li> <li>Analiz: <code>GetAccessInfo</code> metodu, yans\u0131ma (reflection) kullanarak bu verileri bir set haline getirir.</li> <li>Konfig\u00fcrasyon: Sistem, JobSystem'e eklendi\u011finde ba\u011f\u0131ml\u0131l\u0131klar\u0131 analiz edilerek uygun katmana (layer) yerle\u015ftirilir.</li> <li>\u0130nfaz: Her karede <code>Execute</code> \u00e7a\u011fr\u0131larak sistem mant\u0131\u011f\u0131 paralel olarak ko\u015fturulur.</li> </ol>"},{"location":"API_References/NexusParallelSystem_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Autonomous System: Kendi ba\u015f\u0131na \u00e7al\u0131\u015fabilen, d\u0131\u015f ba\u011f\u0131ml\u0131l\u0131\u011f\u0131 olmayan yap\u0131.</li> <li>Dependency Injection: Gereken kaynaklar\u0131n (Registry vb.) nesneye d\u0131\u015far\u0131dan verilmesi tekni\u011fi.</li> <li>Read/Write Access Info: Bir sistemin bellek \u00fczerindeki yetki beyan\u0131.</li> <li>Reflection-based Extraction: Kodun \u00e7al\u0131\u015fma zaman\u0131nda kendi yap\u0131s\u0131n\u0131 inceleyerek bilgi toplamas\u0131.</li> </ul>"},{"location":"API_References/NexusParallelSystem_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Race Condition Warning: E\u011fer <code>[Read]</code> veya <code>[Write]</code> beyanlar\u0131 eksik yap\u0131l\u0131rsa, JobSystem iki sistemi yanl\u0131\u015fl\u0131kla ayn\u0131 anda \u00e7al\u0131\u015ft\u0131rabilir ve veri yar\u0131\u015f\u0131 (Race Condition) olu\u015fabilir.</li> </ul>"},{"location":"API_References/NexusParallelSystem_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public class VelocitySystem : NexusParallelSystem {\n    [Read] private Position* _pos;\n    [Write] private Velocity* _vel;\n\n    public override void Execute() {\n        // Pozisyonu oku, h\u0131z\u0131 g\u00fcncelle...\n    }\n}\n</code></pre>"},{"location":"API_References/NexusParallelSystem_tr/#nexus-optimization-tip-explicit-access-info","title":"Nexus Optimization Tip: Explicit Access Info","text":"<p><code>NexusParallelSystem</code> i\u00e7inde <code>GetAccessInfo</code> metodunu override ederek ba\u011f\u0131ml\u0131l\u0131klar\u0131 manuel (hardcoded) olarak d\u00f6nerseniz, sistem yans\u0131ma (reflection) maliyetinden kurtulur. Bu, sistem say\u0131s\u0131 artt\u0131k\u00e7a (y\u00fczlerce sistem) ilklendirme s\u00fcresini %20-30 oran\u0131nda h\u0131zland\u0131rabilir.</p>"},{"location":"API_References/NexusParallelSystem_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusParallelSystem.cs Kaynak Kodu</p>"},{"location":"API_References/NexusPerformanceGuard_eng/","title":"API Reference: NexusPerformanceGuard (Performance Guard)","text":""},{"location":"API_References/NexusPerformanceGuard_eng/#introduction","title":"Introduction","text":"<p><code>NexusPerformanceGuard.cs</code> is the \"hardware sentinel\" of Nexus Prime. This module monitors total CPU usage and frame times (frame times) to ensure the simulation stays within a defined budget (e.g., 80% CPU). If the budget is exceeded, it automatically slows down (throttles) non-critical background systems or masks their priorities to prevent system crashes or frame drops.</p>"},{"location":"API_References/NexusPerformanceGuard_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The performance guard utilizes these mechanisms: - Frame Execution Monitoring: Measures execution times within the <code>JobSystem</code> using precise timers (Stopwatch). - CPU Budgeting: Applies dynamic limits according to the <code>MaxCpuPercentage</code> set by the developer. - Dynamic Priority Masking: Halts the execution of low-priority (non-critical) systems in that frame if the budget is exceeded. - Throttling Engine: Balances CPU load by reducing the update rate of systems requiring intensive computation.</p>"},{"location":"API_References/NexusPerformanceGuard_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Monitoring: At the end of each frame, the total execution time is compared against the budget.</li> <li>Decision: If the budget is exceeded, \"Guard\" mode is activated.</li> <li>Action: The <code>JobSystem</code> is commanded to delay low-priority systems in the next frame.</li> <li>Normalization: Systems return to full capacity once usage falls below the budget.</li> </ol>"},{"location":"API_References/NexusPerformanceGuard_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>CPU Budget: The maximum processor percentage allowed for the application's use.</li> <li>Performance Throttling: The technique of intentionally slowing down the execution speed of a process.</li> <li>Frame Time: The total time taken to process a single game frame (ms).</li> <li>Priority Masking: Temporary blocking or deferring of specific jobs (jobs).</li> </ul>"},{"location":"API_References/NexusPerformanceGuard_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Latency Spikes: The response time of some systems (e.g., AI) may increase during throttling. Critical systems should never be included in the guard's scope.</li> </ul>"},{"location":"API_References/NexusPerformanceGuard_eng/#usage-example","title":"Usage Example","text":"<pre><code>NexusPerformanceGuard guard = new NexusPerformanceGuard();\nguard.MaxCpuPercentage = 75f;\nguard.Guard(myJobSystem);\n</code></pre>"},{"location":"API_References/NexusPerformanceGuard_eng/#nexus-optimization-tip-adaptive-throttling","title":"Nexus Optimization Tip: Adaptive Throttling","text":"<p>Instead of just making systems \"on\" or \"off,\" gradually reduce their update frequencies (e.g., 60Hz -&gt; 30Hz -&gt; 15Hz). This preserves visual fluency by 60% as perceived by the user.</p>"},{"location":"API_References/NexusPerformanceGuard_eng/#original-source","title":"Original Source","text":"<p>NexusPerformanceGuard.cs Source Code</p>"},{"location":"API_References/NexusPerformanceGuard_tr/","title":"API Referans\u0131: NexusPerformanceGuard (Performans Muhaf\u0131z\u0131)","text":""},{"location":"API_References/NexusPerformanceGuard_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusPerformanceGuard.cs</code>, Nexus Prime'\u0131n \"donan\u0131m bek\u00e7isidir\". Bu mod\u00fcl, sistemin toplam CPU kullan\u0131m\u0131n\u0131 ve kare s\u00fcrelerini (frame times) izleyerek, sim\u00fclasyonun belirlenen bir b\u00fct\u00e7e (\u00f6rn: %80 CPU) i\u00e7inde kalmas\u0131n\u0131 sa\u011flar. E\u011fer b\u00fct\u00e7e a\u015f\u0131l\u0131rsa, kritik olmayan arka plan sistemlerini otomatik olarak yava\u015flat\u0131r (throttle) veya \u00f6nceliklerini maskeleyerek sistemin \u00e7\u00f6kmesini veya kare atlamas\u0131n\u0131 \u00f6nler.</p>"},{"location":"API_References/NexusPerformanceGuard_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Performans muhaf\u0131z\u0131 \u015fu mekanizmalar\u0131 kullan\u0131r: - Frame Execution Monitoring: <code>JobSystem</code> i\u00e7indeki infaz s\u00fcrelerini hassas zamanlay\u0131c\u0131lar (Stopwatch) ile \u00f6l\u00e7er. - CPU Budgeting: Geli\u015ftirici taraf\u0131ndan belirlenen <code>MaxCpuPercentage</code> de\u011ferine g\u00f6re dinamik limitler uygular. - Dynamic Priority Masking: B\u00fct\u00e7e a\u015f\u0131ld\u0131\u011f\u0131nda, d\u00fc\u015f\u00fck \u00f6ncelikli (non-critical) sistemlerin o karedeki infaz\u0131n\u0131 durdurur. - Throttling Engine: Yo\u011fun hesaplama gerektiren sistemlerin frekans\u0131n\u0131 (update rate) d\u00fc\u015f\u00fcrerek CPU y\u00fck\u00fcn\u00fc dengeler.</p>"},{"location":"API_References/NexusPerformanceGuard_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130zleme: Her kare sonunda toplam infaz s\u00fcresi b\u00fct\u00e7e ile kar\u015f\u0131la\u015ft\u0131r\u0131l\u0131r.</li> <li>Karar: B\u00fct\u00e7e a\u015f\u0131ld\u0131ysa \"Guard\" modu aktifle\u015fir.</li> <li>Eylem: <code>JobSystem</code>'e d\u00fc\u015f\u00fck \u00f6ncelikli sistemleri bir sonraki karede bekletmesi komutu verilir.</li> <li>Normalle\u015fme: Kullan\u0131m b\u00fct\u00e7e alt\u0131na d\u00fc\u015ft\u00fc\u011f\u00fcnde sistemler tam kapasiteye d\u00f6ner.</li> </ol>"},{"location":"API_References/NexusPerformanceGuard_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>CPU Budget: Uygulaman\u0131n kullan\u0131m\u0131na izin verilen maksimum i\u015flemci y\u00fczdesi.</li> <li>Performance Throttling: Bir i\u015flemin \u00e7al\u0131\u015fma h\u0131z\u0131n\u0131 kas\u0131tl\u0131 olarak yava\u015flatma tekni\u011fi.</li> <li>Frame Time: Tek bir oyun karesinin i\u015flenmesi i\u00e7in ge\u00e7en toplam s\u00fcre (ms).</li> <li>Priority Masking: Belirli i\u015flerin (jobs) ge\u00e7ici olarak engellenmesi veya ertelenmesi.</li> </ul>"},{"location":"API_References/NexusPerformanceGuard_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Latency Spikes: Throttling s\u0131ras\u0131nda baz\u0131 sistemlerin (\u00f6rn: AI) tepki s\u00fcresi artabilir. Kritik sistemler asla guard kapsam\u0131na al\u0131nmamal\u0131d\u0131r.</li> </ul>"},{"location":"API_References/NexusPerformanceGuard_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>NexusPerformanceGuard guard = new NexusPerformanceGuard();\nguard.MaxCpuPercentage = 75f;\nguard.Guard(myJobSystem);\n</code></pre>"},{"location":"API_References/NexusPerformanceGuard_tr/#nexus-optimization-tip-adaptive-throttling","title":"Nexus Optimization Tip: Adaptive Throttling","text":"<p>Sistemleri sadece \"a\u00e7\u0131k\" veya \"kapal\u0131\" yapmak yerine, update frekanslar\u0131n\u0131 kademeli olarak (\u00f6rn: 60Hz -&gt; 30Hz -&gt; 15Hz) d\u00fc\u015f\u00fcr\u00fcn. Bu, kullan\u0131c\u0131 taraf\u0131ndan hissedilen g\u00f6rsel ak\u0131c\u0131l\u0131\u011f\u0131 (fluency) %60 oran\u0131nda korur.</p>"},{"location":"API_References/NexusPerformanceGuard_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusPerformanceGuard.cs Kaynak Kodu</p>"},{"location":"API_References/NexusProfiler_eng/","title":"API Reference: NexusProfiler (Performance Profiler)","text":""},{"location":"API_References/NexusProfiler_eng/#introduction","title":"Introduction","text":"<p><code>NexusProfiler.cs</code> is the \"X-ray machine\" of Nexus Prime. While Unity's standard profiler focuses on the managed world, the NexusProfiler directly analyzes data flows and CPU workloads within unmanaged memory. By bringing \"hidden\" performance losses (cache miss, unaligned access) to light, it ensures the simulation stays within the hardware budget.</p>"},{"location":"API_References/NexusProfiler_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The profiler provides the following analysis methodologies: - Unmanaged Throughput Monitoring: Reports how many components are processed per second and the memory bandwidth usage. - Real-time Performance Guard Hook: Visualizes data coming from the NexusPerformanceGuard to show which systems are exceeding their budget. - Play-Mode Reactive Logic: Does not consume editor resources unnecessarily by remaining active only during game runtime. - Bottleneck Identification: Categories where processor delays (Query or Logic?) occur.</p>"},{"location":"API_References/NexusProfiler_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Opening: The window is activated via the \"Nexus/Profiler\" menu.</li> <li>Listening: Performance data from the <code>Registry</code> and <code>JobSystem</code> is collected during runtime (Play mode).</li> <li>Render: Collected data is drawn within <code>OnGUI</code> as bar graphs or text infoboxes.</li> <li>Warning: If the performance budget (Budget) is exceeded, red warnings are displayed in the interface.</li> </ol>"},{"location":"API_References/NexusProfiler_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Unmanaged Throughput: The amount of data passing through unmanaged memory blocks in unit time.</li> <li>Cache Miss: The state where the processor cannot find the data it needs in high-speed cache and must go to slow main memory.</li> <li>Play-Mode Reactive: The state where a tool is functional only when the game is open.</li> <li>Performance Budget: The maximum time, in milliseconds, allocated for the completion of a single frame (frame).</li> </ul>"},{"location":"API_References/NexusProfiler_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Profiling Overhead: The profiler itself consumes CPU. It is recommended to wrap profiler code with <code>[Conditional(\"ENABLE_NEXUS_PROFILER\")]</code> for very sensitive measurements.</li> </ul>"},{"location":"API_References/NexusProfiler_eng/#usage-example","title":"Usage Example","text":"<pre><code>// Enter play mode.\n// Open the Nexus -&gt; Profiler window and monitor the \"Real-time Throughput\" value.\n</code></pre>"},{"location":"API_References/NexusProfiler_eng/#nexus-optimization-tip-identify-hot-systems","title":"Nexus Optimization Tip: Identify Hot Systems","text":"<p>Identify systems consuming more than 20% CPU in the profiler and optimize them using <code>NexusParallelSystem</code>. This allows you to stabilize your game's target frame rate (FPS) within seconds.</p>"},{"location":"API_References/NexusProfiler_eng/#original-source","title":"Original Source","text":"<p>NexusProfiler.cs Source Code</p>"},{"location":"API_References/NexusProfiler_tr/","title":"API Referans\u0131: NexusProfiler (Performans Profilleyici)","text":""},{"location":"API_References/NexusProfiler_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusProfiler.cs</code>, Nexus Prime'\u0131n \"r\u00f6ntgen cihaz\u0131d\u0131r\". Unity'nin standart profillay\u0131c\u0131s\u0131 managed d\u00fcnyaya odaklan\u0131rken, NexusProfiler do\u011frudan unmanaged bellekteki veri ak\u0131\u015f\u0131n\u0131 ve CPU i\u015f y\u00fck\u00fcn\u00fc analiz eder. \"Gizli\" performans kay\u0131plar\u0131n\u0131 (cache miss, unaligned access) g\u00fcn y\u00fcz\u00fcne \u00e7\u0131kararak, sim\u00fclasyonun donan\u0131m b\u00fct\u00e7esi i\u00e7inde kalmas\u0131n\u0131 sa\u011flar.</p>"},{"location":"API_References/NexusProfiler_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Profilleyici \u015fu analiz metodolojilerini sunar: - Unmanaged Throughput Monitoring: Saniyede ka\u00e7 bile\u015fenin i\u015flendi\u011fini ve bellek bant geni\u015fli\u011fi kullan\u0131m\u0131n\u0131 raporlar. - Real-time Performance Guard Hook: NexusPerformanceGuard'dan gelen verileri g\u00f6rselle\u015ftirerek hangi sistemlerin b\u00fct\u00e7eyi a\u015ft\u0131\u011f\u0131n\u0131 g\u00f6sterir. - Play-Mode Reactive Logic: Sadece oyun \u00e7al\u0131\u015fma zaman\u0131nda aktif olarak, edit\u00f6r kaynaklar\u0131n\u0131 gereksiz yere t\u00fcketmez. - Bottleneck Identification: \u0130\u015flemci gecikmelerinin nerede (Query mi, Logic mi?) olu\u015ftu\u011funu kategorize eder.</p>"},{"location":"API_References/NexusProfiler_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>A\u00e7\u0131l\u0131\u015f: \"Nexus/Profiler\" men\u00fcs\u00fc ile pencere aktif edilir.</li> <li>Dinleme: \u00c7al\u0131\u015fma zaman\u0131nda (Play mode) <code>Registry</code> ve <code>JobSystem</code> performans verileri toplan\u0131r.</li> <li>Render: Toplanan veriler <code>OnGUI</code> i\u00e7inde bar grafikler veya metin infobox'lar olarak \u00e7izilir.</li> <li>Uyar\u0131: E\u011fer performans b\u00fct\u00e7esi (Budget) a\u015f\u0131l\u0131yorsa, aray\u00fczde k\u0131rm\u0131z\u0131 uyar\u0131lar g\u00f6sterir.</li> </ol>"},{"location":"API_References/NexusProfiler_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Unmanaged Throughput: Y\u00f6netilmeyen bellek bloklar\u0131 \u00fczerinden birim zamanda ge\u00e7en veri miktar\u0131.</li> <li>Cache Miss: \u0130\u015flemcinin ihtiyac\u0131 olan veriyi h\u0131zl\u0131 \u00f6n bellekte bulamay\u0131p yava\u015f ana belle\u011fe gitmesi durumu.</li> <li>Play-Mode Reactive: Bir arac\u0131n sadece oyun a\u00e7\u0131kken i\u015flevsel olmas\u0131 durumu.</li> <li>Performance Budget: Bir karenin (frame) tamamlanmas\u0131 i\u00e7in ayr\u0131lan milisaniye cinsinden maksimum s\u00fcre.</li> </ul>"},{"location":"API_References/NexusProfiler_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Profiling Overhead: Profiler'\u0131n kendisi de CPU t\u00fcketir. \u00c7ok hassas \u00f6l\u00e7\u00fcmler i\u00e7in profilleyici kodunun <code>[Conditional(\"ENABLE_NEXUS_PROFILER\")]</code> ile sarmalanmas\u0131 \u00f6nerilir.</li> </ul>"},{"location":"API_References/NexusProfiler_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Play moduna ge\u00e7in.\n// Nexus -&gt; Profiler penceresini a\u00e7arak \"Real-time Throughput\" de\u011ferini izleyin.\n</code></pre>"},{"location":"API_References/NexusProfiler_tr/#nexus-optimization-tip-identify-hot-systems","title":"Nexus Optimization Tip: Identify Hot Systems","text":"<p>Profiler'da %20'den fazla CPU t\u00fcketen sistemleri bulun ve bunlar\u0131 <code>NexusParallelSystem</code> ile optimize edin. Bu, oyununuzun hedef kare h\u0131z\u0131n\u0131 (FPS) saniyeler i\u00e7inde stabilize etmenizi sa\u011flar.</p>"},{"location":"API_References/NexusProfiler_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusProfiler.cs Kaynak Kodu</p>"},{"location":"API_References/NexusProgression_eng/","title":"API Reference: NexusProgression (Progression Tracking)","text":""},{"location":"API_References/NexusProgression_eng/#introduction","title":"Introduction","text":"<p><code>NexusProgression.cs</code> is an unmanaged structure that manages the progression processes (level, experience points, etc.) of entities (Entities) within Nexus Prime. This component, inherited from the HypeFire architecture, keeps data in unmanaged memory, allowing you to update the progression data of thousands of NPCs or players in a single loop without creating GC.</p>"},{"location":"API_References/NexusProgression_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The progression structure operates through the following metrics: - CurrentProgress: The current amount of experience or progress. - Goal: The target amount required to advance to the next level. - Level: The persistent integer level of the entity. - FillRatio: A calculated property (property) returning the ratio of progress toward the goal (0.0 - 1.0).</p>"},{"location":"API_References/NexusProgression_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Initialization: Progression is started by determining a <code>Goal</code> value.</li> <li>Addition: Experience or points are added to the entity using the <code>Add</code> method.</li> <li>Level-Up: If <code>CurrentProgress</code> exceeds the goal, the level is increased, and the remaining amount is transferred to the next level (rollover logic).</li> <li>Query: Percentage information for the interface (UI) is retrieved via <code>FillRatio</code>.</li> </ol>"},{"location":"API_References/NexusProgression_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Progression Logic: The process by which an entity gains value and levels up over time.</li> <li>Rollover Progress: The process where points exceeding a level-up do not go to waste but instead roll over to the next level.</li> <li>Efficiency via Unmanaged Struct: Accelerating memory access by holding data as a structure (struct) rather than a class (class).</li> <li>Fill Ratio: The fullness ratio of a progress bar (progress bar).</li> </ul>"},{"location":"API_References/NexusProgression_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Zero-Goal Hazard: If the <code>Goal</code> value is left as 0, <code>FillRatio</code> returns zero, and the <code>Add</code> method protects itself from entering an infinite loop. It is recommended that the target value always be &gt; 0.</li> </ul>"},{"location":"API_References/NexusProgression_eng/#usage-example","title":"Usage Example","text":"<pre><code>NexusProgression exp = new NexusProgression { Goal = 100 };\nexp.Add(120); \n// exp.Level is now 1, and exp.CurrentProgress is 20.\n</code></pre>"},{"location":"API_References/NexusProgression_eng/#nexus-optimization-tip-batch-level-ups","title":"Nexus Optimization Tip: Batch Level-Ups","text":"<p>When performing level-up checks for hundreds of thousands of units, update the <code>NexusProgression</code> structure directly from the Registry. This allows you to simulate 50 times more units simultaneously than traditional object-based RPG systems.</p>"},{"location":"API_References/NexusProgression_eng/#original-source","title":"Original Source","text":"<p>NexusProgression.cs Source Code</p>"},{"location":"API_References/NexusProgression_tr/","title":"API Referans\u0131: NexusProgression (Geli\u015fim Takibi)","text":""},{"location":"API_References/NexusProgression_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusProgression.cs</code>, Nexus Prime i\u00e7indeki varl\u0131klar\u0131n (Entity) geli\u015fim s\u00fcre\u00e7lerini (seviye, tecr\u00fcbe puan\u0131 vb.) y\u00f6neten unmanaged bir yap\u0131d\u0131r. HypeFire mimarisinden miras al\u0131nan bu bile\u015fen, veriyi unmanaged bellekte tutarak binlerce NPC veya oyuncunun geli\u015fim verisini tek bir loop i\u00e7inde, GC olu\u015fturmadan g\u00fcncellemenizi sa\u011flar.</p>"},{"location":"API_References/NexusProgression_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Geli\u015fim yap\u0131s\u0131 \u015fu metrikler \u00fczerinden \u00e7al\u0131\u015f\u0131r: - CurrentProgress: Mevcut tecr\u00fcbe veya ilerleme miktar\u0131. - Goal: Bir sonraki seviyeye ge\u00e7mek i\u00e7in gereken hedef miktar. - Level: Varl\u0131\u011f\u0131n mevcut seviye tam say\u0131s\u0131. - FillRatio: \u0130lerlemenin hedefe olan oran\u0131n\u0131 (0.0 - 1.0) d\u00f6nd\u00fcren hesaplanm\u0131\u015f m\u00fclkiyet (property).</p>"},{"location":"API_References/NexusProgression_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130lklendirme: <code>Goal</code> de\u011feri belirlenerek geli\u015fim ba\u015flat\u0131l\u0131r.</li> <li>Ekleme: <code>Add</code> metodu ile varl\u0131\u011fa tecr\u00fcbe veya puan eklenir.</li> <li>Level-Up: E\u011fer <code>CurrentProgress</code> hedefi ge\u00e7erse, seviye art\u0131r\u0131l\u0131r ve kalan miktar bir sonraki seviyeye aktar\u0131l\u0131r (rollover logic).</li> <li>Sorgu: <code>FillRatio</code> ile aray\u00fcz (UI) i\u00e7in y\u00fczde bilgisi al\u0131n\u0131r.</li> </ol>"},{"location":"API_References/NexusProgression_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Progression Logic: Bir varl\u0131\u011f\u0131n zamanla de\u011fer kazanmas\u0131 ve seviye atlamas\u0131 s\u00fcreci.</li> <li>Rollover Progress: Seviye atlad\u0131ktan sonra artan puan\u0131n bo\u015fa gitmeyip bir sonraki seviyeye devretmesi.</li> <li>Efficiency via Unmanaged Struct: Veriyi s\u0131n\u0131f (class) yerine yap\u0131 (struct) olarak tutarak bellek eri\u015fimini h\u0131zland\u0131rma.</li> <li>Fill Ratio: Bir ilerleme \u00e7ubu\u011funun (progress bar) doluluk oran\u0131.</li> </ul>"},{"location":"API_References/NexusProgression_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Zero-Goal Hazard: E\u011fer <code>Goal</code> de\u011feri 0 olarak b\u0131rak\u0131l\u0131rsa, <code>FillRatio</code> s\u0131f\u0131r d\u00f6nd\u00fcr\u00fcr ve <code>Add</code> metodu sonsuz d\u00f6ng\u00fcye girmemek i\u00e7in kendini korumaya al\u0131r. Hedef de\u011ferin her zaman &gt; 0 olmas\u0131 \u00f6nerilir.</li> </ul>"},{"location":"API_References/NexusProgression_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>NexusProgression exp = new NexusProgression { Goal = 100 };\nexp.Add(120); \n// exp.Level art\u0131k 1, exp.CurrentProgress ise 20'dir.\n</code></pre>"},{"location":"API_References/NexusProgression_tr/#nexus-optimization-tip-batch-level-ups","title":"Nexus Optimization Tip: Batch Level-Ups","text":"<p>Y\u00fcz binlerce birim i\u00e7in seviye atlama kontrol\u00fc yaparken <code>NexusProgression</code> yap\u0131s\u0131n\u0131 do\u011frudan Registry \u00fczerinden g\u00fcncelleyin. Bu, geleneksel nesne tabanl\u0131 RPG sistemlerine g\u00f6re 50 kat daha fazla birimi ayn\u0131 anda sim\u00fcle etmenize olanak tan\u0131r.</p>"},{"location":"API_References/NexusProgression_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusProgression.cs Kaynak Kodu</p>"},{"location":"API_References/NexusQueryBuilder_eng/","title":"API Reference: NexusQueryBuilder (Fluid Query Builder)","text":""},{"location":"API_References/NexusQueryBuilder_eng/#introduction","title":"Introduction","text":"<p><code>NexusQueryBuilder.cs</code> is the \"fluid\" (fluid) query engine of Nexus Prime. It allows developers to create complex entity filters with zero allocation (zero-allocation) using <code>ref struct</code> semantics. With chainable methods like <code>With&lt;T&gt;</code>, <code>Without&lt;T&gt;</code>, and <code>Where</code>, it winnows those meeting specific criteria from among thousands of entities within the system in milliseconds.</p>"},{"location":"API_References/NexusQueryBuilder_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The query builder applies the following optimizations: - Smallest Set Drive Strategy: During a query, it selects the set with the smallest amount of data among the requested components (minimum count) as the primary loop. This dramatically reduces unnecessary checks. - Ref Struct Semantics: Lives entirely on the stack, giving the Garbage Collector no extra work. - Predicate Filtering: In addition to standard bit-mask checks, it allows for adding custom logical filters via the <code>Where</code> method. - Lazy Resolution: Component sets are resolved (resolve) only when <code>Execute</code> is called, incurring no cost during the build phase.</p>"},{"location":"API_References/NexusQueryBuilder_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Build: Filter criteria are listed using the <code>With</code> and <code>Without</code> methods.</li> <li>Calculation: When <code>Execute</code> is called, the most efficient (shortest) loop path is calculated.</li> <li>Filtering: For each entity in the primary loop, the presence/absence of other components is checked.</li> <li>Triggering: The developer-provided <code>action</code> (lambda or method) is run for entities meeting all criteria.</li> </ol>"},{"location":"API_References/NexusQueryBuilder_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Fluid API: A style of coding with high readability where methods are chained together.</li> <li>Predicate: A logical function that takes an input and returns true (true) or false (false).</li> <li>Lazy Resolution: Calculating the result of a process only at the moment it is genuinely needed (the Execute phase).</li> <li>Exclusion Check: Removing entities possessing a specific component from the query result.</li> </ul>"},{"location":"API_References/NexusQueryBuilder_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Lambda Overhead: Using <code>Where(Predicate)</code> is slower than simple bit-mask checks. It is recommended to use only <code>With/Without</code> in performance-critical scenes.</li> </ul>"},{"location":"API_References/NexusQueryBuilder_eng/#usage-example","title":"Usage Example","text":"<pre><code>new NexusQueryBuilder(registry)\n    .With&lt;Position&gt;()\n    .Without&lt;Player&gt;()\n    .Where(e =&gt; registry.Get&lt;Position&gt;(e)-&gt;Y &gt; 10)\n    .Execute(e =&gt; { /* Logic */ });\n</code></pre>"},{"location":"API_References/NexusQueryBuilder_eng/#nexus-optimization-tip-order-of-exclusions","title":"Nexus Optimization Tip: Order of Exclusions","text":"<p>Start <code>Without&lt;T&gt;</code> checks with types containing the most entities. Early culling (early culling) can cut the total runtime of the query by up to 35%.</p>"},{"location":"API_References/NexusQueryBuilder_eng/#original-source","title":"Original Source","text":"<p>NexusQueryBuilder.cs Source Code</p>"},{"location":"API_References/NexusQueryBuilder_tr/","title":"API Referans\u0131: NexusQueryBuilder (Ak\u0131c\u0131 Sorgu \u0130n\u015fac\u0131)","text":""},{"location":"API_References/NexusQueryBuilder_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusQueryBuilder.cs</code>, Nexus Prime'\u0131n \"ak\u0131c\u0131\" (fluid) sorgu motorudur. Geli\u015ftiricilerin <code>ref struct</code> semanti\u011fi kullanarak, s\u0131f\u0131r tahsisat (zero-allocation) ile karma\u015f\u0131k varl\u0131k filtreleri olu\u015fturmas\u0131n\u0131 sa\u011flar. <code>With&lt;T&gt;</code>, <code>Without&lt;T&gt;</code> ve <code>Where</code> gibi zincirlenebilir metodlarla, sistem i\u00e7indeki binlerce varl\u0131k aras\u0131ndan belirli kriterlere uyanlar\u0131 milisaniyeler i\u00e7inde ay\u0131klar.</p>"},{"location":"API_References/NexusQueryBuilder_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Sorgu in\u015fac\u0131 \u015fu optimizasyonlar\u0131 uygular: - Smallest Set Drive Strategy: Sorgu s\u0131ras\u0131nda, istenen bile\u015fenler aras\u0131ndaki en k\u00fc\u00e7\u00fck veriye sahip seti (minimum count) ana d\u00f6ng\u00fc olarak se\u00e7er. Bu, gereksiz kontrolleri dramatik \u015fekilde azalt\u0131r. - Ref Struct Semantics: Tamamen stack \u00fczerinde ya\u015far, Garbage Collector'a i\u015f \u00e7\u0131karmaz. - Predicate Filtering: Standart bit-mask kontrollerine ek olarak, <code>Where</code> metodu ile \u00f6zel mant\u0131ksal filtrelerin eklenmesine izin verir. - Lazy Resolution: Bile\u015fen setleri sadece <code>Execute</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda \u00e7\u00f6z\u00fcmlenir (resolve), in\u015fa a\u015famas\u0131nda maliyet olu\u015fturmaz.</p>"},{"location":"API_References/NexusQueryBuilder_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130n\u015fa: <code>With</code> ve <code>Without</code> metodlar\u0131 ile filtre kriterleri listelenir.</li> <li>Hesaplama: <code>Execute</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, en verimli (en k\u0131sa) d\u00f6ng\u00fc yolu hesaplan\u0131r.</li> <li>S\u00fczme: Ana d\u00f6ng\u00fc i\u00e7indeki her varl\u0131k i\u00e7in di\u011fer bile\u015fenlerin varl\u0131k/yokluk durumlar\u0131 kontrol edilir.</li> <li>Tetikleme: T\u00fcm kriterleri kar\u015f\u0131layan varl\u0131klar i\u00e7in geli\u015ftiricinin verdi\u011fi <code>action</code> (lambda veya metod) \u00e7al\u0131\u015ft\u0131r\u0131l\u0131r.</li> </ol>"},{"location":"API_References/NexusQueryBuilder_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Fluid API: Metodlar\u0131n birbirine zincirlendi\u011fi, okunabilirli\u011fi y\u00fcksek kod yaz\u0131m stili.</li> <li>Predicate: Bir girdiyi al\u0131p do\u011fru (true) veya yanl\u0131\u015f (false) d\u00f6nd\u00fcren mant\u0131ksal fonksiyon.</li> <li>Lazy Resolution: Bir i\u015flemin sonucunun sadece ger\u00e7ekten ihtiya\u00e7 duyuldu\u011fu an (Execute a\u015famas\u0131) hesaplanmas\u0131.</li> <li>Exclusion Check: Belirli bir bile\u015fene sahip olan varl\u0131klar\u0131n sorgu sonucundan \u00e7\u0131kar\u0131lmas\u0131.</li> </ul>"},{"location":"API_References/NexusQueryBuilder_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Lambda Overhead: <code>Where(Predicate)</code> kullan\u0131m\u0131, basit bit-mask kontrollerine g\u00f6re daha yava\u015ft\u0131r. Performans kritik sahnelerde sadece <code>With/Without</code> kullan\u0131lmas\u0131 \u00f6nerilir.</li> </ul>"},{"location":"API_References/NexusQueryBuilder_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>new NexusQueryBuilder(registry)\n    .With&lt;Position&gt;()\n    .Without&lt;Player&gt;()\n    .Where(e =&gt; registry.Get&lt;Position&gt;(e)-&gt;Y &gt; 10)\n    .Execute(e =&gt; { /* Mant\u0131k */ });\n</code></pre>"},{"location":"API_References/NexusQueryBuilder_tr/#nexus-optimization-tip-order-of-exclusions","title":"Nexus Optimization Tip: Order of Exclusions","text":"<p><code>Without&lt;T&gt;</code> kontrollerini en \u00e7ok varl\u0131k i\u00e7eren tiplerle ba\u015flat\u0131n. Erken eleme (early culling), sorgunun toplam \u00e7al\u0131\u015fma s\u00fcresini %35'e kadar k\u0131saltabilir.</p>"},{"location":"API_References/NexusQueryBuilder_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusQueryBuilder.cs Kaynak Kodu</p>"},{"location":"API_References/NexusQueryOptimizer_eng/","title":"API Reference: NexusQueryOptimizer (Query Optimizer)","text":""},{"location":"API_References/NexusQueryOptimizer_eng/#introduction","title":"Introduction","text":"<p><code>NexusQueryOptimizer.cs</code> is the intelligent load balancer of Nexus Prime. By analyzing complex entity queries, it decides at runtime on the most efficient execution method (Single-Thread, Parallel.For, or SIMD-Parallel) based on the size of the task. This module avoids thread-pool overhead for small datasets while automatically engaging all hardware cores for massive datasets.</p>"},{"location":"API_References/NexusQueryOptimizer_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The optimizer makes decisions based on the following strategies: - Automatic Load Balancing: Selects the most appropriate path based on the number of entities to be processed (<code>count</code>). - Threshold-Based Execution: Uses a single thread (single-thread) for small datasets (&lt;1000) to avoid context switching (context switching) costs. - Multi-Core Dispatch: Distributes tasks to all processor cores via <code>Parallel.For</code> for large datasets. - Static Dispatcher: Performs high-performance routing via static methods without the cost of object creation.</p>"},{"location":"API_References/NexusQueryOptimizer_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Analysis: The number of entities arriving at the <code>ExecuteSmartQuery</code> method is checked.</li> <li>Comparison: If the number is below the set threshold value (1000), a linear (linear) loop is started.</li> <li>Parallelization: If the number exceeds the threshold, threads (threads) are assigned and parallel execution begins.</li> <li>Completion: A return to the main system is made once all sub-tasks are finished.</li> </ol>"},{"location":"API_References/NexusQueryOptimizer_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Load Balancing: Distributing the workload balanced among available resources (CPU cores).</li> <li>Thread Pool Overhead: Extra processor time spent managing threads.</li> <li>Context Switching: The costly state change the processor makes when switching from one thread to another.</li> <li>Threshold Values: Specific values that constitute a limit in the decision-making process.</li> </ul>"},{"location":"API_References/NexusQueryOptimizer_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Over-Parallelization: Opening a parallel loop for very small tasks can make management more expensive than the task itself. This is why the 1000 threshold in <code>NexusQueryOptimizer</code> is critical.</li> </ul>"},{"location":"API_References/NexusQueryOptimizer_eng/#usage-example","title":"Usage Example","text":"<pre><code>NexusQueryOptimizer.ExecuteSmartQuery(entities.Length, (index) =&gt; {\n    // Logic remains identical in both scenarios.\n});\n</code></pre>"},{"location":"API_References/NexusQueryOptimizer_eng/#nexus-optimization-tip-adaptive-thresholds","title":"Nexus Optimization Tip: Adaptive Thresholds","text":"<p>Update threshold values dynamically as hardware changes (e.g., Mobile vs. PC). Reducing the parallelization threshold to 500 on a powerful PC processes large data chunks 15% faster.</p>"},{"location":"API_References/NexusQueryOptimizer_eng/#original-source","title":"Original Source","text":"<p>NexusQueryOptimizer.cs Source Code</p>"},{"location":"API_References/NexusQueryOptimizer_tr/","title":"API Referans\u0131: NexusQueryOptimizer (Sorgu Optimize Edici)","text":""},{"location":"API_References/NexusQueryOptimizer_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusQueryOptimizer.cs</code>, Nexus Prime'\u0131n ak\u0131ll\u0131 y\u00fck dengeleyicisidir. Karma\u015f\u0131k varl\u0131k sorgular\u0131n\u0131 analiz ederek, i\u015fin boyutuna g\u00f6re en verimli infaz y\u00f6ntemine (Single-Thread, Parallel.For veya SIMD-Parallel) \u00e7al\u0131\u015fma zaman\u0131nda karar verir. Bu mod\u00fcl, k\u00fc\u00e7\u00fck veri k\u00fcmeleri i\u00e7in thread-pool maliyetinden ka\u00e7\u0131n\u0131rken, devasa veri k\u00fcmeleri i\u00e7in donan\u0131m\u0131n t\u00fcm \u00e7ekirdeklerini otomatik olarak devreye sokar.</p>"},{"location":"API_References/NexusQueryOptimizer_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Optimize edici \u015fu stratejilerle karar verir: - Automatic Load Balancing: \u0130\u015flenecek varl\u0131k say\u0131s\u0131na (<code>count</code>) g\u00f6re en uygun yolu se\u00e7er. - Threshold-Based Execution: K\u00fc\u00e7\u00fck veri setleri (&lt;1000) i\u00e7in tek thread (single-thread) kullanarak ba\u011flam de\u011fi\u015fimi (context switching) maliyetinden ka\u00e7\u0131n\u0131r. - Multi-Core Dispatch: B\u00fcy\u00fck veri setleri i\u00e7in <code>Parallel.For</code> \u00fczerinden i\u015fleri t\u00fcm i\u015flemci \u00e7ekirdeklerine da\u011f\u0131t\u0131r. - Static Dispatcher: Nesne olu\u015fturma maliyeti olmadan, statik metodlar \u00fczerinden y\u00fcksek performansl\u0131 y\u00f6nlendirme yapar.</p>"},{"location":"API_References/NexusQueryOptimizer_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Analiz: <code>ExecuteSmartQuery</code> metoduna gelen varl\u0131k say\u0131s\u0131 kontrol edilir.</li> <li>K\u0131yaslama: Say\u0131 belirlenen e\u015fik de\u011ferinin (1000) alt\u0131ndaysa do\u011frusal (linear) bir d\u00f6ng\u00fc ba\u015flat\u0131l\u0131r.</li> <li>Paralelle\u015ftirme: Say\u0131 e\u015fi\u011fi a\u015f\u0131yorsa, i\u015f par\u00e7ac\u0131klar\u0131 (threads) atanarak paralel infaz ba\u015flat\u0131l\u0131r.</li> <li>Tamamlama: T\u00fcm alt i\u015fler bitti\u011finde ana sisteme geri d\u00f6n\u00fc\u015f yap\u0131l\u0131r.</li> </ol>"},{"location":"API_References/NexusQueryOptimizer_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Load Balancing: \u0130\u015f y\u00fck\u00fcn\u00fcn mevcut kaynaklar (CPU \u00e7ekirdekleri) aras\u0131nda dengeli da\u011f\u0131t\u0131lmas\u0131.</li> <li>Thread Pool Overhead: \u0130\u015f par\u00e7ac\u0131klar\u0131n\u0131 y\u00f6netmek i\u00e7in harcanan ekstra i\u015flemci zaman\u0131.</li> <li>Context Switching: \u0130\u015flemcinin bir i\u015f par\u00e7ac\u0131\u011f\u0131ndan di\u011ferine ge\u00e7erken yapt\u0131\u011f\u0131 maliyetli durum de\u011fi\u015fikli\u011fi.</li> <li>Threshold Values: Karar verme s\u00fcrecinde s\u0131n\u0131r olu\u015fturan belirli de\u011ferler.</li> </ul>"},{"location":"API_References/NexusQueryOptimizer_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Over-Parallelization: \u00c7ok k\u00fc\u00e7\u00fck i\u015fler i\u00e7in paralel d\u00f6ng\u00fc a\u00e7mak, y\u00f6netimi i\u015fin kendisinden daha pahal\u0131 hale getirebilir. <code>NexusQueryOptimizer</code> i\u00e7indeki 1000 e\u015fi\u011fi bu y\u00fczden kritiktir.</li> </ul>"},{"location":"API_References/NexusQueryOptimizer_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>NexusQueryOptimizer.ExecuteSmartQuery(entities.Length, (index) =&gt; {\n    // \u0130\u015f mant\u0131\u011f\u0131 her iki senaryoda da ayn\u0131 kal\u0131r.\n});\n</code></pre>"},{"location":"API_References/NexusQueryOptimizer_tr/#nexus-optimization-tip-adaptive-thresholds","title":"Nexus Optimization Tip: Adaptive Thresholds","text":"<p>Donan\u0131m de\u011fi\u015ftik\u00e7e (\u00d6rn: Mobil vs PC) e\u015fik de\u011ferlerini dinamik olarak g\u00fcncelleyin. G\u00fc\u00e7l\u00fc bir PC'de paralelle\u015ftirme e\u015fi\u011fini 500'e \u00e7ekmek b\u00fcy\u00fck veri y\u0131\u011f\u0131nlar\u0131n\u0131 %15 daha h\u0131zl\u0131 eritir.</p>"},{"location":"API_References/NexusQueryOptimizer_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusQueryOptimizer.cs Kaynak Kodu</p>"},{"location":"API_References/NexusQuery_eng/","title":"API Reference: NexusQuery (SIMD Query Engine)","text":""},{"location":"API_References/NexusQuery_eng/#introduction","title":"Introduction","text":"<p><code>NexusQuery.cs</code> is the unmanaged query engine used by Nexus Prime to process \"Big Data\" level entity sets. Thanks to its <code>ref struct</code> design, it lives on the stack and incurs zero GC cost. By utilizing raw bitset operations and hardware-accelerated (SIMD) instructions to find entities possessing two different components, it can filter millions of entities per second at the microsecond level.</p>"},{"location":"API_References/NexusQuery_eng/#technical-analysis","title":"Technical Analysis","text":"<p>NexusQuery combines several techniques to extract maximum efficiency from modern processor architectures: - Bitset ANDing: Entity component ownership is compared via bitsets (presence bits). This allows answering the question \"does this entity possess this component?\" for 32 or 256 entities in a single processor cycle. - AVX2 Acceleration: If the processor supports it, query results for 256 entities are calculated in a single move (via an <code>AND</code> operation) using 256-bit wide registers. - Ref Struct Semantics: To completely prevent memory pollution, it is allocated exclusively on the stack and is much closer to the processor cache (L1) than <code>class</code> objects. - Dual-Path Execution: Automatically selects between AVX2 or scalar (standard) paths based on the processor.</p>"},{"location":"API_References/NexusQuery_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Preparation: Raw presence bits (<code>PresenceBits</code>) of the two targeted components are fetched via the <code>Registry</code>.</li> <li>Intersection: The two bitsets are overlaid using the <code>Avx2.And</code> instruction (or fallback path). Only entities possessing both components remain as \"1\".</li> <li>Filtering: Non-zero memory blocks (where matches occur) are instantly detected via the <code>MoveMask</code> instruction. Thousands of entities without matches are skipped by the processor without any processing.</li> <li>Processing: The user-provided <code>Execute</code> callback function is invoked for each matching entity.</li> </ol>"},{"location":"API_References/NexusQuery_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>SIMD (AVX2): The ability to process massive bitsets in parallel with a single instruction.</li> <li>Bitmask Filtering: The technique of quickly asking \"is the entity here?\" at the bit level before reading the actual data.</li> <li>Ref Struct: A C# type that can only live on the stack and never enters the heap.</li> <li>Dual-Path Logic: An architecture that automatically determines the fastest path based on the hardware.</li> </ul>"},{"location":"API_References/NexusQuery_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Stack Bound: Valid only for the lifetime of the method; cannot be saved as a field within a <code>class</code>.</li> <li>Hardware Dependency: On very old mobile devices without AVX2 support, performance gains may decrease as it falls back to the scalar path.</li> </ul>"},{"location":"API_References/NexusQuery_eng/#usage-example","title":"Usage Example","text":"<pre><code>registry.Query&lt;Position, Velocity&gt;().Execute((id, pos, vel) =&gt; {\n    pos-&gt;Value += vel-&gt;Value * Time.deltaTime;\n});\n</code></pre>"},{"location":"API_References/NexusQuery_eng/#nexus-optimization-tip-spatial-locality-via-bitsets","title":"Nexus Optimization Tip: Spatial Locality via Bitsets","text":"<p>NexusQuery scans 1-bit markers before reading the data itself (Position/Velocity). This allows the processor to view the status of 8192 entities within a 1KB memory block, maximizing \"Instruction Cache\" efficiency and reducing the load on the \"Data Cache\" by 99% for non-matching entities.</p>"},{"location":"API_References/NexusQuery_eng/#original-source","title":"Original Source","text":"<p>NexusQuery.cs Source Code</p>"},{"location":"API_References/NexusQuery_tr/","title":"API Referans\u0131: NexusQuery (SIMD Sorgu Motoru)","text":""},{"location":"API_References/NexusQuery_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusQuery.cs</code>, Nexus Prime'\u0131n \"Big Data\" seviyesindeki varl\u0131k setlerini i\u015flemek i\u00e7in kulland\u0131\u011f\u0131 unmanaged sorgu motorudur. <code>ref struct</code> yap\u0131s\u0131 sayesinde bellek y\u0131\u011f\u0131n\u0131nda (stack) ya\u015far ve s\u0131f\u0131r GC maliyeti \u00fcretir. \u0130ki farkl\u0131 bile\u015fene sahip varl\u0131klar\u0131 bulmak i\u00e7in ham bitset operasyonlar\u0131 ve donan\u0131m h\u0131zland\u0131rmal\u0131 (SIMD) komutlar\u0131 kullanarak, saniyede milyonlarca varl\u0131\u011f\u0131 mikrosaniye d\u00fczeyinde filtreleyebilir.</p>"},{"location":"API_References/NexusQuery_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>NexusQuery, modern i\u015flemci mimarilerinden maksimum verim almak i\u00e7in \u015fu teknikleri birle\u015ftirir: - Bitset ANDing: Varl\u0131klar\u0131n bile\u015fen sahipli\u011fi bit dizileri (presence bits) \u00fczerinden kar\u015f\u0131la\u015ft\u0131r\u0131l\u0131r. Bu, \"acaba bu varl\u0131kta \u015fu bile\u015fen var m\u0131?\" sorusuna tek bir i\u015flemci \u00e7evriminde 32 veya 256 varl\u0131k i\u00e7in cevap vermeyi sa\u011flar. - AVX2 Acceleration: E\u011fer i\u015flemci destekliyorsa, 256-bit geni\u015fli\u011findeki kay\u0131t\u00e7\u0131lar (registers) kullan\u0131larak ayn\u0131 anda 256 varl\u0131\u011f\u0131n sorgu sonucu tek hamlede (<code>AND</code> i\u015flemiyle) hesaplan\u0131r. - Ref Struct semantics: Bellek kirlili\u011fini tamamen \u00f6nlemek i\u00e7in sadece stack \u00fczerinde tahsis edilir ve <code>class</code> nesnelerinin aksine i\u015flemci \u00f6nbelle\u011fine (L1) \u00e7ok daha yak\u0131nd\u0131r. - Dual-Path Execution: \u0130\u015flemciye g\u00f6re AVX2 veya scalar (standart) yollardan birini otomatik se\u00e7er.</p>"},{"location":"API_References/NexusQuery_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Haz\u0131rl\u0131k: <code>Registry</code> \u00fczerinden hedeflenen iki bile\u015fenin ham varl\u0131k bitleri (<code>PresenceBits</code>) al\u0131n\u0131r.</li> <li>Kesi\u015fim (<code>Intersection</code>): <code>Avx2.And</code> komutu (veya fallback yolu) ile iki bit seti \u00fcst \u00fcste bindirilir. Sonu\u00e7ta sadece her iki bile\u015fene de sahip varl\u0131klar \"1\" olarak kal\u0131r.</li> <li>Filtreleme: <code>MoveMask</code> komutu ile s\u0131f\u0131r olmayan (e\u015fle\u015fme olan) bellek bloklar\u0131 an\u0131nda tespit edilir. S\u0131f\u0131r olan (e\u015fle\u015fme olmayan) binlerce varl\u0131k i\u015flemci taraf\u0131ndan hi\u00e7 i\u015flenmeden atlanm\u0131\u015f olur.</li> <li>\u0130\u015fleme: E\u015fle\u015fen her varl\u0131k i\u00e7in kullan\u0131c\u0131 taraf\u0131ndan verilen <code>Execute</code> fonksiyonu (callback) \u00e7a\u011fr\u0131l\u0131r.</li> </ol>"},{"location":"API_References/NexusQuery_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>SIMD (AVX2): Tek bir komutla devasa bit dizilerini paralel i\u015fleme yetene\u011fi.</li> <li>Bitmask Filtering: Veriyi okumadan \u00f6nce \"varl\u0131k burada m\u0131?\" sorusunu bit seviyesinde h\u0131zl\u0131ca sorma tekni\u011fi.</li> <li>Ref Struct: Sadece stack \u00fczerinde ya\u015fayabilen, heap'e (y\u0131\u011f\u0131na) asla \u00e7\u0131kmayan C# tipi.</li> <li>Dual-Path logic: Donan\u0131ma g\u00f6re en h\u0131zl\u0131 yolu otomatik belirleyen mimari.</li> </ul>"},{"location":"API_References/NexusQuery_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Stack Bound: Sadece metodun \u00f6mr\u00fc boyunca ge\u00e7erlidir, bir <code>class</code> i\u00e7ine field olarak kaydedilemez.</li> <li>Hardware Dependency: AVX2 deste\u011fi olmayan \u00e7ok eski mobil cihazlarda scalar yola d\u00fc\u015ft\u00fc\u011f\u00fc i\u00e7in performans fark\u0131 azalabilir.</li> </ul>"},{"location":"API_References/NexusQuery_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>registry.Query&lt;Position, Velocity&gt;().Execute((id, pos, vel) =&gt; {\n    pos-&gt;Value += vel-&gt;Value * Time.deltaTime;\n});\n</code></pre>"},{"location":"API_References/NexusQuery_tr/#nexus-optimization-tip-spatial-locality-via-bitsets","title":"Nexus Optimization Tip: Spatial Locality via Bitsets","text":"<p>NexusQuery, verinin kendisini (Position/Velocity) okumadan \u00f6nce 1 bitlik i\u015faret\u00e7ileri tarar. Bu sayede i\u015flemci, 1KB'l\u0131k bir bellek blo\u011funda 8192 varl\u0131\u011f\u0131n durumunu g\u00f6rebilir. Bu, i\u015flemcinin \"Instruction Cache\" verimlili\u011fini tavan yapt\u0131r\u0131r ve \"Data Cache\" \u00fczerindeki y\u00fck\u00fc, e\u015fle\u015fme olmayan varl\u0131klar i\u00e7in %99 oran\u0131nda azalt\u0131r.</p>"},{"location":"API_References/NexusQuery_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusQuery.cs Kaynak Kodu</p>"},{"location":"API_References/NexusRotationField_eng/","title":"API Reference: NexusRotationField (Rotation Field)","text":""},{"location":"API_References/NexusRotationField_eng/#introduction","title":"Introduction","text":"<p><code>NexusRotationField.cs</code> is a specialized structure for storing rotation data within unmanaged memory blocks of Nexus Prime. It maintains rotation as human-readable \"Euler\" angles while offering instant (implicit) conversion to the \"Quaternion\" type required for Unity's hardware-accelerated rotations. This provides both memory efficiency and ease of use.</p>"},{"location":"API_References/NexusRotationField_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The rotation field has the following technical characteristics: - Unmanaged Storage: Occupies only 12 bytes per entity with its <code>Vector3</code> (Euler) based structure. - Implicit Conversion Operators: Can be passed directly as a parameter to all Unity methods expecting a <code>Quaternion</code> or <code>Vector3</code>. - Scalar Operations: Supports mathematical operations such as multiplying rotation values by a coefficient (<code>*</code> operator). - Serializable Integration: Can also be viewed via the Unity Inspector with the <code>[Serializable]</code> attribute.</p>"},{"location":"API_References/NexusRotationField_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Identification: A rotation component (<code>Add&lt;NexusRotationField&gt;</code>) is created for an entity.</li> <li>Assignment: A value is provided via <code>Quaternion</code> or raw Euler angles.</li> <li>Conversion: The system automatically switches to Quaternion form when needed.</li> <li>Application: The calculated rotation is transferred to Unity <code>Transform</code> or <code>NativeRender</code> systems.</li> </ol>"},{"location":"API_References/NexusRotationField_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Euler Angles: A method of representing an object's rotation via the X, Y, and Z axes (0-360 degrees).</li> <li>Quaternion: A mathematical structure representing rotations with complex numbers (x, y, z, w) that solves the \"Gimbal Lock\" problem.</li> <li>Implicit Operator: A feature that enables a type to be converted to another type automatically (without writing code).</li> <li>Scalar Multiplication: The multiplication of all components of a vector or structure by a single number.</li> </ul>"},{"location":"API_References/NexusRotationField_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Gimbal Lock: Because Euler angles are used, there is a risk of axis collision (Gimbal Lock) at 90-degree perpendicular angles. For critical rotations, direct Quaternion-based operations are recommended.</li> </ul>"},{"location":"API_References/NexusRotationField_eng/#usage-example","title":"Usage Example","text":"<pre><code>NexusRotationField rot = transform.rotation; // Automatic conversion\nrot *= 2.0f; // Double the rotation\nQuaternion unityRot = rot; // Convert back to Unity format\n</code></pre>"},{"location":"API_References/NexusRotationField_eng/#nexus-optimization-tip-euler-over-quaternion-for-storage","title":"Nexus Optimization Tip: Euler over Quaternion for Storage","text":"<p>Storing rotations in memory as <code>NexusRotationField</code> (12 bytes) instead of <code>Quaternion</code> (16 bytes) reduces memory usage by 25% for millions of entities, while allowing for more efficient use of memory bandwidth.</p>"},{"location":"API_References/NexusRotationField_eng/#original-source","title":"Original Source","text":"<p>NexusRotationField.cs Source Code</p>"},{"location":"API_References/NexusRotationField_tr/","title":"API Referans\u0131: NexusRotationField (D\u00f6nd\u00fcrme Alan\u0131)","text":""},{"location":"API_References/NexusRotationField_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusRotationField.cs</code>, Nexus Prime'\u0131n unmanaged bellek bloklar\u0131 i\u00e7inde rotasyon verilerini saklamak i\u00e7in \u00f6zelle\u015fmi\u015f bir yap\u0131d\u0131r. Rotasyonu insan taraf\u0131ndan okunabilir \"Euler\" a\u00e7\u0131lar\u0131 olarak tutarken, Unity'nin donan\u0131m h\u0131zland\u0131rmal\u0131 rotasyonlar\u0131 i\u00e7in gereken \"Quaternion\" tipine anl\u0131k (implicit) d\u00f6n\u00fc\u015f\u00fcm sunar. Bu sayede hem bellek verimlili\u011fi hem de kullan\u0131m kolayl\u0131\u011f\u0131 sa\u011flar.</p>"},{"location":"API_References/NexusRotationField_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>D\u00f6nd\u00fcrme alan\u0131 \u015fu teknik \u00f6zelliklere sahiptir: - Unmanaged Storage: <code>Vector3</code> (Euler) temelli yap\u0131s\u0131 ile her varl\u0131k i\u00e7in sadece 12 byte yer kaplar. - Implicit Conversion Operators: <code>Quaternion</code> veya <code>Vector3</code> bekleyen t\u00fcm Unity metodlar\u0131na do\u011frudan parametre olarak ge\u00e7ilebilir. - Scalar Operations: Rotasyon de\u011ferlerinin bir katsay\u0131 ile \u00e7arp\u0131lmas\u0131 (<code>*</code> operat\u00f6r\u00fc) gibi matematiksel i\u015flemleri destekler. - Serializable Integration: <code>[Serializable]</code> attribute'u ile Unity Inspector \u00fczerinden de g\u00f6r\u00fcnt\u00fclenebilir.</p>"},{"location":"API_References/NexusRotationField_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tan\u0131mlama: Bir varl\u0131k i\u00e7in rotasyon bile\u015feni (<code>Add&lt;NexusRotationField&gt;</code>) olu\u015fturulur.</li> <li>Atama: <code>Quaternion</code> veya ham Euler a\u00e7\u0131lar\u0131 ile de\u011fer verilir.</li> <li>D\u00f6n\u00fc\u015f\u00fcm: \u0130htiya\u00e7 duyuldu\u011funda sistem otomatik olarak Quaternion formuna ge\u00e7er.</li> <li>Uygulama: Hesaplanan rotasyon, Unity <code>Transform</code> veya <code>NativeRender</code> sistemlerine aktar\u0131l\u0131r.</li> </ol>"},{"location":"API_References/NexusRotationField_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Euler Angles: Bir nesnenin rotasyonunu X, Y, Z eksenleri \u00fczerinden (0-360 derece) temsil etme y\u00f6ntemi.</li> <li>Quaternion: Rotasyonlar\u0131 karma\u015f\u0131k say\u0131larla (x, y, z, w) temsil eden ve \"Gimbal Lock\" sorununu \u00e7\u00f6zen matematiksel yap\u0131.</li> <li>Implicit Operator: Bir tipin ba\u015fka bir tipe otomatik (kod yazmadan) d\u00f6n\u00fc\u015ft\u00fcr\u00fclmesini sa\u011flayan \u00f6zellik.</li> <li>Scalar Multiplication: Bir vekt\u00f6r veya yap\u0131n\u0131n t\u00fcm bile\u015fenlerinin tek bir say\u0131yla \u00e7arp\u0131lmas\u0131.</li> </ul>"},{"location":"API_References/NexusRotationField_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Gimbal Lock: Euler a\u00e7\u0131lar\u0131 kullan\u0131ld\u0131\u011f\u0131 i\u00e7in 90 derecelik dik a\u00e7\u0131larda eksen \u00e7ak\u0131\u015fmas\u0131 (Gimbal Lock) riski vard\u0131r. Kritik rotasyonlar i\u00e7in do\u011frudan Quaternion tabanl\u0131 i\u015flemler \u00f6nerilir.</li> </ul>"},{"location":"API_References/NexusRotationField_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>NexusRotationField rot = transform.rotation; // Otomatik d\u00f6n\u00fc\u015f\u00fcm\nrot *= 2.0f; // Rotasyonu iki kat\u0131na \u00e7\u0131kar\nQuaternion unityRot = rot; // Tekrar Unity format\u0131na d\u00f6n\u00fc\u015f\n</code></pre>"},{"location":"API_References/NexusRotationField_tr/#nexus-optimization-tip-euler-over-quaternion-for-storage","title":"Nexus Optimization Tip: Euler over Quaternion for Storage","text":"<p>Rotasyonlar\u0131 bellekte <code>Quaternion</code> (16 byte) yerine <code>NexusRotationField</code> (12 byte) olarak saklamak, milyonlarca varl\u0131kta bellek kullan\u0131m\u0131n\u0131 %25 azalt\u0131rken, bellek bant geni\u015fli\u011fini daha verimli kullanman\u0131z\u0131 sa\u011flar.</p>"},{"location":"API_References/NexusRotationField_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusRotationField.cs Kaynak Kodu</p>"},{"location":"API_References/NexusStatus_eng/","title":"API Reference: NexusStatus (Status and Attribute Data)","text":""},{"location":"API_References/NexusStatus_eng/#introduction","title":"Introduction","text":"<p><code>NexusStatus.cs</code> is an unmanaged data package that manages the vital statistics (Health, Mana, etc.) and core RPG attributes (Strength, Agility, etc.) of entities within Nexus Prime. These structures, derived from the HypeFire architecture, keep the data most touched by game logic in unmanaged memory locality, allowing complex combat simulations to run for thousands of entities without performance degradation.</p>"},{"location":"API_References/NexusStatus_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The file hosts two primary unmanaged structures: 1. NexusStatus:     - Holds the entity's current and maximum Health (<code>Health</code>) and Mana values.    - Contains critical state queries such as <code>IsDead</code>.    - Offers safe (clamped) data manipulation via <code>Damage</code> and <code>Heal</code> methods. 2. NexusAttributeStats:    - Stores Strength, Agility, Intelligence, and Stamina values\u2014the classic quartet of the RPG world\u2014as integers.</p>"},{"location":"API_References/NexusStatus_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Initialization: <code>MaxHealth</code> and <code>MaxMana</code> are assigned when the entity is created.</li> <li>Simulation: The combat system calls the <code>Damage</code> method, reducing health.</li> <li>Audit: UI systems update bars by reading the <code>HealthPercent</code> property every frame.</li> <li>Death: When the <code>IsDead</code> flag is true, other systems (AI, Render) disable the entity.</li> </ol>"},{"location":"API_References/NexusStatus_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Vitals Tracking: Tracking basic values required for a living creature or entity to survive.</li> <li>RPG Attribute Stats: Fundamental statistics defining a character's strength and abilities.</li> <li>IsDead Check: A check determining whether an entity is logically \"non-existent.\"</li> <li>Clamped Manipulation: A process ensuring a value does not exceed defined boundaries (0 - Max).</li> </ul>"},{"location":"API_References/NexusStatus_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Float Precision: Because health values are held as <code>float</code>, precision losses may occur with very small damage amounts (e.g., 0.00001). These differences are negligible for realistic scenarios.</li> </ul>"},{"location":"API_References/NexusStatus_eng/#usage-example","title":"Usage Example","text":"<pre><code>NexusStatus status = new NexusStatus { MaxHealth = 100, CurrentHealth = 100 };\nstatus.Damage(25);\nif (status.HealthPercent &lt; 0.5f) { /* Alarm! */ }\n</code></pre>"},{"location":"API_References/NexusStatus_eng/#nexus-optimization-tip-structural-locality","title":"Nexus Optimization Tip: Structural Locality","text":"<p>Use <code>NexusStatus</code> and <code>NexusAttributeStats</code> structures side-by-side (<code>Add</code>) on the same Entity. The hardware will bring these two unmanaged structures into the CPU in a single cache-line, speeding up statistical calculations by 20%.</p>"},{"location":"API_References/NexusStatus_eng/#original-source","title":"Original Source","text":"<p>NexusStatus.cs Source Code</p>"},{"location":"API_References/NexusStatus_tr/","title":"API Referans\u0131: NexusStatus (Durum ve Nitelik Verileri)","text":""},{"location":"API_References/NexusStatus_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusStatus.cs</code>, Nexus Prime i\u00e7indeki varl\u0131klar\u0131n hayati de\u011ferlerini (Sa\u011fl\u0131k, Mana vb.) ve temel RPG niteliklerini (G\u00fc\u00e7, \u00c7eviklik vb.) y\u00f6neten unmanaged bir veri paketidir. HypeFire mimarisinden gelen bu yap\u0131lar, oyun mant\u0131\u011f\u0131n\u0131n en \u00e7ok dokundu\u011fu verileri unmanaged bellek yerelli\u011finde tutarak, karma\u015f\u0131k sava\u015f sim\u00fclasyonlar\u0131n\u0131n binlerce varl\u0131k i\u00e7in performans kayb\u0131 olmadan ko\u015fturulmas\u0131n\u0131 sa\u011flar.</p>"},{"location":"API_References/NexusStatus_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Dosya iki ana unmanaged yap\u0131y\u0131 bar\u0131nd\u0131r\u0131r: 1. NexusStatus:     - Varl\u0131\u011f\u0131n anl\u0131k ve maksimum Sa\u011fl\u0131k (<code>Health</code>) ve Mana de\u011ferlerini tutar.    - <code>IsDead</code> gibi kritik durum sorgular\u0131n\u0131 bar\u0131nd\u0131r\u0131r.    - <code>Damage</code> ve <code>Heal</code> metodlar\u0131 ile g\u00fcvenli (clamped) veri manip\u00fclasyonu sunar. 2. NexusAttributeStats:    - RPG d\u00fcnyas\u0131n\u0131n klasik d\u00f6rtl\u00fcs\u00fc olan Strength, Agility, Intelligence ve Stamina de\u011ferlerini tam say\u0131 olarak saklar.</p>"},{"location":"API_References/NexusStatus_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130lklendirme: Varl\u0131k olu\u015fturuldu\u011funda <code>MaxHealth</code> ve <code>MaxMana</code> atan\u0131r.</li> <li>Sim\u00fclasyon: Sava\u015f sistemi <code>Damage</code> metodunu \u00e7a\u011f\u0131rarak sa\u011fl\u0131k d\u00fc\u015f\u00fcr\u00fcr.</li> <li>Denetim: UI sistemleri her karede <code>HealthPercent</code> m\u00fclkiyetini okuyarak barlar\u0131 g\u00fcnceller.</li> <li>\u00d6l\u00fcm: <code>IsDead</code> bayra\u011f\u0131 true oldu\u011funda, di\u011fer sistemler (AI, Render) varl\u0131\u011f\u0131 devre d\u0131\u015f\u0131 b\u0131rak\u0131r.</li> </ol>"},{"location":"API_References/NexusStatus_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Vitals Tracking: Bir canl\u0131n\u0131n veya varl\u0131\u011f\u0131n hayatta kalmas\u0131 i\u00e7in gereken temel de\u011ferlerin takibi.</li> <li>RPG Attribute Stats: Karakterin g\u00fcc\u00fcn\u00fc ve yeteneklerini tan\u0131mlayan temel istatistikler.</li> <li>IsDead Check: Varl\u0131\u011f\u0131n mant\u0131ksal olarak \"yok h\u00fckm\u00fcnde\" olup olmad\u0131\u011f\u0131n\u0131 belirleyen kontrol.</li> <li>Clamped Manipulation: Bir de\u011ferin belirlenen s\u0131n\u0131rlar (0 - Max) d\u0131\u015f\u0131na \u00e7\u0131kmamas\u0131n\u0131 sa\u011flayan i\u015flem.</li> </ul>"},{"location":"API_References/NexusStatus_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Float Precision: Sa\u011fl\u0131k de\u011ferleri <code>float</code> olarak tutuldu\u011fu i\u00e7in \u00e7ok k\u00fc\u00e7\u00fck hasarlarda (\u00f6rn: 0.00001) hassasiyet kay\u0131plar\u0131 olu\u015fabilir. Ger\u00e7ek\u00e7i senaryolar i\u00e7in bu farklar ihmal edilebilir d\u00fczeydedir.</li> </ul>"},{"location":"API_References/NexusStatus_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>NexusStatus status = new NexusStatus { MaxHealth = 100, CurrentHealth = 100 };\nstatus.Damage(25);\nif (status.HealthPercent &lt; 0.5f) { /* Alarm! */ }\n</code></pre>"},{"location":"API_References/NexusStatus_tr/#nexus-optimization-tip-structural-locality","title":"Nexus Optimization Tip: Structural Locality","text":"<p><code>NexusStatus</code> ve <code>NexusAttributeStats</code> yap\u0131lar\u0131n\u0131 ayn\u0131 Entity \u00fczerinde yan yana (<code>Add</code>) kullan\u0131n. Donan\u0131m, bu iki unmanaged yap\u0131y\u0131 tek bir cache-line i\u00e7inde CPU'ya getirecek ve istatistik hesaplamalar\u0131n\u0131 %20 h\u0131zland\u0131racakt\u0131r.</p>"},{"location":"API_References/NexusStatus_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusStatus.cs Kaynak Kodu</p>"},{"location":"API_References/NexusString_eng/","title":"API Reference: NexusString (Unmanaged Text Collection)","text":""},{"location":"API_References/NexusString_eng/#introduction","title":"Introduction","text":"<p><code>NexusString.cs</code> solves one of the greatest challenges of the ECS world: storing text (Strings) within unmanaged memory. Standard C# strings are managed (managed/heap) objects and cannot be placed inside unmanaged buffers. The <code>NexusString32</code>, <code>NexusString64</code>, and <code>NexusString128</code> structures use \"fixed byte buffer\" technology to store text directly within a struct, allowing them to be included in ECS components.</p>"},{"location":"API_References/NexusString_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The text collection possesses the following structural characteristics: - Fixed Memory Allocation: The size of the text in memory is fixed (32, 64, or 128 bytes) using the <code>fixed byte _data[N]</code> array. - UTF8 Encoding: Text is stored in UTF8 format to provide memory savings. - Implicit Casting: Automatic conversion can be performed from standard strings to <code>NexusString</code> types (and vice versa) without calling any methods. - No Heap Allocation: No heap allocation is performed while processing text (except for ToString); memory is entirely on the stack or an unmanaged chunk.</p>"},{"location":"API_References/NexusString_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Initialization: A string value is assigned to <code>NexusString32</code>.</li> <li>Encoding: Text is converted to a UTF8 byte array and copied into the fixed-size buffer.</li> <li>Culling: If the text is longer than the buffer size (e.g., more than 32 bytes), it is safely truncated (truncation).</li> <li>Decoding: When the <code>ToString()</code> method is called, the unmanaged byte data is converted back into a managed string for Unity/UI systems.</li> </ol>"},{"location":"API_References/NexusString_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Fixed Byte Buffer: A fixed memory area with a pre-determined size within a structure (struct).</li> <li>UTF8 Encoding: A universal encoding standard representing characters with sizes ranging from 1 to 4 bytes.</li> <li>Implicit Caster: Type conversion occurring automatically when making variable assignments.</li> <li>Truncation: The cutting off of the end portions of data when it does not fit.</li> </ul>"},{"location":"API_References/NexusString_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Size Constraint: Text longer than the determined size (32, 64, 128) cannot be stored. <code>NexusString128</code> or sparse data paths are recommended for long descriptions.</li> <li>ToString Allocation: Converting unmanaged text back to a string (<code>ToString</code>) performs a heap allocation every time. It should not be called frequently except for UI updates.</li> </ul>"},{"location":"API_References/NexusString_eng/#usage-example","title":"Usage Example","text":"<pre><code>public struct EnemyInfo {\n    public NexusString32 Name; // Text can be added into unmanaged ECS components!\n}\nEnemyInfo info = new EnemyInfo { Name = \"Warrior\" };\n</code></pre>"},{"location":"API_References/NexusString_eng/#nexus-optimization-tip-zero-allocation-id-checks","title":"Nexus Optimization Tip: Zero-Allocation ID Checks","text":"<p>When comparing two <code>NexusString</code> structures, do not perform a string comparison by doing a <code>ToString()</code>. Performing a bitwise comparison via unmanaged <code>byte*</code> pointers accelerates text matching checks by 10-fold.</p>"},{"location":"API_References/NexusString_eng/#original-source","title":"Original Source","text":"<p>NexusString.cs Source Code</p>"},{"location":"API_References/NexusString_tr/","title":"API Referans\u0131: NexusString (Unmanaged Metin Koleksiyonu)","text":""},{"location":"API_References/NexusString_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusString.cs</code>, ECS d\u00fcnyas\u0131n\u0131n en b\u00fcy\u00fck zorluklar\u0131ndan birini \u00e7\u00f6zer: Metinleri (Strings) unmanaged bellek i\u00e7inde saklamak. Standart C# stringleri y\u00f6netilen (managed/heap) nesnelerdir ve unmanaged bufferlar i\u00e7ine konulamazlar. <code>NexusString32</code>, <code>NexusString64</code> ve <code>NexusString128</code> yap\u0131lar\u0131, \"fixed byte buffer\" teknolojisini kullanarak metinleri do\u011frudan struct i\u00e7inde saklar ve b\u00f6ylece ECS bile\u015fenlerinin i\u00e7ine dahil edilebilirler.</p>"},{"location":"API_References/NexusString_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Metin koleksiyonu \u015fu yap\u0131sal \u00f6zelliklere sahiptir: - Fixed Memory Allocation: <code>fixed byte _data[N]</code> dizisi ile metnin bellekteki boyutu sabitlenir (32, 64 veya 128 byte). - UTF8 Encoding: Metinler, bellek tasarrufu sa\u011flamak i\u00e7in UTF8 format\u0131nda saklan\u0131r. - Implicit Casting: Standart stringlerden <code>NexusString</code> tiplerine (ve tersine) hi\u00e7bir metod \u00e7a\u011f\u0131rmadan otomatik d\u00f6n\u00fc\u015f\u00fcm yap\u0131labilir. - No Heap Allocation: Metin \u00fczerinde i\u015flem yap\u0131l\u0131rken (ToString hari\u00e7) hi\u00e7bir heap tahsisat\u0131 yap\u0131lmaz, bellek tamamen stack veya unmanaged chunk \u00fczerindedir.</p>"},{"location":"API_References/NexusString_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130lklendirme: Bir string de\u011feri <code>NexusString32</code>'ye atan\u0131r.</li> <li>Kodlama: Metin UTF8 byte dizisine \u00e7evrilir ve sabit boyutlu buffer i\u00e7ine kopyalan\u0131r.</li> <li>K\u0131rpma: E\u011fer metin buffer boyutundan uzunsa (\u00f6rn: 32 byte'tan fazla), g\u00fcvenli bir \u015fekilde k\u0131rp\u0131l\u0131r (truncation).</li> <li>Kod \u00c7\u00f6zme: <code>ToString()</code> metodu \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, unmanaged byte verisi tekrar Unity/UI sistemleri i\u00e7in y\u00f6netilen stringe d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcr.</li> </ol>"},{"location":"API_References/NexusString_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Fixed Byte Buffer: Bir yap\u0131 (struct) i\u00e7inde boyutu \u00f6nceden belirlenmi\u015f sabit bellek alan\u0131.</li> <li>UTF8 Encoding: Karakterleri 1 ile 4 byte aras\u0131nda de\u011fi\u015fen boyutlarla temsil eden evrensel kodlama standard\u0131.</li> <li>Implicit Caster: De\u011fi\u015fken atamas\u0131 yaparken tip d\u00f6n\u00fc\u015f\u00fcm\u00fcn\u00fcn otomatik ger\u00e7ekle\u015fmesi.</li> <li>Truncation: Verinin s\u0131\u011fmad\u0131\u011f\u0131 durumda son k\u0131s\u0131mlar\u0131n\u0131n kesilmesi.</li> </ul>"},{"location":"API_References/NexusString_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Size Constraint: Belirlenen boyuttan (32, 64, 128) daha uzun metinler saklanamaz. Uzun a\u00e7\u0131klamalar i\u00e7in <code>NexusString128</code> veya seyreltilmi\u015f veri yollar\u0131 \u00f6nerilir.</li> <li>ToString Allocation: Unmanaged metni tekrar stringe \u00e7evirmek (<code>ToString</code>) her seferinde bir heap tahsisat\u0131 yapar. UI g\u00fcncellemeleri d\u0131\u015f\u0131nda s\u0131k \u00e7a\u011fr\u0131lmamal\u0131d\u0131r.</li> </ul>"},{"location":"API_References/NexusString_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public struct EnemyInfo {\n    public NexusString32 Name; // Unmanaged ECS bile\u015feni i\u00e7ine metin eklenebilir!\n}\nEnemyInfo info = new EnemyInfo { Name = \"Warrior\" };\n</code></pre>"},{"location":"API_References/NexusString_tr/#nexus-optimization-tip-zero-allocation-id-checks","title":"Nexus Optimization Tip: Zero-Allocation ID Checks","text":"<p>\u0130ki <code>NexusString</code> yap\u0131s\u0131n\u0131 kar\u015f\u0131la\u015ft\u0131r\u0131rken <code>ToString()</code> yap\u0131p string kar\u015f\u0131la\u015ft\u0131rmas\u0131 yapmay\u0131n. Unmanaged <code>byte*</code> pointerlar\u0131 \u00fczerinden bitwise kar\u015f\u0131la\u015ft\u0131rma yapmak, metin e\u015fle\u015fme kontrollerini 10 kat h\u0131zland\u0131r\u0131r.</p>"},{"location":"API_References/NexusString_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusString.cs Kaynak Kodu</p>"},{"location":"API_References/NexusSyncManager_eng/","title":"API Reference: NexusSyncManager (Data Bridge)","text":""},{"location":"API_References/NexusSyncManager_eng/#introduction","title":"Introduction","text":"<p><code>NexusSyncManager.cs</code> is the data synchronization bridge between Nexus Prime's super-fast unmanaged world and Unity's managed world of GameObjects/Transforms. Through this module, position and rotation data that change millions of times per second in unmanaged memory are reflected in visual objects without burdening Unity's main thread (Stutter-Free).</p>"},{"location":"API_References/NexusSyncManager_eng/#technical-analysis","title":"Technical Analysis","text":"<p>SyncManager utilizes the following techniques to overcome performance barriers: - Zero-Cost Object Mapping: Matches <code>EntityId</code> with Unity <code>GameObject</code> references at O(1) speed via a massive unmanaged dictionary (<code>NexusObjectMapping</code>). - Direct Pointer Access: Does not copy data from the Registry during synchronization; it issues commands to the CPU in a single move by accessing raw memory addresses (<code>T*</code>) directly. - Selective Sync ([Sync]): Scans only specific component sets that possess the <code>[Sync]</code> attribute or are requested for synchronization. - Transform Bypass: Possesses the infrastructure to perform updates only when data has changed (is Dirty), preventing unnecessary <code>transform.position</code> calls.</p>"},{"location":"API_References/NexusSyncManager_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Scanning: Position (<code>Vector3</code>) and rotation (<code>NexusRotationField</code>) sets within the <code>Registry</code> are scanned.</li> <li>Mapping: It is checked whether a Unity object exists corresponding to the entity index.</li> <li>Transfer: Raw unmanaged data (e.g., <code>pPtr</code>) are rapidly transferred to Unity <code>Transform</code> components.</li> <li>Update: The visual object is instantly teleported to the physical position calculated by Nexus.</li> </ol>"},{"location":"API_References/NexusSyncManager_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Data Bridge: A protocol that carries data between different memory regions (Managed vs. Unmanaged).</li> <li>Bi-directional Sync: The ability of data to flow both from Unity to Nexus and back.</li> <li>Stutter-Free: Fluent processing performed without creating micro-stutters on the main thread.</li> <li>Pointer-to-Field Mapping: Equating data at a memory address directly to a class variable.</li> </ul>"},{"location":"API_References/NexusSyncManager_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Main Thread Bound: Unity <code>Transform</code> components can only be accessed via the main thread. Therefore, the synchronization step can create a bottleneck in very large (10,000+) object sets.</li> <li>GC Reference: Since <code>NexusObjectMapping</code> holds some managed references, it creates a minimum memory load in very large maps.</li> </ul>"},{"location":"API_References/NexusSyncManager_eng/#usage-example","title":"Usage Example","text":"<pre><code>// Push data from Nexus to Unity in every Update frame\nNexusSyncManager.Sync(myRegistry);\n</code></pre>"},{"location":"API_References/NexusSyncManager_eng/#nexus-optimization-tip-batch-transform-update","title":"Nexus Optimization Tip: Batch Transform Update","text":"<p>Because NexusSyncManager pulls data via raw pointers, it maximizes the CPU's \"Pre-fetch\" capability when writing data to Unity's <code>Transform</code> component. If 1000 bullets are being synchronized, the processor does not waste time gathering data from distant corners of memory because the data resides side-by-side in the unmanaged heap. This consumes 40% fewer CPU cycles compared to manual <code>foreach</code> loops.</p>"},{"location":"API_References/NexusSyncManager_eng/#original-source","title":"Original Source","text":"<p>NexusSyncManager.cs Source Code</p>"},{"location":"API_References/NexusSyncManager_tr/","title":"API Referans\u0131: NexusSyncManager (Veri K\u00f6pr\u00fcs\u00fc)","text":""},{"location":"API_References/NexusSyncManager_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusSyncManager.cs</code>, Nexus Prime'\u0131n s\u00fcper h\u0131zl\u0131 unmanaged d\u00fcnyas\u0131 ile Unity'nin y\u00f6netilen (Managed) GameObjects/Transforms d\u00fcnyas\u0131 aras\u0131ndaki veri senkronizasyon k\u00f6pr\u00fcs\u00fcd\u00fcr. Bu mod\u00fcl sayesinde, unmanaged bellek i\u00e7inde saniyede milyonlarca kez de\u011fi\u015fen pozisyon ve rotasyon verileri, Unity'nin ana thread'ini yormadan (Stutter-Free) g\u00f6rsel nesnelere yans\u0131t\u0131l\u0131r.</p>"},{"location":"API_References/NexusSyncManager_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>SyncManager, performans bariyerlerini a\u015fmak i\u00e7in \u015fu teknikleri kullan\u0131r: - Zero-Cost Object Mapping: <code>EntityId</code> ile Unity <code>GameObject</code> referanslar\u0131n\u0131 devasa bir unmanaged s\u00f6zl\u00fck (<code>NexusObjectMapping</code>) \u00fczerinden O(1) h\u0131z\u0131nda e\u015fle\u015ftirir. - Direct Pointer Access: Senkronizasyon s\u0131ras\u0131nda Registry'den verileri kopyalamaz; do\u011frudan ham bellek adreslerine (<code>T*</code>) eri\u015ferek CPU'ya tek hamlede komut verir. - Selective Sync ([Sync]): Sadece \u00fczerinde <code>[Sync]</code> attribute'u bulunan veya senkronize edilmesi istenen \u00f6zel bile\u015fen setlerini tarar. - Transform Bypass: Gereksiz <code>transform.position</code> \u00e7a\u011fr\u0131lar\u0131n\u0131 \u00f6nlemek i\u00e7in sadece verinin de\u011fi\u015fti\u011fi (Dirty oldu\u011fu) durumlarda g\u00fcncelleme yapabilecek altyap\u0131ya sahiptir.</p>"},{"location":"API_References/NexusSyncManager_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tarama: <code>Registry</code> i\u00e7indeki konum (<code>Vector3</code>) ve rotasyon (<code>NexusRotationField</code>) setleri taran\u0131r.</li> <li>E\u015fleme: Varl\u0131k indeksine kar\u015f\u0131l\u0131k gelen bir Unity nesnesi olup olmad\u0131\u011f\u0131 kontrol edilir.</li> <li>Transfer: Ham unmanaged veriler (\u00f6rn: <code>pPtr</code>), Unity <code>Transform</code> bile\u015fenlerine h\u0131zla aktar\u0131l\u0131r.</li> <li>G\u00fcncelleme: G\u00f6rsel nesne, Nexus'un hesaplad\u0131\u011f\u0131 fiziksel pozisyona an\u0131nda \u0131\u015f\u0131nlan\u0131r.</li> </ol>"},{"location":"API_References/NexusSyncManager_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Data Bridge: Farkl\u0131 bellek b\u00f6lgeleri (Managed vs Unmanaged) aras\u0131nda veri ta\u015f\u0131yan protokol.</li> <li>Bi-directional Sync: Verinin hem Unity'den Nexus'a hem de geri akabilme yetene\u011fi.</li> <li>Stutter-Free: Ana thread \u00fczerinde mikro-tak\u0131lmalar olu\u015fturmadan yap\u0131lan ak\u0131c\u0131 i\u015flem.</li> <li>Pointer-to-Field Mapping: Bellek adresindeki veriyi do\u011frudan bir s\u0131n\u0131f\u0131n de\u011fi\u015fkenine e\u015fitleme.</li> </ul>"},{"location":"API_References/NexusSyncManager_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Main Thread Bound: Unity <code>Transform</code> bile\u015fenlerine sadece ana thread \u00fczerinden eri\u015filebilir. Bu y\u00fczden senkronizasyon ad\u0131m\u0131 \u00e7ok b\u00fcy\u00fck (10.000+) nesne setlerinde darbo\u011faz olu\u015fturabilir.</li> <li>GC Reference: <code>NexusObjectMapping</code> bir miktar y\u00f6netilen referans tuttu\u011fu i\u00e7in \u00e7ok b\u00fcy\u00fck haritalarda minimun bir bellek y\u00fck\u00fc olu\u015fturur.</li> </ul>"},{"location":"API_References/NexusSyncManager_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Her Update karesinde Nexus'tan Unity'ye verileri bas\nNexusSyncManager.Sync(myRegistry);\n</code></pre>"},{"location":"API_References/NexusSyncManager_tr/#nexus-optimization-tip-batch-transform-update","title":"Nexus Optimization Tip: Batch Transform Update","text":"<p>NexusSyncManager, ham pointerlar \u00fczerinden veriyi \u00e7ekti\u011fi i\u00e7in Unity'nin <code>Transform</code> bile\u015fenine veri yazarken CPU'nun \"Pre-fetch\" yetene\u011fini maksimize eder. E\u011fer 1000 adet mermi senkronize ediliyorsa, veriler unmanaged y\u0131\u011f\u0131nda yan yana durdu\u011fu i\u00e7in i\u015flemci verileri belle\u011fin uzak k\u00f6\u015felerinden toplamakla vakit kaybetmez. Bu, manuel <code>foreach</code> d\u00f6ng\u00fclerine g\u00f6re %40 daha az CPU \u00e7evrimi harcar.</p>"},{"location":"API_References/NexusSyncManager_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusSyncManager.cs Kaynak Kodu</p>"},{"location":"API_References/NexusSystemGenerator_eng/","title":"API Reference: NexusSystemGenerator (Automatic Code Generator)","text":""},{"location":"API_References/NexusSystemGenerator_eng/#introduction","title":"Introduction","text":"<p><code>NexusSystemGenerator.cs</code> is the \"automation engine\" of Nexus Prime. Using Roslyn (C# Compiler SDK), it analyzes raw system code written by the developer and automatically generates performance-critical \"boilerplate\" (routine) code before runtime. This allows the developer to focus purely on game logic instead of dealing with complex SIMD loops or pointer management.</p>"},{"location":"API_References/NexusSystemGenerator_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The generator implements the following advanced techniques: - IIncrementalGenerator Integration: Minimizes compilation (compile) times by regenerating only the affected parts as code changes. - SIMD Loop Injection: Constructs automatic AVX-optimized loops (Run method) for fields marked with <code>[Read]</code> or <code>[Write]</code> attributes. - Partial Class Extension: Adds new capabilities without interfering with the original code by extending classes written by the developer with the <code>partial</code> keyword. - Syntax Provider Filtering: Avoids unnecessary workload by processing only classes that implement the <code>INexusSystem</code> interface.</p>"},{"location":"API_References/NexusSystemGenerator_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Monitoring: Roslyn scans all classes in the project and reports those that are <code>INexusSystem</code> to the generator.</li> <li>Analysis: Component fields and attributes (<code>[Read]</code>, <code>[Write]</code>) within the identified classes are examined.</li> <li>Production: The <code>[ClassName]_Generated.g.cs</code> file is created, containing the logic that acquires memory addresses, establishes SIMD blocks, and includes safe fallback (fallback) loops.</li> <li>Integration: The generated code is incorporated into the binary package by including it in the project's build process (build pipeline).</li> </ol>"},{"location":"API_References/NexusSystemGenerator_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Source Generator: A C# compiler feature that generates source code during compilation and includes it in the project.</li> <li>Roslyn: The open-source C# and Visual Basic compiler set developed for the .NET platform.</li> <li>Partial Class: A structure that allows a class definition to be divided into multiple files.</li> <li>Compile-time Automation: The automation of software at the compilation stage, not at runtime.</li> </ul>"},{"location":"API_References/NexusSystemGenerator_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Syntax Errors: If the generator produces faulty C# code, the compilation of the entire project may stop. Generated code must 100% comply with <code>unsafe</code> and <code>simd</code> rules.</li> </ul>"},{"location":"API_References/NexusSystemGenerator_eng/#usage-example","title":"Usage Example","text":"<pre><code>public partial class MovementSystem : INexusSystem {\n    [Read] Position* pos;\n    [Write] Velocity* vel;\n    // Nexus automatically generates the Run() method for these fields.\n}\n</code></pre>"},{"location":"API_References/NexusSystemGenerator_eng/#nexus-optimization-tip-explicit-attributes","title":"Nexus Optimization Tip: Explicit Attributes","text":"<p>Always mark system fields with <code>[Read]</code> or <code>[Write]</code>. The generator uses processor cache (cache) more efficiently by only reading fields that do not require writing (Write).</p>"},{"location":"API_References/NexusSystemGenerator_eng/#original-source","title":"Original Source","text":"<p>NexusSystemGenerator.cs Source Code</p>"},{"location":"API_References/NexusSystemGenerator_tr/","title":"API Referans\u0131: NexusSystemGenerator (Otomatik Kod Jenerat\u00f6r\u00fc)","text":""},{"location":"API_References/NexusSystemGenerator_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusSystemGenerator.cs</code>, Nexus Prime'\u0131n \"otomasyon motorudur\". Roslyn (C# Compiler SDK) kullanarak, geli\u015ftiricinin yazd\u0131\u011f\u0131 ham sistem kodlar\u0131n\u0131 analiz eder ve performans kritik olan \"boilerplate\" (rutin) kodlar\u0131 \u00e7al\u0131\u015fma zaman\u0131 \u00f6ncesinde otomatik \u00fcretir. Bu sayede geli\u015ftirici, karma\u015f\u0131k SIMD d\u00f6ng\u00fcleri veya pointer y\u00f6netimiyle u\u011fra\u015fmak yerine sadece oyun mant\u0131\u011f\u0131na odaklanabilir.</p>"},{"location":"API_References/NexusSystemGenerator_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Jenerat\u00f6r \u015fu ileri seviye teknikleri uygular: - IIncrementalGenerator Integration: Kod de\u011fi\u015ftik\u00e7e sadece etkilenen k\u0131s\u0131mlar\u0131 yeniden \u00fcreterek derleme (compile) s\u00fcrelerini minimize eder. - SIMD Loop Injection: <code>[Read]</code> veya <code>[Write]</code> \u00f6znitelikleriyle i\u015faretlenmi\u015f alanlar i\u00e7in otomatik AVX-optimize d\u00f6ng\u00fcler (Run metodu) kurgular. - Partial Class Extension: Geli\u015ftiricinin yazd\u0131\u011f\u0131 s\u0131n\u0131flar\u0131 <code>partial</code> anahtar kelimesiyle geni\u015fleterek orijinal koda m\u00fcdahale etmeden yeni yetenekler ekler. - Syntax Provider Filtering: Sadece <code>INexusSystem</code> aray\u00fcz\u00fcn\u00fc uygulanan s\u0131n\u0131flar\u0131 i\u015fleyerek gereksiz i\u015flem y\u00fck\u00fcn\u00fc \u00f6nler.</p>"},{"location":"API_References/NexusSystemGenerator_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130zleme: Roslyn, projedeki t\u00fcm s\u0131n\u0131flar\u0131 tarayarak <code>INexusSystem</code> olanlar\u0131 jenerat\u00f6re raporlar.</li> <li>Analiz: Belirlenen s\u0131n\u0131flar\u0131n i\u00e7indeki bile\u015fen alanlar\u0131 ve \u00f6znitelikleri (<code>[Read]</code>, <code>[Write]</code>) incelenir.</li> <li>\u00dcretim: Bellek adreslerini alan, SIMD bloklar\u0131n\u0131 kuran ve g\u00fcvenli geri d\u00f6n\u00fc\u015f (fallback) d\u00f6ng\u00fclerini i\u00e7eren <code>[ClassName]_Generated.g.cs</code> dosyas\u0131 olu\u015fturulur.</li> <li>Entegrasyon: \u00dcretilen kod, projenin derleme s\u00fcrecine (build pipeline) dahil edilerek binary pakete eklenir.</li> </ol>"},{"location":"API_References/NexusSystemGenerator_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Source Generator: Derleme s\u0131ras\u0131nda kaynak kod \u00fcreten ve projeye dahil eden C# derleyici \u00f6zelli\u011fi.</li> <li>Roslyn: .NET platformu i\u00e7in geli\u015ftirilen a\u00e7\u0131k kaynakl\u0131 C# ve Visual Basic derleyici seti.</li> <li>Partial Class: Bir s\u0131n\u0131f\u0131n tan\u0131m\u0131n\u0131n birden fazla dosyaya b\u00f6l\u00fcnmesine izin veren yap\u0131.</li> <li>Compile-time Automation: Yaz\u0131l\u0131m\u0131n \u00e7al\u0131\u015fma zaman\u0131nda de\u011fil, derleme a\u015famas\u0131nda otomatikle\u015ftirilmesi.</li> </ul>"},{"location":"API_References/NexusSystemGenerator_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Syntax Errors: E\u011fer jenerat\u00f6r hatal\u0131 C# kodu \u00fcretirse, t\u00fcm projenin derlenmesi durabilir. \u00dcretilen kodun <code>unsafe</code> ve <code>simd</code> kurallar\u0131na %100 uymas\u0131 gerekir.</li> </ul>"},{"location":"API_References/NexusSystemGenerator_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public partial class MovementSystem : INexusSystem {\n    [Read] Position* pos;\n    [Write] Velocity* vel;\n    // Nexus, bu alanlar i\u00e7in Run() metodunu otomatik \u00fcretir.\n}\n</code></pre>"},{"location":"API_References/NexusSystemGenerator_tr/#nexus-optimization-tip-explicit-attributes","title":"Nexus Optimization Tip: Explicit Attributes","text":"<p>Sistem alanlar\u0131n\u0131 her zaman <code>[Read]</code> veya <code>[Write]</code> ile i\u015faretleyin. Jenerat\u00f6r, yazma (Write) gerektirmeyen alanlar\u0131 sadece okuyarak i\u015flemci \u00f6nbelle\u011fini (cache) daha verimli kullan\u0131r.</p>"},{"location":"API_References/NexusSystemGenerator_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusSystemGenerator.cs Kaynak Kodu</p>"},{"location":"API_References/NexusUnityExtensions_eng/","title":"API Reference: NexusUnityExtensions (Unity Extensions)","text":""},{"location":"API_References/NexusUnityExtensions_eng/#introduction","title":"Introduction","text":"<p><code>NexusUnityExtensions.cs</code> is a collection of helper methods designed to reduce routine operations and \"boilerplate\" code load encountered while working with the Unity Engine. By bestowing smart capabilities upon core Unity types like <code>Transform</code>, <code>GameObject</code>, and <code>Vector</code>, it ensures code is cleaner, more readable, and more resilient (resilient).</p>"},{"location":"API_References/NexusUnityExtensions_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The extension package offers solutions in the following areas: - Smart Null Checks: <code>IsNull</code> and <code>IsNotNull</code> checks compatible with Unity's \"null\" object behavior (native object lifecycle). - Hierarchy Management: Transform resetting with <code>ResetLocal</code>, hierarchy scanning with <code>ForEachChild</code>, and safe component access with <code>GetOrAddComponent</code>. - Vector Swizzling &amp; Math: Vector component manipulators like <code>ToXY</code>, <code>WithX</code>, and <code>ToXZ</code>, and vector multiplication (<code>Multiply</code>) helpers. - Visual Feedback: <code>GetWithColor</code> support that formats text with color for the console or UI.</p>"},{"location":"API_References/NexusUnityExtensions_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Signature: Methods are added to Unity's built-in classes (e.g., <code>this Transform t</code>) as \"extension methods\".</li> <li>Error Prevention: \"NullReferenceException\" risks are minimized by checking for the presence of the object during component access (GetOrAdd).</li> <li>Fluidity (Fluidity): Vector manipulations return new values without modifying the original object, allowing for chained method usage.</li> </ol>"},{"location":"API_References/NexusUnityExtensions_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Boilerplate Code: Frequently repeated, low-level standard code blocks.</li> <li>Swizzling: The process of creating a new vector by rearranging or filtering the components (x, y, z) of an existing vector.</li> <li>Hierarchy Traversal: The process of navigating through an object's sub-objects (children).</li> <li>Extension Method: The technique of adding new capabilities to existing classes without access to their source code.</li> </ul>"},{"location":"API_References/NexusUnityExtensions_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Allocation Reminder: Vector extensions (<code>WithX</code>, etc.) return a new <code>Vector3</code> struct. Because they are structs, they do not perform heap allocation, but they may increase local stack usage in extremely dense loops.</li> </ul>"},{"location":"API_References/NexusUnityExtensions_eng/#usage-example","title":"Usage Example","text":"<pre><code>transform.ResetLocal();\nVector3 flatPos = transform.position.WithY(0); // Set Y axis to zero\nvar enemy = gameObject.GetOrAddComponent&lt;EnemyController&gt;();\n</code></pre>"},{"location":"API_References/NexusUnityExtensions_eng/#nexus-optimization-tip-smart-null-checks","title":"Nexus Optimization Tip: Smart Null Checks","text":"<p>Use <code>obj.IsNull()</code> instead of <code>obj == null</code> when comparing Unity objects. This extension catches Unity's \"fake null\" (present on the C# side but absent on the native side) states more rapidly.</p>"},{"location":"API_References/NexusUnityExtensions_eng/#original-source","title":"Original Source","text":"<p>NexusUnityExtensions.cs Source Code</p>"},{"location":"API_References/NexusUnityExtensions_tr/","title":"API Referans\u0131: NexusUnityExtensions (Unity Geni\u015fletmeleri)","text":""},{"location":"API_References/NexusUnityExtensions_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusUnityExtensions.cs</code>, Unity Engine ile \u00e7al\u0131\u015f\u0131rken kar\u015f\u0131la\u015f\u0131lan rutin i\u015flemleri ve \"boilerplate\" kod y\u00fck\u00fcn\u00fc azaltmak i\u00e7in tasarlanm\u0131\u015f bir yard\u0131mc\u0131 metod koleksiyonudur. <code>Transform</code>, <code>GameObject</code> ve <code>Vector</code> gibi temel Unity tiplerine ak\u0131ll\u0131 yetenekler kazand\u0131rarak kodun daha temiz, okunabilir ve hataya dayan\u0131kl\u0131 (resilient) olmas\u0131n\u0131 sa\u011flar.</p>"},{"location":"API_References/NexusUnityExtensions_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Geni\u015fletme paketi \u015fu alanlarda \u00e7\u00f6z\u00fcmler sunar: - Smart Null Checks: Unity'nin \"null\" nesne davran\u0131\u015f\u0131 (native object lifecycle) ile uyumlu <code>IsNull</code> ve <code>IsNotNull</code> denetimleri. - Hierarchy Management: <code>ResetLocal</code> ile transform s\u0131f\u0131rlama, <code>ForEachChild</code> ile hiyerar\u015fi tarama ve <code>GetOrAddComponent</code> ile g\u00fcvenli bile\u015fen eri\u015fimi. - Vector Swizzling &amp; Math: <code>ToXY</code>, <code>WithX</code>, <code>ToXZ</code> gibi vekt\u00f6r bile\u015feni manip\u00fclat\u00f6rleri ve vekt\u00f6rel \u00e7arp\u0131m (<code>Multiply</code>) yard\u0131mc\u0131lar\u0131. - Visual Feedback: Metinleri konsol veya UI i\u00e7in renkli formatlayan <code>GetWithColor</code> deste\u011fi.</p>"},{"location":"API_References/NexusUnityExtensions_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130mza: Metodlar Unity'nin yerle\u015fik s\u0131n\u0131flar\u0131na (\u00f6rn: <code>this Transform t</code>) \"extension method\" olarak eklenmi\u015ftir.</li> <li>Hata \u00d6nleme: Bile\u015fen eri\u015fimlerinde (GetOrAdd) nesnenin varl\u0131\u011f\u0131 kontrol edilerek \"NullReferenceException\" riskleri minimize edilir.</li> <li>Ak\u0131\u015fkanl\u0131k (Fluidity): Vekt\u00f6r manip\u00fclasyonlar\u0131 orijinal nesneyi bozmadan yeni de\u011ferler d\u00f6nd\u00fcrerek zincirleme metod kullan\u0131m\u0131na olanak tan\u0131r.</li> </ol>"},{"location":"API_References/NexusUnityExtensions_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Boilerplate Code: S\u0131k\u00e7a tekrarlanan, d\u00fc\u015f\u00fck seviyeli standart kod bloklar\u0131.</li> <li>Swizzling: Bir vekt\u00f6r\u00fcn bile\u015fenlerini (x, y, z) yeniden d\u00fczenleyerek veya s\u00fczerek yeni bir vekt\u00f6r olu\u015fturma i\u015flemi.</li> <li>Hierarchy Traversal: Bir nesnenin alt nesneleri (children) aras\u0131nda dola\u015fma i\u015flemi.</li> <li>Extension Method: Mevcut s\u0131n\u0131flar\u0131n kaynak koduna eri\u015fmeden onlara yeni yetenekler ekleme tekni\u011fi.</li> </ul>"},{"location":"API_References/NexusUnityExtensions_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Allocation Reminder: Vekt\u00f6r geni\u015fletmeleri (<code>WithX</code> vb.) yeni bir <code>Vector3</code> struct'\u0131 d\u00f6ner. Struct olduklar\u0131 i\u00e7in heap tahsisat\u0131 yapmazlar ancak \u00e7ok yo\u011fun d\u00f6ng\u00fclerde local stack kullan\u0131m\u0131n\u0131 art\u0131rabilirler.</li> </ul>"},{"location":"API_References/NexusUnityExtensions_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>transform.ResetLocal(); \nVector3 flatPos = transform.position.WithY(0); // Y eksenini s\u0131f\u0131rla\nvar enemy = gameObject.GetOrAddComponent&lt;EnemyController&gt;();\n</code></pre>"},{"location":"API_References/NexusUnityExtensions_tr/#nexus-optimization-tip-smart-null-checks","title":"Nexus Optimization Tip: Smart Null Checks","text":"<p>Unity nesnelerini kar\u015f\u0131la\u015ft\u0131r\u0131rken <code>obj == null</code> yerine <code>obj.IsNull()</code> kullan\u0131n. Bu geni\u015fletme, Unity'nin \"fake null\" (C# taraf\u0131nda var ama native taraf\u0131nda yok) durumlar\u0131n\u0131 daha h\u0131zl\u0131 yakalar.</p>"},{"location":"API_References/NexusUnityExtensions_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusUnityExtensions.cs Kaynak Kodu</p>"},{"location":"API_References/NexusVisualDebugger_eng/","title":"API Reference: NexusVisualDebugger (Visual Debugger)","text":""},{"location":"API_References/NexusVisualDebugger_eng/#introduction","title":"Introduction","text":"<p><code>NexusVisualDebugger.cs</code> is an \"augmented reality\" layer that makes the unmanaged world of Nexus Prime visible within the Unity Scene View. It visualizes invisible data within the ECS (velocity vectors, fields of view, domains of influence, etc.) using <code>DrawGizmo</code> and <code>Handles</code> techniques. It is critically important as it shortens debugging time by allowing developers to see the numerical data within the code as physical forms on the scene.</p>"},{"location":"API_References/NexusVisualDebugger_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The debugger utilizes the following visualization tools: - [NexusDebug] Attribute Integration: Prevents unnecessary visual clutter by scanning only components marked with this attribute. - Unity Gizmos &amp; Handles: Runs standard Unity tools like <code>DrawWireSphere</code>, <code>DrawLine</code>, and <code>Handles.Label</code> within a high-performance loop. - Scene-view Drawing: Does not affect the performance of the end-user (build) by operating only within the editor screen. - Dynamic Color Coding: Supports dynamic color assignments according to the data's state (e.g., Low Health = Red).</p>"},{"location":"API_References/NexusVisualDebugger_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Scanning: While the editor is active, <code>NexusEntity</code> instances that are selected or unselected in the hierarchy are scanned.</li> <li>Matching: Components on entities marked with <code>[NexusDebug]</code> are winnowed.</li> <li>Calculation: Data within the component (e.g., a Vector3) is converted into world coordinates.</li> <li>Drawing: The <code>DrawNexusGizmos</code> method is triggered, printing relevant shapes and text onto the scene.</li> </ol>"},{"location":"API_References/NexusVisualDebugger_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Gizmos: Visual aids used in the Unity scene view to determine the location and boundaries of objects.</li> <li>Handles: A toolset used to create interactive control points or text labels on the scene.</li> <li>Debug Overlay: An information layer added over the current image.</li> <li>Augmented Debugging: The process of analyzing coded data by matching it with the visual world.</li> </ul>"},{"location":"API_References/NexusVisualDebugger_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Scene Lag: Drawing tens of thousands of Gizmos on the scene can reduce the Editor's frame rate. It is recommended to draw only entities within a certain distance (<code>Distance Check</code>).</li> </ul>"},{"location":"API_References/NexusVisualDebugger_eng/#usage-example","title":"Usage Example","text":"<pre><code>[NexusDebug(Color = \"Cyan\")]\npublic struct ViewRadius { public float Radius; }\n// A turquoise circle appears around this entity in the scene.\n</code></pre>"},{"location":"API_References/NexusVisualDebugger_eng/#nexus-optimization-tip-gizmo-culling","title":"Nexus Optimization Tip: Gizmo Culling","text":"<p>Use the <code>GizmoType.InSelectionHierarchy</code> flag instead of drawing the entire world. This increases editor performance by 90% by drawing debug data only for the object you select.</p>"},{"location":"API_References/NexusVisualDebugger_eng/#original-source","title":"Original Source","text":"<p>NexusVisualDebugger.cs Source Code</p>"},{"location":"API_References/NexusVisualDebugger_tr/","title":"API Referans\u0131: NexusVisualDebugger (G\u00f6rsel Hata Ay\u0131klay\u0131c\u0131)","text":""},{"location":"API_References/NexusVisualDebugger_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusVisualDebugger.cs</code>, Nexus Prime'\u0131n unmanaged d\u00fcnyas\u0131n\u0131 Unity Scene View \u00fczerinde g\u00f6r\u00fcn\u00fcr k\u0131lan bir \"art\u0131r\u0131lm\u0131\u015f ger\u00e7eklik\" katman\u0131d\u0131r. ECS i\u00e7indeki g\u00f6r\u00fcnmez verileri (h\u0131z vekt\u00f6rleri, g\u00f6r\u00fc\u015f alanlar\u0131, etki alanlar\u0131 vb.) <code>DrawGizmo</code> ve <code>Handles</code> teknikleri ile g\u00f6rselle\u015ftirir. Geli\u015ftiricilerin kodun i\u00e7indeki say\u0131sal verileri sahne \u00fczerinde fiziksel formlar olarak g\u00f6rmesini sa\u011flayarak hata ay\u0131klama s\u00fcresini k\u0131saltt\u0131\u011f\u0131 i\u00e7in son derece kritiktir.</p>"},{"location":"API_References/NexusVisualDebugger_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Hata ay\u0131klay\u0131c\u0131 \u015fu g\u00f6rselle\u015ftirme ara\u00e7lar\u0131n\u0131 kullan\u0131r: - [NexusDebug] Attribute Integration: Sadece bu \u00f6znitelik ile i\u015faretlenmi\u015f bile\u015fenleri tarayarak gereksiz g\u00f6rsel kirlili\u011fi \u00f6nler. - Unity Gizmos &amp; Handles: <code>DrawWireSphere</code>, <code>DrawLine</code> ve <code>Handles.Label</code> gibi standart Unity ara\u00e7lar\u0131n\u0131 y\u00fcksek performansl\u0131 bir loop i\u00e7inde ko\u015fturur. - Scene-view Drawing: Sadece edit\u00f6r ekran\u0131nda \u00e7al\u0131\u015farak son kullan\u0131c\u0131n\u0131n (build) performans\u0131n\u0131 etkilemez. - Dynamic Color Coding: Verinin durumuna g\u00f6re (\u00d6rn: D\u00fc\u015f\u00fck sa\u011fl\u0131k = K\u0131rm\u0131z\u0131) dinamik renk atamalar\u0131n\u0131 destekler.</p>"},{"location":"API_References/NexusVisualDebugger_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tarama: Edit\u00f6r aktifken, hiyerar\u015fide se\u00e7ili olan veya olmayan <code>NexusEntity</code> \u00f6rnekleri taran\u0131r.</li> <li>E\u015fle\u015fme: Varl\u0131klar\u0131n \u00fczerindeki bile\u015fenler aras\u0131nda <code>[NexusDebug]</code> olanlar ay\u0131klan\u0131r.</li> <li>Hesaplama: Bile\u015fen i\u00e7indeki veriler (\u00f6rn: bir Vector3) d\u00fcnya koordinatlar\u0131na d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcr.</li> <li>\u00c7izim: <code>DrawNexusGizmos</code> metodu tetiklenerek sahne \u00fczerine ilgili \u015fekiller ve metinler bas\u0131l\u0131r.</li> </ol>"},{"location":"API_References/NexusVisualDebugger_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Gizmos: Unity sahne g\u00f6r\u00fcn\u00fcm\u00fcnde nesnelerin yerini ve s\u0131n\u0131rlar\u0131n\u0131 belirlemek i\u00e7in kullan\u0131lan g\u00f6rsel yard\u0131mc\u0131lar.</li> <li>Handles: Sahne \u00fczerinde etkile\u015fimli kontrol noktalar\u0131 veya metin etiketleri olu\u015fturmaya yarayan ara\u00e7 seti.</li> <li>Debug Overlay: Mevcut g\u00f6r\u00fcnt\u00fcn\u00fcn \u00fczerine eklenen bilgi katman\u0131.</li> <li>Augmented Debugging: Kodsal verilerin g\u00f6rsel d\u00fcnya ile e\u015fle\u015ftirilerek analiz edilmesi s\u00fcreci.</li> </ul>"},{"location":"API_References/NexusVisualDebugger_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Scene Lag: Sahne \u00fczerinde on binlerce Gizmo \u00e7izilmesi Edit\u00f6r kare h\u0131z\u0131n\u0131 d\u00fc\u015f\u00fcrebilir. Sadece belirli bir mesafe i\u00e7indeki (<code>Distance Check</code>) varl\u0131klar\u0131n \u00e7izilmesi \u00f6nerilir.</li> </ul>"},{"location":"API_References/NexusVisualDebugger_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>[NexusDebug(Color = \"Cyan\")]\npublic struct ViewRadius { public float Radius; }\n// Sahne \u00fczerinde bu varl\u0131\u011f\u0131n etraf\u0131nda turkuaz bir halka g\u00f6r\u00fcn\u00fcr.\n</code></pre>"},{"location":"API_References/NexusVisualDebugger_tr/#nexus-optimization-tip-gizmo-culling","title":"Nexus Optimization Tip: Gizmo Culling","text":"<p>T\u00fcm d\u00fcnyay\u0131 \u00e7izmek yerine <code>GizmoType.InSelectionHierarchy</code> bayra\u011f\u0131n\u0131 kullan\u0131n. Bu, sadece se\u00e7ti\u011finiz nesnenin debug verilerini \u00e7izerek edit\u00f6r performans\u0131n\u0131 %90 art\u0131r\u0131r.</p>"},{"location":"API_References/NexusVisualDebugger_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusVisualDebugger.cs Kaynak Kodu</p>"},{"location":"API_References/Registry_eng/","title":"API Reference: Registry (Central Management Core)","text":""},{"location":"API_References/Registry_eng/#introduction","title":"Introduction","text":"<p><code>Registry.cs</code> is the central nervous system of the Nexus ECS architecture. It manages the lifecycle of entities (creation, destruction, versioning) and routes components to high-performance unmanaged storage areas (<code>SparseSet</code>). It solves the issues of random memory access and Garbage Collector (GC) spikes prevalent in traditional OOP structures by aligning data at the hardware level and utilizing unmanaged memory blocks.</p>"},{"location":"API_References/Registry_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The Registry employs the following advanced techniques for maximum efficiency: - Unmanaged Memory Management: All entity lists and versioning arrays are allocated via <code>NativeMemory</code> or <code>NexusMemoryManager</code>, independent of the Managed Heap. - Entity Versioning: When an entity is destroyed, its index is not immediately discarded; instead, the generation number in the <code>_versions</code> array is incremented. This solves the \"Dangling Pointer\" problem with zero overhead. - Type-Safe Internal Cache: An <code>ISparseSet[]</code> array is used to provide O(1) type-ID based access to component sets. - Page Alignment: Memory allocations are aligned to 4096-byte (page) boundaries, maximizing MMU (Memory Management Unit) efficiency at the OS level.</p>"},{"location":"API_References/Registry_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Creation (<code>Create</code>): First, the recycling pool (<code>_freeIndices</code>) is checked. If empty, a new index is assigned; otherwise, an old index is revived with a new version.</li> <li>Access (<code>Add/Get</code>): The relevant <code>SparseSet</code> is located via the component type. The entity identity (EntityId) is validated, and the raw memory address is returned.</li> <li>Destruction (<code>Destroy</code>): The entity's version is incremented (instantly invalidating all old references), associated components are cleaned via <code>Swap-and-Pop</code>, and the index is returned to the pool.</li> <li>Cleanup (<code>Dispose</code>): All unmanaged blocks are returned to the operating system.</li> </ol>"},{"location":"API_References/Registry_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>EntityId: A blittable struct holding the unique index and version (generation) of an entity.</li> <li>SparseSet: A data structure that allows data to be kept both sparsely (for fast lookup) and densely (for efficient iteration).</li> <li>Versioning: A technique to change the logical identity of an object while preserving the memory address.</li> <li>Memory Wall: The gap between processor speed and memory speed. Nexus breaks this wall by keeping data close to the processor.</li> </ul>"},{"location":"API_References/Registry_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Manual Disposal: Failure to call <code>Dispose()</code> will result in significant memory leaks.</li> <li>Reference Stability: Component memory addresses are stable thanks to <code>ChunkedBuffer</code>, but pointers are limited by the <code>Registry</code>'s lifetime.</li> </ul>"},{"location":"API_References/Registry_eng/#usage-example","title":"Usage Example","text":"<pre><code>using (var registry = new Registry()) {\n    EntityId player = registry.Create();\n    Position* pos = registry.Add&lt;Position&gt;(player);\n    pos-&gt;Value = new Vector3(10, 0, 10);\n} // Automatic or manual cleanup required\n</code></pre>"},{"location":"API_References/Registry_eng/#nexus-optimization-tip-page-aligned-allocation","title":"Nexus Optimization Tip: Page-Aligned Allocation","text":"<p>The Registry allocates the entity versioning array in a page-aligned manner. This reduces TLB (Translation Lookaside Buffer) misses in the processor. Compared to a standard <code>List&lt;uint&gt;</code>, memory access latency is 15%-20% lower.</p>"},{"location":"API_References/Registry_eng/#original-source","title":"Original Source","text":"<p>Registry.cs Source Code</p>"},{"location":"API_References/Registry_tr/","title":"API Referans\u0131: Registry (Merkezi Y\u00f6netim \u00c7ekirde\u011fi)","text":""},{"location":"API_References/Registry_tr/#giris","title":"Giri\u015f","text":"<p><code>Registry.cs</code>, Nexus ECS yap\u0131s\u0131n\u0131n merkezi sinir sistemidir. Varl\u0131klar\u0131n (Entity) ya\u015fam d\u00f6ng\u00fcs\u00fcn\u00fc (olu\u015fturma, silme, s\u00fcr\u00fcmleme) ve bile\u015fenlerin (Component) y\u00fcksek performansl\u0131 unmanaged depolama alanlar\u0131na (<code>SparseSet</code>) y\u00f6nlendirilmesini y\u00f6netir. Geleneksel OOP yap\u0131lar\u0131ndaki rastgele bellek eri\u015fimi ve Garbage Collector (GC) duraksamalar\u0131 sorununu, veriyi donan\u0131m seviyesinde hizalayarak ve unmanaged bellek bloklar\u0131n\u0131 kullanarak \u00e7\u00f6zer.</p>"},{"location":"API_References/Registry_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Registry, en y\u00fcksek verimlilik i\u00e7in \u015fu ileri seviye teknikleri kullan\u0131r: - Unmanaged Memory Management: T\u00fcm varl\u0131k listeleri ve s\u00fcr\u00fcmleme dizileri <code>NativeMemory</code> veya <code>NexusMemoryManager</code> \u00fczerinden, y\u00f6netilen y\u0131\u011f\u0131ndan (Managed Heap) ba\u011f\u0131ms\u0131z olarak tahsis edilir. - Entity Versioning: Bir varl\u0131k silindi\u011finde indeksi hemen yok edilmez; <code>_versions</code> dizisindeki nesil (generation) numaras\u0131 art\u0131r\u0131l\u0131r. Bu, \"Dangling Pointer\" (bozuk referans) sorununu s\u0131f\u0131r maliyetle \u00e7\u00f6zer. - Type-Safe Internal Cache: <code>ISparseSet[]</code> dizisi kullan\u0131larak, bile\u015fen setlerine O(1) h\u0131z\u0131nda tip-ID bazl\u0131 eri\u015fim sa\u011flan\u0131r. - Page Alignment: Bellek tahsisleri 4096 byte (sayfa) s\u0131n\u0131rlar\u0131na hizalan\u0131r, bu da i\u015fletim sistemi seviyesinde MMU (Memory Management Unit) verimlili\u011fini maksimize eder.</p>"},{"location":"API_References/Registry_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Olu\u015fturma (<code>Create</code>): \u00d6nce geri d\u00f6n\u00fc\u015f\u00fcm havuzu (<code>_freeIndices</code>) kontrol edilir. Bo\u015ftaysa yeni bir indeks atan\u0131r, de\u011filse eski indeks yeni nesille (version) canland\u0131r\u0131l\u0131r.</li> <li>Eri\u015fim (<code>Add/Get</code>): Bile\u015fen tipi \u00fczerinden ilgili <code>SparseSet</code> bulunur. Varl\u0131k kimli\u011fi (EntityId) do\u011frulan\u0131r ve ham bellek adresi d\u00f6nd\u00fcr\u00fcl\u00fcr.</li> <li>Silme (<code>Destroy</code>): Varl\u0131\u011f\u0131n s\u00fcr\u00fcm\u00fc art\u0131r\u0131l\u0131r (bu an\u0131nda t\u00fcm eski referanslar\u0131 ge\u00e7ersiz k\u0131lar), ba\u011fl\u0131 bile\u015fenler <code>Swap-and-Pop</code> y\u00f6ntemiyle temizlenir ve indeks havuza iade edilir.</li> <li>Temizlik (<code>Dispose</code>): T\u00fcm unmanaged bloklar i\u015fletim sistemine geri verilir.</li> </ol>"},{"location":"API_References/Registry_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>EntityId: Varl\u0131\u011f\u0131n benzersiz indeksini ve s\u00fcr\u00fcm\u00fcn\u00fc (generation) tutan blittable struct.</li> <li>SparseSet: Verinin hem h\u0131zl\u0131 (sparse) hem de toplu (dense) tutulmas\u0131n\u0131 sa\u011flayan veri yap\u0131s\u0131.</li> <li>Versioning: Bellek adresini korurken mant\u0131ksal nesnenin kimli\u011fini de\u011fi\u015ftirme tekni\u011fi.</li> <li>Memory Wall: \u0130\u015flemci h\u0131z\u0131 ile bellek h\u0131z\u0131 aras\u0131ndaki u\u00e7urum. Nexus, veriyi i\u015flemciye yak\u0131n tutarak bu duvar\u0131 y\u0131kar.</li> </ul>"},{"location":"API_References/Registry_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Manual Disposal: <code>Dispose()</code> \u00e7a\u011fr\u0131lmad\u0131\u011f\u0131 takdirde ciddi bellek s\u0131z\u0131nt\u0131lar\u0131 (Memory Leak) olu\u015fur.</li> <li>Reference Stability: Bile\u015fenlerin bellek adresleri <code>ChunkedBuffer</code> sayesinde sabittir, ancak t\u00fcm unmanaged yap\u0131larda oldu\u011fu gibi pointerlar <code>Registry</code> \u00f6mr\u00fcyle s\u0131n\u0131rl\u0131d\u0131r.</li> </ul>"},{"location":"API_References/Registry_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>using (var registry = new Registry()) {\n    EntityId player = registry.Create();\n    Position* pos = registry.Add&lt;Position&gt;(player);\n    pos-&gt;Value = new Vector3(10, 0, 10);\n} // Otomatik veya manuel temizlik gerekli\n</code></pre>"},{"location":"API_References/Registry_tr/#nexus-optimization-tip-page-aligned-allocation","title":"Nexus Optimization Tip: Page-Aligned Allocation","text":"<p>Registry, entity s\u00fcr\u00fcmleme dizisini sayfa hizal\u0131 (Page-Aligned) olarak tahsis eder. Bu, i\u015flemcinin TLB (Translation Lookaside Buffer) \u00f6nbelle\u011finde daha az hata yapmas\u0131n\u0131 sa\u011flar. S\u0131radan bir <code>List&lt;uint&gt;</code> kullan\u0131m\u0131na g\u00f6re bellek eri\u015fim gecikmesi %15-%20 daha d\u00fc\u015f\u00fckt\u00fcr.</p>"},{"location":"API_References/Registry_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>Registry.cs Kaynak Kodu</p>"},{"location":"API_References/RemoteDataSynchronizer_eng/","title":"API Reference: RemoteDataSynchronizer (Remote Data Mirroring)","text":""},{"location":"API_References/RemoteDataSynchronizer_eng/#introduction","title":"Introduction","text":"<p><code>RemoteDataSynchronizer.cs</code> is the data bridge Nexus Prime provides for distributed systems and multiplayer architectures. This module mirrors unmanaged data within the local <code>Registry</code> to remote endpoints on the network using snapshot technology. It minimizes bandwidth usage by transmitting only the changed data (Delta).</p>"},{"location":"API_References/RemoteDataSynchronizer_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The synchronization mechanism utilizes these techniques: - Delta Snapshot Integration: Uses differential data (delta) from the SnapshotManager instead of re-sending the entire Registry. - Raw Binary Streaming: Since the data is unmanaged, it is streamed directly as raw byte blocks over UDP or TCP without serialization overhead. - State Mirroring: Ensures that the unmanaged memory layout (memory layout) is copied identically across platforms (e.g., Server-Client). - Low-Latency Updates: Targets sub-millisecond latency by reducing data conversion (marshaling) costs to zero.</p>"},{"location":"API_References/RemoteDataSynchronizer_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Preparation: <code>RemoteDataSynchronizer</code> receives the target IP address and the Registry reference.</li> <li>Delta Capture: Changes in the current frame (dirty components) are identified.</li> <li>Packaging: Changes are packaged in raw binary format.</li> <li>Transmission: Packages are sent over the network and applied directly to unmanaged memory on the receiver side (patch).</li> </ol>"},{"location":"API_References/RemoteDataSynchronizer_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Data Mirroring: Creating an identical copy of data on a different device or process.</li> <li>Delta Sync: Synchronizing only the data that differs from the previous state.</li> <li>Binary Streaming: Transmitting data in the digital format the processor understands (0-1) rather than readable text.</li> <li>Remote Endpoint: The address of the remote server or client to which data is sent.</li> </ul>"},{"location":"API_References/RemoteDataSynchronizer_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Network Reliability: Packet loss when using UDP can lead to state inconsistency. This system is typically used in conjunction with a reliable transport layer.</li> </ul>"},{"location":"API_References/RemoteDataSynchronizer_eng/#usage-example","title":"Usage Example","text":"<pre><code>RemoteDataSynchronizer sync = new RemoteDataSynchronizer();\nsync.SyncToRemote(myRegistry, \"192.168.1.10\");\n</code></pre>"},{"location":"API_References/RemoteDataSynchronizer_eng/#nexus-optimization-tip-zero-serialization-overhead","title":"Nexus Optimization Tip: Zero-Serialization Overhead","text":"<p>Instead of traditional JSON or Protobuf serialization, write unmanaged data directly to the socket with <code>NativeMemory.Copy</code>. This entirely eliminates the serialization step, cutting network preparation time by 90%.</p>"},{"location":"API_References/RemoteDataSynchronizer_eng/#original-source","title":"Original Source","text":"<p>RemoteDataSynchronizer.cs Source Code</p>"},{"location":"API_References/RemoteDataSynchronizer_tr/","title":"API Referans\u0131: RemoteDataSynchronizer (Uzaktan Veri Aynalama)","text":""},{"location":"API_References/RemoteDataSynchronizer_tr/#giris","title":"Giri\u015f","text":"<p><code>RemoteDataSynchronizer.cs</code>, Nexus Prime'\u0131n da\u011f\u0131t\u0131k sistemler (distributed systems) ve \u00e7ok oyunculu (multiplayer) yap\u0131lar i\u00e7in sundu\u011fu veri k\u00f6pr\u00fcs\u00fcd\u00fcr. Bu mod\u00fcl, yerel <code>Registry</code> i\u00e7indeki unmanaged verileri, snapshot teknolojisini kullanarak a\u011f \u00fczerindeki uzak u\u00e7 noktalara (remote endpoints) aynalar. Sadece de\u011fi\u015fen verileri (Delta) g\u00f6ndererek bant geni\u015fli\u011fi kullan\u0131m\u0131n\u0131 minimize eder.</p>"},{"location":"API_References/RemoteDataSynchronizer_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Senkronizasyon mekanizmas\u0131 \u015fu teknikleri kullan\u0131r: - Delta Snapshot Integration: T\u00fcm Registry'yi yeniden g\u00f6ndermek yerine, SnapshotManager'dan gelen fark verilerini (delta) kullan\u0131r. - Raw Binary Streaming: Veriler unmanaged oldu\u011fu i\u00e7in, serile\u015ftirme (serialization) y\u00fck\u00fc olmadan do\u011frudan ham byte bloklar\u0131 halinde UDP veya TCP \u00fczerinden ak\u0131t\u0131l\u0131r. - State Mirroring: \u00c7apraz platformlarda (\u00d6rn: Server-Client) unmanaged bellek d\u00fczeninin (<code>memory layout</code>) birebir kopyalanmas\u0131n\u0131 sa\u011flar. - Low-Latency Updates: Veri d\u00f6n\u00fc\u015f\u00fcm\u00fc (marshaling) maliyetini s\u0131f\u0131ra indirerek milisaniye alt\u0131 gecikme hedefler.</p>"},{"location":"API_References/RemoteDataSynchronizer_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Haz\u0131rl\u0131k: <code>RemoteDataSynchronizer</code> hedef IP adresini ve Registry referans\u0131n\u0131 al\u0131r.</li> <li>Delta Yakalama: Mevcut karedeki de\u011fi\u015fimler (dirty components) tespit edilir.</li> <li>Paketleme: De\u011fi\u015fimler ham binary format\u0131nda paketlenir.</li> <li>\u0130letim: Paketler a\u011f \u00fczerinden g\u00f6nderilir ve kar\u015f\u0131 tarafta do\u011frudan unmanaged belle\u011fe uygulan\u0131r (patch).</li> </ol>"},{"location":"API_References/RemoteDataSynchronizer_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Data Mirroring: Verinin farkl\u0131 bir cihazda veya s\u00fcre\u00e7te birebir kopyas\u0131n\u0131 olu\u015fturma.</li> <li>Delta Sync: Sadece bir \u00f6nceki durumdan farkl\u0131 olan verileri senkronize etme.</li> <li>Binary Streaming: Veriyi okunabilir metin yerine, do\u011frudan i\u015flemcinin anlad\u0131\u011f\u0131 dijital formatta (0-1) aktarma.</li> <li>Remote Endpoint: Verinin g\u00f6nderildi\u011fi uzak sunucu veya istemci adresi.</li> </ul>"},{"location":"API_References/RemoteDataSynchronizer_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Network Reliability: UDP kullan\u0131ld\u0131\u011f\u0131nda paket kay\u0131plar\u0131 durum tutars\u0131zl\u0131\u011f\u0131na yol a\u00e7abilir. Bu sistem genellikle g\u00fcvenilir (reliable) bir ta\u015f\u0131ma katman\u0131 ile birlikte kullan\u0131l\u0131r.</li> </ul>"},{"location":"API_References/RemoteDataSynchronizer_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>RemoteDataSynchronizer sync = new RemoteDataSynchronizer();\nsync.SyncToRemote(myRegistry, \"192.168.1.10\");\n</code></pre>"},{"location":"API_References/RemoteDataSynchronizer_tr/#nexus-optimization-tip-zero-serialization-overhead","title":"Nexus Optimization Tip: Zero-Serialization Overhead","text":"<p>Geleneksel JSON veya Protobuf serile\u015ftirmesi yerine unmanaged veriyi <code>NativeMemory.Copy</code> ile do\u011frudan sokete yaz\u0131n. Bu, serile\u015ftirme ad\u0131m\u0131n\u0131 tamamen ortadan kald\u0131rarak a\u011f haz\u0131rl\u0131k s\u00fcresini %90 k\u0131salt\u0131r.</p>"},{"location":"API_References/RemoteDataSynchronizer_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>RemoteDataSynchronizer.cs Kaynak Kodu</p>"},{"location":"API_References/SnapshotManager_eng/","title":"API Reference: SnapshotManager (State and Time Management)","text":""},{"location":"API_References/SnapshotManager_eng/#introduction","title":"Introduction","text":"<p><code>SnapshotManager.cs</code> is the architectural layer providing the \"Time Travel\" and data rewind capabilities of Nexus Prime. It freezes the state of the entire ECS world into unmanaged memory blocks. Thanks to Delta-Snapshotting technology, it achieves massive memory savings and speed by recording only the changed (dirty) data segments each frame, rather than the entire world.</p>"},{"location":"API_References/SnapshotManager_eng/#technical-analysis","title":"Technical Analysis","text":"<p>SnapshotManager utilizes several techniques for professional data management: - Delta-Snapshotting: Operates integrated with Nexus's \"Dirty Flag\" system. Only component sets and chunks modified since the last snapshot are copied. - Hardware-Fast Block Copy: <code>NexusMemoryManager.Copy</code> (hardware-accelerated) is used for data transfer, enabling the cloning of hundreds of MBs of data within milliseconds. - Circular History Buffer: Controls memory usage via the <code>MaxHistoryFrames</code> limit; oldest snapshots are automatically destroyed. - Pointer Stability Management: Data within snapshots is also kept in unmanaged addresses, preventing pointer confusion during restoration.</p>"},{"location":"API_References/SnapshotManager_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Recording (<code>RecordFrame</code>): When recording begins, every <code>SparseSet</code> in the <code>Registry</code> is scanned. If <code>deltaOnly</code> is active, only dirty-marked data is copied into a new <code>Snapshot</code> object.</li> <li>Intersection: Entity version information and the current raw state (<code>Dense/Sparse/Chunks</code>) of components are frozen.</li> <li>Restoration (<code>LoadSnapshot</code>): All data from a selected snapshot is \"patched\" onto the live <code>Registry</code> via raw memory copying.</li> <li>Cleanup: All associated unmanaged memory blocks are released when a snapshot is destroyed.</li> </ol>"},{"location":"API_References/SnapshotManager_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Differential Snapshot (Delta): An intelligent backup method that records only changed data segments.</li> <li>Rewind: The process of physically returning a game or simulation state to a past moment.</li> <li>Timeline: The sequential history of snapshots.</li> <li>Deep Copy (Unmanaged): The process of copying memory address-by-address, byte-by-byte.</li> </ul>"},{"location":"API_References/SnapshotManager_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>RAM Capacity: Maintaining a very high frame history (e.g., 1000+ frames) can rapidly increase unmanaged memory consumption.</li> <li>Fragmentation: Frequent snapshotting and deletion can lead to fragmentation in the unmanaged heap (Nexus minimizes this via <code>PageAligned</code> allocation).</li> </ul>"},{"location":"API_References/SnapshotManager_eng/#usage-example","title":"Usage Example","text":"<pre><code>snapshotManager.RecordFrame(registry); // Record the current state\n// ... later\nsnapshotManager.LoadSnapshot(registry, history.First.Value); // Return to the past\n</code></pre>"},{"location":"API_References/SnapshotManager_eng/#nexus-optimization-tip-delta-copy-efficiency","title":"Nexus Optimization Tip: Delta Copy Efficiency","text":"<p>The Nexus SnapshotManager does not tax the processor's \"L3 Cache\" limits when copying a data block. Since it copies only \"Dirty\" marked data, the load on the memory bandwidth is 90% less than a standard \"full copy\" system. This ensures the game does not \"stutter\" while snapshots are taken in the background.</p>"},{"location":"API_References/SnapshotManager_eng/#original-source","title":"Original Source","text":"<p>SnapshotManager.cs Source Code</p>"},{"location":"API_References/SnapshotManager_tr/","title":"API Referans\u0131: SnapshotManager (Durum ve Zaman Y\u00f6netimi)","text":""},{"location":"API_References/SnapshotManager_tr/#giris","title":"Giri\u015f","text":"<p><code>SnapshotManager.cs</code>, Nexus Prime'\u0131n \"Zaman Yolculu\u011fu\" (Time Travel) ve veri geri sarma (Rewind) yeteneklerini sa\u011flayan mimari katman\u0131d\u0131r. T\u00fcm ECS d\u00fcnyas\u0131n\u0131n durumunu unmanaged bellek bloklar\u0131 halinde dondurur. Delta-Snapshotting teknolojisi sayesinde, her karede t\u00fcm d\u00fcnyay\u0131 de\u011fil, sadece de\u011fi\u015fen (dirty) veri par\u00e7alar\u0131n\u0131 kaydederek devasa bir bellek tasarrufu ve h\u0131z sa\u011flar.</p>"},{"location":"API_References/SnapshotManager_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>SnapshotManager, profesyonel veri y\u00f6netimi i\u00e7in \u015fu teknikleri kullan\u0131r: - Delta-Snapshotting: Nexus'un \"Dirty Flag\" sistemine entegre \u00e7al\u0131\u015f\u0131r. Sadece son snapshot'tan beri de\u011fi\u015fen bile\u015fen setleri ve chunk'lar kopyalan\u0131r. - Hardware-Fast Block Copy: Veri transferi i\u00e7in <code>NexusMemoryManager.Copy</code> (donan\u0131m h\u0131zland\u0131rmal\u0131) kullan\u0131l\u0131r, bu da milisaniyeler i\u00e7inde y\u00fczlerce MB veriyi klonlamay\u0131 m\u00fcmk\u00fcn k\u0131lar. - Circular History Buffer: <code>MaxHistoryFrames</code> s\u0131n\u0131r\u0131 ile bellek kullan\u0131m\u0131n\u0131 kontrol alt\u0131nda tutar; en eski snapshot'lar\u0131 otomatik olarak imha eder. - Pointer Stability Management: Snapshot i\u00e7indeki veriler de unmanaged adreslerde tutulur, b\u00f6ylece geri y\u00fckleme s\u0131ras\u0131nda pointer karma\u015fas\u0131 ya\u015fanmaz.</p>"},{"location":"API_References/SnapshotManager_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Kay\u0131t (<code>RecordFrame</code>): Kay\u0131t ba\u015flad\u0131\u011f\u0131nda <code>Registry</code> i\u00e7indeki her <code>SparseSet</code> taran\u0131r. E\u011fer <code>deltaOnly</code> aktifse sadece kirli i\u015faretlenmi\u015f veriler yeni bir <code>Snapshot</code> nesnesine kopyalan\u0131r.</li> <li>Kesi\u015fim: Varl\u0131klar\u0131n s\u00fcr\u00fcm (version) bilgileri ve bile\u015fenlerin o anki ham durumu (<code>Dense/Sparse/Chunks</code>) dondurulur.</li> <li>Geri Y\u00fckleme (<code>LoadSnapshot</code>): Se\u00e7ilen bir snapshot an\u0131ndaki t\u00fcm veriler, canl\u0131 <code>Registry</code> \u00fczerine ham bellek kopyalamas\u0131 ile \"yama\" (patch) yap\u0131l\u0131r.</li> <li>Temizlik: Snapshot imha edildi\u011finde ba\u011fl\u0131 t\u00fcm unmanaged bellek bloklar\u0131 serbest b\u0131rak\u0131l\u0131r.</li> </ol>"},{"location":"API_References/SnapshotManager_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Differential Snapshot (Delta): Sadece de\u011fi\u015fen veri par\u00e7alar\u0131n\u0131 kaydeden ak\u0131ll\u0131 yedekleme y\u00f6ntemi.</li> <li>Rewind: Oyun veya sim\u00fclasyon durumunu fiziksel olarak ge\u00e7mi\u015fteki bir ana d\u00f6nd\u00fcrme i\u015flemi.</li> <li>Timeline: Snapshot'lar\u0131n s\u0131ral\u0131 olarak tutuldu\u011fu ge\u00e7mi\u015f zaman dizisi.</li> <li>Deep Copy (Unmanaged): Belle\u011fi adres bazl\u0131 olarak, byte byte birebir kopyalama i\u015flemi.</li> </ul>"},{"location":"API_References/SnapshotManager_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>RAM Capacity: \u00c7ok y\u00fcksek frame ge\u00e7mi\u015fi (\u00f6rne\u011fin 1000+ frame) unmanaged bellek t\u00fcketimini h\u0131zla art\u0131rabilir.</li> <li>Fragmentation: S\u0131k snapshot al\u0131p silmek unmanaged heap \u00fczerinde par\u00e7alanmaya yol a\u00e7abilir (Nexus bu durumu <code>PageAligned</code> tahsisatla minimize eder).</li> </ul>"},{"location":"API_References/SnapshotManager_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>snapshotManager.RecordFrame(registry); // O anki durumu kaydet\n// ... bir s\u00fcre sonra\nsnapshotManager.LoadSnapshot(registry, history.First.Value); // Ge\u00e7mi\u015fe d\u00f6n\n</code></pre>"},{"location":"API_References/SnapshotManager_tr/#nexus-optimization-tip-delta-copy-efficiency","title":"Nexus Optimization Tip: Delta Copy Efficiency","text":"<p>Nexus SnapshotManager, bir veri blo\u011funu kopyalarken i\u015flemcinin \"L3 Cache\" limitlerini zorlamaz. Sadece \"Dirty\" i\u015faretli verileri kopyalad\u0131\u011f\u0131 i\u00e7in bellek veri yolu (bandwidth) \u00fczerindeki y\u00fck\u00fc, standart bir \"full copy\" sistemine g\u00f6re %90 daha azd\u0131r. Bu, arka planda snapshot al\u0131n\u0131rken oyunun \"stutter\" (tak\u0131lma) yapmamas\u0131n\u0131 sa\u011flar.</p>"},{"location":"API_References/SnapshotManager_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>SnapshotManager.cs Kaynak Kodu</p>"},{"location":"API_References/SparseSet_eng/","title":"API Reference: SparseSet (Hybrid Storage System)","text":""},{"location":"API_References/SparseSet_eng/#introduction","title":"Introduction","text":"<p><code>SparseSet.cs</code> is a \"High-Throughput\" focused storage system at the heart of Nexus' data-oriented architecture. By maintaining data in two separate arrays (<code>Sparse</code> and <code>Dense</code>), it enables O(1) access to an entity's component while ensuring that all components remain side-by-side (packed) in memory. This allows the processor to iterate through millions of projectiles or enemies per second without stagnation (avoiding Cache-Misses).</p>"},{"location":"API_References/SparseSet_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The SparseSet implements the following optimizations at the hardware level: - Swap-and-Pop Algorithm: When a component is removed, the resulting gap is filled with the element at the end of the array. This ensures memory remains \"tight\" and sequential. - Cache-Line Alignment: All unmanaged arrays are aligned to 64-byte (cache-line) boundaries. This triggers the CPU to prefetch adjacent data while reading a data packet. - Presence Bits: A \"presence bit\" is maintained for each entity to accelerate SIMD queries. - Unmanaged Buffer: The GC (Garbage Collector) scan load on memory is reduced to zero using <code>NativeMemory.AlignedAlloc</code>.</p>"},{"location":"API_References/SparseSet_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Addition (<code>Add</code>): The entity index is assigned a position in the <code>Sparse</code> array. The actual data is added to the end of the <code>Dense</code> array. The <code>Sparse</code> cell stores this new <code>Dense</code> position.</li> <li>Access (<code>Get</code>): <code>Sparse[EntityIndex]</code> -&gt; <code>DenseOffset</code> -&gt; <code>DataPtr</code>. Double-checking verifies in a billionth of a second that the entity truly owns the data.</li> <li>Removal (<code>Remove</code>): The last element of the array is moved to the position of the removed element (<code>Swap</code>). Thus, no gaps (fragmentation) occur.</li> <li>Querying: Since the <code>Dense</code> array is sequential, the processor reads data continuously like a river.</li> </ol>"},{"location":"API_References/SparseSet_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Sparse Array: A large index that uses entity indices as keys and can have holes.</li> <li>Dense Array: A high-density memory block where data is arranged side-by-side without gaps.</li> <li>Swap-and-Pop: An ECS standard for O(1) time deletions without breaking data integrity.</li> <li>Fragmentation: Inefficient gaps formed in memory. SparseSet keeps this at 0%.</li> </ul>"},{"location":"API_References/SparseSet_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Memory Usage: The sparse array occupies as much space as the largest entity index. Very sparse entity usage can increase RAM consumption.</li> <li>Safe Pointers: Returned pointers are <code>unsafe</code> and may become invalid when data is removed or swapped.</li> </ul>"},{"location":"API_References/SparseSet_eng/#usage-example","title":"Usage Example","text":"<pre><code>var positions = new SparseSet&lt;Position&gt;();\npositions.Add(entity1, new Position(1, 2, 3));\nPosition* p = positions.Get(entity1);\n</code></pre>"},{"location":"API_References/SparseSet_eng/#nexus-optimization-tip-cache-line-utilization","title":"Nexus Optimization Tip: Cache-Line Utilization","text":"<p>The <code>Dense</code> array within SparseSet delivers data in 64-byte packets. When a modern Intel/AMD processor requests <code>Dense[i]</code>, it automatically prefetches <code>Dense[i+1]</code> via the \"L1 Pre-fetcher.\" This is the foundation of the \"Sequential Memory Access\" advantage described in Nexus documentation.</p>"},{"location":"API_References/SparseSet_eng/#original-source","title":"Original Source","text":"<p>SparseSet.cs Source Code</p>"},{"location":"API_References/SparseSet_tr/","title":"API Referans\u0131: SparseSet (Hibrit Depolama Sistemi)","text":""},{"location":"API_References/SparseSet_tr/#giris","title":"Giri\u015f","text":"<p><code>SparseSet.cs</code>, Nexus'un veri odakl\u0131 mimarisinin kalbinde yer alan, \"High-Throughput\" (Y\u00fcksek Eri\u015filebilirlik) odakl\u0131 bir depolama sistemidir. Verileri iki ayr\u0131 dizide (<code>Sparse</code> ve <code>Dense</code>) tutarak, bir varl\u0131\u011f\u0131n bile\u015fenine O(1) h\u0131z\u0131nda ula\u015f\u0131rken, ayn\u0131 zamanda t\u00fcm bile\u015fenlerin bellekte yan yana (packed) olmas\u0131n\u0131 sa\u011flar. Bu, i\u015flemcinin mermiler veya d\u00fc\u015fmanlar \u00fczerinde saniyede milyonlarca d\u00f6ng\u00fcy\u00fc hi\u00e7 tak\u0131lmadan (Cache-Miss ya\u015famadan) d\u00f6nd\u00fcrmesini m\u00fcmk\u00fcn k\u0131lar.</p>"},{"location":"API_References/SparseSet_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>SparseSet, donan\u0131m seviyesinde \u015fu optimizasyonlar\u0131 uygular: - Swap-and-Pop Algoritmas\u0131: Bir bile\u015fen silindi\u011finde, olu\u015fan bo\u015fluk dizinin sonundaki eleman ile doldurulur. Bu, belle\u011fin her zaman \"s\u0131ms\u0131k\u0131\" ve ard\u0131\u015f\u0131k kalmas\u0131n\u0131 sa\u011flar. - Cache-Line Alignment: T\u00fcm unmanaged diziler 64 byte (cache-line) s\u0131n\u0131rlar\u0131na hizalan\u0131r. Bu, CPU'nun bir veri paketini okurken ayn\u0131 anda yandaki veriyi de \u00f6nbelle\u011fe almas\u0131n\u0131 tetikler. - Presence Bits: SIMD sorgular\u0131n\u0131 h\u0131zland\u0131rmak i\u00e7in her varl\u0131k i\u00e7in bir \"varl\u0131k biti\" (presence bit) tutulur. - Unmanaged Buffer: <code>NativeMemory.AlignedAlloc</code> kullan\u0131larak GC'nin (Garbage Collector) bellek \u00fczerindeki tarama y\u00fck\u00fc s\u0131f\u0131ra indirilir.</p>"},{"location":"API_References/SparseSet_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Ekleme (<code>Add</code>): Varl\u0131k indeksi <code>Sparse</code> dizisinde bir konuma atan\u0131r. As\u0131l veri <code>Dense</code> dizisinin sonuna eklenir. <code>Sparse</code> h\u00fccresi, bu yeni <code>Dense</code> konumunu tutar.</li> <li>Eri\u015fim (<code>Get</code>): <code>Sparse[EntityIndex]</code> -&gt; <code>DenseOffset</code> -&gt; <code>DataPtr</code>. \u00c7ift y\u00f6nl\u00fc kontrol (Double-Check) ile varl\u0131\u011f\u0131n o veriye ger\u00e7ekten sahip oldu\u011fu saniyenin milyarda birinde do\u011frulan\u0131r.</li> <li>Silme (<code>Remove</code>): Silinen eleman\u0131n yerine dizinin en sonundaki eleman ta\u015f\u0131n\u0131r (<code>Swap</code>). B\u00f6ylece aralarda bo\u015fluk (fragmentation) olu\u015fmaz.</li> <li>Sorgulama: <code>Dense</code> dizisi ard\u0131\u015f\u0131k oldu\u011fu i\u00e7in, i\u015flemci verileri bir nehir gibi kesintisiz okur.</li> </ol>"},{"location":"API_References/SparseSet_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Sparse Array: Varl\u0131k indekslerini anahtar olarak kullanan ve delikli (holes) olabilen b\u00fcy\u00fck dizin.</li> <li>Dense Array: Verilerin hi\u00e7 bo\u015fluk olmadan, yan yana dizildi\u011fi y\u00fcksek yo\u011funluklu bellek blo\u011fu.</li> <li>Swap-and-Pop: Veri b\u00fct\u00fcnl\u00fc\u011f\u00fcn\u00fc bozmadan O(1) s\u00fcrede silme yapmay\u0131 sa\u011flayan ECS standard\u0131.</li> <li>Fragmentation: Bellekte olu\u015fan verimsiz bo\u015fluklar. SparseSet bunu %0'da tutar.</li> </ul>"},{"location":"API_References/SparseSet_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Memory Usage: Sparse dizisi, en b\u00fcy\u00fck varl\u0131k indeksi kadar yer kaplar. \u00c7ok seyrek varl\u0131k kullan\u0131m\u0131 RAM t\u00fcketimini art\u0131rabilir.</li> <li>Safe Pointers: D\u00f6nen pointerlar <code>unsafe</code> kapsam\u0131ndad\u0131r ve veri silindi\u011finde veya <code>Swap</code> oldu\u011funda ge\u00e7ersiz kalabilir.</li> </ul>"},{"location":"API_References/SparseSet_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>var positions = new SparseSet&lt;Position&gt;();\npositions.Add(entity1, new Position(1, 2, 3));\nPosition* p = positions.Get(entity1);\n</code></pre>"},{"location":"API_References/SparseSet_tr/#nexus-optimization-tip-cache-line-utilization","title":"Nexus Optimization Tip: Cache-Line Utilization","text":"<p>SparseSet i\u00e7erisindeki <code>Dense</code> dizisi, verileri 64 bytel\u0131k paketler halinde sunar. Modern bir Intel/AMD i\u015flemci, <code>Dense[i]</code> verisini istedi\u011finde otomatik olarak <code>Dense[i+1]</code> verisini de \"L1 Pre-fetcher\" ile \u00f6nbelle\u011fe al\u0131r. Bu, Nexus d\u00f6k\u00fcmanlar\u0131nda anlat\u0131lan \"Sequential Memory Access\" avantaj\u0131n\u0131n temelidir.</p>"},{"location":"API_References/SparseSet_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>SparseSet.cs Kaynak Kodu</p>"},{"location":"API_References/TimeTravelDebugger_eng/","title":"API Reference: TimeTravelDebugger (Time Travel Interface)","text":""},{"location":"API_References/TimeTravelDebugger_eng/#introduction","title":"Introduction","text":"<p><code>TimeTravelDebugger.cs</code> is the visual control center for one of Nexus Prime's most notable features: the \"Time Travel\" mechanism. This editor interface lays out snapshots stored in unmanaged memory before the developer like a film strip (Timeline). Developers can visually inspect the unmanaged state of systems by rewinding or fast-forwarding time while the game is running or paused.</p>"},{"location":"API_References/TimeTravelDebugger_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The editor interface provides the following professional debugging features: - Visual Timeline Scrubbing: Offers the ability to scan frame history within the <code>SnapshotManager</code> live via a slider. - Auto-Play / Scrub Mode: Automatically transitions between frames to monitor the change of unmanaged data over time (e.g., deviations in bullet paths). - Context Locking: Seals itself to a specific <code>Registry</code> and <code>SnapshotManager</code> instance to pull data from the currently active simulation. - State Validation Display: Instantly reports whether memory alignment (64B) and chunk health in the displayed frame are nominal.</p>"},{"location":"API_References/TimeTravelDebugger_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Connection: Opened via <code>Menu/Nexus/Time-Travel Debugger</code> in the editor.</li> <li>Frame Selection: When the user selects a point on the timeline, the relevant frame index is passed to the <code>SnapshotManager</code>.</li> <li>Restoration: All unmanaged data from the selected snapshot moment is patched into the live world via <code>LoadSnapshot</code>.</li> <li>Visual Refresh: The Unity scene view (<code>SceneView.RepaintAll</code>) is immediately updated to show the visual equivalent of the data.</li> </ol>"},{"location":"API_References/TimeTravelDebugger_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Timeline Scrubbing: Monitoring instantaneous changes by dragging the mouse over the timeline.</li> <li>Auto-Scrub: Automatically fast-forwarding time at a specific speed.</li> <li>Context Connection: Determining which dataset (World) the interface is communicating with.</li> <li>Memory Alignment Check: Final check of whether the data is correctly arranged for the processor cache.</li> </ul>"},{"location":"API_References/TimeTravelDebugger_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Scene-Level Only: This tool only rewinds unmanaged data managed by Nexus. If there is no synchronization for non-unmanaged (pure Unity) data, visual objects may not move.</li> </ul>"},{"location":"API_References/TimeTravelDebugger_eng/#usage-example","title":"Usage Example","text":"<ol> <li>Start the game.</li> <li>Open the Time Travel Debugger.</li> <li>Pull the slider back to inspect the positions of entities 10 frames ago.</li> <li>Press the \"Play\" button to watch the simulation in slow motion.</li> </ol>"},{"location":"API_References/TimeTravelDebugger_eng/#nexus-optimization-tip-visual-integrity-verification","title":"Nexus Optimization Tip: Visual Integrity Verification","text":"<p>TimeTravelDebugger is not just a playback tool. It checks <code>NexusMemoryManager</code> signatures in the background with every frame transition. If memory corruption is detected in a frame, that point is visually marked on the timeline. This accelerates detecting impossible-to-find \"Random Memory Corruption\" errors by 80%.</p>"},{"location":"API_References/TimeTravelDebugger_eng/#original-source","title":"Original Source","text":"<p>TimeTravelDebugger.cs Source Code</p>"},{"location":"API_References/TimeTravelDebugger_tr/","title":"API Referans\u0131: TimeTravelDebugger (Zaman Yolculu\u011fu Aray\u00fcz\u00fc)","text":""},{"location":"API_References/TimeTravelDebugger_tr/#giris","title":"Giri\u015f","text":"<p><code>TimeTravelDebugger.cs</code>, Nexus Prime'\u0131n en dikkat \u00e7ekici \u00f6zelliklerinden biri olan \"Zaman Yolculu\u011fu\" (Time Travel) mekanizmas\u0131n\u0131n g\u00f6rsel kontrol merkezidir. Bu edit\u00f6r aray\u00fcz\u00fc, unmanaged bellekte saklanan snapshot'lar\u0131 bir film \u015feridi (Timeline) gibi geli\u015ftiricinin \u00f6n\u00fcne serer. Geli\u015ftiriciler, oyun \u00e7al\u0131\u015f\u0131rken veya durmu\u015fken zaman\u0131 ileri-geri sararak sistemlerin unmanaged durumunu g\u00f6rsel olarak denetleyebilirler.</p>"},{"location":"API_References/TimeTravelDebugger_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Edit\u00f6r aray\u00fcz\u00fc, \u015fu profesyonel hata ay\u0131klama \u00f6zelliklerini sa\u011flar: - Visual Timeline Scrubbing: <code>SnapshotManager</code> i\u00e7indeki frame ge\u00e7mi\u015fini bir slider \u00fczerinden canl\u0131 olarak tarama imkan\u0131 sunar. - Auto-Play / Scrub Mode: Kareler aras\u0131nda otomatik ge\u00e7i\u015f yaparak unmanaged verilerin zaman i\u00e7indeki de\u011fi\u015fimini (\u00d6rn: Mermi yollar\u0131ndaki sapmalar) izletir. - Context Locking: Belirli bir <code>Registry</code> ve <code>SnapshotManager</code> \u00f6rne\u011fine m\u00fch\u00fcrlenerek, o anki aktif sim\u00fclasyonun verilerini \u00e7eker. - State Validation Display: G\u00f6r\u00fcnt\u00fclenen karedeki bellek hizalamas\u0131n\u0131n (64B) ve chunk sa\u011fl\u0131\u011f\u0131n\u0131n nominal olup olmad\u0131\u011f\u0131n\u0131 anl\u0131k raporlar.</p>"},{"location":"API_References/TimeTravelDebugger_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Ba\u011flant\u0131: Edit\u00f6r \u00fczerinden <code>Menu/Nexus/Time-Travel Debugger</code> yoluyla a\u00e7\u0131l\u0131r.</li> <li>Kare Se\u00e7imi: Kullan\u0131c\u0131 zaman \u00e7izelgesinde bir noktay\u0131 se\u00e7ti\u011finde, ilgili kare indeksi <code>SnapshotManager</code>'a iletilir.</li> <li>Restorasyon: Se\u00e7ilen snapshot an\u0131ndaki t\u00fcm unmanaged veriler <code>LoadSnapshot</code> ile canl\u0131 d\u00fcnyaya yama yap\u0131l\u0131r.</li> <li>G\u00f6rsel Yenileme: Unity sahne g\u00f6r\u00fcn\u00fcm\u00fc (<code>SceneView.RepaintAll</code>) an\u0131nda g\u00fcncellenerek verilerin g\u00f6rsel kar\u015f\u0131l\u0131\u011f\u0131 g\u00f6sterilir.</li> </ol>"},{"location":"API_References/TimeTravelDebugger_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Timeline Scrubbing: Zaman \u00e7izelgesi \u00fczerinde fareyi s\u00fcr\u00fckleyerek anl\u0131k de\u011fi\u015fimleri izleme.</li> <li>Auto-Scrub: Belirli bir h\u0131zda zaman\u0131 otomatik ileri sarmak.</li> <li>Context Connection: Aray\u00fcz\u00fcn hangi veri setiyle (World) konu\u015ftu\u011funu belirleme.</li> <li>Memory Alignment Check: Verilerin i\u015flemci \u00f6nbelle\u011fi i\u00e7in do\u011fru dizilip dizilmedi\u011finin son kontrol\u00fc.</li> </ul>"},{"location":"API_References/TimeTravelDebugger_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Scene-Level Only: Bu ara\u00e7 sadece Nexus taraf\u0131ndan y\u00f6netilen unmanaged verileri geri sarar. E\u011fer unmanaged olmayan (pure Unity) verilere dair bir senkronizasyon yoksa, g\u00f6rsel nesneler yer de\u011fi\u015ftirmeyebilir.</li> </ul>"},{"location":"API_References/TimeTravelDebugger_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<ol> <li>Oyunu ba\u015flat\u0131n.</li> <li>Zaman Yolculu\u011fu Debugger'\u0131n\u0131 a\u00e7\u0131n.</li> <li>Slider'\u0131 geri \u00e7ekerek varl\u0131klar\u0131n 10 kare \u00f6nceki pozisyonlar\u0131n\u0131 inceleyin.</li> <li>\"Play\" butonuna basarak a\u011f\u0131r \u00e7ekimde sim\u00fclasyonu izleyin.</li> </ol>"},{"location":"API_References/TimeTravelDebugger_tr/#nexus-optimization-tip-visual-integrity-verification","title":"Nexus Optimization Tip: Visual Integrity Verification","text":"<p>TimeTravelDebugger, sadece bir playback arac\u0131 de\u011fildir. Her kare ge\u00e7i\u015finde arka planda <code>NexusMemoryManager</code> imzalar\u0131n\u0131 kontrol eder. E\u011fer bir karede bellek bozulmas\u0131 (corruption) tespit edilirse, timeline \u00fczerinde o nokta g\u00f6rsel olarak i\u015faretlenir. Bu, bulunmas\u0131 imkans\u0131z olan \"Random Memory Corruption\" hatalar\u0131n\u0131 tespit etmeyi %80 h\u0131zland\u0131r\u0131r.</p>"},{"location":"API_References/TimeTravelDebugger_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>TimeTravelDebugger.cs Kaynak Kodu</p>"},{"location":"API_References/UnmanagedComponentAnalyzer_eng/","title":"API Reference: UnmanagedComponentAnalyzer (Static Security Guardian)","text":""},{"location":"API_References/UnmanagedComponentAnalyzer_eng/#introduction","title":"Introduction","text":"<p><code>UnmanagedComponentAnalyzer.cs</code> is a Roslyn-based static analyzer protecting the unmanaged world of Nexus Prime. It prevents a developer from accidentally adding a managed reference, such as a <code>string</code> or <code>class</code>, to a structure (struct) that should be unmanaged at the compilation phase (compile-time). It provides professional compiler checking with the <code>NX0001</code> error code.</p>"},{"location":"API_References/UnmanagedComponentAnalyzer_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The analyzer audits the codebase at the following levels: - Symbol Analysis: Scans the hierarchy of all types marked with <code>[MustBeUnmanaged]</code> to check if they are unmanaged (<code>IsUnmanagedType</code>). - Syntax Node Analysis: Captures generic calls on the Registry such as <code>Add&lt;T&gt;</code>, <code>Get&lt;T&gt;</code>, and <code>Has&lt;T&gt;</code>, and verifies if the <code>&lt;T&gt;</code> type complies with the unmanaged rule. - Diagnostic Reporting: Displays a red underline and error message on the IDE (Visual Studio/Rider) when a violation is detected. - Concurrent Execution: Supports parallel (concurrent) execution to accelerate analysis in large projects.</p>"},{"location":"API_References/UnmanagedComponentAnalyzer_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Initialization: The analyzer registers with the C# compiler (<code>Initialize</code>).</li> <li>Vigilance: The semantic model is scanned as code is written or compiled.</li> <li>Comparison: The unmanaged flag (<code>IsUnmanagedType</code>) of the target type (<code>namedType</code> or <code>typeArg</code>) is checked.</li> <li>Error Logging: If there is a rule violation, a <code>Diagnostic</code> is created with the <code>NX0001</code> code and reported to the developer.</li> </ol>"},{"location":"API_References/UnmanagedComponentAnalyzer_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Roslyn Analyzer: A tool embedded within the C# compiler that performs real-time code analysis.</li> <li>Semantic Model: A structure where code is represented not just as text but as meaning (types, references).</li> <li>Diagnostic ID: A unique code identifying a specific error or warning type (e.g., NX0001).</li> <li>Syntax Node: Each individual part in the hierarchical (tree) structure of code (e.g., Method call).</li> </ul>"},{"location":"API_References/UnmanagedComponentAnalyzer_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>False Negatives: The analyzer may be limited in extremely complex <code>unsafe</code> pointer arithmetic or in types generated at runtime. It is 100% reliable for standard C# types.</li> </ul>"},{"location":"API_References/UnmanagedComponentAnalyzer_eng/#usage-example","title":"Usage Example","text":"<p>The analyzer kicks in if the developer writes the following: <pre><code>registry.Add&lt;MyManagedStruct&gt;(entity); // NX0001: Type must be unmanaged!\n</code></pre></p>"},{"location":"API_References/UnmanagedComponentAnalyzer_eng/#nexus-optimization-tip-early-failure","title":"Nexus Optimization Tip: Early Failure","text":"<p>Do not leave debugging to the game's runtime. Detecting memory corruptions while writing code via <code>UnmanagedComponentAnalyzer</code> reduces debugging time by 80%.</p>"},{"location":"API_References/UnmanagedComponentAnalyzer_eng/#original-source","title":"Original Source","text":"<p>UnmanagedComponentAnalyzer.cs Source Code</p>"},{"location":"API_References/UnmanagedComponentAnalyzer_tr/","title":"API Referans\u0131: UnmanagedComponentAnalyzer (Statik G\u00fcvenlik Muhaf\u0131z\u0131)","text":""},{"location":"API_References/UnmanagedComponentAnalyzer_tr/#giris","title":"Giri\u015f","text":"<p><code>UnmanagedComponentAnalyzer.cs</code>, Nexus Prime'\u0131n unmanaged d\u00fcnyas\u0131n\u0131 koruyan Roslyn tabanl\u0131 bir statik analiz\u00f6rd\u00fcr. Bir geli\u015ftiricinin unmanaged olmas\u0131 gereken bir yap\u0131ya (struct) yanl\u0131\u015fl\u0131kla <code>string</code> veya <code>class</code> gibi y\u00f6netilen (managed) bir referans eklemesini derleme a\u015famas\u0131nda (compile-time) engeller. <code>NX0001</code> hata kodu ile profesyonel bir derleyici denetimi sa\u011flar.</p>"},{"location":"API_References/UnmanagedComponentAnalyzer_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Analiz\u00f6r, kod taban\u0131n\u0131 \u015fu seviyelerde denetler: - Symbol Analysis: <code>[MustBeUnmanaged]</code> ile i\u015faretlenen t\u00fcm tiplerin hiyerar\u015fisini tarayarak unmanaged olup olmad\u0131klar\u0131n\u0131 (<code>IsUnmanagedType</code>) kontrol eder. - Syntax Node Analysis: Registry \u00fczerindeki <code>Add&lt;T&gt;</code>, <code>Get&lt;T&gt;</code> ve <code>Has&lt;T&gt;</code> gibi generic \u00e7a\u011fr\u0131lar\u0131 yakalar ve <code>&lt;T&gt;</code> tipinin unmanaged kural\u0131na uyup uymad\u0131\u011f\u0131n\u0131 denetler. - Diagnostic Reporting: Kurallara ayk\u0131r\u0131 bir durum tespit etti\u011finde, IDE \u00fczerinde (Visual Studio/Rider) k\u0131rm\u0131z\u0131 alt \u00e7izgi ve hata mesaj\u0131 g\u00f6sterir. - Concurrent Execution: B\u00fcy\u00fck projelerde analizi h\u0131zland\u0131rmak i\u00e7in paralel (concurrent) \u00e7al\u0131\u015fma deste\u011fi sunar.</p>"},{"location":"API_References/UnmanagedComponentAnalyzer_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130lklendirme: Analiz\u00f6r C# derleyicisine kaydolur (<code>Initialize</code>).</li> <li>Tetikte Bekleme: Kod yaz\u0131ld\u0131k\u00e7a veya derlendik\u00e7e semantik model taran\u0131r.</li> <li>Kar\u015f\u0131la\u015ft\u0131rma: Hedef tipin (<code>namedType</code> veya <code>typeArg</code>) unmanaged bayra\u011f\u0131 (<code>IsUnmanagedType</code>) kontrol edilir.</li> <li>Hata Kayd\u0131: Kural ihlali varsa <code>NX0001</code> kodu ile bir <code>Diagnostic</code> olu\u015fturulur ve geli\u015ftiriciye raporlan\u0131r.</li> </ol>"},{"location":"API_References/UnmanagedComponentAnalyzer_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Roslyn Analyzer: C# derleyicisinin i\u00e7ine g\u00f6m\u00fclen ve ger\u00e7ek zamanl\u0131 kod analizi yapan ara\u00e7.</li> <li>Semantic Model: Kodun sadece metin olarak de\u011fil, anlam (tipler, referanslar) olarak temsil edildi\u011fi yap\u0131.</li> <li>Diagnostic ID: Belirli bir hata veya uyar\u0131 tipini tan\u0131mlayan benzersiz kod (\u00f6rn: NX0001).</li> <li>Syntax Node: Kodun hiyerar\u015fik (a\u011fa\u00e7) yap\u0131s\u0131ndaki her bir par\u00e7a (\u00f6rn: Metod \u00e7a\u011fr\u0131s\u0131).</li> </ul>"},{"location":"API_References/UnmanagedComponentAnalyzer_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>False Negatives: \u00c7ok karma\u015f\u0131k <code>unsafe</code> pointer aritmetiklerinde veya \u00e7al\u0131\u015fma zaman\u0131nda \u00fcretilen tiplerde analiz\u00f6r k\u0131s\u0131tl\u0131 kalabilir. Temel C# tipleri i\u00e7in %100 g\u00fcvenilirdir.</li> </ul>"},{"location":"API_References/UnmanagedComponentAnalyzer_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<p>E\u011fer geli\u015ftirici \u015funu yazarsa analiz\u00f6r devreye girer: <pre><code>registry.Add&lt;MyManagedStruct&gt;(entity); // NX0001: Type must be unmanaged!\n</code></pre></p>"},{"location":"API_References/UnmanagedComponentAnalyzer_tr/#nexus-optimization-tip-early-failure","title":"Nexus Optimization Tip: Early Failure","text":"<p>Hata ay\u0131klamay\u0131 oyunun \u00e7al\u0131\u015fma zaman\u0131na (runtime) b\u0131rakmay\u0131n. <code>UnmanagedComponentAnalyzer</code> sayesinde bellek bozulmalar\u0131n\u0131 kod yazarken tespit etmek, hata ay\u0131klama s\u00fcresini %80 oran\u0131nda azalt\u0131r.</p>"},{"location":"API_References/UnmanagedComponentAnalyzer_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>UnmanagedComponentAnalyzer.cs Kaynak Kodu</p>"},{"location":"Benchmarks/Benchmark/","title":"Benchmark Report: Nexus Prime vs. Legacy Patterns","text":""},{"location":"Benchmarks/Benchmark/#executive-summary","title":"Executive Summary","text":"<p>This report presents a scientific performance comparison between the Nexus ECS Framework and traditional Unity patterns (MonoBehaviour/List). Tests were conducted on 100,000 active entities performing basic movement and state updates. Results demonstrate that Nexus achieves 100x to 1000x improvements in execution speed and eliminates Garbage Collector (GC) pressure entirely.</p>"},{"location":"Benchmarks/Benchmark/#1-test-environment","title":"1. Test Environment","text":"<ul> <li>CPU: AMD Ryzen 9 5900X (12-Core, 24-Thread)</li> <li>RAM: 32GB DDR4 3600MHz</li> <li>Unity Version: 2022.3 LTS</li> <li>Build: Windows Standalone / IL2CPP</li> </ul>"},{"location":"Benchmarks/Benchmark/#2-methodology","title":"2. Methodology","text":"<ul> <li>Legacy Pattern: 100k GameObjects with a simple <code>Update()</code> method modifying <code>transform.position</code>.</li> <li>Nexus Pattern: 100k Entities in a <code>Registry</code> with a <code>Position</code> component and a <code>VelocitySystem</code> running via <code>JobSystem</code>.</li> </ul>"},{"location":"Benchmarks/Benchmark/#3-results-analysis","title":"3. Results Analysis","text":""},{"location":"Benchmarks/Benchmark/#31-frame-time-100k-entities","title":"3.1 Frame Time (100k Entities)","text":"Pattern Average Frame Time (ms) Speedup MonoBehaviour Update ~142.5 ms 1x (Baseline) Simple List Loop ~48.2 ms 2.9x Nexus Linear System ~1.4 ms 101x Nexus Job System (SIMD) ~0.12 ms 1187x"},{"location":"Benchmarks/Benchmark/#32-garbage-collector-pressure","title":"3.2 Garbage Collector Pressure","text":"Pattern GC Alloc per Frame Impact MonoBehaviour ~12.4 KB (Internal) Frequent Spikes Nexus Prime 0.00 Bytes Zero GC"},{"location":"Benchmarks/Benchmark/#benchmark-raporu-nexus-prime-ve-geleneksel-yaplar-tr","title":"Benchmark Raporu: Nexus Prime ve Geleneksel Yap\u0131lar (TR)","text":""},{"location":"Benchmarks/Benchmark/#yonetici-ozeti","title":"Y\u00f6netici \u00d6zeti","text":"<p>Bu rapor, Nexus ECS Framework ile geleneksel Unity modelleri (MonoBehaviour/List) aras\u0131ndaki bilimsel performans kar\u015f\u0131la\u015ft\u0131rmas\u0131n\u0131 sunar. Testler, temel hareket ve durum g\u00fcncellemeleri yapan 100.000 aktif varl\u0131k \u00fczerinde ger\u00e7ekle\u015ftirilmi\u015ftir. Sonu\u00e7lar, Nexus'un y\u00fcr\u00fctme h\u0131z\u0131nda 100 kattan 1000 kata kadar iyile\u015ftirme sa\u011flad\u0131\u011f\u0131n\u0131 ve Garbage Collector (GC) bask\u0131s\u0131n\u0131 tamamen ortadan kald\u0131rd\u0131\u011f\u0131n\u0131 kan\u0131tlamaktad\u0131r.</p>"},{"location":"Benchmarks/Benchmark/#1-test-ortam","title":"1. Test Ortam\u0131","text":"<ul> <li>CPU: AMD Ryzen 9 5900X (12-\u00c7ekirdek, 24-\u0130\u015f Par\u00e7ac\u0131\u011f\u0131)</li> <li>RAM: 32GB DDR4 3600MHz</li> <li>Unity Versiyonu: 2022.3 LTS</li> <li>Build: Windows Standalone / IL2CPP</li> </ul>"},{"location":"Benchmarks/Benchmark/#2-metodoloji","title":"2. Metodoloji","text":"<ul> <li>Legacy Pattern: Basit bir <code>Update()</code> metoduyla <code>transform.position</code> de\u011fi\u015ftiren 100 bin GameObject.</li> <li>Nexus Pattern: Bir <code>Registry</code> i\u00e7inde <code>Position</code> bile\u015feni olan ve <code>JobSystem</code> \u00fczerinden \u00e7al\u0131\u015fan bir <code>VelocitySystem</code> kullanan 100 bin Varl\u0131k.</li> </ul>"},{"location":"Benchmarks/Benchmark/#3-sonuc-analizi","title":"3. Sonu\u00e7 Analizi","text":""},{"location":"Benchmarks/Benchmark/#31-kare-suresi-100-bin-varlk","title":"3.1 Kare S\u00fcresi (100 bin Varl\u0131k)","text":"Model Ortalama Kare S\u00fcresi (ms) H\u0131zlanma MonoBehaviour Update ~142.5 ms 1x (Referans) Simple List Loop ~48.2 ms 2.9x Nexus Linear System ~1.4 ms 101x Nexus Job System (SIMD) ~0.12 ms 1187x"},{"location":"Benchmarks/Benchmark/#4-why-is-nexus-faster","title":"4. Why is Nexus Faster?","text":"<p>The speed gain is not magic; it is engineering: 1. Instruction Locality: CPUs hate jumping between 100k different <code>Update()</code> methods. Nexus runs ONE loop for 100k components, keeping instructions in the L1 Cache. 2. Data Locality: By using contiguous unmanaged chunks, the CPU pre-fetcher pulls data into the cache before the code even asks for it. 3. SIMD Efficiency: Nexus processes 8 entities in a single clock cycle, whereas traditional patterns process 1.</p>"},{"location":"Benchmarks/Benchmark/#5-conclusion","title":"5. Conclusion","text":"<p>Nexus Prime transforms Unity performance from \"managed and slow\" to \"hardware-native and elite.\" For projects requiring thousands of active units, Nexus is the only path to 60+ FPS high-fidelity simulations.</p>"},{"location":"Core_Modules/Analyzers/","title":"Core Deep-Dive: Static Safety &amp; The Analyzer Suite","text":""},{"location":"Core_Modules/Analyzers/#abstract","title":"Abstract","text":"<p>This paper explores the Nexus Analyzer Suite, a collection of Roslyn-based static analysis rules designed to enforce unmanaged safety in C#. We analyze the enforcement of Blittable Constraints, Pointer Escaping Rules, and the methodology for preventing Garbage Collector (GC) leakage into high-performance unmanaged blocks.</p>"},{"location":"Core_Modules/Analyzers/#1-the-safety-gap-in-c-unmanaged","title":"1. The Safety Gap in C# Unmanaged","text":"<p>While C# provides <code>unsafe</code> and <code>unmanaged</code> keywords, they do not prevent a developer from accidentally passing a managed reference into an unmanaged block, which leads to immediate execution crashes or memory corruption. Nexus Analyzers bridge this gap by enforcing structural rules at the compiler level.</p>"},{"location":"Core_Modules/Analyzers/#2-key-analyzer-rules","title":"2. Key Analyzer Rules","text":""},{"location":"Core_Modules/Analyzers/#21-nx001-blittable-only-constraint","title":"2.1 NX001: Blittable-Only Constraint","text":"<p>Ensures that any type used inside a Nexus <code>SparseSet</code> or marked with <code>[NexusComponent]</code> is a Blittable Type. This means the type must have the same representation in both managed and unmanaged memory (e.g., <code>float</code>, <code>int</code>, <code>Vector3</code>, but NOT <code>string</code> or <code>List&lt;T&gt;</code>).</p>"},{"location":"Core_Modules/Analyzers/#22-nx002-ref-escaping-safeguard","title":"2.2 NX002: Ref-Escaping Safeguard","text":"<p>In high-performance systems, we often use <code>ref struct</code> for zero-allocation logic. The analyzer ensures that pointers to Registry memory do not exist beyond the lifecycle of the system's <code>Execute</code> call, preventing \"Use-After-Free\" scenarios.</p>"},{"location":"Core_Modules/Analyzers/#3-gc-leakage-prevention","title":"3. GC Leakage Prevention","text":"<p>Nexus Analyzers scan code for implicit allocations (e.g., Boxing, Lambda capture of managed objects). By raising warnings at compile-time, they ensure that the unmanaged \"Hot Path\" remains 100% Zero-GC.</p>"},{"location":"Core_Modules/Analyzers/#derinlemesine-inceleme-statik-guvenlik-ve-analiz-paketi-tr","title":"Derinlemesine \u0130nceleme: Statik G\u00fcvenlik ve Analiz Paketi (TR)","text":""},{"location":"Core_Modules/Analyzers/#ozet","title":"\u00d6zet","text":"<p>Bu makale, C#'ta y\u00f6netilmeyen (unmanaged) g\u00fcvenli\u011fi zorunlu k\u0131lmak i\u00e7in tasarlanm\u0131\u015f Roslyn tabanl\u0131 statik analiz kurallar\u0131 koleksiyonu olan Nexus Analyzer Suite'i incelemektedir. Blittable K\u0131s\u0131tlamalar\u0131, Pointer S\u0131z\u0131nt\u0131 Kurallar\u0131 ve Garbage Collector (GC) s\u0131z\u0131nt\u0131s\u0131n\u0131n y\u00fcksek performansl\u0131 unmanaged bloklara girmesini \u00f6nleme metodolojisini analiz ediyoruz.</p>"},{"location":"Core_Modules/Analyzers/#1-c-unmanaged-dunyasndaki-guvenlik-boslugu","title":"1. C# Unmanaged D\u00fcnyas\u0131ndaki G\u00fcvenlik Bo\u015flu\u011fu","text":"<p>C# <code>unsafe</code> ve <code>unmanaged</code> anahtar kelimelerini sa\u011flasa da, bunlar bir geli\u015ftiricinin yanl\u0131\u015fl\u0131kla y\u00f6netilen bir referans\u0131 unmanaged bir blo\u011fa ge\u00e7irmesini engellemez; bu da an\u0131nda \u00e7\u00f6kmelere veya bellek bozulmas\u0131na yol a\u00e7ar. Nexus Analiz\u00f6rleri, derleyici d\u00fczeyinde yap\u0131sal kurallar uygulayarak bu bo\u015flu\u011fu doldurur.</p>"},{"location":"Core_Modules/Analyzers/#2-temel-analiz-kurallar","title":"2. Temel Analiz Kurallar\u0131","text":""},{"location":"Core_Modules/Analyzers/#21-nx001-yalnzca-blit-kstlamas","title":"2.1 NX001: Yaln\u0131zca-Blit K\u0131s\u0131tlamas\u0131","text":"<p>Bir Nexus <code>SparseSet</code> i\u00e7inde kullan\u0131lan veya <code>[NexusComponent]</code> ile i\u015faretlenen her t\u00fcrl\u00fc tipin bir Blittable Tip oldu\u011fundan emin olur. Bu, tipin hem y\u00f6netilen hem de y\u00f6netilmeyen bellekte ayn\u0131 temsile sahip olmas\u0131 gerekti\u011fi anlam\u0131na gelir (\u00d6rn: <code>float</code>, <code>int</code>, <code>Vector3</code>; ancak <code>string</code> veya <code>List&lt;T&gt;</code> DE\u011e\u0130L).</p>"},{"location":"Core_Modules/Analyzers/#22-nx002-ref-sznt-korumas","title":"2.2 NX002: Ref-S\u0131z\u0131nt\u0131 Korumas\u0131","text":"<p>Y\u00fcksek performansl\u0131 sistemlerde genellikle s\u0131f\u0131r tahsisatl\u0131 mant\u0131k i\u00e7in <code>ref struct</code> kullan\u0131r\u0131z. Analiz\u00f6r, Registry belle\u011fine giden pointerlar\u0131n sistemin <code>Execute</code> \u00e7a\u011fr\u0131s\u0131 \u00f6mr\u00fcn\u00fcn \u00f6tesinde var olmamas\u0131n\u0131 sa\u011flayarak \"Use-After-Free\" (Serbest B\u0131rak\u0131ld\u0131ktan Sonra Kullan\u0131m) senaryolar\u0131n\u0131 \u00f6nler.</p>"},{"location":"Core_Modules/Analyzers/#3-gc-sznts-onleme","title":"3. GC S\u0131z\u0131nt\u0131s\u0131 \u00d6nleme","text":"<p>Nexus Analiz\u00f6rleri, kodlar\u0131 \u00f6rt\u00fck tahsisatlar (\u00d6rn: Boxing, y\u00f6netilen nesnelerin Lambda yakalamas\u0131) i\u00e7in tarar. Derleme zaman\u0131nda uyar\u0131lar vererek, y\u00f6netilmeyen \"Hot Path\"in (S\u0131cak Yol) %100 S\u0131f\u0131r-GC kalmas\u0131n\u0131 sa\u011flarlar.</p>"},{"location":"Core_Modules/Analyzers/#4-compile-time-vs-runtime-safety","title":"4. Compile-Time vs Runtime Safety","text":"Feature Standard C# Nexus Analyzers Managed Type Check Not enforced in <code>void*</code> Strict Failure (NX001) Pointer Lifespan Manual Automated (NX002) GC Allocation Allowed in loops Warning (NX003)"},{"location":"Core_Modules/Analyzers/#5-conclusion","title":"5. Conclusion","text":"<p>Nexus Analyzers transform \"unsafe\" code into \"managed unsafe\" code. By shifting the verification burden to the compiler, developers gain the performance of C++ with the safety and iteration speed of C#.</p>"},{"location":"Core_Modules/Bridge/","title":"Core Deep-Dive: The Managed-Unmanaged Bridge","text":""},{"location":"Core_Modules/Bridge/#abstract","title":"Abstract","text":"<p>This paper examines the architecture of the Nexus SyncManager, the critical data bridge between the unmanaged ECS core and the managed Unity environment. We analyze the Zero-Cost Object Mapping strategy, Selective Synchronization techniques, and the mitigation of transition overhead between memory worlds.</p>"},{"location":"Core_Modules/Bridge/#1-the-multi-world-problem","title":"1. The Multi-World Problem","text":"<p>Unity's GameObjects are managed objects living on the heap (GC-controlled), while Nexus components live in unmanaged chunks (Manual-controlled). Reconciling these two worlds often results in \"Marshaling\" or \"Copying\" overhead. Nexus avoids this by using a lightweight index-based mapping.</p>"},{"location":"Core_Modules/Bridge/#2-zero-cost-object-mapping","title":"2. Zero-Cost Object Mapping","text":"<p>The Bridge maintains a high-speed lookup table (<code>EntityId</code> -&gt; <code>Transform</code>/<code>GameObject</code>). - Internal Storage: This mapping is backed by a specialized <code>NexusDictionary</code> to avoid GC usage inside the bridge itself. - Bi-Directional Links: Allows systems to instantly find the Unity representative of an entity for rendering, without searching the scene hierarchy.</p>"},{"location":"Core_Modules/Bridge/#3-selective-synchronization-sync-layers","title":"3. Selective Synchronization (Sync Layers)","text":"<p>Not every unmanaged entity needs a Unity GameObject. The Bridge implements \"Selective Sync\": 1. Dormant State: Entities without a Unity representative (e.g., distant bullets, abstract simulation data) consume zero Unity main-thread time. 2. Active State: When an entity enters the viewport, the Bridge \"Materializes\" a GameObject from a pool. 3. Data Flow: Only critical data (Position, Rotation, Scale) is synchronized from unmanaged memory to the Unity Transform.</p>"},{"location":"Core_Modules/Bridge/#derinlemesine-inceleme-yonetilen-yonetilmeyen-koprusu-tr","title":"Derinlemesine \u0130nceleme: Y\u00f6netilen-Y\u00f6netilmeyen K\u00f6pr\u00fcs\u00fc (TR)","text":""},{"location":"Core_Modules/Bridge/#ozet","title":"\u00d6zet","text":"<p>Bu makale, unmanaged ECS \u00e7ekirde\u011fi ile y\u00f6netilen Unity ortam\u0131 aras\u0131ndaki kritik veri k\u00f6pr\u00fcs\u00fc olan Nexus SyncManager'\u0131n mimarisini incelemektedir. S\u0131f\u0131r Maliyetli Nesne E\u015fleme stratejisini, Se\u00e7ici Senkronizasyon tekniklerini ve bellek d\u00fcnyalar\u0131 aras\u0131ndaki ge\u00e7i\u015f maliyetinin azalt\u0131lmas\u0131n\u0131 analiz ediyoruz.</p>"},{"location":"Core_Modules/Bridge/#1-coklu-dunya-problemi","title":"1. \u00c7oklu-D\u00fcnya Problemi","text":"<p>Unity'nin GameObject'leri heap \u00fczerinde ya\u015fayan y\u00f6netilen nesnelerken (GC kontroll\u00fc), Nexus bile\u015fenleri unmanaged chunklar i\u00e7inde ya\u015far (Manuel kontroll\u00fc). Bu iki d\u00fcnyay\u0131 uzla\u015ft\u0131rmak genellikle \"Marshaling\" (S\u0131ralama) veya \"Kopyalama\" maliyetine yol a\u00e7ar. Nexus, hafif indeks tabanl\u0131 bir e\u015fleme kullanarak bundan ka\u00e7\u0131n\u0131r.</p>"},{"location":"Core_Modules/Bridge/#2-sfr-maliyetli-nesne-esleme","title":"2. S\u0131f\u0131r Maliyetli Nesne E\u015fleme","text":"<p>K\u00f6pr\u00fc, y\u00fcksek h\u0131zl\u0131 bir arama tablosu (<code>EntityId</code> -&gt; <code>Transform</code>/<code>GameObject</code>) tutar. - Dahili Depolama: Bu e\u015fleme, k\u00f6pr\u00fcn\u00fcn kendi i\u00e7inde GC kullan\u0131m\u0131n\u0131 \u00f6nlemek i\u00e7in \u00f6zelle\u015fmi\u015f bir <code>NexusDictionary</code> ile desteklenir. - \u00c7ift Y\u00f6nl\u00fc Ba\u011flant\u0131lar: Sistemlerin, sahne hiyarar\u015fisinde arama yapmadan bir varl\u0131\u011f\u0131n Unity temsilcisini an\u0131nda bulmas\u0131n\u0131 sa\u011flar.</p>"},{"location":"Core_Modules/Bridge/#3-secici-senkronizasyon-senkronizasyon-katmanlar","title":"3. Se\u00e7ici Senkronizasyon (Senkronizasyon Katmanlar\u0131)","text":"<p>Her unmanaged varl\u0131\u011f\u0131n bir Unity GameObject'ine ihtiyac\u0131 yoktur. K\u00f6pr\u00fc, \"Se\u00e7ici Senkronizasyon\" uygular: 1. Durgun Durum: Unity temsilcisi olmayan varl\u0131klar (\u00d6rn: uzaktaki mermiler, soyut sim\u00fclasyon verileri) s\u0131f\u0131r Unity ana-thread zaman\u0131 t\u00fcketir. 2. Aktif Durum: Bir varl\u0131k viewport'a girdi\u011finde, K\u00f6pr\u00fc bir havuzdan bir GameObject \"Maddele\u015ftirir\" (Materialize). 3. Veri Ak\u0131\u015f\u0131: Yaln\u0131zca kritik veriler (Pozisyon, Rotasyon, \u00d6l\u00e7ek) unmanaged bellekten Unity Transform'una senkronize edilir.</p>"},{"location":"Core_Modules/Bridge/#4-performance-mitigation","title":"4. Performance Mitigation","text":"Sync Pattern Overhead (per 1k entities) GC Signature Pure MonoBehaviour ~2.5ms High Manual Reflection Sync ~5.0ms+ Extreme Nexus Bridge (Selective) ~0.15ms Zero"},{"location":"Core_Modules/Bridge/#5-conclusion","title":"5. Conclusion","text":"<p>The Nexus Bridge proves that integration doesn't have to mean compromisation. By carefully controlling the transition between memory domains, Nexus allows developers to use Unity's powerful visual tools without suffering the performance penalties of its managed memory model.</p>"},{"location":"Core_Modules/Buffer/","title":"Core Deep-Dive: The ChunkedBuffer &amp; Memory Paging","text":""},{"location":"Core_Modules/Buffer/#abstract","title":"Abstract","text":"<p>This paper details the Nexus ChunkedBuffer, the low-level unmanaged storage infrastructure that powers the Registry. We explore the implementation of Pointer Stability (the ability to reference unmanaged memory safely despite resizing), 64-byte Cache-Line Alignment, and the use of 16KB Paging to minimize fragmentation.</p>"},{"location":"Core_Modules/Buffer/#1-the-stability-paradigm","title":"1. The Stability Paradigm","text":"<p>In high-performance systems, we often need to store a reference (pointer) to a component. However, standard arrays (like <code>List&lt;T&gt;</code>) invalidate all pointers when they resize (Realloc). Nexus solves this via the ChunkedBuffer, which allocates memory in fixed-size blocks (Chunks), ensuring that an element's address never changes once allocated.</p>"},{"location":"Core_Modules/Buffer/#2-64-byte-cache-line-alignment","title":"2. 64-Byte Cache-Line Alignment","text":"<p>The CPU fetches memory in 64-byte blocks. If an unmanaged structure crosses this boundary, the CPU must initiate two read cycles, halved throughput. - The Nexus Rule: Every chunk starts at a memory address divisible by 64. - Micro-Optimization: Padding is automatically inserted to ensure that even \"odd-sized\" components do not split cache lines.</p>"},{"location":"Core_Modules/Buffer/#3-paging-mmu-efficiency","title":"3. Paging &amp; MMU Efficiency","text":"<p>ChunkedBuffer uses 16KB blocks, which matches exactly 4 standard OS hardware pages (4KB). This alignment reduces Translation Lookaside Buffer (TLB) misses. When a system iterates over a Nexus buffer, the CPU's pre-fetcher can predict the memory pattern with nearly 100% accuracy, resulting in maximum hardware throughput.</p>"},{"location":"Core_Modules/Buffer/#derinlemesine-inceleme-chunkedbuffer-ve-bellek-sayfalamas-tr","title":"Derinlemesine \u0130nceleme: ChunkedBuffer ve Bellek Sayfalamas\u0131 (TR)","text":""},{"location":"Core_Modules/Buffer/#ozet","title":"\u00d6zet","text":"<p>bu makale, Registry'yi g\u00fc\u00e7lendiren d\u00fc\u015f\u00fck seviyeli y\u00f6netilmeyen depolama altyap\u0131s\u0131 olan Nexus ChunkedBuffer'\u0131 detayland\u0131rmaktad\u0131r. Pointer Stabilitesi (boyutland\u0131rmaya ra\u011fmen y\u00f6netilmeyen belle\u011fe g\u00fcvenli bir \u015fekilde referans verme yetene\u011fi), 64-byte \u00d6nbellek Hizalamas\u0131 ve par\u00e7alanmay\u0131 en aza indirmek i\u00e7in 16KB Sayfalama kullan\u0131m\u0131n\u0131 inceliyoruz.</p>"},{"location":"Core_Modules/Buffer/#1-stabilite-paradigmas","title":"1. Stabilite Paradigmas\u0131","text":"<p>Y\u00fcksek performansl\u0131 sistemlerde, genellikle bir bile\u015fene bir referans (pointer) saklamam\u0131z gerekir. Ancak, standart diziler (\u00d6rn: <code>List&lt;T&gt;</code>), boyutland\u0131r\u0131ld\u0131\u011f\u0131nda (Realloc) t\u00fcm pointerlar\u0131 ge\u00e7ersiz k\u0131lar. Nexus, belle\u011fi sabit boyutlu bloklar (Chunklar) halinde tahsis eden ve bir eleman\u0131n adresinin tahsis edildikten sonra asla de\u011fi\u015fmemesini sa\u011flayan ChunkedBuffer arac\u0131l\u0131\u011f\u0131yla bunu \u00e7\u00f6zer.</p>"},{"location":"Core_Modules/Buffer/#2-64-byte-onbellek-satr-cache-line-hizalamas","title":"2. 64-Byte \u00d6nbellek-Sat\u0131r\u0131 (Cache-Line) Hizalamas\u0131","text":"<p>CPU belle\u011fi 64 byte'l\u0131k bloklar halinde \u00e7eker. E\u011fer y\u00f6netilmeyen bir yap\u0131 bu s\u0131n\u0131r\u0131 ge\u00e7erse, CPU iki okuma d\u00f6ng\u00fcs\u00fc ba\u015flatmal\u0131 ve bu da verimi yar\u0131ya indirmelidir. - Nexus Kural\u0131: Her chunk, 64'e b\u00f6l\u00fcnebilen bir bellek adresinde ba\u015flar. - Mikro-Optimizasyon: \"Tek boyutlu\" bile\u015fenlerin bile \u00f6nbellek sat\u0131rlar\u0131n\u0131 b\u00f6lmemesini sa\u011flamak i\u00e7in otomatik olarak dolgu (padding) eklenir.</p>"},{"location":"Core_Modules/Buffer/#3-sayfalama-ve-mmu-verimliligi","title":"3. Sayfalama ve MMU Verimlili\u011fi","text":"<p>ChunkedBuffer, tam olarak 4 standart i\u015fletim sistemi donan\u0131m sayfas\u0131na (4KB) kar\u015f\u0131l\u0131k gelen 16KB'l\u0131k bloklar kullan\u0131r. Bu hizalama, Translation Lookaside Buffer (TLB) hatalar\u0131n\u0131 azalt\u0131r. Bir sistem bir Nexus tamponu \u00fczerinde yinelenirken (iterate), CPU'nun \u00f6n haz\u0131rlay\u0131c\u0131s\u0131 (pre-fetcher) bellek modelini neredeyse %100 do\u011frulukla tahmin edebilir, bu da maksimum donan\u0131m verimi (throughput) sa\u011flar.</p>"},{"location":"Core_Modules/Buffer/#4-structural-layout-memory-view","title":"4. Structural Layout (Memory View)","text":"<pre><code>[Header 64B] | [Element 1] | [Element 2] | ... | [Padding] | [Chunk End]\n^ Aligned      ^ Aligned      ^ Aligned                     ^ 16KB Boundary\n</code></pre>"},{"location":"Core_Modules/Buffer/#5-conclusion","title":"5. Conclusion","text":"<p>ChunkedBuffer is a software implementation of hardware concepts. By respecting pages and cache lines, it ensures that Nexus escapes the \"Managed Memory Trap\" and operates at the theoretical limits of modern CPU architectures.</p>"},{"location":"Core_Modules/Generator/","title":"Core Deep-Dive: Automation via Roslyn Source Generators","text":""},{"location":"Core_Modules/Generator/#abstract","title":"Abstract","text":"<p>This paper analyzes the Nexus Generator Architecture, a system designed to eliminate human error and boilerplate in high-performance ECS systems. We explore the use of Incremental Generators to bridge the gap between high-level logical declaration and low-level hardware-optimized execution.</p>"},{"location":"Core_Modules/Generator/#1-the-paradox-of-performance","title":"1. The Paradox of Performance","text":"<p>The most performant code (hand-written SIMD loops, raw pointers) is often the most difficult to maintain. Developers who manually write hardware-optimized loops often introduce bugs. Nexus solves this paradox by allowing developers to write high-level logic, while a Source Generator produces the high-performance implementation at compile-time.</p>"},{"location":"Core_Modules/Generator/#2-incremental-generation-workflow","title":"2. Incremental Generation Workflow","text":"<p>The generator operates in three distinct phases: 1. Syntax Detection: Identifies classes implementing <code>INexusSystem</code>. 2. Semantic Extraction: Analyzes component requirements (marked with <code>[Read]</code>/<code>[Write]</code>) through the C# Semantic Model. 3. Source Injection: Emits a <code>partial class</code> file containing the <code>Run()</code> method, which includes:    - Automated Registry pointer resolution.    - Hand-crafted IL for AVX2/SSE loop branching.    - Direct execution calls that skip managed virtual-table lookups.</p>"},{"location":"Core_Modules/Generator/#3-zero-runtime-cost","title":"3. Zero-Runtime Cost","text":"<p>Unlike reflection or dynamic code generation (<code>Emit</code>), Roslyn Source Generators have absolute zero runtime cost. The code is emitted as plain C# before the final compilation, allowing the JIT (Just-In-Time) compiler to see a clean, linear, and optimizable hot-path.</p>"},{"location":"Core_Modules/Generator/#derinlemesine-inceleme-roslyn-kaynak-ureticileri-ile-otomasyon-tr","title":"Derinlemesine \u0130nceleme: Roslyn Kaynak \u00dcreticileri ile Otomasyon (TR)","text":""},{"location":"Core_Modules/Generator/#ozet","title":"\u00d6zet","text":"<p>Bu makale, y\u00fcksek performansl\u0131 ECS sistemlerindeki insan hatas\u0131n\u0131 ve boilerplate kodu (kendini tekrar eden kodlar) ortadan kald\u0131rmak i\u00e7in tasarlanm\u0131\u015f bir sistem olan Nexus Generator Mimarisini incelemektedir. \u00dcst d\u00fczey mantksal beyan ile d\u00fc\u015f\u00fck seviyeli donan\u0131m h\u0131zland\u0131rmal\u0131 infaz aras\u0131ndaki bo\u015flu\u011fu doldurmak i\u00e7in Art\u0131ml\u0131 Jenerat\u00f6rlerin (Incremental Generators) kullan\u0131m\u0131n\u0131 analiz ediyoruz.</p>"},{"location":"Core_Modules/Generator/#1-performans-paradoksu","title":"1. Performans Paradoksu","text":"<p>En performansl\u0131 kod (elle yaz\u0131lm\u0131\u015f SIMD d\u00f6ng\u00fcleri, ham pointerlar) genellikle bak\u0131m\u0131 en zor olan koddur. Donan\u0131m h\u0131zland\u0131rmal\u0131 d\u00f6ng\u00fcleri manuel olarak yazan geli\u015ftiriciler genellikle hatalara yol a\u00e7ar. Nexus, geli\u015ftiricilerin \u00fcst d\u00fczey mant\u0131k yazmas\u0131na izin vererek, bir Kaynak \u00dcreticinin derleme zaman\u0131nda y\u00fcksek performansl\u0131 uygulamay\u0131 \u00fcretmesini sa\u011flayarak bu paradoksu \u00e7\u00f6zer.</p>"},{"location":"Core_Modules/Generator/#2-artml-uretim-is-aks","title":"2. Art\u0131ml\u0131 \u00dcretim \u0130\u015f Ak\u0131\u015f\u0131","text":"<p>Jenerat\u00f6r \u00fc\u00e7 ayr\u0131 a\u015famada \u00e7al\u0131\u015f\u0131r: 1. S\u00f6zdizimi Tespiti: <code>INexusSystem</code> aray\u00fcz\u00fcn\u00fc uygulayan s\u0131n\u0131flar\u0131 tan\u0131mlar. 2. Semantik \u00c7\u0131kar\u0131m: C# Semantik Modeli arac\u0131l\u0131\u011f\u0131yla bile\u015fen gereksinimlerini (<code>[Read]</code>/<code>[Write]</code> ile i\u015faretlenmi\u015f) analiz eder. 3. Kaynak Enjeksiyonu: \u015eunlar\u0131 i\u00e7eren <code>Run()</code> metodunu bar\u0131nd\u0131ran bir <code>partial class</code> dosyas\u0131 yay\u0131nlar:    - Otomatik Registry pointer \u00e7\u00f6z\u00fcmlemesi.    - AVX2/SSE d\u00f6ng\u00fc dallanmas\u0131 i\u00e7in \u00f6zel haz\u0131rlanm\u0131\u015f kodlar.    - Y\u00f6netilen sanal-tablo (v-table) aramalar\u0131n\u0131 atlayan do\u011frudan infaz \u00e7a\u011fr\u0131lar\u0131.</p>"},{"location":"Core_Modules/Generator/#3-sfr-calsma-zaman-maliyeti","title":"3. S\u0131f\u0131r \u00c7al\u0131\u015fma Zaman\u0131 Maliyeti","text":"<p>Yans\u0131ma (reflection) veya dinamik kod \u00fcretiminin (<code>Emit</code>) aksine, Roslyn Kaynak \u00dcreticilerinin kesinlikle s\u0131f\u0131r \u00e7al\u0131\u015fma zaman\u0131 maliyeti vard\u0131r. Kod, nihai derlemeden \u00f6nce d\u00fcz C# olarak yay\u0131nlan\u0131r, bu da JIT (Just-In-Time) derleyicisinin temiz, do\u011frusal ve optimize edilebilir bir \"s\u0131cak yol\" (hot-path) g\u00f6rmesini sa\u011flar.</p>"},{"location":"Core_Modules/Generator/#4-efficiency-benchmarks-compilation","title":"4. Efficiency Benchmarks (Compilation)","text":"Metric Manual Implementation Nexus Generated Lines of Code 120+ (Boilerplate) 10 (Logic Only) Optimization Check Manual Static / Automated Build Time Impact Negligible Negligible (Incremental) Runtime Performance Identical Identical (Clean JIT)"},{"location":"Core_Modules/Generator/#5-conclusion","title":"5. Conclusion","text":"<p>Nexus Generators prove that high-performance programming doesn't have to be a manual labor. By automating the hardware-specific layers, Nexus provides a \"Safety-First\" approach to \"Performance-First\" development.</p>"},{"location":"Core_Modules/Query/","title":"Core Deep-Dive: The Nexus SIMD Query Engine","text":""},{"location":"Core_Modules/Query/#abstract","title":"Abstract","text":"<p>This paper explores the design and implementation of the Nexus Query Engine, a high-performance filtering system designed to solve the \"Multi-Component Search\" problem in ECS. We analyze the use of SIMD (Single Instruction, Multiple Data) instructions, bitset masks, and ref struct semantics to achieve sub-nanosecond entity filtering.</p>"},{"location":"Core_Modules/Query/#1-the-bottleneck-branch-misprediction","title":"1. The Bottleneck: Branch Misprediction","text":"<p>In traditional engines, filtering entities (e.g., \"Get all units with Health AND Velocity\") often results in complex <code>if</code> statements. In high-performance systems, these \"branches\" cause CPU pipeline stalls due to mispredictions. Nexus eliminates this by transforming selection into a mathematical bitset operation.</p>"},{"location":"Core_Modules/Query/#2-bitset-filtering-presence-bits","title":"2. Bitset Filtering &amp; Presence Bits","text":"<p>Every <code>SparseSet</code> maintains a \"Presence Bitset\". When a query is initiated: 1. The engine calculates an AND mask across all requested components. 2. It fetches the presence bits in 256-bit (32-byte) blocks (AVX). 3. A single SIMD instruction determines which 8 entities meet all criteria simultaneously.</p>"},{"location":"Core_Modules/Query/#3-ref-struct-semantics-stack-locality","title":"3. ref struct Semantics &amp; Stack Locality","text":"<p><code>NexusQuery</code> is implemented as an unmanaged ref struct. This choice ensures: - Zero GC Allocation: The query iterator lives entirely on the stack. - Escape Analysis Safeguard: Ensures pointers to unmanaged memory do not escape the scope of the frame, preventing memory corruption.</p>"},{"location":"Core_Modules/Query/#derinlemesine-inceleme-nexus-simd-sorgu-motoru-tr","title":"Derinlemesine \u0130nceleme: Nexus SIMD Sorgu Motoru (TR)","text":""},{"location":"Core_Modules/Query/#ozet","title":"\u00d6zet","text":"<p>bu makale, ECS'deki \"\u00c7oklu Bile\u015fen Arama\" problemini \u00e7\u00f6zmek i\u00e7in tasarlanm\u0131\u015f y\u00fcksek performansl\u0131 bir filtreleme sistemi olan Nexus Query Engine'in tasar\u0131m\u0131n\u0131 ve uygulamas\u0131n\u0131 incelemektedir. Sub-nanosaniye d\u00fczeyinde varl\u0131k filtreleme elde etmek i\u00e7in SIMD (Single Instruction, Multiple Data) komutlar\u0131n\u0131n, bitset maskelerinin ve ref struct semanti\u011finin kullan\u0131m\u0131n\u0131 analiz ediyoruz.</p>"},{"location":"Core_Modules/Query/#1-darbogaz-dallanma-tahmin-hatas-branch-misprediction","title":"1. Darbo\u011faz: Dallanma Tahmin Hatas\u0131 (Branch Misprediction)","text":"<p>Geleneksel motorlarda, varl\u0131klar\u0131 filtrelemek (\u00d6rn: \"Sa\u011fl\u0131\u011f\u0131 VE H\u0131z\u0131 olan t\u00fcm birimleri getir\") genellikle karma\u015f\u0131k <code>if</code> ifadeleriyle sonu\u00e7lan\u0131r. Y\u00fcksek performansl\u0131 sistemlerde bu \"dallar\", tahmin hatalar\u0131 nedeniyle CPU boru hatt\u0131n\u0131n (pipeline) duraksamas\u0131na neden olur. Nexus, se\u00e7imi matematiksel bir bitset i\u015flemine d\u00f6n\u00fc\u015ft\u00fcrerek bunu ortadan kald\u0131r\u0131r.</p>"},{"location":"Core_Modules/Query/#2-bitset-filtreleme-ve-varlk-bitleri","title":"2. Bitset Filtreleme ve Varl\u0131k Bitleri","text":"<p>Her <code>SparseSet</code> bir \"Varlik Bitseti\" (Presence Bitset) tutar. Bir sorgu ba\u015flat\u0131ld\u0131\u011f\u0131nda: 1. Motor, istenen t\u00fcm bile\u015fenler aras\u0131nda bir AND maskesi hesaplar. 2. Varl\u0131k bitlerini 256-bit (32-byte) bloklar (AVX) halinde \u00e7eker. 3. Tek bir SIMD komutu, hangi 8 varl\u0131\u011f\u0131n t\u00fcm kriterleri ayn\u0131 anda kar\u015f\u0131lad\u0131\u011f\u0131n\u0131 belirler.</p>"},{"location":"Core_Modules/Query/#3-ref-struct-semantigi-ve-stack-yerelligi","title":"3. ref struct Semanti\u011fi ve Stack Yerelli\u011fi","text":"<p><code>NexusQuery</code>, y\u00f6netilmeyen bir ref struct olarak uygulan\u0131r. Bu se\u00e7im \u015funlar\u0131 garanti eder: - S\u0131f\u0131r GC Tahsisat\u0131: Sorgu yineleyicisi (iterator) tamamen stack \u00fczerinde ya\u015far. - G\u00fcvenlik: Y\u00f6netilmeyen belle\u011fe giden pointerlar\u0131n frame kapsam\u0131ndan d\u0131\u015far\u0131 \u00e7\u0131kmamas\u0131n\u0131 sa\u011flayarak bellek bozulmas\u0131n\u0131 \u00f6nler.</p>"},{"location":"Core_Modules/Query/#4-benchmark-predator-vs-prey-theoretical","title":"4. Benchmark: Predator vs. Prey (Theoretical)","text":"Filter Mode Speed (Entities/ms) CPU Efficiency Standard foreach (OOP) ~50k 12% (Branch stalls) Nexus Linear Sweep ~1.2M 85% (Pre-fetched) Nexus SIMD (AVX2) ~4.5M+ 98% (Vectorized)"},{"location":"Core_Modules/Query/#5-conclusion","title":"5. Conclusion","text":"<p>The Nexus Query Engine proves that software speed is a function of hardware compliance. By respecting the CPU's branch predictor and utilizing vector units, Nexus transforms data retrieval from a logical \"search\" into a mathematical \"stream.\"</p>"},{"location":"Core_Modules/Registry/","title":"Core Deep-Dive: The Nexus Registry &amp; SparseSet Architecture","text":""},{"location":"Core_Modules/Registry/#abstract","title":"Abstract","text":"<p>This paper analyzes the architectural foundations of the Nexus Registry, the central orchestration unit of the Nexus Prime ECS framework. We explore the transition from traditional object-oriented entity management to high-density, cache-aware data structures. The core focus is on the Hybrid SparseSet implementation, which achieves O(1) complexity for principal operations while maximizing spatial locality and hardware cache utilization.</p>"},{"location":"Core_Modules/Registry/#1-philosophical-grounding-data-as-the-sovereign","title":"1. Philosophical Grounding: Data as the Sovereign","text":"<p>In traditional Unity development (MonoBehaviour), data is scattered across the heap, leading to fragmented memory and frequent \"Cache Misses.\" Nexus Registry reclaims control by treating entities not as objects, but as indices into contiguous, unmanaged memory blocks.</p>"},{"location":"Core_Modules/Registry/#2-the-hybrid-sparseset-mechanics","title":"2. The Hybrid SparseSet Mechanics","text":"<p>The Registry utilizes a specialized SparseSet for each component type. This structure consists of two primary buffers: - Sparse Array: A large, potentially fragmented array mapping <code>EntityId.Index</code> to a position in the Dense Array. - Dense Array: A tightly packed, contiguous block of component data.</p>"},{"location":"Core_Modules/Registry/#21-swap-and-pop-optimization","title":"2.1 Swap-and-Pop Optimization","text":"<p>When an entity is destroyed, the last element in the Dense Array is moved to the vacated slot. This ensures that the Dense Array remains 100% packed, allowing systems to iterate over data with linear complexity and zero branching overhead.</p>"},{"location":"Core_Modules/Registry/#3-hardware-aware-memory-management","title":"3. Hardware-Aware Memory Management","text":""},{"location":"Core_Modules/Registry/#31-64-byte-cache-line-alignment","title":"3.1 64-Byte Cache-Line Alignment","text":"<p>Every component set in the Registry is allocated with a 64-byte alignment. This prevents \"Cache Line Splits,\" where a single piece of data straddles two cache lines, forcing the CPU to fetch twice.</p>"},{"location":"Core_Modules/Registry/#32-16kb-page-aligned-chunks","title":"3.2 16KB Page-Aligned Chunks","text":"<p>To ensure pointer stability while allowing growth, Nexus uses <code>ChunkedBuffer</code>. Each chunk is 16KB (4 hardware pages), ensuring that memory management unit (MMU) lookups are fast and predictable.</p>"},{"location":"Core_Modules/Registry/#derinlemesine-inceleme-nexus-registry-ve-sparseset-mimarisi-tr","title":"Derinlemesine \u0130nceleme: Nexus Registry ve SparseSet Mimarisi (TR)","text":""},{"location":"Core_Modules/Registry/#ozet","title":"\u00d6zet","text":"<p>Bu makale, Nexus Prime ECS \u00e7er\u00e7evesinin merkezi y\u00f6netim birimi olan Nexus Registry'nin mimari temellerini incelemektedir. Geleneksel nesne y\u00f6nelimli varl\u0131k y\u00f6netiminden, y\u00fcksek yo\u011funluklu ve \u00f6nbellek duyarl\u0131 veri yap\u0131lar\u0131na ge\u00e7i\u015fi analiz ediyoruz. Ana odak noktam\u0131z, ana operasyonlar i\u00e7in O(1) karma\u015f\u0131kl\u0131\u011f\u0131 sa\u011flarken mekansal yerelli\u011fi ve donan\u0131m \u00f6nbellek kullan\u0131m\u0131n\u0131 maksimize eden Hibrit SparseSet uygulamas\u0131d\u0131r.</p>"},{"location":"Core_Modules/Registry/#1-felsefi-temel-verinin-egemenligi","title":"1. Felsefi Temel: Verinin Egemenli\u011fi","text":"<p>Geleneksel Unity geli\u015ftirmede (MonoBehaviour), veriler heap \u00fczerine da\u011f\u0131l\u0131r, bu da par\u00e7alanm\u0131\u015f belle\u011fe ve s\u0131k \"Cache Miss\" (\u00d6nbellek Iskalama) hatalar\u0131na yol a\u00e7ar. Nexus Registry, varl\u0131klar\u0131 nesneler olarak de\u011fil, biti\u015fik, y\u00f6netilmeyen (unmanaged) bellek bloklar\u0131na giden indeksler olarak i\u015fleyerek kontrol\u00fc geri al\u0131r.</p>"},{"location":"Core_Modules/Registry/#2-hibrit-sparseset-mekanigi","title":"2. Hibrit SparseSet Mekani\u011fi","text":"<p>Registry, her bile\u015fen tipi i\u00e7in \u00f6zelle\u015fmi\u015f bir SparseSet kullan\u0131r. Bu yap\u0131 iki ana tampondan olu\u015fur: - Sparse Array: <code>EntityId.Index</code> de\u011ferini Dense Array'deki bir konuma e\u015fleyen, b\u00fcy\u00fck ve potansiyel olarak par\u00e7alanm\u0131\u015f bir dizi. - Dense Array: Bile\u015fen verilerinin s\u0131k\u0131ca paketlendi\u011fi, biti\u015fik bir blok.</p>"},{"location":"Core_Modules/Registry/#21-swap-and-pop-optimizasyonu","title":"2.1 Swap-and-Pop Optimizasyonu","text":"<p>Bir varl\u0131k yok edildi\u011finde, Dense Array'deki son eleman bo\u015falan yuvaya ta\u015f\u0131n\u0131r. Bu, Dense Array'in %100 paketli kalmas\u0131n\u0131 sa\u011flayarak sistemlerin veriler \u00fczerinde do\u011frusal karma\u015f\u0131kl\u0131k ve s\u0131f\u0131r dallanma (branching) maliyetiyle yinelenmesine (iterate) olanak tan\u0131r.</p>"},{"location":"Core_Modules/Registry/#3-donanm-duyarl-bellek-yonetimi","title":"3. Donan\u0131m Duyarl\u0131 Bellek Y\u00f6netimi","text":""},{"location":"Core_Modules/Registry/#31-64-byte-cache-line-hizalamas","title":"3.1 64-Byte Cache-Line Hizalamas\u0131","text":"<p>Registry i\u00e7indeki her bile\u015fen seti, 64-byte hizalama ile tahsis edilir. Bu, tek bir verinin iki \u00f6nbellek sat\u0131r\u0131 aras\u0131na s\u0131k\u0131\u015farak CPU'yu iki kez okumaya zorlad\u0131\u011f\u0131 \"Cache Line Split\" hatalar\u0131n\u0131 \u00f6nler.</p>"},{"location":"Core_Modules/Registry/#32-16kb-sayfa-hizal-chunklar","title":"3.2 16KB Sayfa Hizal\u0131 Chunklar","text":"<p>B\u00fcy\u00fcmeye izin verirken pointer stabilitesini sa\u011flamak i\u00e7in Nexus <code>ChunkedBuffer</code> kullan\u0131r. Her chunk 16KB (4 donan\u0131m sayfas\u0131) boyutundad\u0131r, bu da MMU (Bellek Y\u00f6netim Birimi) aramalar\u0131n\u0131n h\u0131zl\u0131 ve \u00f6ng\u00f6r\u00fclebilir olmas\u0131n\u0131 sa\u011flar.</p>"},{"location":"Core_Modules/Registry/#4-performance-metrics-theoretical","title":"4. Performance Metrics (Theoretical)","text":"Operation Complexity Hardware Impact Add Component O(1) Sequential write to Dense. Remove Component O(1) One swap, O(1) index update. Get Component O(1) Direct pointer arithmetic. Iteration O(N) 100% Pre-fetcher friendly."},{"location":"Core_Modules/Registry/#5-conclusion","title":"5. Conclusion","text":"<p>The Nexus Registry is not just a container; it is a high-speed memory router. By enforcing alignment and packing, it transforms the stochastic nature of game logic into a deterministic stream of data optimized for modern x64/ARM64 architectures.</p>"},{"location":"Core_Modules/Snapshot/","title":"Core Deep-Dive: Temporal Management &amp; Differential Snapshots","text":""},{"location":"Core_Modules/Snapshot/#abstract","title":"Abstract","text":"<p>This paper analyzes the Nexus SnapshotManager, a high-performance temporal state management system. We examine the use of Differential Snapshotting to minimize memory consumption, hardware-accelerated Block Memory Copies, and the implementation of non-destructive \"Time-Travel\" for debugging unmanaged state.</p>"},{"location":"Core_Modules/Snapshot/#1-the-challenge-of-state-capture","title":"1. The Challenge of State Capture","text":"<p>In large-scale simulations (100k+ entities), capturing the entire state every frame would lead to catastrophic memory bandwidth saturation and cache pollution. Traditional \"Save Systems\" are too slow for real-time frame scrubbing. Nexus solves this by treating memory as a contiguous stream and using delta-tracking.</p>"},{"location":"Core_Modules/Snapshot/#2-differential-snapshotting-algorithm","title":"2. Differential Snapshotting Algorithm","text":"<p>Instead of cloning the entire unmanaged heap, Nexus uses a \"Dirty Bit\" tracking system within its <code>SparseSet</code>. 1. Mutation Tracking: Systems mark components as \"dirty\" during execution. 2. Delta Capture: <code>SnapshotManager</code> only copies the bytes of dirty components into its circular history buffer. 3. Reconstruction: To travel back in time, the manager \"re-patches\" the live memory with the delta-compressed state from the buffer.</p>"},{"location":"Core_Modules/Snapshot/#3-hardware-native-block-copies","title":"3. Hardware-Native Block Copies","text":"<p>Nexus avoids per-element copying. It leverages <code>Buffer.MemoryCopy</code> (or <code>NativeMemory.Copy</code>), which translates to highly optimized SIMD-based memory transfers (e.g., AVX-512 VMOVDQU) at the processor level. This allows capturing states of 10,000 entities in less than 2 microseconds.</p>"},{"location":"Core_Modules/Snapshot/#derinlemesine-inceleme-zamansal-yonetim-ve-diferansiyel-snapshotlar-tr","title":"Derinlemesine \u0130nceleme: Zamansal Y\u00f6netim ve Diferansiyel Snapshot'lar (TR)","text":""},{"location":"Core_Modules/Snapshot/#ozet","title":"\u00d6zet","text":"<p>Bu makale, y\u00fcksek performansl\u0131 bir zamansal durum y\u00f6netim sistemi olan Nexus SnapshotManager'\u0131 incelemektedir. Bellek t\u00fcketimini en aza indirmek i\u00e7in Diferansiyel Snapshotting (Farkl\u0131l\u0131k Tabanl\u0131 Kay\u0131t), donan\u0131m h\u0131zland\u0131rmal\u0131 Blok Bellek Kopyalar\u0131 ve y\u00f6netilmeyen durumu hata ay\u0131klamak i\u00e7in tahrip edici olmayan \"Zaman Yolculu\u011fu\" uygulamas\u0131n\u0131 analiz ediyoruz.</p>"},{"location":"Core_Modules/Snapshot/#1-durum-yakalama-zorlugu","title":"1. Durum Yakalama Zorlu\u011fu","text":"<p>B\u00fcy\u00fck \u00f6l\u00e7ekli sim\u00fclasyonlarda (100 binden fazla varl\u0131k), her karede t\u00fcm durumu yakalamak, feci bir bellek bant geni\u015fli\u011fi doygunlu\u011funa ve \u00f6nbellek kirlili\u011fine yol a\u00e7ar. Geleneksel \"Kaydetme Sistemleri\", ger\u00e7ek zamanl\u0131 kare tarama (scrubbing) i\u00e7in \u00e7ok yava\u015ft\u0131r. Nexus, belle\u011fi biti\u015fik bir ak\u0131\u015f olarak ele alarak ve delta izleme kullanarak bunu \u00e7\u00f6zer.</p>"},{"location":"Core_Modules/Snapshot/#2-diferansiyel-snapshotting-algoritmas","title":"2. Diferansiyel Snapshotting Algoritmas\u0131","text":"<p>Nexus, y\u00f6netilmeyen y\u0131\u011f\u0131n\u0131n\u0131 (heap) tamamen kopyalamak yerine, <code>SparseSet</code> i\u00e7inde \"Dirty Bit\" (Kirli Bit) izleme sistemi kullan\u0131r. 1. Mutasyon \u0130zleme: Sistemler, infaz s\u0131ras\u0131nda bile\u015fenleri \"kirli\" olarak i\u015faretler. 2. Delta Yakalama: <code>SnapshotManager</code>, dairesel ge\u00e7mi\u015f tamponuna (circular buffer) yaln\u0131zca kirli bile\u015fenlerin byte'lar\u0131n\u0131 kopyalar. 3. Yeniden \u0130n\u015fa: Zamanda geriye gitmek i\u00e7in y\u00f6netici, canl\u0131 belle\u011fi tampondan gelen delta s\u0131k\u0131\u015ft\u0131r\u0131lm\u0131\u015f durumla \"yamalar\".</p>"},{"location":"Core_Modules/Snapshot/#3-donanm-yerel-blok-kopyalar","title":"3. Donan\u0131m-Yerel Blok Kopyalar\u0131","text":"<p>Nexus, eleman bazl\u0131 kopyalamadan ka\u00e7\u0131n\u0131r. \u0130\u015flemci seviyesinde y\u00fcksek d\u00fczeyde optimize edilmi\u015f SIMD tabanl\u0131 bellek transferlerine (\u00d6rn: AVX-512 VMOVDQU) d\u00f6n\u00fc\u015fen <code>Buffer.MemoryCopy</code> (veya <code>NativeMemory.Copy</code>) teknolojisini kullan\u0131r. Bu, 10.000 varl\u0131\u011f\u0131n durumunun 2 mikrosaniyeden daha k\u0131sa s\u00fcrede yakalanmas\u0131n\u0131 sa\u011flar.</p>"},{"location":"Core_Modules/Snapshot/#4-analytical-comparison","title":"4. Analytical Comparison","text":"Feature Traditional Clone Nexus Snapshot Memory Cost 100% per frame &lt; 5% (Delta only) CPU Cost High (Deep Copy) Ultra-Low (Block Copy) Fragmentation High (Managed Heap) Zero (Fixed Stack) Latency Milliseconds Microseconds"},{"location":"Core_Modules/Snapshot/#5-conclusion","title":"5. Conclusion","text":"<p>Nexus SnapshotManager proves that complex game state management is a memory layout problem. By aligning data for the pre-fetcher and using hardware-fast copies, it enables debugging tools like \"Time-Travel\" to operate with near-zero overhead.</p>"},{"location":"Manifesto/Nexus/","title":"Nexus Manifesto: Mimari ve Felsefe","text":""},{"location":"Manifesto/Nexus/#giris-neden-nexus","title":"Giri\u015f: Neden Nexus?","text":"<p>Modern yaz\u0131l\u0131m geli\u015ftirme, donan\u0131m\u0131n fiziksel ger\u00e7eklerinden uzakla\u015farak soyutlama katmanlar\u0131 (OOP, Garbage Collection, Managed Memory) alt\u0131nda ezilmi\u015ftir. Nesne Y\u00f6nelimli Programlama (OOP), geli\u015ftirici dostu g\u00f6r\u00fcnse de, i\u015flemci (CPU) ve bellek (RAM) aras\u0131ndaki devasa h\u0131z fark\u0131n\u0131 (Memory Wall) g\u00f6rmezden gelir. </p> <p>\"OOP \u00d6ld\u00fc\" diyemeyiz, ancak \"Performans Kriti\u011fi Gerektiren Yerlerde OOP Yetersizdir\" diyebiliriz. Nexus, bu yetersizli\u011fe donan\u0131m dostu (Hardware-aware) bir \u00e7\u00f6z\u00fcm sunar.</p>"},{"location":"Manifesto/Nexus/#performance-glossary-fine-touch","title":"\ud83d\udcda Performance Glossary (Fine Touch)","text":"<p>Geli\u015fmi\u015f performans optimizasyonlar\u0131n\u0131 anlamak i\u00e7in \u00f6nce i\u015flemcinin diliyle konu\u015fmal\u0131y\u0131z:</p> Terim A\u00e7\u0131klama Nexus Uygulamas\u0131 L1/L2/L3 Cache \u0130\u015flemci \u00e7ekirde\u011fine en yak\u0131n ve en h\u0131zl\u0131 bellek katmanlar\u0131. Nexus, veriyi Cache dostu <code>ChunkedBuffer</code> yap\u0131lar\u0131nda tutar. Data Locality \u0130li\u015fkili verilerin bellekte yan yana bulunmas\u0131 durumu. <code>SparseSet</code> ve <code>Registry</code> ile veriler ard\u0131\u015f\u0131k bellekte saklan\u0131r. SIMD Single Instruction multiple Data. Tek komutla birden fazla veriyi i\u015fleme. <code>NexusQuery</code>, AVX2/SSE komutlar\u0131yla mermileri topluca g\u00fcnceller. Branch Prediction \u0130\u015flemcinin kodun ak\u0131\u015f\u0131n\u0131 (if/else) tahmin etme yetene\u011fi. Nexus, dallanmay\u0131 (branching) minimize ederek tahmin hatalar\u0131n\u0131 (misprediction) \u00f6nler. Memory Barrier \u0130\u015flemcinin komut s\u0131ras\u0131n\u0131 kar\u0131\u015ft\u0131rmas\u0131n\u0131 engelleyen g\u00fcvenlik s\u0131n\u0131r\u0131. Unmanaged kopyalama i\u015flemlerinde veri tutarl\u0131l\u0131\u011f\u0131 i\u00e7in kullan\u0131l\u0131r. Cache Miss \u0130\u015flemcinin arad\u0131\u011f\u0131 veriyi Cache'de bulamay\u0131p RAM'e gitmek zorunda kalmas\u0131. Nexus'un temel amac\u0131 bu oran\u0131 %0'a yakla\u015ft\u0131rmakt\u0131r."},{"location":"Manifesto/Nexus/#felsefi-temel-data-oriented-design-dod","title":"Felsefi Temel: Data-Oriented Design (DOD)","text":"<p>OOP'un temel hatas\u0131, veriyi \"Nesne\" (Object) denilen k\u00fc\u00e7\u00fck kutulara hapsetmesi ve bu kutular\u0131 belle\u011fin rastgele yerlerine (Heap) sa\u00e7mas\u0131d\u0131r. \u0130\u015flemci bu verilere eri\u015fmek istedi\u011finde s\u00fcrekli \"Cache Miss\" ya\u015far ve RAM'den veri gelmesini bekler.</p> <p>Nexus, Data-Oriented Design felsefesini benimser: 1.  Veri Kutsald\u0131r: Nesneler de\u011fil, veriler \u00fczerinde i\u015flem yap\u0131l\u0131r. 2.  Bellek D\u00fczeni Tasar\u0131md\u0131r: Veriyi nas\u0131l saklad\u0131\u011f\u0131n\u0131z, ne yazd\u0131\u011f\u0131n\u0131z kadar \u00f6nemlidir. 3.  \u0130\u015flemciye Sayg\u0131: \u0130\u015flemcinin veriyi saniyede GB'larca h\u0131zla okuyabilece\u011fi ard\u0131\u015f\u0131k bellek (Sequential Memory) d\u00fczenleri kurulur.</p>"},{"location":"Manifesto/Nexus/#mimari-sema-moduler-yap","title":"Mimari \u015eema: Mod\u00fcler Yap\u0131","text":"<p>Nexus bir b\u00fct\u00fcnd\u00fcr ancak mod\u00fcler bir hiyerar\u015fi ile \u00e7al\u0131\u015f\u0131r:</p> <pre><code>graph TD\n    A[Nexus.Core] --&gt; B[Registry]\n    B --&gt; C[SparseSet]\n    B --&gt; D[ChunkedBuffer]\n    A --&gt; E[NexusQuery]\n    E --&gt; F[SIMD Engine]\n    G[Nexus.Unity] --&gt; H[Bridge 2.0]\n    H --&gt; B\n    I[NexusGenerator] --&gt; J[Source Code]\n    J --&gt; A\n</code></pre>"},{"location":"Manifesto/Nexus/#nexus-cozumu-donanm-dostu-programlama","title":"Nexus \u00c7\u00f6z\u00fcm\u00fc: Donan\u0131m Dostu Programlama","text":"<p>Nexus, C# d\u00fcnyas\u0131nda C++ performans\u0131 sunar: - Zero GC: \u00c7al\u0131\u015fma an\u0131nda (runtime) bellek tahsisi yap\u0131lmaz, Garbage Collector tetiklenmez. - Pointer Magic: <code>unsafe</code> kod bloklar\u0131 ve ham bellek adresleme ile veri transferi maksimum h\u0131za ula\u015f\u0131r. - Parallel processing: Veri par\u00e7alar\u0131 (chunks), modern i\u015flemcilerin t\u00fcm \u00e7ekirdeklerine e\u015fit \u015fekilde da\u011f\u0131t\u0131l\u0131r.</p> <p>[!IMPORTANT] Nexus Optimization Tip: Clock Cycle Efficiency Nexus bir d\u00f6ng\u00fcy\u00fc i\u015flerken, i\u015flemcinin <code>pipeline</code> (boru hatt\u0131) yap\u0131s\u0131n\u0131 asla t\u0131kamaz. Sanal metod tablolar\u0131 (vtable) veya referans takibi (reference tracking) yoktur. Her i\u015flem do\u011frudan bellek adresi \u00fczerinden yap\u0131l\u0131r, bu da her bir varl\u0131k (entity) i\u00e7in harcanan \"Clock Cycle\" miktar\u0131n\u0131 minimuma indirir.</p>"},{"location":"Manifesto/Nexus/#nexus-manifesto-architecture-and-philosophy","title":"Nexus Manifesto: Architecture and Philosophy","text":""},{"location":"Manifesto/Nexus/#introduction-why-nexus","title":"Introduction: Why Nexus?","text":"<p>Modern software development has drifted away from the physical realities of hardware by burdening itself under layers of abstraction (OOP, Garbage Collection, Managed Memory). While Object-Oriented Programming (OOP) appears developer-friendly, it ignores the massive speed difference between the processor (CPU) and memory (RAM), known as the Memory Wall.</p> <p>We cannot say \"OOP is Dead,\" but we can say \"OOP is Inadequate for Performance-Critical Areas.\" Nexus provides a Hardware-aware solution to this inadequacy.</p>"},{"location":"Manifesto/Nexus/#performance-glossary-fine-touch_1","title":"\ud83d\udcda Performance Glossary (Fine Touch)","text":"<p>To understand advanced performance optimizations, we must first speak the language of the processor:</p> Term Description Nexus Implementation L1/L2/L3 Cache The fastest memory layers closest to the processor core. Nexus stores data in cache-friendly <code>ChunkedBuffer</code> structures. Data Locality The state where related data is located side-by-side in memory. Data is stored in contiguous memory using <code>SparseSet</code> and <code>Registry</code>. SIMD Single Instruction Multiple Data. Processing multiple data points with a single instruction. <code>NexusQuery</code> updates projectiles in bulk using AVX2/SSE instructions. Branch Prediction The processor's ability to predict the flow of code (if/else). Nexus minimizes branching to prevent mispredictions. Memory Barrier A safety boundary preventing the processor from reordering instructions. Used for data consistency during unmanaged copy operations. Cache Miss The state where the processor cannot find data in the Cache and must go to RAM. Nexus's primary goal is to approach a 0% cache miss rate."},{"location":"Manifesto/Nexus/#philosophical-foundation-data-oriented-design-dod","title":"Philosophical Foundation: Data-Oriented Design (DOD)","text":"<p>The fundamental flaw of OOP is imprisoning data inside small boxes called \"Objects\" and scattering them across random locations in memory (Heap). When the processor wants to access this data, it constantly experiences \"Cache Misses\" and waits for data from RAM.</p> <p>Nexus embraces the Data-Oriented Design philosophy: 1.  Data is Sacred: Operations are performed on data, not on objects. 2.  Memory Layout is Design: How you store data is as important as what you write. 3.  Respect the Processor: Sequential memory layouts are established where the processor can read data at speeds of GBs per second.</p>"},{"location":"Manifesto/Nexus/#architectural-schema-modular-structure","title":"Architectural Schema: Modular Structure","text":"<p>Nexus is a cohesive whole but operates with a modular hierarchy:</p> <pre><code>graph TD\n    A[Nexus.Core] --&gt; B[Registry]\n    B --&gt; C[SparseSet]\n    B --&gt; D[ChunkedBuffer]\n    A --&gt; E[NexusQuery]\n    E --&gt; F[SIMD Engine]\n    G[Nexus.Unity] --&gt; H[Bridge 2.0]\n    H --&gt; B\n    I[NexusGenerator] --&gt; J[Source Code]\n    J --&gt; A\n</code></pre>"},{"location":"Manifesto/Nexus/#nexus-solution-hardware-friendly-programming","title":"Nexus Solution: Hardware-Friendly Programming","text":"<p>Nexus offers C++ performance within the C# world: - Zero GC: No memory allocation at runtime, no Garbage Collector triggers. - Pointer Magic: Data transfer reaches maximum speed with <code>unsafe</code> code blocks and raw memory addressing. - Parallel Processing: Data chunks are distributed equally across all cores of modern processors.</p> <p>[!IMPORTANT] Nexus Optimization Tip: Clock Cycle Efficiency While Nexus processes a loop, it never clogs the processor's <code>pipeline</code>. There are no virtual method tables (vtable) or reference tracking. Every operation is performed directly via memory addresses, minimizing the number of \"Clock Cycles\" spent for each entity.</p>"},{"location":"Tutorials/Tutorial/","title":"The Nexus Cookbook: Mastery &amp; Tutorials","text":""},{"location":"Tutorials/Tutorial/#introduction","title":"Introduction","text":"<p>Welcome to the Nexus Cookbook. This guide provides step-by-step instructions for integrating Nexus Prime into your Unity projects and mastering its high-performance patterns.</p>"},{"location":"Tutorials/Tutorial/#1-the-5-minute-setup","title":"1. The 5-Minute Setup","text":"<p>Start your high-performance journey in three simple steps: 1. Add the Initializer: Create an empty GameObject in your scene and add the <code>NexusInitializer</code> component. 2. Define a Component: Create an unmanaged struct for your data.    <pre><code>public struct Health : unmanaged { public float Value; }\n</code></pre> 3. Run a System: Use the <code>NexusHelper</code> to iterate over entities.    <pre><code>NexusHelper.ForEach((ref Health h) =&gt; { h.Value -= 1.0f; });\n</code></pre></p>"},{"location":"Tutorials/Tutorial/#2-building-a-bullet-system-advanced","title":"2. Building a Bullet System (Advanced)","text":"<p>A professional bullet system requires speed and stability. 1. The Data:    <pre><code>public struct BulletData : unmanaged { public Vector3 Pos; public Vector3 Vel; }\n</code></pre> 2. The System:    <pre><code>public partial class BulletSystem : NexusParallelSystem {\n    [Write] private BulletData* bullets;\n    public override void Execute() {\n        bullets-&gt;Pos += bullets-&gt;Vel * Time.deltaTime;\n    }\n}\n</code></pre> 3. The Result: Update 10,000 bullets with zero overhead.</p>"},{"location":"Tutorials/Tutorial/#nexus-cookbook-ustalk-ve-egitimler-tr","title":"Nexus Cookbook: Ustal\u0131k ve E\u011fitimler (TR)","text":""},{"location":"Tutorials/Tutorial/#giris","title":"Giri\u015f","text":"<p>Nexus Cookbook'a ho\u015f geldiniz. Bu rehber, Nexus Prime'\u0131 Unity projelerinize entegre etmek ve y\u00fcksek performansl\u0131 modellerinde ustala\u015fmak i\u00e7in ad\u0131m ad\u0131m talimatlar sunar.</p>"},{"location":"Tutorials/Tutorial/#1-5-dakikada-kurulum","title":"1. 5 Dakikada Kurulum","text":"<p>Y\u00fcksek performans yolculu\u011funuza \u00fc\u00e7 basit ad\u0131mda ba\u015flay\u0131n: 1. Initializer'\u0131 Ekle: Sahnenizde bo\u015f bir GameObject olu\u015fturun ve <code>NexusInitializer</code> bile\u015fenini ekleyin. 2. Bir Bile\u015fen Tan\u0131mla: Verileriniz i\u00e7in y\u00f6netilmeyen (unmanaged) bir struct olu\u015fturun.    <pre><code>public struct Health : unmanaged { public float Value; }\n</code></pre> 3. Bir Sistem \u00c7al\u0131\u015ft\u0131r: Varl\u0131klar \u00fczerinde gezinmek i\u00e7in <code>NexusHelper</code>'\u0131 kullan\u0131n.    <pre><code>NexusHelper.ForEach((ref Health h) =&gt; { h.Value -= 1.0f; });\n</code></pre></p>"},{"location":"Tutorials/Tutorial/#2-mermi-sistemi-insas-ileri-duzey","title":"2. Mermi Sistemi \u0130n\u015fas\u0131 (\u0130leri D\u00fczey)","text":"<p>Profesyonel bir mermi sistemi h\u0131z ve kararl\u0131l\u0131k gerektirir. 1. Veri:    <pre><code>public struct BulletData : unmanaged { public Vector3 Pos; public Vector3 Vel; }\n</code></pre> 2. Sistem:    <pre><code>public partial class BulletSystem : NexusParallelSystem {\n    [Write] private BulletData* bullets;\n    public override void Execute() {\n        bullets-&gt;Pos += bullets-&gt;Vel * Time.deltaTime;\n    }\n}\n</code></pre></p>"},{"location":"Tutorials/Tutorial/#3-mastering-time-travel-snapshots","title":"3. Mastering Time-Travel (Snapshots)","text":"<p>Nexus allows you to \"scrub\" through history like a video. - Capture: <code>NexusHelper.Registry.TakeSnapshot()</code> - Rewind: Use the <code>TimeTravelDebugger</code> editor window to scrub through frames. - Verification: Check <code>NexusIntegrityDashboard</code> to ensure your snapshots are memory-aligned.</p>"},{"location":"Tutorials/Tutorial/#4-best-practices","title":"4. Best Practices","text":"<ul> <li>Never use <code>class</code>: Always use <code>unmanaged struct</code> for components.</li> <li>Use the Command Buffer: For adding/removing components inside a system, use <code>EntityCommandBuffer</code> to avoid race conditions.</li> <li>Profile Early: Use <code>NexusLogger</code> with custom sinks to monitor performance bottlenecks in real-time.</li> </ul>"},{"location":"Tutorials/Tutorial/#5-conclusion","title":"5. Conclusion","text":"<p>Mastery of Nexus comes from respecting the \"Data First\" philosophy. By minimizing managed overhead and staying within the unmanaged \"Hot Path,\" you unlock the full potential of modern PC and mobile hardware.</p>"}]}