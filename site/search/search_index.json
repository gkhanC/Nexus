{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Nexus Prime: A High-Performance, Hardware-Aware ECS Architecture for Real-Time Simulations","text":""},{"location":"#abstract-executive-summary","title":"Abstract / Executive Summary","text":"<p>This manifesto details the technical foundations of Nexus Prime, an elite Entity Component System (ECS) framework designed to solve the systemic performance bottlenecks of modern high-level managed environments. We analyze the Memory Wall, the failure of the Object-Oriented Paradigm (OOP) at scale, and the architectural crisis of modern managed runtimes. Nexus Prime offers a \"Zero-Friction\" unmanaged architecture that operates at the theoretical limits of modern CPU architectures while providing a seamless, type-safe bridge to managed environments like Unity. This document serves as a comprehensive technical guide, problem-solution analysis, and philosophical roadmap for high-scale simulation development.</p>"},{"location":"#0-performance-glossary-foundations-of-modern-systems","title":"0. Performance Glossary: Foundations of Modern Systems","text":"<p>To grasp the architectural necessity of Nexus Prime, one must understand the physical constraints of the hardware it operates upon:</p> Term Nexus Prime Context Technical Definition L1/L2/L3 Cache Primary Target Small, extremely fast CPU-internal memory. Nexus aims for 100% hit rates to prevent high-latency DRAM fetches. Cache Miss The Nemesis Occurs when requested data is not in cache, forcing a \\(\\sim 100ns\\) trip to RAM. Data Locality Architectural Pillar Physical proximity of data in RAM. Nexus ensures 100% spatial locality via contiguous buffers. Instruction Pipelining Execution Strategy Overlapping instruction execution. Nexus use branchless logic to prevent pipeline \"bubbles.\" SIMD Computational Multiplier Single Instruction, Multiple Data. Nexus utilizes AVX-256 to transform 8-16 64-bit entities in one cycle. Memory Barrier Safety Guard Enforces memory operation order. Managed by JobSystem for thread-safe unmanaged access. TLB Paging Optimization Translation Lookaside Buffer. optimized by Nexus 16KB paging to speed up address translation. Blittable Type The Requirement Data that has the same representation in both managed and unmanaged memory."},{"location":"#1-the-paradigm-shift-the-philosophy-of-dod","title":"1. The Paradigm Shift: The Philosophy of DOD","text":"<p>Traditional game development relies on Object-Oriented Programming (OOP), where data and logic are encapsulated together. While intuitive for humans, OOP is fundamentally mismatched for modern hardware. Data-Oriented Design (DOD) shifts the focus from \"What an object is\" to \"What the data does.\"</p>"},{"location":"#2-problem-identification-the-physics-of-inefficiency","title":"2. Problem Identification: The Physics of Inefficiency","text":""},{"location":"#21-the-hardware-crisis-ram-vs-cpu-memory","title":"2.1 The Hardware Crisis: RAM vs. CPU Memory","text":"<p>The \"Memory Wall\" is the divergence between CPU speed and RAM latency. Since 1980, CPUs became \\(\\sim 10,000\\%\\) faster, while RAM only \\(\\sim 10\\%\\).</p> <p>The Latency Gap (Physical Reality): <pre><code>graph LR\n    CPU((CPU)) --- L1[L1 Cache: 1ns]\n    L1 --- L2[L2 Cache: 4ns]\n    L2 --- L3[L3 Cache: 15ns]\n    L3 --- DRAM[DRAM: 100ns]\n    DRAM --- NET[NETWORK: 10ms]\n\n    style CPU fill:#f96\n    style DRAM fill:#3399ff\n</code></pre></p> <p>Stall Mathematics:</p>"},{"location":"#22-the-reference-crisis-fragmentation-pointer-chasing","title":"2.2 The Reference Crisis: Fragmentation &amp; Pointer Chasing","text":"<p>In standard C#, a class instance is a reference.</p> <ul> <li>Pointer Chasing: Every <code>unit.transform.position</code> access requires solving 3 pointers in sequence. The CPU cannot \"pre-fetch\" these because it doesn't know the address of the next pointer until the current one is fetched.</li> <li>Heap Fragmentation: Managed objects are placed wherever the GC finds space. Over time, the heap looks like Swiss cheese, ensuring every object fetch is a Cache Miss.</li> </ul>"},{"location":"#3-deep-dive-memory-topography-contiguity-vs-scattering","title":"3. Deep Dive: Memory Topography (Contiguity vs. Scattering)","text":""},{"location":"#31-c-memory-structures-the-scattered-oop-reality","title":"3.1 C# Memory Structures: The Scattered OOP Reality","text":"<p>In C#, reference types (<code>class</code>) allocate memory dynamically on the Managed Heap, connected by a web of pointers.</p> <pre><code>// The C# OOP Approach (Scattered in Memory)\npublic class UnitOOP {\n    public int ID;         // 4 bytes\n    public string Name;    // Pointer (8 bytes) -&gt; Heap Address 2\n    public Transform Data; // Pointer (8 bytes) -&gt; Heap Address 3\n}\n\nList&lt;UnitOOP&gt; army = new List&lt;UnitOOP&gt;(); // Array of Pointers -&gt; Heap Address 1\n</code></pre> <p>Schema: Standard C# Managed Heap Layout</p> <pre><code>graph TD\n    subgraph Managed_Heap_Scattered\n        List[List Array of Pointers] --&gt;|Ptr 1| ObjA[UnitOOP A @0x1000]\n        List --&gt;|Ptr 2| ObjB[UnitOOP B @0x8F20]\n        List --&gt;|Ptr 3| ObjC[UnitOOP C @0x2A40]\n\n        ObjA --&gt;|Ptr| TransA[Transform Data @0x1050]\n        ObjB --&gt;|Ptr| TransB[Transform Data @0x9000]\n        ObjC --&gt;|Ptr| TransC[Transform Data @0x3010]\n    end\n    style List fill:#f9d0c4\n    style ObjA fill:#ff9999\n    style ObjB fill:#ff9999\n    style ObjC fill:#ff9999\n</code></pre>"},{"location":"#32-the-nexus-solution-sequential-contiguity","title":"3.2 The Nexus Solution: Sequential Contiguity","text":"<p>Nexus eliminates the pointer web by using strictly unmanaged, blittable structs stored in linear native memory buffers.</p> <pre><code>// The Nexus Approach (Sequential in Memory)\n[StructLayout(LayoutKind.Sequential)]\npublic struct UnitData {\n    public int ID;         // 4 bytes\n    public Vector3 Pos;    // 12 bytes\n} // Total: Exactly 16 bytes. Blittable.\n\nChunkedBuffer&lt;UnitData&gt; armyData = new ChunkedBuffer&lt;UnitData&gt;(); \n// 1 Contiguous Block of Native Memory\n</code></pre> <p>Schema: Nexus Unmanaged Linear Layout</p> <pre><code>graph LR\n    subgraph Unmanaged_Native_Memory_Nexus\n        direction LR\n        Block1[UnitData A &lt;br/&gt; 16 Bytes] --- Block2[UnitData B &lt;br/&gt; 16 Bytes] --- Block3[UnitData C &lt;br/&gt; 16 Bytes] --- Block4[UnitData D &lt;br/&gt; 16 Bytes]\n    end\n    subgraph CPU_Cache_Line_64_Bytes\n        direction LR\n        Cache[Fetches A, B, C, and D in exactly 1 CPU Cycle]\n    end\n    Block1 -.-&gt; Cache\n    Block4 -.-&gt; Cache\n    style Block1 fill:#c4f9d0\n    style Block2 fill:#c4f9d0\n    style Block3 fill:#c4f9d0\n    style Block4 fill:#c4f9d0\n    style Cache fill:#99ff99\n</code></pre> <p>Instruction Efficiency Math: For a 64-byte Cache Line and a 16-byte component:</p> <p>Nexus fetches 4 entities at once. OOP fetches 1 entity (plus 48 bytes of garbage data), wasting  of the bandwidth and forcing  more memory trips.</p>"},{"location":"#33-predictive-memory-modeling-anticipating-bottlenecks","title":"3.3 Predictive Memory Modeling: Anticipating Bottlenecks","text":"<p>Even in contiguous arrays, hidden hardware flaws can destroy performance if not predicted. Nexus Engine explicitly designs against two major hardware bottlenecks: Cache Straddling and False Sharing.</p> <p>Predictive Schema 1: Cache Straddling (Unaligned Data Penalty) When a struct is not aligned to cache line boundaries, reading a single entity requires fetching two separate cache lines from L2/L3, instantly halving performance. Nexus predicts and prevents this via strict 64-byte padded allocations.</p> <pre><code>graph TD\n    subgraph Bad_Alignment_Cache_Straddling\n        Line1[Cache Line 1: 64 Bytes] --- StructA[Entity 1: 40 Bytes]\n        Line1 --- Split[Entity 2 Part 1: 24 Bytes]\n        Line2[Cache Line 2: 64 Bytes] --- Split2[Entity 2 Part 2: 16 Bytes]\n        Line2 --- StructC[Entity 3: 40 Bytes]\n        Split -.-&gt; |Requires 2 fetches for 1 Entity!| Alert((STALL))\n    end\n    style Alert fill:#ff4444,color:#fff\n</code></pre> <p>Predictive Schema 2: False Sharing (Multithreading Collision) If Core A writes to <code>Entity 1</code> and Core B writes to <code>Entity 2</code>, but both entities sit on the same 64-byte Cache Line, the CPU forces an artificial lock, causing severe thread stalling. Nexus prevents this by chunking data far apart for different worker threads.</p> <pre><code>graph LR\n    Core1((CPU Core 1)) --&gt;|Writes| E1[Entity 1]\n    Core2((CPU Core 2)) --&gt;|Writes| E2[Entity 2]\n\n    subgraph Same_Cache_Line_64B\n        E1 --- E2\n    end\n\n    Core1 -.-&gt; |Hardware Lock Triggered!| Core2\n    style Same_Cache_Line_64B fill:#ffcccc\n</code></pre>"},{"location":"#4-the-nexus-engine-orchestrating-contiguity-the-how","title":"4. The Nexus Engine: Orchestrating Contiguity (The \"How\")","text":""},{"location":"#41-sparseset-the-id-to-direct-bridge","title":"4.1 SparseSet: The ID-to-Direct Bridge","text":"<p>Nexus uses SparseSets to marry ID-based accessibility with array-based performance.</p> <ul> <li>Sparse Array: Indexed by Entity ID. Stores the index in the Dense Array.</li> <li>Dense Array: Stores the actual raw component data. This is what the CPU iterates over.</li> </ul>"},{"location":"#42-swap-and-pop-maintaining-100-density","title":"4.2 Swap-and-Pop: Maintaining 100% Density","text":"<p>To prevent holes when an entity is deleted in C#, arrays usually leave a <code>null</code> gap, causing a cache miss during iteration. Nexus uses Swap-and-Pop.</p> <p>Schema: Swap-and-Pop Mechanism</p> <pre><code>stateDiagram-v2\n    direction LR\n    state \"Before Deletion (Dense Array)\" as S1 {\n        [A] --&gt; [B] --&gt; [C] --&gt; [D]\n    }\n    state \"Deleting Entity 'B'\" as S2 {\n        [A] --&gt; [Empty] --&gt; [C] --&gt; [D]\n    }\n    state \"Swap-and-Pop Action\" as S3 {\n        [A] --&gt; [D_Moves_Here] --&gt; [C] --&gt; [Removed]\n    }\n    state \"After Deletion\" as S4 {\n        [A] --&gt; [D] --&gt; [C]\n    }\n    S1 --&gt; S2\n    S2 --&gt; S3\n    S3 --&gt; S4\n</code></pre> <p>Mathematical Proof of Density:</p>"},{"location":"#5-alternative-industry-solutions-unity-dots-ecs-vs-nexus-prime","title":"5. Alternative Industry Solutions: Unity DOTS / ECS vs. Nexus Prime","text":"<p>To contextualize Nexus Prime, we must compare it against mainstream ECS frameworks, specifically Unity DOTS (Entities). While both solve the OOP memory fragmentation problem, they use fundamentally different internal architectures.</p>"},{"location":"#51-unity-dots-the-archetype-architecture","title":"5.1 Unity DOTS: The Archetype Architecture","text":"<p>Unity uses Archetypes. Entities with the exact same combination of components are grouped into the same physical 16KB memory \"Chunk\".</p> <ul> <li>The Flaw (Structural Changes): If you add a \"Poisoned\" component to a single \"Unit\", Unity must move that entire unit's data from the \"Unit\" chunk to a new \"Unit + Poisoned\" chunk. This stalls multithreading and triggers massive memory copying.</li> </ul>"},{"location":"#52-nexus-prime-the-sparseset-architecture","title":"5.2 Nexus Prime: The SparseSet Architecture","text":"<p>Nexus isolates components into individual arrays. A \"Unit\" is just an ID. Its <code>Position</code> lives in the Position array, and its <code>Health</code> lives in the Health array.</p> <ul> <li>The Advantage (Frictionless Composition): Adding a \"Poisoned\" component to a Unit simply involves writing data to the end of the <code>Poisoned</code> array. The entity's Position and Health data never moves. No structural changes, no pipeline stalls.</li> </ul> Feature Unity DOTS (Archetype) Nexus Prime (SparseSet) Difference Impact Component Layout Grouped by Entity type in Chunks Isolated arrays per Component type Nexus iterates single components faster (no interlacing). Adding/Removing Components Very Slow (Structural Change, copy data) Instant (Array append, no moving) Nexus excels in highly dynamic games with rapid state changes. Multithreaded Queries High complexity (Sync Points required) Lock-free component arrays Nexus minimizes pipeline bubbles during state changes. Query Iteration Perfect cache locality across multiple comps Slight penalty for cross-component ID lookup Unity is faster when reading 5+ components simultaneously; Nexus is faster for isolated systems."},{"location":"#6-zero-gc-management-the-technical-proof","title":"6. Zero-GC Management: The Technical Proof","text":"<p>Nexus achieves Zero-GC by using <code>NativeMemory.Alloc</code>.</p> <ul> <li>The Mechanism: By using <code>blittable structs</code>, we ensure the GC root-scanner never has to \"walk\" these memory blocks.</li> <li>The Result: 10GB of simulation data has exactly the same GC pressure as 10KB.</li> </ul>"},{"location":"#7-logic-orchestration-dag-simd-and-paging","title":"7. Logic Orchestration: DAG, SIMD, and Paging","text":""},{"location":"#71-directed-acyclic-graph-dag-scaling","title":"7.1 Directed Acyclic Graph (DAG) Scaling","text":"<p>Nexus uses Kahn's Algorithm to solve dependencies.</p> <ul> <li>Theorem: If , then  and  can execute in parallel.</li> <li>Result: Automatic, lock-free parallelization across all available CPU cores.</li> </ul>"},{"location":"#72-simd-avx2-vectorization","title":"7.2 SIMD (AVX2) Vectorization","text":"<p>Filtering through millions of entities with <code>if</code> is a branch-prediction disaster.</p> <ul> <li>Nexus Approach: Uses bitwise operations on 256-bit registers. Process 32 filters in 1 instruction.</li> <li>Formula: </li> </ul>"},{"location":"#73-16kb-paging-64-byte-alignment","title":"7.3 16KB Paging &amp; 64-Byte Alignment","text":"<ul> <li>16KB Paging: Matches 4 typical OS memory pages, maximizing TLB cache hits.</li> <li>64-Byte Alignment: Ensures every component fits perfectly into a CPU Cache Line. Crossing a cache line boundary doubles access cost.</li> </ul>"},{"location":"#8-performance-realities-benchmarks","title":"8. Performance Realities: Benchmarks","text":"<p>Verified results from the Benchmark Whitepaper:</p> Metric Managed C# (Unity) Nexus Prime Speedup Lifecycle (100k) 840.0 ms 8.0 ms 105.0x Update Iteration 12.4 ms 0.2 ms 62.0x Math (10M Ops) 480.0 ms 42.0 ms 11.4x Memory Allocation 450 KB / Frame 0 KB / Frame INF (Zero-GC)"},{"location":"#9-strategic-evaluation-pros-cons-and-risks","title":"9. Strategic Evaluation: Pros, Cons, and Risks","text":""},{"location":"#91-advantages-pros-strengths","title":"9.1 Advantages (Pros) &amp; Strengths","text":"<ul> <li>Unlimited Scale: Sims that were physically impossible in OOP become trivial.</li> <li>Predictable Stability: Zero GC spikes means zero \"unexplained stuttering.\"</li> <li>Direct Hardware Control: High-precision AVX/SSE usage.</li> </ul>"},{"location":"#92-risks-and-weaknesses-cons","title":"9.2 Risks and Weaknesses (Cons)","text":"<ul> <li>Manual Cleanup: Forgetting to call <code>Dispose()</code> leads to unmanaged memory leaks.</li> <li>Point-Lookup Tax: SparseSet lookup used for random <code>Get</code> is slower than direct array access (3.4x slower).</li> <li>Small Scale Friction: Setup overhead for  entities outweighs execution gains.</li> </ul>"},{"location":"#10-conclusion-the-philosophical-horizon","title":"10. Conclusion: The Philosophical Horizon","text":"<p>Nexus Prime is a commitment to hardware respect. It changes your coding habits from \"Creating objects\" to \"Orchestrating data.\" By aligning software logic with the physical laws of the CPU, it transforms performance from a \"best-effort\" outcome into a deterministic mathematical certainty.</p>"},{"location":"#nexus-prime-gercek-zamanl-simulasyonlar-icin-yuksek-performansl-donanm-duyarl-ecs-mimarisi","title":"Nexus Prime: Ger\u00e7ek Zamanl\u0131 Sim\u00fclasyonlar \u0130\u00e7in Y\u00fcksek Performansl\u0131, Donan\u0131m Duyarl\u0131 ECS Mimarisi","text":"<p>Yazar: Nexus Prime Sistem M\u00fchendisli\u011fi Ekibi</p> <p>Tarih: \u015eubat 2026 Anahtar Kelimeler: Sistem Mimarisi, Donan\u0131m Duyarl\u0131 Tasar\u0131m, Veri Odakl\u0131 Programlama, SIMD, Bellek Hizalamas\u0131, Bellek Duvar\u0131, S\u0131f\u0131r-GC</p>"},{"location":"#ozet-yonetici-ozeti","title":"\u00d6zet / Y\u00f6netici \u00d6zeti","text":"<p>Bu manifesto, Nexus Prime'\u0131n teknik temellerini ve modern donan\u0131m \u00fczerindeki verimlilik stratejilerini detayland\u0131rmaktad\u0131r. Bellek Duvar\u0131'n\u0131 ve OOP'nin \u00f6l\u00e7eklenme krizlerini analiz ediyoruz. Nexus Prime, \"S\u0131f\u0131r-S\u00fcrt\u00fcnmeli\" unmanaged mimarisi ile CPU'nun teorik s\u0131n\u0131rlar\u0131nda \u00e7al\u0131\u015f\u0131rken, Unity gibi motorlara kesintisiz bir k\u00f6pr\u00fc sunar. Bu dok\u00fcman, y\u00fcksek \u00f6l\u00e7ekli sim\u00fclasyon geli\u015ftirme i\u00e7in kapsaml\u0131 bir teknik rehber ve felsefi yol haritas\u0131d\u0131r.</p>"},{"location":"#0-performans-sozlugu-modern-sistem-temelleri","title":"0. Performans S\u00f6zl\u00fc\u011f\u00fc: Modern Sistem Temelleri","text":"<p>Nexus Prime'\u0131n mimari gereklili\u011fini kavramak i\u00e7in, \u00fczerinde \u00e7al\u0131\u015ft\u0131\u011f\u0131 donan\u0131m\u0131n fiziksel k\u0131s\u0131tlamalar\u0131 anla\u015f\u0131lmal\u0131d\u0131r:</p> Terim Nexus Prime Ba\u011flam\u0131 Teknik Tan\u0131m L1/L2/L3 Cache Birincil Hedef K\u00fc\u00e7\u00fck, son derece h\u0131zl\u0131 CPU-i\u00e7i bellek. Nexus y\u00fcksek gecikmeli DRAM \u00e7a\u011fr\u0131lar\u0131n\u0131 \u00f6nlemek i\u00e7in %100 isabet oran\u0131n\u0131 hedefler. Cache Miss D\u00fc\u015fman \u0130stenen verinin \u00f6nbellekte bulunamamas\u0131 ve RAM'e 'lik bir seyahat yap\u0131lmas\u0131. Veri Yerelli\u011fi Mimari S\u00fctun Verilerin RAM'deki fiziksel yak\u0131nl\u0131\u011f\u0131. Nexus biti\u015fik arabelleklerle %100 mekansal yerellik sa\u011flar. Komut Hatt\u0131 Y\u00fcr\u00fctme Stratejisi CPU'nun komutlar\u0131 i\u00e7 i\u00e7e i\u015flemesi. Nexus dallanmas\u0131z mant\u0131k ile hat t\u0131kan\u0131kl\u0131klar\u0131n\u0131 \u00f6nler. SIMD Hesaplama \u00c7arpan\u0131 Tek Komut, \u00c7oklu Veri. Nexus 8-16 adet 64-bitlik varl\u0131\u011f\u0131 tek d\u00f6ng\u00fcde i\u015flemek i\u00e7in AVX-256 kullan\u0131r. Memory Barrier G\u00fcvenlik Kalkan\u0131 Bellek i\u015flem s\u0131ras\u0131n\u0131 zorunlu k\u0131lar. \u0130\u015f par\u00e7ac\u0131\u011f\u0131 g\u00fcvenli unmanaged eri\u015fim i\u00e7in JobSystem taraf\u0131ndan y\u00f6netilir. TLB Sayfalama Optimizasyonu Bellek adresi d\u00f6n\u00fc\u015ft\u00fcrme \u00f6nbelle\u011fi. Nexus 16KB sayfalama ile adres d\u00f6n\u00fc\u015ft\u00fcrmeyi h\u0131zland\u0131r\u0131r. Blittable Type Kesin Ko\u015ful Hem managed hem unmanaged bellekte ayn\u0131 fiziksel yap\u0131ya sahip veri t\u00fcr\u00fc."},{"location":"#1-paradigma-degisimi-veri-odakl-tasarm-dod-felsefesi","title":"1. Paradigma De\u011fi\u015fimi: Veri Odakl\u0131 Tasar\u0131m (DOD) Felsefesi","text":"<p>Geleneksel oyun geli\u015ftirme, veri ve mant\u0131\u011f\u0131n bir arada kaps\u00fcllendi\u011fi Nesne Y\u00f6nelimli Programlamaya (OOP) dayan\u0131r. \u0130nsan zihni i\u00e7in sezgisel olsa da, OOP modern donan\u0131m i\u00e7in temelden uyumsuzdur. Veri Odakl\u0131 Tasar\u0131m (DOD), oda\u011f\u0131 \"Bir nesne nedir?\" sorusundan \"Veri ne yapar?\" sorusuna kayd\u0131r\u0131r.</p>"},{"location":"#2-sorun-tespiti-verimsizligin-fizigi","title":"2. Sorun Tespiti: Verimsizli\u011fin Fizi\u011fi","text":""},{"location":"#21-donanm-krizi-ram-vs-cpu-bellegi","title":"2.1 Donan\u0131m Krizi: RAM vs. CPU Belle\u011fi","text":"<p>\"Bellek Duvar\u0131\", CPU h\u0131z\u0131 ile RAM gecikmesi aras\u0131ndaki ayr\u0131\u015fmad\u0131r. 1980'den bu yana CPU'lar  h\u0131zlan\u0131rken, RAM yaln\u0131zca  h\u0131zlanm\u0131\u015ft\u0131r.</p> <p>Gecikme U\u00e7urumu (Fiziksel Ger\u00e7eklik):</p> <pre><code>graph LR\n    CPU((CPU)) --- L1[L1 Cache: 1ns]\n    L1 --- L2[L2 Cache: 4ns]\n    L2 --- L3[L3 Cache: 15ns]\n    L3 --- DRAM[DRAM: 100ns]\n    DRAM --- NET[NETWORK: 10ms]\n\n    style CPU fill:#f96\n    style DRAM fill:#3399ff\n</code></pre> <p>Duraksama Matemati\u011fi:</p>"},{"location":"#22-referans-krizi-parcalanma-ve-isaretci-takibi","title":"2.2 Referans Krizi: Par\u00e7alanma ve \u0130\u015faret\u00e7i Takibi","text":"<p>Standart C#'ta bir s\u0131n\u0131f (class) \u00f6rne\u011fi bir referanst\u0131r.</p> <ul> <li>\u0130\u015faret\u00e7i Takibi (Pointer Chasing): Her <code>unit.transform.position</code> eri\u015fimi, s\u0131rayla 3 i\u015faret\u00e7inin \u00e7\u00f6z\u00fclmesini gerektirir. CPU mevcut i\u015faret\u00e7i getirilene kadar bir sonrakinin adresini bilmedi\u011fi i\u00e7in bunlar\u0131 \"\u00f6nceden getiremez\" (pre-fetch).</li> <li>Y\u0131\u011f\u0131n Par\u00e7alanmas\u0131 (Heap Fragmentation): Y\u00f6netilen nesneler GC'nin bo\u015fluk buldu\u011fu her yere yerle\u015ftirilir. Zamanla y\u0131\u011f\u0131n delikli peynire d\u00f6ner ve her nesne \u00e7a\u011fr\u0131s\u0131n\u0131n bir \u00d6nbellek Iskalatmas\u0131 (Cache Miss) olmas\u0131 garanti alt\u0131na al\u0131n\u0131r.</li> </ul>"},{"location":"#3-derinlemesine-inceleme-bellek-topografyas-sral-vs-dagnk","title":"3. Derinlemesine \u0130nceleme: Bellek Topografyas\u0131 (S\u0131ral\u0131 vs. Da\u011f\u0131n\u0131k)","text":""},{"location":"#31-c-bellek-yaplar-dagnk-oop-gercekligi","title":"3.1 C# Bellek Yap\u0131lar\u0131: Da\u011f\u0131n\u0131k OOP Ger\u00e7ekli\u011fi","text":"<p>C#'ta referans tipleri (<code>class</code>), bir i\u015faret\u00e7i a\u011f\u0131yla birbirine ba\u011flanm\u0131\u015f \u015fekilde Y\u00f6netilen Y\u0131\u011f\u0131n (Managed Heap) \u00fczerinde dinamik olarak bellek tahsis eder.</p> <pre><code>// C# OOP Yakla\u015f\u0131m\u0131 (Bellekte Da\u011f\u0131n\u0131k)\npublic class UnitOOP {\n    public int ID;         // 4 byte\n    public string Name;    // \u0130\u015faret\u00e7i (8 byte) -&gt; Y\u0131\u011f\u0131n Adresi 2\n    public Transform Data; // \u0130\u015faret\u00e7i (8 byte) -&gt; Y\u0131\u011f\u0131n Adresi 3\n}\n\nList&lt;UnitOOP&gt; army = new List&lt;UnitOOP&gt;(); // \u0130\u015faret\u00e7i Dizisi -&gt; Y\u0131\u011f\u0131n Adresi 1\n</code></pre> <p>\u015eema: Standart C# Y\u00f6netilen Y\u0131\u011f\u0131n (Managed Heap) Yerle\u015fimi</p> <pre><code>graph TD\n    subgraph Managed_Heap_Daginik\n        List[Isaretci Dizisi Listesi] --&gt;|Isaretci 1| ObjA[UnitOOP A @0x1000]\n        List --&gt;|Isaretci 2| ObjB[UnitOOP B @0x8F20]\n        List --&gt;|Isaretci 3| ObjC[UnitOOP C @0x2A40]\n\n        ObjA --&gt;|Isaretci| TransA[Transform Verisi @0x1050]\n        ObjB --&gt;|Isaretci| TransB[Transform Verisi @0x9000]\n        ObjC --&gt;|Isaretci| TransC[Transform Verisi @0x3010]\n    end\n    style List fill:#f9d0c4\n    style ObjA fill:#ff9999\n    style ObjB fill:#ff9999\n    style ObjC fill:#ff9999\n</code></pre>"},{"location":"#32-nexus-cozumu-sral-bitisiklik","title":"3.2 Nexus \u00c7\u00f6z\u00fcm\u00fc: S\u0131ral\u0131 Biti\u015fiklik","text":"<p>Nexus, do\u011frusal yerel bellek arabelleklerinde depolanan tamamen y\u00f6netilmeyen (unmanaged), blittable yap\u0131lar (struct) kullanarak i\u015faret\u00e7i a\u011f\u0131n\u0131 ortadan kald\u0131r\u0131r.</p> <pre><code>// Nexus Yakla\u015f\u0131m\u0131 (Bellekte S\u0131ral\u0131)\n[StructLayout(LayoutKind.Sequential)]\npublic struct UnitData {\n    public int ID;         // 4 byte\n    public Vector3 Pos;    // 12 byte\n} // Toplam: Tam olarak 16 byte. Blittable.\n\nChunkedBuffer&lt;UnitData&gt; armyData = new ChunkedBuffer&lt;UnitData&gt;(); \n// 1 Adet Biti\u015fik Yerel Bellek Blo\u011fu\n</code></pre> <p>\u015eema: Nexus Unmanaged Do\u011frusal Yerle\u015fimi</p> <pre><code>graph LR\n    subgraph Unmanaged_Yerel_Bellek_Nexus\n        direction LR\n        Block1[UnitData A &lt;br/&gt; 16 Byte] --- Block2[UnitData B &lt;br/&gt; 16 Byte] --- Block3[UnitData C &lt;br/&gt; 16 Byte] --- Block4[UnitData D &lt;br/&gt; 16 Byte]\n    end\n    subgraph CPU_Onbellek_Satiri_64_Byte\n        direction LR\n        Cache[A, B, C ve D'yi tam olarak 1 CPU D\u00f6ng\u00fcs\u00fcnde getirir]\n    end\n    Block1 -.-&gt; Cache\n    Block4 -.-&gt; Cache\n    style Block1 fill:#c4f9d0\n    style Block2 fill:#c4f9d0\n    style Block3 fill:#c4f9d0\n    style Block4 fill:#c4f9d0\n    style Cache fill:#99ff99\n</code></pre> <p>Komut Verimlili\u011fi Matemati\u011fi: 64-byte'l\u0131k bir \u00d6nbellek Sat\u0131r\u0131 (Cache Line) ve 16-byte'l\u0131k bir bile\u015fen i\u00e7in:</p> <p>Nexus tek seferde 4 varl\u0131k getirir. OOP 1 varl\u0131k (art\u0131 48 byte \u00e7\u00f6p veri) getirir, bant geni\u015fli\u011finin 'ini bo\u015fa harcar ve  daha fazla bellek seyahatine zorlar.</p>"},{"location":"#33-ongorucu-bellek-modellemesi-darbogazlar-tahmin-etme","title":"3.3 \u00d6ng\u00f6r\u00fcc\u00fc Bellek Modellemesi: Darbo\u011fazlar\u0131 Tahmin Etme","text":"<p>Biti\u015fik dizilerde bile, gizli donan\u0131m kusurlar\u0131 \u00f6nceden tahmin edilmezse performans\u0131 yok edebilir. Nexus Engine, iki b\u00fcy\u00fck donan\u0131m darbo\u011faz\u0131na kar\u015f\u0131 a\u00e7\u0131k\u00e7a tasarlanm\u0131\u015ft\u0131r: \u00d6nbellek Par\u00e7alanmas\u0131 (Cache Straddling) ve Sahte Payla\u015f\u0131m (False Sharing).</p> <p>\u00d6ng\u00f6r\u00fcc\u00fc \u015eema 1: \u00d6nbellek Par\u00e7alanmas\u0131 (Hizalanmam\u0131\u015f Veri Cezas\u0131) Bir struct \u00f6nbellek sat\u0131r\u0131 (cache line) s\u0131n\u0131rlar\u0131na hizalanmad\u0131\u011f\u0131nda, tek bir varl\u0131\u011f\u0131 okumak L2/L3'ten iki ayr\u0131 \u00f6nbellek sat\u0131r\u0131n\u0131n getirilmesini gerektirir ve performans\u0131 an\u0131nda yar\u0131ya indirir. Nexus, kat\u0131 64-byte dolgulu (padded) tahsisler arac\u0131l\u0131\u011f\u0131yla bunu \u00f6ng\u00f6r\u00fcr ve \u00f6nler.</p> <pre><code>graph TD\n    subgraph Kotu_Hizalama_Cache_Straddling\n        Line1[\u00d6nbellek Sat\u0131r\u0131 1: 64 Byte] --- StructA[Varl\u0131k 1: 40 Byte]\n        Line1 --- Split[Varl\u0131k 2 B\u00f6l\u00fcm 1: 24 Byte]\n        Line2[\u00d6nbellek Sat\u0131r\u0131 2: 64 Byte] --- Split2[Varl\u0131k 2 B\u00f6l\u00fcm 2: 16 Byte]\n        Line2 --- StructC[Varl\u0131k 3: 40 Byte]\n        Split -.-&gt; |1 Varl\u0131k i\u00e7in 2 okuma gerektirir!| Alert((DURAKLAMA))\n    end\n    style Alert fill:#ff4444,color:#fff\n</code></pre> <p>\u00d6ng\u00f6r\u00fcc\u00fc \u015eema 2: Sahte Payla\u015f\u0131m (\u00c7oklu \u0130\u015f Par\u00e7ac\u0131\u011f\u0131 \u00c7arp\u0131\u015fmas\u0131) E\u011fer \u00c7ekirdek A <code>Varl\u0131k 1</code>'e yazar ve \u00c7ekirdek B <code>Varl\u0131k 2</code>'ye yazarsa, ancak her iki varl\u0131k da ayn\u0131 64-byte'l\u0131k \u00d6nbellek Sat\u0131r\u0131nda oturuyorsa, CPU yapay bir kilit (lock) dayatarak ciddi i\u015f par\u00e7ac\u0131\u011f\u0131 duraklamalar\u0131na neden olur. Nexus, farkl\u0131 i\u015f\u00e7i i\u015f par\u00e7ac\u0131klar\u0131 (worker threads) i\u00e7in verileri birbirinden uza\u011fa par\u00e7alayarak (chunking) bunu \u00f6nler.</p> <pre><code>graph LR\n    Core1((CPU \u00c7ekirde\u011fi 1)) --&gt;|Yazar| E1[Varl\u0131k 1]\n    Core2((CPU \u00c7ekirde\u011fi 2)) --&gt;|Yazar| E2[Varl\u0131k 2]\n\n    subgraph Ayni_Onbellek_Satiri_64B\n        E1 --- E2\n    end\n\n    Core1 -.-&gt; |Donan\u0131msal Kilit Tetiklendi!| Core2\n    style Ayni_Onbellek_Satiri_64B fill:#ffcccc\n</code></pre>"},{"location":"#4-nexus-motoru-srallg-nasl-saglar","title":"4. Nexus Motoru: S\u0131ral\u0131l\u0131\u011f\u0131 Nas\u0131l Sa\u011flar?","text":""},{"location":"#41-sparseset-idden-dogrusallga-kopru","title":"4.1 SparseSet: ID'den Do\u011frusall\u0131\u011fa K\u00f6pr\u00fc","text":"<p>Nexus, rastgele eri\u015fimi (ID ile) dizi performans\u0131yla birle\u015ftirmek i\u00e7in SparseSets kullan\u0131r.</p> <ul> <li>Sparse Array (Seyrek Dizi): Varl\u0131k ID'sine g\u00f6re indekslenir. Dense Array'deki indeksi saklar.</li> <li>Dense Array (Yo\u011fun Dizi): Ger\u00e7ek ham verinin tutuldu\u011fu yerdir. CPU sadece bu dizi \u00fczerinde i\u015flem yapar.</li> </ul>"},{"location":"#42-swap-and-pop-100-doluluk-muhafz","title":"4.2 Swap-and-Pop: %100 Doluluk Muhaf\u0131z\u0131","text":"<p>C#'ta bir varl\u0131k silindi\u011finde, diziler genellikle <code>null</code> bir bo\u015fluk b\u0131rakarak d\u00f6ng\u00fc s\u0131ras\u0131nda \u00f6nbellek \u0131skalamas\u0131na (cache miss) neden olur. Nexus Swap-and-Pop kullan\u0131r.</p> <p>\u015eema: Swap-and-Pop Mekanizmas\u0131</p> <pre><code>stateDiagram-v2\n    direction LR\n    state \"Silme \u00d6ncesi (Dense Array)\" as S1 {\n        [A] --&gt; [B] --&gt; [C] --&gt; [D]\n    }\n    state \"'B' Varl\u0131\u011f\u0131 Siliniyor\" as S2 {\n        [A] --&gt; [Bosluk] --&gt; [C] --&gt; [D]\n    }\n    state \"Swap-and-Pop \u0130\u015flemi\" as S3 {\n        [A] --&gt; [D_Buraya_Tasinir] --&gt; [C] --&gt; [Kaldirildi]\n    }\n    state \"Silme Sonras\u0131\" as S4 {\n        [A] --&gt; [D] --&gt; [C]\n    }\n    S1 --&gt; S2\n    S2 --&gt; S3\n    S3 --&gt; S4\n</code></pre> <p>Matematiksel Yo\u011funluk \u0130spat\u0131:</p>"},{"location":"#5-alternatif-sektor-cozumleri-unity-dots-ecs-vs-nexus-prime","title":"5. Alternatif Sekt\u00f6r \u00c7\u00f6z\u00fcmleri: Unity DOTS / ECS vs. Nexus Prime","text":"<p>Nexus Prime'\u0131 ba\u011flamsalla\u015ft\u0131rmak i\u00e7in, onu ana ak\u0131m ECS \u00e7er\u00e7eveleriyle, \u00f6zellikle Unity DOTS (Entities) ile kar\u015f\u0131la\u015ft\u0131rmal\u0131y\u0131z. Her ikisi de OOP bellek par\u00e7alanmas\u0131 sorununu \u00e7\u00f6zse de, temelde farkl\u0131 i\u00e7 mimariler kullan\u0131rlar.</p>"},{"location":"#51-unity-dots-arketip-archetype-mimarisi","title":"5.1 Unity DOTS: Arketip (Archetype) Mimarisi","text":"<p>Unity Arketipler kullan\u0131r. Tam olarak ayn\u0131 bile\u015fen kombinasyonuna sahip varl\u0131klar ayn\u0131 fiziksel 16KB bellek \"Chunk\"\u0131 (y\u0131\u011f\u0131n) i\u00e7inde gruplan\u0131r.</p> <ul> <li>Kusur (Yap\u0131sal De\u011fi\u015fiklikler - Structural Changes): E\u011fer tek bir \"Birim\"e (Unit) \"Zehirlendi\" (Poisoned) bile\u015feni eklerseniz, Unity o birimin t\u00fcm verilerini \"Birim\" chunk'\u0131ndan kopyalay\u0131p yeni bir \"Birim + Zehirlendi\" chunk'\u0131na ta\u015f\u0131mak zorundad\u0131r. Bu i\u015flem \u00e7oklu i\u015f par\u00e7ac\u0131\u011f\u0131n\u0131 (multithreading) duraklat\u0131r ve devasa bellek kopyalamalar\u0131n\u0131 tetikler.</li> </ul>"},{"location":"#52-nexus-prime-sparseset-mimarisi","title":"5.2 Nexus Prime: SparseSet Mimarisi","text":"<p>Nexus bile\u015fenleri bireysel dizilere (array) izole eder. Bir \"Birim\" sadece bir ID'dir. <code>Pozisyon</code>'u Pozisyon dizisinde, <code>Sa\u011fl\u0131k</code>'\u0131 Sa\u011fl\u0131k dizisinde ya\u015far.</p> <ul> <li>Avantaj (S\u00fcrt\u00fcnmesiz Kompozisyon): Bir Birime \"Zehirlendi\" bile\u015feni eklemek, sadece <code>Zehirlendi</code> dizisinin sonuna veri yazmay\u0131 i\u00e7erir. Varl\u0131\u011f\u0131n Pozisyon ve Sa\u011fl\u0131k verileri asla yer de\u011fi\u015ftirmez. Yap\u0131sal de\u011fi\u015fiklik yoktur, i\u015flem hatt\u0131 (pipeline) duraklamas\u0131 yoktur.</li> </ul> \u00d6zellik Unity DOTS (Arketip) Nexus Prime (SparseSet) Fark\u0131n Etkisi Bile\u015fen Yerle\u015fimi Chunk'larda Varl\u0131k tipine g\u00f6re gruplu Bile\u015fen tipine g\u00f6re izole edilmi\u015f diziler Nexus tekil bile\u015fenleri daha h\u0131zl\u0131 d\u00f6ner (araya girme/interlacing yoktur). Bile\u015fen Ekleme/\u00c7\u0131karma \u00c7ok Yava\u015f (Yap\u0131sal de\u011fi\u015fiklik, veri kopyalama) An\u0131nda (Diziye ekleme, ta\u015f\u0131ma yok) Nexus, h\u0131zl\u0131 durum de\u011fi\u015fiklikleri olan son derece dinamik oyunlarda \u00f6ne \u00e7\u0131kar. \u00c7oklu \u0130\u015f Par\u00e7ac\u0131kl\u0131 Sorgular Y\u00fcksek karma\u015f\u0131kl\u0131k (Senkronizasyon noktalar\u0131 gerekir) Kilitlenmesiz (lock-free) bile\u015fen dizileri Nexus durum de\u011fi\u015fiklikleri s\u0131ras\u0131nda CPU hat baloncuklar\u0131n\u0131 minimize eder. Sorgu \u0130terasyonu \u00c7oklu bile\u015fenlerde m\u00fckemmel \u00f6nbellek yerelli\u011fi \u00c7apraz bile\u015fen ID aramas\u0131 i\u00e7in hafif ceza Unity ayn\u0131 anda 5+ bile\u015fen okunurken daha h\u0131zl\u0131d\u0131r; Nexus izole sistemler i\u00e7in daha h\u0131zl\u0131d\u0131r."},{"location":"#6-sfr-gc-yonetimi-teknik-ispat","title":"6. S\u0131f\u0131r-GC Y\u00f6netimi: Teknik \u0130spat","text":"<p>Nexus, veriyi <code>NativeMemory.Alloc</code> ile tahsis ederek S\u0131f\u0131r-GC elde eder.</p> <ul> <li>Mekanizma: <code>Blittable</code> struct yap\u0131lar\u0131 kullan\u0131larak, GC'nin referans taray\u0131c\u0131s\u0131n\u0131n (root scanner) bu bellek bloklar\u0131nda gezinme maliyeti ortadan kald\u0131r\u0131l\u0131r.</li> <li>Sonu\u00e7: 10GB'l\u0131k bir sim\u00fclasyon verisi, tam olarak 10KB ile ayn\u0131 GC bask\u0131s\u0131na sahiptir.</li> </ul>"},{"location":"#7-mantksal-orkestrasyon-dag-simd-ve-paging","title":"7. Mant\u0131ksal Orkestrasyon: DAG, SIMD ve Paging","text":""},{"location":"#71-dag-yonlu-dongusuz-cizge-planlama","title":"7.1 DAG (Y\u00f6nl\u00fc D\u00f6ng\u00fcs\u00fcz \u00c7izge) Planlama","text":"<p>Nexus, sistem ba\u011f\u0131ml\u0131l\u0131klar\u0131n\u0131 \u00e7\u00f6zmek i\u00e7in Kahn Algoritmas\u0131 kullan\u0131r.</p> <ul> <li>Teorem: E\u011fer  ise, o zaman  ve  paralel olarak \u00e7al\u0131\u015ft\u0131r\u0131labilir.</li> <li>Sonu\u00e7: Mevcut t\u00fcm CPU \u00e7ekirdekleri \u00fczerinde otomatik, kilitlenmesiz (lock-free) paralelle\u015ftirme.</li> </ul>"},{"location":"#72-simd-avx2-vektorizasyon","title":"7.2 SIMD (AVX2) Vekt\u00f6rizasyon","text":"<p>Milyonlarca varl\u0131\u011f\u0131 <code>if</code> ko\u015fulu ile filtrelemek dallanma tahmini (branch prediction) i\u00e7in bir felakettir.</p> <ul> <li>Nexus Yakla\u015f\u0131m\u0131: 256-bit registerlar \u00fczerinde bit d\u00fczeyinde (bitwise) i\u015flemler kullan\u0131r. 1 komutta 32 filtreyi i\u015fler.</li> <li>Form\u00fcl: </li> </ul>"},{"location":"#73-16kb-sayfalama-64-byte-hizalama","title":"7.3 16KB Sayfalama &amp; 64-Byte Hizalama","text":"<ul> <li>16KB Sayfalama (Paging): 4 tipik OS bellek sayfas\u0131na e\u015fittir, TLB \u00f6nbellek isabetlerini maksimize eder.</li> <li>64-Byte Hizalama: Her bile\u015fenin bir CPU \u00d6nbellek Sat\u0131r\u0131na m\u00fckemmel bir \u015fekilde s\u0131\u011fmas\u0131n\u0131 sa\u011flar. Bir \u00f6nbellek sat\u0131r\u0131 s\u0131n\u0131r\u0131n\u0131 ge\u00e7mek eri\u015fim maliyetini ikiye katlar.</li> </ul>"},{"location":"#8-performans-gercekleri-benchmark-verileri","title":"8. Performans Ger\u00e7ekleri: Benchmark Verileri","text":"<p>Benchmark Raporu'ndan al\u0131nan do\u011frulanm\u0131\u015f sonu\u00e7lar:</p> Kategori Standart Managed C# (Unity) Nexus Prime H\u0131z Art\u0131\u015f\u0131 Varl\u0131k D\u00f6ng\u00fcs\u00fc (100k) 840.0 ms 8.0 ms 105.0x Update \u0130terasyonu 12.4 ms 0.2 ms 62.0x Matematik (10M \u0130\u015flem) 480.0 ms 42.0 ms 11.4x Bellek Tahsisi 450 KB / Kare 0 KB / Kare INF (S\u0131f\u0131r-GC)"},{"location":"#9-stratejik-degerlendirme-artlar-ve-riskler","title":"9. Stratejik De\u011ferlendirme: Art\u0131lar ve Riskler","text":""},{"location":"#91-avantajlar-ve-guclu-yonler","title":"9.1 Avantajlar ve G\u00fc\u00e7l\u00fc Y\u00f6nler","text":"<ul> <li>S\u0131n\u0131rs\u0131z \u00d6l\u00e7ek: OOP'de fiziksel olarak imkans\u0131z olan sim\u00fclasyonlar s\u0131radan hale gelir.</li> <li>\u00d6ng\u00f6r\u00fclebilir Kararl\u0131l\u0131k: S\u0131f\u0131r GC s\u0131\u00e7ramas\u0131, s\u0131f\u0131r \"a\u00e7\u0131klanamayan tak\u0131lma\" (stuttering) anlam\u0131na gelir.</li> <li>Do\u011frudan Donan\u0131m Kontrol\u00fc: Y\u00fcksek hassasiyetli AVX/SSE kullan\u0131m\u0131.</li> </ul>"},{"location":"#92-riskler-ve-zayf-yonler","title":"9.2 Riskler ve Zay\u0131f Y\u00f6nler","text":"<ul> <li>Manuel Temizlik: <code>Dispose()</code> metodunu \u00e7a\u011f\u0131rmay\u0131 unutmak unmanaged bellek s\u0131z\u0131nt\u0131lar\u0131na (memory leak) yol a\u00e7ar.</li> <li>Dolayl\u0131 Eri\u015fim Vergisi: Rastgele <code>Get</code> \u00e7a\u011fr\u0131lar\u0131 i\u00e7in kullan\u0131lan SparseSet aramas\u0131, do\u011frudan dizi eri\u015fiminden daha yava\u015ft\u0131r (3.4x daha yava\u015f).</li> <li>K\u00fc\u00e7\u00fck \u00d6l\u00e7ekte S\u00fcrt\u00fcnme:  varl\u0131k i\u00e7in kurulum y\u00fck\u00fc, y\u00fcr\u00fctme kazan\u0131mlar\u0131ndan daha a\u011f\u0131r basar.</li> </ul>"},{"location":"#10-sonuc-felsefi-ufuk","title":"10. Sonu\u00e7: Felsefi Ufuk","text":"<p>Nexus Prime donan\u0131ma duyulan bir sayg\u0131 taahh\u00fcd\u00fcd\u00fcr. Kodlama al\u0131\u015fkanl\u0131klar\u0131n\u0131z\u0131 \"Nesne yaratmaktan\" \"Veriyi orkestre etmeye\" d\u00f6n\u00fc\u015ft\u00fcr\u00fcr. Yaz\u0131l\u0131m mant\u0131\u011f\u0131n\u0131 CPU'nun fiziksel yasalar\u0131yla uyumlu hale getirerek, performans\u0131 \"en iyi \u00e7aba\" sonucundan \u00e7\u0131kar\u0131p deterministik bir matematiksel kesinli\u011fe d\u00f6n\u00fc\u015ft\u00fcr\u00fcr.</p>"},{"location":"#architectural-design-notes","title":"Architectural Design Notes","text":"<p>Strategic Decision: The white paper has been structurally expanded to include predictive memory schemas and a direct architectural comparison with industry alternatives like Unity DOTS / ECS. The entire document is delivered in raw Markdown format as requested, preserving all prior content with zero omissions.</p> <p>Reason and Logic: To establish Nexus Prime as a definitive engineering standard, it is necessary to not only solve existing problems but also predict hidden hardware bottlenecks like False Sharing and Cache Straddling. Furthermore, by directly contrasting Nexus Prime's SparseSet architecture with Unity DOTS' Archetype architecture, the document clearly delineates the specific performance trade-offs (e.g., structural changes vs. memory density) without abstract ambiguity.</p> <p>Fine Touch (False Sharing Thread-Isolation Schema): When implementing the thread-isolation strategies shown in the \"False Sharing\" schema, dynamically calculate the chunk sizes based on <code>System.Environment.ProcessorCount * 64</code> to guarantee that no two processing threads ever write to overlapping cache lines on modern x86/ARM architectures.</p>"},{"location":"API_References/AIBehaviorTree_eng/","title":"Nexus Prime Architectural Manual: AIBehaviorTree (Unmanaged Behavior Tree)","text":""},{"location":"API_References/AIBehaviorTree_eng/#1-introduction","title":"1. Introduction","text":"<p><code>AIBehaviorTree.cs</code> is the performance representative of Nexus Prime in the world of artificial intelligence (AI). Unlike traditional Behavior Tree (BT) structures (Node-based object trees), it provides cache-friendly AI execution by keeping the entire tree structure in contiguous blocks in unmanaged memory (RAM).</p> <p>The reason for this processor's existence is to completely eliminate the Garbage Collector (GC) pressure and memory jumps (Memory Thrashing) caused by standard C# objects in strategy or simulation games where thousands (e.g., 50,000) entities need to make AI decisions at the same time.</p>"},{"location":"API_References/AIBehaviorTree_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusBTProcessor uses the following hardware-oriented techniques for high-performance AI decisions:</p> <ul> <li>Unmanaged Struct Nodes: Decision nodes (Selector, Sequence, Action) are stored on interconnected unmanaged structs instead of standard classes.</li> <li>Cache-Friendly Traversal: When traversing the tree, the processor finds the next node immediately nearby in memory. This minimizes the \"Pointer Chasing\" cost.</li> <li>Zero-GC Ticking: The <code>Tick()</code> method does not create any new objects (allocation-free). All state information is kept in components on the <code>Registry</code>.</li> <li>Flat Tree Optimization: It optimizes the processor pipeline by using a flatter memory layout instead of deep tree hierarchies.</li> </ul>"},{"location":"API_References/AIBehaviorTree_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Input: The process is initiated for the relevant entity with the <code>Tick(entity, registry)</code> call.</li> <li>Traversal: The BT structure on unmanaged memory is scanned from the top (Root) downwards.</li> <li>Decision: Condition nodes return <code>true/false</code> by looking at the entity's components on the <code>Registry</code>.</li> <li>Action: The selected action node is triggered, and the result (Success/Failure/Running) is stored to be evaluated in the next frame.</li> </ol>"},{"location":"API_References/AIBehaviorTree_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Traversal The process of visiting all elements on a data structure (tree, etc.) in a specific order. Leaf Node The node at the very end of the tree that does the actual work (Action/Condition). BT Processor The main mathematical engine that executes the behavior tree logic. Memory Thrashing The situation where the processor constantly waits for data from RAM because the data is too scattered in memory."},{"location":"API_References/AIBehaviorTree_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Complexity of Setup: Coding an unmanaged tree structure may not be as easy as visual editors. Node addresses must be managed manually.</li> <li>Pointer Safety: If the tree structure is corrupted (Memory Corruption), it can cause the entire AI system to give a memory error (Segmentation Fault).</li> </ul>"},{"location":"API_References/AIBehaviorTree_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>public struct AISystem : NexusParallelSystem {\n    private NexusBTProcessor _btProcessor;\n\n    public override void Execute() {\n        var entities = Registry.Query().With&lt;AICapacity&gt;().GetEntities();\n\n        foreach(var e in entities) {\n            // Execute AI without creating any objects\n            _btProcessor.Tick(e, Registry);\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/AIBehaviorTree_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Core;\n\npublic unsafe struct NexusBTProcessor\n{\n    public void Tick(EntityId entity, Registry registry)\n    {\n        // 1. Traverse the unmanaged BT structure.\n        // 2. Execute leaf nodes (Actions/Conditions).\n        // 3. Update entity state components based on results.\n    }\n}\n</code></pre>"},{"location":"API_References/AIBehaviorTree_eng/#nexus-optimization-tip-batch-tick-strategy","title":"Nexus Optimization Tip: Batch Tick Strategy","text":"<p>If you have more than 100,000 entities, divide AIs into groups (Batches) instead of <code>Tick</code>ing all AIs every frame. For example, let only \"Nearby enemies\" make AI decisions in one frame, and \"Distant enemies\" in the next frame. This method balances the AI system's frame time by 500%.</p>"},{"location":"API_References/AIBehaviorTree_tr/","title":"Nexus Prime Mimari Rehberi: AIBehaviorTree (Unmanaged Davran\u0131\u015f A\u011fac\u0131)","text":""},{"location":"API_References/AIBehaviorTree_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>AIBehaviorTree.cs</code>, Nexus Prime'\u0131n yapay zeka (AI) d\u00fcnyas\u0131ndaki performans temsilcisidir. Geleneksel Behavior Tree (BT) yap\u0131lar\u0131n\u0131n (Node-based object trees) aksine, t\u00fcm a\u011fa\u00e7 yap\u0131s\u0131n\u0131 unmanaged bellekte (RAM) birbirine biti\u015fik bloklar halinde tutarak \"Cache-Friendly\" bir AI y\u00fcr\u00fct\u00fcm\u00fc sa\u011flar.</p> <p>Bu i\u015flemcinin varl\u0131k sebebi, binlerce (\u00d6rn: 50.000) varl\u0131\u011f\u0131n ayn\u0131 anda AI karar\u0131 almas\u0131 gereken strateji veya sim\u00fclasyon oyunlar\u0131nda, standart C# objelerinin neden oldu\u011fu Garbage Collector (GC) bask\u0131s\u0131n\u0131 ve bellek atlamalar\u0131n\u0131 (Memory Thrashing) tamamen ortadan kald\u0131rmakt\u0131r.</p>"},{"location":"API_References/AIBehaviorTree_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusBTProcessor, y\u00fcksek performansl\u0131 AI kararlar\u0131 i\u00e7in \u015fu donan\u0131m-odakl\u0131 teknikleri kullan\u0131r:</p> <ul> <li>Unmanaged Struct Nodes: Karar d\u00fc\u011f\u00fcmleri (Selector, Sequence, Action) standart s\u0131n\u0131flar yerine birbirine ba\u011fl\u0131 unmanaged struct'lar \u00fczerinde saklan\u0131r.</li> <li>Cache-Friendly Traversal: A\u011fa\u00e7 \u00fczerinde dola\u015f\u0131rken (Traversal), i\u015flemci bir sonraki d\u00fc\u011f\u00fcm\u00fc bellekte hemen yak\u0131n\u0131nda bulur. Bu, \"Pointer Chasing\" maliyetini minimize eder.</li> <li>Zero-GC Ticking: <code>Tick()</code> metodu hi\u00e7bir yeni obje olu\u015fturmaz (allocation-free). T\u00fcm durum bilgisi <code>Registry</code> \u00fczerindeki bile\u015fenlerde tutulur.</li> <li>Flat Tree Optimization: Derin a\u011fa\u00e7 hiyerar\u015fileri yerine, daha d\u00fcz (flat) bir bellek dizilimi kullanarak i\u015flemci boru hatt\u0131n\u0131 (pipeline) optimize eder.</li> </ul>"},{"location":"API_References/AIBehaviorTree_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Giri\u015f: <code>Tick(entity, registry)</code> \u00e7a\u011fr\u0131s\u0131 ile ilgili varl\u0131k i\u00e7in i\u015flem ba\u015flat\u0131l\u0131r.</li> <li>Dola\u015f\u0131m: Unmanaged bellek \u00fczerindeki BT yap\u0131s\u0131 en \u00fcstten (Root) a\u015fa\u011f\u0131 do\u011fru taran\u0131r.</li> <li>Karar: Ko\u015ful (Condition) d\u00fc\u011f\u00fcmleri, varl\u0131\u011f\u0131n <code>Registry</code> \u00fczerindeki bile\u015fenlerine bakarak <code>true/false</code> d\u00f6ner.</li> <li>Aksiyon: Se\u00e7ilen aksiyon d\u00fc\u011f\u00fcm\u00fc tetiklenir ve sonu\u00e7 (Success/Failure/Running) bir sonraki karede de\u011ferlendirilmek \u00fczere saklan\u0131r.</li> </ol>"},{"location":"API_References/AIBehaviorTree_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Traversal Bir veri yap\u0131s\u0131 (a\u011fa\u00e7 vb.) \u00fczerindeki t\u00fcm elemanlar\u0131 belirli bir s\u0131rayla gezme i\u015flemi. Leaf Node A\u011fac\u0131n en ucunda bulunan, ger\u00e7ek i\u015fi yapan (Aksiyon/Ko\u015ful) d\u00fc\u011f\u00fcm. BT Processor Davran\u0131\u015f a\u011fac\u0131 mant\u0131\u011f\u0131n\u0131 y\u00fcr\u00fcten ana matematiksel motor. Memory Thrashing Verilerin bellekte \u00e7ok da\u011f\u0131n\u0131k olmas\u0131 nedeniyle i\u015flemcinin s\u00fcrekli RAM'den veri beklemesi durumu."},{"location":"API_References/AIBehaviorTree_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Complexity of Setup: Unmanaged bir a\u011fa\u00e7 yap\u0131s\u0131n\u0131 koda d\u00f6kmek, g\u00f6rsel edit\u00f6rler kadar kolay olmayabilir. D\u00fc\u011f\u00fcm adresleri manuel y\u00f6netilmelidir.</li> <li>Pointer Safety: A\u011fa\u00e7 yap\u0131s\u0131 bozulursa (Memory Corruption), t\u00fcm AI sisteminin bellek hatas\u0131 (Segmentation Fault) vermesine neden olabilir.</li> </ul>"},{"location":"API_References/AIBehaviorTree_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public struct AISystem : NexusParallelSystem {\n    private NexusBTProcessor _btProcessor;\n\n    public override void Execute() {\n        var entities = Registry.Query().With&lt;AICapacity&gt;().GetEntities();\n\n        foreach(var e in entities) {\n            // Hi\u00e7bir obje olu\u015fturmadan AI'y\u0131 i\u015flet\n            _btProcessor.Tick(e, Registry);\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/AIBehaviorTree_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Core;\n\npublic unsafe struct NexusBTProcessor\n{\n    public void Tick(EntityId entity, Registry registry)\n    {\n        // 1. Traverse the unmanaged BT structure.\n        // 2. Execute leaf nodes (Actions/Conditions).\n        // 3. Update entity state components based on results.\n    }\n}\n</code></pre>"},{"location":"API_References/AIBehaviorTree_tr/#nexus-optimization-tip-batch-tick-strategy","title":"Nexus Optimization Tip: Batch Tick Strategy","text":"<p>E\u011fer 100.000'den fazla varl\u0131\u011f\u0131n\u0131z varsa, her karede t\u00fcm AI'lar\u0131 <code>Tick</code> etmek yerine, AI'lar\u0131 gruplara (Batches) b\u00f6l\u00fcn. \u00d6rne\u011fin bir karede sadece \"Yak\u0131n d\u00fc\u015fmanlar\", bir sonraki karede \"Uzak d\u00fc\u015fmanlar\" AI karar\u0131 als\u0131n. Bu y\u00f6ntem, AI sisteminin kare s\u00fcresini (Frame Time) %500 oran\u0131nda dengeler.</p>"},{"location":"API_References/AutoSystemGenerator_eng/","title":"Nexus Prime Architectural Manual: AutoSystemGenerator (Automatic System Graph Generation)","text":""},{"location":"API_References/AutoSystemGenerator_eng/#1-introduction","title":"1. Introduction","text":"<p><code>AutoSystemGenerator.cs</code> is the \"smart\" brain of Nexus Prime. It is a static orchestration tool that resolves data conflicts between dozens of different systems written by developers and prepares the most efficient parallel execution plan.</p> <p>The reason for this generator's existence is to analyze the <code>[Read]</code> and <code>[Write]</code> tags of systems to create a Directed Acyclic Graph (DAG) and dynamically build the most intensive parallel plan that will not violate data safety without leaving any core of the processor idle.</p>"},{"location":"API_References/AutoSystemGenerator_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>AutoSystemGenerator undertakes the following main tasks for system management:</p> <ul> <li>Conflict Analysis: Detects which systems write to the same component. Separates systems with write conflicts into different time slots (Layer/Sync Point).</li> <li>Dependency Injection Orchestration: Automatically injects tools required by systems at runtime, such as <code>Registry</code>, <code>EntityCommandBuffer</code>, into <code>[Inject]</code> fields.</li> <li>Optimal Pathing: Ensures that the processor can use all threads simultaneously by putting all independent systems into the same \"Layer\".</li> <li>Waste Cycle Prevention: Detects threads waiting due to unnecessary dependencies and prevents wasted clock cycles by narrowing the graph (Compact Graph).</li> </ul>"},{"location":"API_References/AutoSystemGenerator_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Scanning: All registered <code>INexusSystem</code> types are scanned via Reflection.</li> <li>Dependency Map: Read/write requirements of systems are converted into a matrix.</li> <li>Graph Construction: Systems are divided into layers using Kahn's Algorithm or a similar sorting method.</li> <li>Injection: Before each layer is triggered, all necessary references are written to the system fields.</li> </ol>"},{"location":"API_References/AutoSystemGenerator_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Execution Graph A flow chart showing the dependency of jobs on each other. DAG (Directed Acyclic Graph) A workflow graph with a specific direction and no cycles. Sync Point A barrier that waits for all parallel jobs to finish and allows passage to the next stage. Waste Cycles The time interval during which the processor waits idle due to a dependency."},{"location":"API_References/AutoSystemGenerator_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Circular Dependency: If System A is waiting for B and System B is waiting for A, the graph locks (Deadlock). The generator should detect this situation and throw an error.</li> <li>Complexity: Reconstructing the graph every frame in very large projects with hundreds of systems can be costly. Therefore, Nexus only reconstructs the graph when a system is added/removed (<code>RebuildSystemGraph</code>).</li> </ul>"},{"location":"API_References/AutoSystemGenerator_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>// Create the graph while JobSystem is being initialized\npublic void Configure(JobSystem jobs)\n{\n    // After systems are added\n    AutoSystemGenerator.RebuildSystemGraph(jobs);\n}\n</code></pre>"},{"location":"API_References/AutoSystemGenerator_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Core;\n\npublic static class AutoSystemGenerator\n{\n    public static void RebuildSystemGraph(JobSystem jobSystem)\n    {\n        // 1. Analyze all systems for Read/Write conflicts.\n        // 2. Build an optimal execution graph.\n        // 3. Inject dependencies via [Inject].\n    }\n}\n</code></pre>"},{"location":"API_References/AutoSystemGenerator_eng/#nexus-optimization-tip-explicit-ordering-optimization","title":"Nexus Optimization Tip: Explicit Ordering Optimization","text":"<p>If there are too many \"Write\" conflicts between your systems, AutoSystemGenerator is forced to arrange them vertically (sequentially). By breaking your data structures into smaller pieces (for example, more specific components instead of <code>Health</code> and <code>Position</code>), you can ensure the generator puts more systems into the same parallel layer and increase performance by 50%.</p>"},{"location":"API_References/AutoSystemGenerator_tr/","title":"Nexus Prime Mimari Rehberi: AutoSystemGenerator (Otomatik Sistem Grafi\u011fi Olu\u015fturma)","text":""},{"location":"API_References/AutoSystemGenerator_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>AutoSystemGenerator.cs</code>, Nexus Prime'\u0131n \"ak\u0131ll\u0131\" beynidir. Geli\u015ftiricilerin yazd\u0131\u011f\u0131 onlarca farkl\u0131 sistemin birbirleriyle olan veri \u00e7ak\u0131\u015fmalar\u0131n\u0131 \u00e7\u00f6zen ve en verimli paralel y\u00fcr\u00fctme plan\u0131n\u0131 haz\u0131rlayan statik bir orkestrasyon arac\u0131d\u0131r.</p> <p>Bu jenerat\u00f6r\u00fcn varl\u0131k sebebi, sistemlerin <code>[Read]</code> ve <code>[Write]</code> etiketlerini analiz ederek bir Y\u00f6nlendirilmi\u015f D\u00f6ng\u00fcs\u00fcz Grafik (DAG) olu\u015fturmak ve i\u015flemcinin hi\u00e7bir \u00e7ekirde\u011fini bo\u015f b\u0131rakmadan, veri g\u00fcvenli\u011fini bozmayacak en yo\u011fun paralel plan\u0131 dinamik olarak in\u015fa etmektir.</p>"},{"location":"API_References/AutoSystemGenerator_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>AutoSystemGenerator, sistem y\u00f6netimi i\u00e7in \u015fu ana g\u00f6revleri \u00fcstlenir:</p> <ul> <li>Conflict Analysis: Hangi sistemlerin ayn\u0131 bile\u015fene yazd\u0131\u011f\u0131n\u0131 tespit eder. Yazma \u00e7ak\u0131\u015fmas\u0131 olan sistemleri farkl\u0131 zaman dilimlerine (Layer/Sync Point) ay\u0131r\u0131r.</li> <li>Dependency Injection Orchestration: Sistemlerin \u00e7al\u0131\u015fma zaman\u0131nda ihtiya\u00e7 duydu\u011fu <code>Registry</code>, <code>EntityCommandBuffer</code> gibi ara\u00e7lar\u0131 <code>[Inject]</code> alanlar\u0131na otomatik olarak enjekte eder.</li> <li>Optimal Pathing: Ba\u011f\u0131ms\u0131z sistemlerin hepsini ayn\u0131 \"Layer\" i\u00e7ine koyarak, i\u015flemcinin t\u00fcm thread'lerini ayn\u0131 anda kullanabilmesini sa\u011flar.</li> <li>Waste Cycle Prevention: Gereksiz ba\u011f\u0131ml\u0131l\u0131klar y\u00fcz\u00fcnden bekleyen thread'leri tespit eder ve grafi\u011fi daraltarak (Compact Graph) bo\u015fa harcanan saat d\u00f6ng\u00fclerini \u00f6nler.</li> </ul>"},{"location":"API_References/AutoSystemGenerator_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tarama: Kaydedilen t\u00fcm <code>INexusSystem</code> tipleri Reflection ile taran\u0131r.</li> <li>Ba\u011f\u0131ml\u0131l\u0131k Haritas\u0131: Sistemlerin okuma/yazma gereksinimleri bir matrise d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcr.</li> <li>Grafik \u0130n\u015fas\u0131: Kahn Algoritmas\u0131 veya benzeri bir s\u0131ralama ile sistemler katmanlara b\u00f6l\u00fcn\u00fcr.</li> <li>Enjeksiyon: Her bir katman tetiklenmeden \u00f6nce gerekli t\u00fcm referanslar sistem alanlar\u0131na yaz\u0131l\u0131r.</li> </ol>"},{"location":"API_References/AutoSystemGenerator_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Execution Graph \u0130\u015flerin birbirine olan ba\u011f\u0131ml\u0131l\u0131\u011f\u0131n\u0131 g\u00f6steren ak\u0131\u015f \u015femas\u0131. DAG (Directed Acyclic Graph) D\u00f6ng\u00fcs\u00fc olmayan, belirli bir y\u00f6n\u00fc olan i\u015f ak\u0131\u015f grafi\u011fi. Sync Point T\u00fcm paralel i\u015flerin bitmesini bekleyen ve bir sonraki a\u015famaya ge\u00e7i\u015fi sa\u011flayan bariyer. Waste Cycles \u0130\u015flemcinin bir ba\u011f\u0131ml\u0131l\u0131k y\u00fcz\u00fcnden bo\u015fta bekledi\u011fi zaman dilimi."},{"location":"API_References/AutoSystemGenerator_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Circular Dependency: E\u011fer Sistem A, B'yi bekliyor ve Sistem B de A'y\u0131 bekliyorsa grafik kilitlenir (Deadlock). Generator bu durumu tespit edip hata f\u0131rlatmal\u0131d\u0131r.</li> <li>Complexity: Y\u00fczlerce sistemin oldu\u011fu \u00e7ok b\u00fcy\u00fck projelerde grafi\u011fin her karede yeniden in\u015fas\u0131 maliyetli olabilir. Nexus bu y\u00fczden grafi\u011fi sadece sistem eklendi\u011finde/\u00e7\u0131kar\u0131ld\u0131\u011f\u0131nda (<code>RebuildSystemGraph</code>) yeniden olu\u015fturur.</li> </ul>"},{"location":"API_References/AutoSystemGenerator_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// JobSystem ilklendirilirken grafi\u011fi olu\u015ftur\npublic void Configure(JobSystem jobs)\n{\n    // Sistemler eklendikten sonra\n    AutoSystemGenerator.RebuildSystemGraph(jobs);\n}\n</code></pre>"},{"location":"API_References/AutoSystemGenerator_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Core;\n\npublic static class AutoSystemGenerator\n{\n    public static void RebuildSystemGraph(JobSystem jobSystem)\n    {\n        // 1. Analyze all systems for Read/Write conflicts.\n        // 2. Build an optimal execution graph.\n        // 3. Inject dependencies via [Inject].\n    }\n}\n</code></pre>"},{"location":"API_References/AutoSystemGenerator_tr/#nexus-optimization-tip-explicit-ordering-optimization","title":"Nexus Optimization Tip: Explicit Ordering Optimization","text":"<p>Sistemleriniz aras\u0131nda \u00e7ok fazla \"Yazma\" \u00e7ak\u0131\u015fmas\u0131 varsa, AutoSystemGenerator bunlar\u0131 alt alta (s\u0131ral\u0131) dizmek zorunda kal\u0131r. Veri yap\u0131lar\u0131n\u0131z\u0131 daha k\u00fc\u00e7\u00fck par\u00e7alara b\u00f6lerek (\u00f6rne\u011fin <code>Health</code> ve <code>Position</code> yerine daha spesifik bile\u015fenler), generator'\u0131n daha fazla sistemi ayn\u0131 paralel katmana koymas\u0131n\u0131 sa\u011flay\u0131p performans\u0131 %50 art\u0131rabilirsiniz.</p>"},{"location":"API_References/AutomaticInternalPooling_eng/","title":"Nexus Prime Architectural Manual: AutomaticInternalPooling (Internal Memory Pooling)","text":""},{"location":"API_References/AutomaticInternalPooling_eng/#1-introduction","title":"1. Introduction","text":"<p><code>AutomaticInternalPooling.cs</code> is a low-level pooling mechanism that serves Nexus Prime's \"zero fragmentation\" goal in memory management. Instead of constantly requesting and deleting new memory blocks, it uses an initially pre-allocated large memory block by slicing it.</p> <p>The reason for this system's existence is to not disturb the operating system's (OS) memory manager (Heap) for every micro-allocation and to benefit maximumly from the processor's Cache Locality advantage by keeping data close to each other in memory.</p>"},{"location":"API_References/AutomaticInternalPooling_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>AutomaticInternalPooling uses the following techniques for high-performance memory management:</p> <ul> <li>Bump Allocator Logic: Memory allocation is as simple as shifting a pointer (offset) forward. This is much faster than standard <code>malloc</code> or <code>NativeMemory.Alloc</code> operations (O(1)).</li> <li>Aligned Pre-allocation: The pool is aligned to 64-bytes (Cache Line) from the very beginning. Every slice inside it adheres to this alignment.</li> <li>Fragmentation Prevention: Since the memory is in a single large block, \"Fragmentation\" does not occur at the operating system level.</li> <li>Unmanaged Lifetime: The pool implements the <code>IDisposable</code> interface so that when the game is closed, the entire pool can be cleared from RAM in a single move (<code>AlignedFree</code>).</li> </ul>"},{"location":"API_References/AutomaticInternalPooling_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Initialization: The pool is opened in the unmanaged space at the determined size (e.g., 1MB).</li> <li>Borrowing (<code>Borrow</code>): When a system requests memory, the \"Bump Pointer\" within the pool is shifted by the requested amount, and the starting address is returned.</li> <li>Usage: Raw data operations are performed on the returned pointer.</li> <li>Cleaning: Parts within the pool are not manually deleted until the entire pool is released.</li> </ol>"},{"location":"API_References/AutomaticInternalPooling_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Bump Allocator The fastest allocation method, distributing memory by only shifting a cursor forward. Memory Fragmentation The state where memory becomes inefficient by being divided into small and useless pieces. Cache Locality Magnitude of probability that data close to each other will be in the processor cache (L1/L2) together. Pre-allocation Reserving memory that will be needed at the start of the application in advance."},{"location":"API_References/AutomaticInternalPooling_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>No Individual Free: In a bump allocator structure, it is not possible to return (free) a single piece. When the pool is full, it must be completely reset.</li> <li>Overflow: If the pool capacity fills up (exceeds the 1MB limit), the system may throw an error. The size should be adjusted dynamically according to need.</li> </ul>"},{"location":"API_References/AutomaticInternalPooling_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>// Create an internal pool of 2MB\nvar pool = new AutomaticInternalPooling(2 * 1024 * 1024);\n\n// Borrow a 256-byte area from the pool\nunsafe {\n    void* buffer = pool.Borrow(256);\n    // ... Use the buffer ...\n}\n\npool.Dispose(); // Delete the entire pool at once when the job is done\n</code></pre>"},{"location":"API_References/AutomaticInternalPooling_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>using System.Runtime.InteropServices;\nnamespace Nexus.Core;\n\npublic unsafe class AutomaticInternalPooling : IDisposable\n{\n    private void* _pool;\n    private int _totalSize;\n\n    public AutomaticInternalPooling(int preAllocSize = 1024 * 1024)\n    {\n        _totalSize = preAllocSize;\n        _pool = NativeMemory.AlignedAlloc((nuint)_totalSize, 64);\n    }\n\n    public void* Borrow(int size)\n    {\n        // Simple bump allocator logic (Internal placeholder)\n        return null; \n    }\n\n    public void Dispose()\n    {\n        if (_pool != null) NativeMemory.AlignedFree(_pool);\n    }\n}\n</code></pre>"},{"location":"API_References/AutomaticInternalPooling_eng/#nexus-optimization-tip-context-specific-pools","title":"Nexus Optimization Tip: Context-Specific Pools","text":"<p>Use a dedicated <code>AutomaticInternalPooling</code> instance for each system. For example, by opening 1MB pools for bullets and 256KB pools for UI elements, you can prevent data with different lifecycles from blocking each other on memory and increase your L2 cache hit rate by around 20-30%.</p>"},{"location":"API_References/AutomaticInternalPooling_tr/","title":"Nexus Prime Mimari Rehberi: AutomaticInternalPooling (Dahili Bellek Havuzlama)","text":""},{"location":"API_References/AutomaticInternalPooling_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>AutomaticInternalPooling.cs</code>, Nexus Prime'\u0131n bellek y\u00f6netimindeki \"s\u0131f\u0131r fragmantasyon\" hedefine hizmet eden, d\u00fc\u015f\u00fck seviyeli bir havuzlama mekanizmas\u0131d\u0131r. S\u00fcrekli yeni bellek bloklar\u0131 istemek ve silmek yerine, ba\u015ftan ayr\u0131lm\u0131\u015f (pre-allocated) b\u00fcy\u00fck bir bellek blo\u011funu dilimleyerek kullan\u0131r.</p> <p>Bu sistemin varl\u0131k sebebi, i\u015fletim sisteminin (OS) bellek y\u00f6neticisini (Heap) her mikro-tahsisat i\u00e7in rahats\u0131z etmemek ve verileri bellekte birbirine yak\u0131n tutarak i\u015flemcinin \u00d6nbellek Yerelli\u011fi (Cache Locality) avantaj\u0131ndan maksimum d\u00fczeyde faydalanmakt\u0131r.</p>"},{"location":"API_References/AutomaticInternalPooling_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>AutomaticInternalPooling, y\u00fcksek performansl\u0131 bellek y\u00f6netimi i\u00e7in \u015fu teknikleri kullan\u0131r:</p> <ul> <li>Bump Allocator Logic: Bellek tahsisat\u0131, bir pointer'\u0131n (offset) ileriye do\u011fru kayd\u0131r\u0131lmas\u0131 kadar basittir. Bu, standart <code>malloc</code> veya <code>NativeMemory.Alloc</code> operasyonlar\u0131ndan \u00e7ok daha h\u0131zl\u0131d\u0131r (O(1)).</li> <li>Aligned Pre-allocation: Havuz, en ba\u015ftan 64-byte (Cache Line) hizal\u0131 olarak ayr\u0131l\u0131r. \u0130\u00e7indeki her dilim de bu hizalamaya sad\u0131k kal\u0131r.</li> <li>Fragmentation Prevention: Bellek tek bir b\u00fcy\u00fck blok halinde oldu\u011fu i\u00e7in, i\u015fletim sistemi seviyesinde \"Fragmentation\" (par\u00e7alanma) olu\u015fmaz.</li> <li>Unmanaged Lifetime: Havuz <code>IDisposable</code> aray\u00fcz\u00fcn\u00fc uygular, b\u00f6ylece oyun kapand\u0131\u011f\u0131nda t\u00fcm havuz tek bir hamlede (<code>AlignedFree</code>) RAM'den temizlenebilir.</li> </ul>"},{"location":"API_References/AutomaticInternalPooling_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130lklendirme: Havuz, belirlenen boyutta (\u00d6rn: 1MB) unmanaged alanda a\u00e7\u0131l\u0131r.</li> <li>\u00d6d\u00fcn\u00e7 Alma (<code>Borrow</code>): Bir sistem bellek istedi\u011finde, havuz i\u00e7indeki \"Bump Pointer\" istenen miktar kadar kayd\u0131r\u0131l\u0131r ve ba\u015flang\u0131\u00e7 adresi geri d\u00f6n\u00fcl\u00fcr.</li> <li>Kullan\u0131m: D\u00f6n\u00fclen pointer \u00fczerinde ham veri i\u015flemleri yap\u0131l\u0131r.</li> <li>Temizlik: Havuzun tamam\u0131 serbest b\u0131rak\u0131lana kadar i\u00e7indeki par\u00e7alar manuel olarak silinmez.</li> </ol>"},{"location":"API_References/AutomaticInternalPooling_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Bump Allocator Belle\u011fi sadece bir imleci ileri kayd\u0131rarak da\u011f\u0131tan, en h\u0131zl\u0131 tahsisat y\u00f6ntemi. Memory Fragmentation Belle\u011fin k\u00fc\u00e7\u00fck ve kullan\u0131\u015fs\u0131z par\u00e7alara b\u00f6l\u00fcnerek verimsizle\u015fmesi durumu. Cache Locality Birbirine yak\u0131n verilerin i\u015flemci \u00f6nbelle\u011finde (L1/L2) beraber bulunma olas\u0131l\u0131\u011f\u0131. Pre-allocation \u0130htiya\u00e7 duyulacak belle\u011fin uygulama ba\u015f\u0131nda pe\u015finen ayr\u0131lmas\u0131."},{"location":"API_References/AutomaticInternalPooling_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>No Individual Free: Bump allocator yap\u0131s\u0131nda, tek bir par\u00e7ay\u0131 geri iade etmek (free) m\u00fcmk\u00fcn de\u011fildir. Havuz doldu\u011funda tamam\u0131 s\u0131f\u0131rlanmal\u0131d\u0131r.</li> <li>Overflow: E\u011fer havuz kapasitesi dolarsa (1MB s\u0131n\u0131r\u0131 a\u015f\u0131l\u0131rsa), sistem hata f\u0131rlatabilir. Boyut ihtiyaca g\u00f6re dinamik ayarlanmal\u0131d\u0131r.</li> </ul>"},{"location":"API_References/AutomaticInternalPooling_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// 2MB'l\u0131k bir dahili havuz olu\u015ftur\nvar pool = new AutomaticInternalPooling(2 * 1024 * 1024);\n\n// Havuzdan 256 byte'l\u0131k bir alan \u00f6d\u00fcn\u00e7 al\nunsafe {\n    void* buffer = pool.Borrow(256);\n    // ... Buffer'\u0131 kullan ...\n}\n\npool.Dispose(); // \u0130\u015f bitince t\u00fcm havuzu tek seferde sil\n</code></pre>"},{"location":"API_References/AutomaticInternalPooling_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>using System.Runtime.InteropServices;\nnamespace Nexus.Core;\n\npublic unsafe class AutomaticInternalPooling : IDisposable\n{\n    private void* _pool;\n    private int _totalSize;\n\n    public AutomaticInternalPooling(int preAllocSize = 1024 * 1024)\n    {\n        _totalSize = preAllocSize;\n        _pool = NativeMemory.AlignedAlloc((nuint)_totalSize, 64);\n    }\n\n    public void* Borrow(int size)\n    {\n        // Simple bump allocator logic (Internal placeholder)\n        return null; \n    }\n\n    public void Dispose()\n    {\n        if (_pool != null) NativeMemory.AlignedFree(_pool);\n    }\n}\n</code></pre>"},{"location":"API_References/AutomaticInternalPooling_tr/#nexus-optimization-tip-context-specific-pools","title":"Nexus Optimization Tip: Context-Specific Pools","text":"<p>Her sistem i\u00e7in \u00f6zel bir <code>AutomaticInternalPooling</code> \u00f6rne\u011fi kullan\u0131n. \u00d6rne\u011fin mermiler i\u00e7in 1MB, UI elementleri i\u00e7in 256KB'l\u0131k havuzlar a\u00e7arak, farkl\u0131 ya\u015fam d\u00f6ng\u00fcs\u00fcne sahip verilerin birbirini bellek \u00fczerinde bloklamas\u0131n\u0131 \u00f6nleyebilir ve L2 cache isabet oran\u0131n\u0131z\u0131 %20-30 civar\u0131nda art\u0131rabilirsiniz.</p>"},{"location":"API_References/BitPackedAttribute_eng/","title":"Nexus Prime Architectural Manual: BitPackedAttribute (Bit-Level Compression)","text":""},{"location":"API_References/BitPackedAttribute_eng/#1-introduction","title":"1. Introduction","text":"<p><code>BitPackedAttribute.cs</code> is a \"Compression Flag\" layer used by Nexus Prime to increase data density and minimize data traffic over the network. It specifies that instead of sending all bytes of a component, it should be packaged to cover only the determined number of bits.</p> <p>The reason for this attribute's existence is to save memory and reduce bandwidth usage by up to 80%, especially for Boolean values, Enums, or small numerical values (e.g., an ID between 0-15), instead of spending a whole <code>int</code> (32 bits) or <code>byte</code> (8 bits).</p>"},{"location":"API_References/BitPackedAttribute_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>BitPackedAttribute offers the following directives for packaging tools:</p> <ul> <li>Bit Length Specification: Declares how many bits a piece of data can be represented in via the <code>Bits</code> parameter (e.g., 4 bits = 0-15 value range).</li> <li>Source Generator Hook: This attribute is scanned by Nexus's Bit-Level Compression Tool, and wrapper classes with <code>Pack/Unpack</code> methods are automatically generated for the relevant component.</li> <li>Network Optimization: During delta serialization, fields with this attribute are transmitted as a bit-stream instead of their raw values.</li> </ul>"},{"location":"API_References/BitPackedAttribute_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Definition: The developer marks a struct component with a small value range with a value like <code>[BitPacked(4)]</code>.</li> <li>Analysis: Nexus's compile-time tools see this flag.</li> <li>Production: Software automatically generates unsafe codes that mask (Masking) and shift (Shifting) this data at bit-level.</li> <li>Execution: Only the targeted bits are processed while data is being recorded or sent.</li> </ol>"},{"location":"API_References/BitPackedAttribute_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>using Nexus.Data;\n\n[BitPacked(3)] // Takes up only 3 bits (for values between 0-7)\npublic struct TeamType {\n    public int Value; \n}\n</code></pre>"},{"location":"API_References/BitPackedAttribute_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Data;\n\n[AttributeUsage(AttributeTargets.Struct)]\npublic class BitPackedAttribute : Attribute\n{\n    public int Bits { get; }\n\n    public BitPackedAttribute(int bitsCount)\n    {\n        Bits = bitsCount;\n    }\n}\n</code></pre>"},{"location":"API_References/BitPackedAttribute_eng/#nexus-optimization-tip-precision-squeezing","title":"Nexus Optimization Tip: Precision Squeezing","text":"<p>If a component takes only very limited values like \"Active/Passive\" or \"Team ID\", be sure to use <code>[BitPacked]</code>. This allows the processor to fit more data into a single \"Cache Line\", logarithmically increasing memory bandwidth efficiency.</p>"},{"location":"API_References/BitPackedAttribute_tr/","title":"Nexus Prime Mimari Rehberi: BitPackedAttribute (Bit Seviyesinde S\u0131k\u0131\u015ft\u0131rma)","text":""},{"location":"API_References/BitPackedAttribute_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>BitPackedAttribute.cs</code>, Nexus Prime'\u0131n veri yo\u011funlu\u011funu (data density) art\u0131rmak ve a\u011f \u00fczerindeki veri trafi\u011fini minimize etmek i\u00e7in kulland\u0131\u011f\u0131 bir \"S\u0131k\u0131\u015ft\u0131rma \u0130\u015fareti\" (Compression Flag) katman\u0131d\u0131r. Bir bile\u015fenin t\u00fcm byte'lar\u0131n\u0131 g\u00f6ndermek yerine, sadece belirlenen bit say\u0131s\u0131 kadar alan\u0131 kapsayacak \u015fekilde paketlenmesi gerekti\u011fini belirtir.</p> <p>Bu \u00f6zniteli\u011fin varl\u0131k sebebi, \u00f6zellikle Boolean de\u011ferler, Enum'lar veya k\u00fc\u00e7\u00fck say\u0131sal de\u011ferler (\u00d6rn: 0-15 aras\u0131 bir ID) i\u00e7in koca bir <code>int</code> (32 bit) veya <code>byte</code> (8 bit) harcamak yerine, bellekten tasarruf ederek bandwidth kullan\u0131m\u0131n\u0131 %80'e kadar azaltmakt\u0131r.</p>"},{"location":"API_References/BitPackedAttribute_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>BitPackedAttribute, paketleme ara\u00e7lar\u0131 i\u00e7in \u015fu direktifleri sunar:</p> <ul> <li>Bit Length Specification: <code>Bits</code> parametresi ile verinin ka\u00e7 bit i\u00e7inde temsil edilebilece\u011fini (\u00d6rn: 4 bit = 0-15 de\u011fer aral\u0131\u011f\u0131) beyan eder.</li> <li>Source Generator Hook: Bu \u00f6znitelik, Nexus'un Bit-Level Compression Tool'u taraf\u0131ndan taran\u0131r ve ilgili bile\u015fen i\u00e7in otomatik olarak <code>S\u0131k\u0131\u015ft\u0131r/A\u00e7</code> (Pack/Unpack) metodlar\u0131na sahip wrapper s\u0131n\u0131flar \u00fcretilir.</li> <li>Network Optimization: Delta serile\u015ftirme s\u0131ras\u0131nda, bu \u00f6zniteli\u011fe sahip alanlar ham de\u011ferleri yerine bit-dizisi (bit-stream) olarak iletilir.</li> </ul>"},{"location":"API_References/BitPackedAttribute_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tan\u0131mlama: Geli\u015ftirici, k\u00fc\u00e7\u00fck de\u011fer aral\u0131\u011f\u0131na sahip bir struct bile\u015fenini <code>[BitPacked(4)]</code> gibi bir de\u011ferle i\u015faretler.</li> <li>Analiz: Nexus'un derleme zaman\u0131 ara\u00e7lar\u0131 bu i\u015fareti g\u00f6r\u00fcr.</li> <li>\u00dcretim: Yaz\u0131l\u0131m, bu veriyi bit-seviyesinde maskeleyen (Masking) ve kayd\u0131ran (Shifting) unsafe kodlar\u0131 otomatik \u00fcretir.</li> <li>Y\u00fcr\u00fct\u00fcm: Veri kaydedilirken veya g\u00f6nderilirken sadece hedeflenen bitler i\u015flenir.</li> </ol>"},{"location":"API_References/BitPackedAttribute_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>using Nexus.Data;\n\n[BitPacked(3)] // Sadece 3 bit yer kaplar (0-7 aras\u0131 de\u011ferler i\u00e7in)\npublic struct TeamType {\n    public int Value; \n}\n</code></pre>"},{"location":"API_References/BitPackedAttribute_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Data;\n\n[AttributeUsage(AttributeTargets.Struct)]\npublic class BitPackedAttribute : Attribute\n{\n    public int Bits { get; }\n\n    public BitPackedAttribute(int bitsCount)\n    {\n        Bits = bitsCount;\n    }\n}\n</code></pre>"},{"location":"API_References/BitPackedAttribute_tr/#nexus-optimization-tip-precision-squeezing","title":"Nexus Optimization Tip: Precision Squeezing","text":"<p>E\u011fer bir bile\u015fen sadece \"Aktif/Pasif\" veya \"Tak\u0131m ID\" gibi \u00e7ok k\u0131s\u0131tl\u0131 de\u011ferler al\u0131yorsa, mutlaka <code>[BitPacked]</code> kullan\u0131n. Bu, i\u015flemcinin daha fazla veriyi tek bir \"Cache Line\" i\u00e7ine s\u0131\u011fd\u0131rmas\u0131n\u0131 sa\u011flayarak bellek bant geni\u015fli\u011fi verimlili\u011fini (Memory Bandwidth Efficiency) logaritmik olarak art\u0131r\u0131r.</p>"},{"location":"API_References/BottleneckVisualizer_eng/","title":"Nexus Prime Architectural Manual: Bottleneck Visualizer (Bottleneck Visualizer)","text":""},{"location":"API_References/BottleneckVisualizer_eng/#1-introduction","title":"1. Introduction","text":"<p><code>BottleneckVisualizer.cs</code> is a visual warning system reflecting Nexus Prime's \"Real-Time Profiler\" data onto the Unity scene view (Scene View). It shows which system or which object tires the processor (CPU) how much with colored bars.</p> <p>The reason for this tool's existence is to immediately see where the bottleneck is physically (\"This enemy group is working very heavy!\") instead of getting lost among complex performance tables.</p>"},{"location":"API_References/BottleneckVisualizer_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Visualization uses the following methods:</p> <ul> <li>Handles.HighLevel UI: Draws 2D bars and text boxes onto the 3D world using the Unity Editor's <code>Handles</code> class.</li> <li>System Cost Mapping: Takes millisecond (ms) based data provided by <code>NexusPerformanceGuard</code>.</li> <li>Color Coding: Colors systems as Green between 0-5ms, Yellow between 5-10ms, and Red for 10ms+.</li> <li>Frustum Dependent Rendering: Preserves Editor performance by drawing only in the area seen by the camera.</li> </ul>"},{"location":"API_References/BottleneckVisualizer_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Measurement: <code>NexusProfiler</code> and sub-systems measure the cost of each frame.</li> <li>Conversion: Entity positions in world coordinates are projected onto screen coordinates (Screen Space).</li> <li>Drawing: A bar graph showing the relevant cost is drawn over the head of each system/object.</li> </ol>"},{"location":"API_References/BottleneckVisualizer_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Showing a system's cost in the scene:\nBottleneckVisualizer.DrawSystemMetrics(screenPos, \"PhysicsJob\", 2.4f);\n\n// Result: A green bar labeled PhysicsJob and 25% full appears on the screen.\n</code></pre>"},{"location":"API_References/BottleneckVisualizer_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic static class BottleneckVisualizer\n{\n    public static void DrawSystemMetrics(Vector2 screenPos, string name, float costMs) {\n        // Use Handles UI to draw bar and label...\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/BottleneckVisualizer_eng/#nexus-optimization-tip-cluster-visualization","title":"Nexus Optimization Tip: Cluster Visualization","text":"<p>Instead of drawing separate bars for each of thousands of bullets, see the bullet group as a \"Cluster\" (Cluster) and draw a single aggregate cost bar. This allows you to focus on the actual problem by reducing visual clutter by 90% during profiling.</p>"},{"location":"API_References/BottleneckVisualizer_tr/","title":"Nexus Prime Mimari Rehberi: Bottleneck Visualizer (Darbo\u011faz G\u00f6rselle\u015ftirici)","text":""},{"location":"API_References/BottleneckVisualizer_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>BottleneckVisualizer.cs</code>, Nexus Prime'\u0131n \"Ger\u00e7ek Zamanl\u0131 Profiler\" verilerini Unity sahne g\u00f6r\u00fcn\u00fcm\u00fc (Scene View) \u00fczerine yans\u0131tan bir g\u00f6rsel uyar\u0131 sistemidir. Hangi sistemin veya hangi nesnenin i\u015flemciyi (CPU) ne kadar yordu\u011funu renkli \u00e7ubuklarla g\u00f6sterir.</p> <p>Bu arac\u0131n varl\u0131k sebebi; karma\u015f\u0131k performans tablolar\u0131 aras\u0131nda kaybolmak yerine, darbo\u011faz\u0131n (bottleneck) fiziksel olarak nerede oldu\u011funu (\"\u015eu d\u00fc\u015fman grubu \u00e7ok a\u011f\u0131r \u00e7al\u0131\u015f\u0131yor!\") an\u0131nda g\u00f6rmektir.</p>"},{"location":"API_References/BottleneckVisualizer_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>G\u00f6rselle\u015ftirme \u015fu y\u00f6ntemleri kullan\u0131r:</p> <ul> <li>Handles.HighLevel UI: Unity Edit\u00f6r'\u00fcn <code>Handles</code> s\u0131n\u0131f\u0131n\u0131 kullanarak 2D barlar ve metin kutular\u0131n\u0131 3D d\u00fcnya \u00fczerine \u00e7izer.</li> <li>System Cost Mapping: <code>NexusPerformanceGuard</code> taraf\u0131ndan sa\u011flanan milisaniye (ms) bazl\u0131 verileri al\u0131r.</li> <li>Color Coding: 0-5ms aras\u0131 Ye\u015fil, 5-10ms Sar\u0131, 10ms+ K\u0131rm\u0131z\u0131 olarak sistemleri renklendirir.</li> <li>Frustum Dependent Rendering: Sadece kameran\u0131n g\u00f6rd\u00fc\u011f\u00fc alanda \u00e7izim yaparak Edit\u00f6r performans\u0131n\u0131 korur.</li> </ul>"},{"location":"API_References/BottleneckVisualizer_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u00d6l\u00e7\u00fcm: <code>NexusProfiler</code> ve alt sistemler her karenin maliyetini \u00f6l\u00e7er.</li> <li>D\u00f6n\u00fc\u015ft\u00fcrme: D\u00fcnya koordinatlar\u0131ndaki entity pozisyonlar\u0131 ekran koordinatlar\u0131na (Screen Space) izd\u00fc\u015f\u00fcr\u00fcl\u00fcr.</li> <li>\u00c7izim: Her sistem/nesne ba\u015f\u0131n\u0131n \u00fczerine ilgili maliyeti g\u00f6steren bir bar grafik \u00e7izilir.</li> </ol>"},{"location":"API_References/BottleneckVisualizer_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Bir sistemin maliyetini sahnede g\u00f6stermek:\nBottleneckVisualizer.DrawSystemMetrics(screenPos, \"PhysicsJob\", 2.4f);\n\n// Sonu\u00e7: Ekranda PhysicsJob yazan ve %25 dolu bir ye\u015fil bar g\u00f6r\u00fcn\u00fcr.\n</code></pre>"},{"location":"API_References/BottleneckVisualizer_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic static class BottleneckVisualizer\n{\n    public static void DrawSystemMetrics(Vector2 screenPos, string name, float costMs) {\n        // Use Handles UI to draw bar and label...\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/BottleneckVisualizer_tr/#nexus-optimization-tip-cluster-visualization","title":"Nexus Optimization Tip: Cluster Visualization","text":"<p>Binlerce merminin her birine ayr\u0131 bar \u00e7izmek yerine, mermi grubunu bir \"Cluster\" (K\u00fcme) olarak g\u00f6r\u00fcp tek bir toplu maliyet bar\u0131 \u00e7izin. Bu, profilleme s\u0131ras\u0131nda g\u00f6rsel kirlili\u011fi %90 azaltarak as\u0131l soruna odaklanman\u0131z\u0131 sa\u011flar.</p>"},{"location":"API_References/BridgeHub_eng/","title":"Nexus Prime Architectural Manual: BridgeHub (Central Bridge Hub)","text":""},{"location":"API_References/BridgeHub_eng/#1-introduction","title":"1. Introduction","text":"<p><code>BridgeHub.cs</code> is the \"Central Exchange\" that manages all data traffic between Nexus Prime's unmanaged simulation world and external engines (Unity, Unreal, etc.). It collects synchronization logics defined for different component types in one place and orchestrates the execution of these logics in the correct order every frame (frame).</p> <p>The reason for this hub's existence is to prevent each system from performing its own synchronization and leading to confusion (Race Condition) and to standardize the data flow by dividing it into two main disciplines: \"Pull\" (from Engine to Nexus) and \"Push\" (from Nexus to Engine).</p>"},{"location":"API_References/BridgeHub_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>BridgeHub manages data flow via these two main channels:</p> <ul> <li>Pull (Engine -&gt; Nexus): Called at the start of the frame (Start of Frame). Pulls input or physics changes from the Unity side to the unmanaged <code>Registry</code>.</li> <li>Push (Nexus -&gt; Engine): Called at the end of the frame (End of Frame). Pushes unmanaged data changed as a result of simulation (e.g., positions resulting from AI) to Unity visual objects.</li> <li>Action Decoupling: Stores synchronization logics in <code>Action</code> lists, providing a generic execution without knowing the internal structure of the Registry.</li> <li>Dirty Check Integration: Offers optional \"Dirty Check\" (Dirty Check) support for each component registered, ensuring only changed data is processed.</li> </ul>"},{"location":"API_References/BridgeHub_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Registration (Register): How which components will be synchronized is reported to the Hub as the application starts.</li> <li>Input Processing (PullAll): All updates in the Unity world are transferred to Nexus in a single pass.</li> <li>Simulation: Nexus unmanaged systems process the data.</li> <li>Visualization (PushAll): Changed results are sprayed back into the Unity world (Transform, VFX, etc.).</li> </ol>"},{"location":"API_References/BridgeHub_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Push/Pull Discipline Rule set ensuring data flow is unidirectional and performed in specific time periods (Phase). Sync Logic Registration Pre-defining how a component type will be copied to the Hub. Orchestration Running multiple independent systems in order within a certain harmony."},{"location":"API_References/BridgeHub_eng/#5-usage-example","title":"5. Usage Example","text":"<pre><code>var hub = new BridgeHub(registry);\n\n// Register logic to push position data from Nexus to Unity\nhub.Register&lt;Vector3&gt;(\n    push: (id, ptr) =&gt; NexusSyncManager.SyncEntity(registry, id, GetGO(id)),\n    pull: (id, ptr) =&gt; *ptr = GetGO(id).transform.position\n);\n\n// Frame Loop\nvoid Update() {\n    hub.PullAll(); // Unity -&gt; Nexus\n    // ... Simulation ...\n    hub.PushAll(); // Nexus -&gt; Unity\n}\n</code></pre>"},{"location":"API_References/BridgeHub_eng/#6-full-source-implementation-direct-implementation","title":"6. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Bridge;\n\npublic class BridgeHub\n{\n    private readonly List&lt;Action&gt; _pushActions = new();\n    private readonly List&lt;Action&gt; _pullActions = new();\n\n    public void Register&lt;T&gt;(PushDelegate push, PullDelegate pull) where T : unmanaged {\n        if (push != null) _pushActions.Add(() =&gt; NexusBridge&lt;T&gt;.Push(_registry, push));\n        if (pull != null) _pullActions.Add(() =&gt; NexusBridge&lt;T&gt;.Pull(_registry, pull));\n    }\n\n    public void PullAll() { foreach (var a in _pullActions) a(); }\n    public void PushAll() { foreach (var a in _pushActions) a(); }\n}\n</code></pre>"},{"location":"API_References/BridgeHub_eng/#nexus-optimization-tip-batch-registration","title":"Nexus Optimization Tip: Batch Registration","text":"<p>Register frequently used components (Transform, Health, etc.) with the Hub via a single bulk registration system (Batch). This prepares the infrastructure needed to process larger memory blocks at once, instead of calling hundreds of <code>Action</code> delegates individually every frame.</p>"},{"location":"API_References/BridgeHub_tr/","title":"Nexus Prime Mimari Rehberi: BridgeHub (Merkezi K\u00f6pr\u00fc Merkezi)","text":""},{"location":"API_References/BridgeHub_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>BridgeHub.cs</code>, Nexus Prime'\u0131n unmanaged sim\u00fclasyon d\u00fcnyas\u0131 ile d\u0131\u015f motorlar (Unity, Unreal vb.) aras\u0131ndaki t\u00fcm veri trafi\u011fini y\u00f6neten \"Merkezi Santral\"dir. Farkl\u0131 bile\u015fen tipleri i\u00e7in tan\u0131mlanm\u0131\u015f senkronizasyon mant\u0131klar\u0131n\u0131 tek bir yerde toplar ve her karede (frame) bu mant\u0131klar\u0131n do\u011fru s\u0131rada \u00e7al\u0131\u015ft\u0131r\u0131lmas\u0131n\u0131 orkestre eder.</p> <p>Bu hub'\u0131n varl\u0131k sebebi; her sistemin kendi ba\u015f\u0131na senkronizasyon yap\u0131p karma\u015faya (Race Condition) yol a\u00e7mas\u0131n\u0131 engellemek ve veri ak\u0131\u015f\u0131n\u0131 \"Pull\" (Motordan Nexus'a) ve \"Push\" (Nexus'tan Motora) \u015feklinde iki ana disipline ay\u0131rarak standartla\u015ft\u0131rmakt\u0131r.</p>"},{"location":"API_References/BridgeHub_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>BridgeHub, veri ak\u0131\u015f\u0131n\u0131 \u015fu iki ana kanal \u00fczerinden y\u00f6netir:</p> <ul> <li>Pull (Engine -&gt; Nexus): Karenin ba\u015f\u0131nda (Start of Frame) \u00e7a\u011fr\u0131l\u0131r. Unity taraf\u0131ndaki girdi veya fizik de\u011fi\u015fimlerini unmanaged <code>Registry</code>'ye \u00e7eker.</li> <li>Push (Nexus -&gt; Engine): Karenin sonunda (End of Frame) \u00e7a\u011fr\u0131l\u0131r. Sim\u00fclasyon sonucunda de\u011fi\u015fen unmanaged verileri (\u00d6rn: AI sonucu pozisyonlar) Unity g\u00f6rsel nesnelerine iter.</li> <li>Action Decoupling: Senkronizasyon mant\u0131klar\u0131n\u0131 <code>Action</code> listelerinde saklayarak, Registry'nin i\u00e7 yap\u0131s\u0131n\u0131 bilmeden jenerik bir y\u00fcr\u00fct\u00fcm sa\u011flar.</li> <li>Dirty Check Integration: Kayd\u0131 yap\u0131lan her bile\u015fen i\u00e7in opsiyonel \"Kirli Kontrol\u00fc\" (Dirty Check) deste\u011fi sunarak sadece de\u011fi\u015fen verilerin i\u015flenmesini sa\u011flar.</li> </ul>"},{"location":"API_References/BridgeHub_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Kay\u0131t (Register): Uygulama ba\u015flarken hangi bile\u015fenlerin nas\u0131l senkronize edilece\u011fi Hub'a bildirilir.</li> <li>Girdi \u0130\u015fleme (PullAll): Unity d\u00fcnyas\u0131ndaki t\u00fcm g\u00fcncellemeler tek bir pasla Nexus'a aktar\u0131l\u0131r.</li> <li>Sim\u00fclasyon: Nexus unmanaged sistemleri veriyi i\u015fler.</li> <li>G\u00f6rselle\u015ftirme (PushAll): De\u011fi\u015fen sonu\u00e7lar tekrar Unity d\u00fcnyas\u0131na (Transform, VFX vb.) p\u00fcsk\u00fcrt\u00fcl\u00fcr.</li> </ol>"},{"location":"API_References/BridgeHub_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Push/Pull Discipline Veri ak\u0131\u015f\u0131n\u0131n tek y\u00f6nl\u00fc ve belirli zaman dilimlerinde (Phase) yap\u0131lmas\u0131n\u0131 sa\u011flayan kural seti. Sync Logic Registration Bir bile\u015fen tipinin nas\u0131l kopyalanaca\u011f\u0131n\u0131n Hub'a \u00f6nceden tan\u0131mlanmas\u0131. Orchestration Birden \u00e7ok ba\u011f\u0131ms\u0131z sistemin belirli bir uyum i\u00e7inde s\u0131rayla \u00e7al\u0131\u015ft\u0131r\u0131lmas\u0131."},{"location":"API_References/BridgeHub_tr/#5-kullanm-ornegi","title":"5. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>var hub = new BridgeHub(registry);\n\n// Pozisyon verisini Nexus'tan Unity'ye itecek mant\u0131\u011f\u0131 kaydet\nhub.Register&lt;Vector3&gt;(\n    push: (id, ptr) =&gt; NexusSyncManager.SyncEntity(registry, id, GetGO(id)),\n    pull: (id, ptr) =&gt; *ptr = GetGO(id).transform.position\n);\n\n// Frame Loop\nvoid Update() {\n    hub.PullAll(); // Unity -&gt; Nexus\n    // ... Sim\u00fclasyon ...\n    hub.PushAll(); // Nexus -&gt; Unity\n}\n</code></pre>"},{"location":"API_References/BridgeHub_tr/#6-tam-kaynak-kod-direct-implementation","title":"6. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Bridge;\n\npublic class BridgeHub\n{\n    private readonly List&lt;Action&gt; _pushActions = new();\n    private readonly List&lt;Action&gt; _pullActions = new();\n\n    public void Register&lt;T&gt;(PushDelegate push, PullDelegate pull) where T : unmanaged {\n        if (push != null) _pushActions.Add(() =&gt; NexusBridge&lt;T&gt;.Push(_registry, push));\n        if (pull != null) _pullActions.Add(() =&gt; NexusBridge&lt;T&gt;.Pull(_registry, pull));\n    }\n\n    public void PullAll() { foreach (var a in _pullActions) a(); }\n    public void PushAll() { foreach (var a in _pushActions) a(); }\n}\n</code></pre>"},{"location":"API_References/BridgeHub_tr/#nexus-optimization-tip-batch-registration","title":"Nexus Optimization Tip: Batch Registration","text":"<p>S\u0131k kullan\u0131lan bile\u015fenleri (Transform, Health vb.) tek bir toplu kay\u0131t sistemi (Batch) \u00fczerinden Hub'a kaydedin. Bu, her karede y\u00fczlerce <code>Action</code> delegesini tek tek \u00e7a\u011f\u0131rmak yerine, daha b\u00fcy\u00fck bellek bloklar\u0131n\u0131 tek seferde i\u015flemek i\u00e7in gereken altyap\u0131y\u0131 haz\u0131rlar.</p>"},{"location":"API_References/ChunkedBuffer_eng/","title":"Nexus Prime Architectural Manual: ChunkedBuffer (Paged Memory Management)","text":""},{"location":"API_References/ChunkedBuffer_eng/#1-introduction","title":"1. Introduction","text":"<p><code>ChunkedBuffer.cs</code> is the guarantee of \"Memory Stability\" for Nexus Prime. When standard unmanaged arrays (<code>T*</code>) are expanded (realloc), all data is moved to a new memory address, which can cause old pointers (those pointing to invalid addresses) to crash the system.</p> <p>ChunkedBuffer solves this problem by keeping data in 16KB fixed pages (Chunks). Even if the buffer grows, the addresses of old pages do not change. This feature allows high-performance systems to safely look at data directly via pointers \"forever\" (or until the component is removed).</p>"},{"location":"API_References/ChunkedBuffer_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>ChunkedBuffer utilizes the following advanced techniques in the memory hierarchy:</p> <ul> <li>Segmented Allocation: Memory is managed in 16KB (OS-friendly) pieces rather than a single massive block.</li> <li>Pointer Stability: The <code>Expand()</code> operation only adds a new page; it does not change the physical location of existing pages in RAM.</li> <li>O(1) Address Math: The address of data at any index is calculated instantly using modular arithmetic with the formula <code>Base + Header + (Index * Size)</code>.</li> <li>Cache-Line Padding: The beginning of each chunk is aligned to 64 bytes (ALIGNMENT). This ensures that the first element fits perfectly into the processor's cache (L1 Cache).</li> </ul>"},{"location":"API_References/ChunkedBuffer_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Calculation: Based on the size of the type (<code>T</code>), it is determined how many elements will fit into 16KB (16384 bytes) (<code>_elementsPerChunk</code>).</li> <li>Addressing (<code>GetPointer</code>): With <code>Index / ElementsPerChunk</code>, which page it's on is found, and with <code>Index % ElementsPerChunk</code>, the offset within the page is found.</li> <li>Expansion (<code>Expand</code>): When capacity is full, a new 16KB block is allocated using <code>NativeMemory.AlignedAlloc</code> and added to the main table (<code>_chunks</code>).</li> <li>Cleanup: When <code>Dispose</code> is called, each page pointer in the main table is released individually (Hardware-safe cleanup).</li> </ol>"},{"location":"API_References/ChunkedBuffer_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Pointer Stability The condition where the memory address of data does not change even if the structure grows. Memory Paging A technique of dividing large data into small, fixed-size pages (OS-level technique). AlignedAlloc Allocating memory starting from addresses that are multiples of a specific number (e.g., 64). Fragmentation Small, inefficient gaps in memory that are unused. ChunkedBuffer keeps this under control."},{"location":"API_References/ChunkedBuffer_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Internal Waste: Small gaps may remain at the end of 16KB blocks depending on the type size. (Nexus accepts this cost for pointer stability).</li> <li>Manual Lifetime: As it is an unmanaged structure, it must be <code>Dispose</code>d, otherwise, it will not be cleared until RAM is full.</li> </ul>"},{"location":"API_References/ChunkedBuffer_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>var buffer = new ChunkedBuffer&lt;Velocity&gt;(1024);\n\n// Get the pointer\nVelocity* vPtr = (Velocity*)buffer.GetPointer(500);\n\n// Grow the buffer (Does not break pointer stability!)\nbuffer.Count = 5000;\n\n// vPtr still points to a valid address!\nvPtr-&gt;X = 10.0f;\n</code></pre>"},{"location":"API_References/ChunkedBuffer_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>using System.Runtime.InteropServices;\nnamespace Nexus.Core;\n\npublic unsafe class ChunkedBuffer&lt;T&gt; : IDisposable where T : unmanaged\n{\n    private const int CHUNK_SIZE = 16 * 1024; \n    private const int ALIGNMENT = 64; \n    private readonly int _elementsPerChunk;\n    private void** _chunks; \n    private int _chunkCount;\n    private int _count;\n\n    public void* GetPointer(int index)\n    {\n        int chunkIdx = index / _elementsPerChunk;\n        int offset = index % _elementsPerChunk;\n        byte* chunkBase = (byte*)_chunks[chunkIdx];\n        return chunkBase + ALIGNMENT + (offset * sizeof(T));\n    }\n\n    private void Expand()\n    {\n        void* newChunk = NativeMemory.AlignedAlloc(CHUNK_SIZE, ALIGNMENT);\n        NativeMemory.Clear(newChunk, CHUNK_SIZE);\n        _chunks[_chunkCount++] = newChunk;\n    }\n\n    // ... Disposal logic\n}\n</code></pre>"},{"location":"API_References/ChunkedBuffer_eng/#nexus-optimization-tip-addressing-arithmetic","title":"Nexus Optimization Tip: Addressing Arithmetic","text":"<p>The address calculation logic of ChunkedBuffer (division/mod operations that can be converted into <code>Shift</code> and <code>AND</code> operations) takes only 1 or 2 clock cycles on modern CPU ALUs (Arithmetic Logic Units). In contrast, traditional dynamic array reallocation (allocation) imposes a cost of thousands of cycles and heavy memory movement (memcpy).</p>"},{"location":"API_References/ChunkedBuffer_tr/","title":"Nexus Prime Mimari Rehberi: ChunkedBuffer (Sayfal\u0131 Bellek Y\u00f6netimi)","text":""},{"location":"API_References/ChunkedBuffer_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>ChunkedBuffer.cs</code>, Nexus Prime'\u0131n \"Bellek Kararl\u0131l\u0131\u011f\u0131\" (Memory Stability) garantisidir. Standart unmanaged diziler (<code>T*</code>) b\u00fcy\u00fct\u00fcld\u00fc\u011f\u00fcnde (realloc), t\u00fcm veriler yeni bir bellek adresine ta\u015f\u0131n\u0131r ve bu durum eski pointerlar\u0131n (ge\u00e7ersiz adres i\u015faret edenler) sistemi \u00e7\u00f6kertmesine yol a\u00e7ar.</p> <p>ChunkedBuffer, verileri 16KB'l\u0131k sabit sayfalar (Chunks) halinde tutarak bu sorunu \u00e7\u00f6zer. Buffer b\u00fcy\u00fcse dahi eski sayfalar\u0131n adresi de\u011fi\u015fmez. Bu \u00f6zellik, y\u00fcksek performansl\u0131 sistemlerin veriye do\u011frudan pointerlar \u00fczerinden g\u00fcvenle \"ebediyen\" (veya bile\u015fen silinene kadar) bakmas\u0131n\u0131 sa\u011flar.</p>"},{"location":"API_References/ChunkedBuffer_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>ChunkedBuffer, bellek hiyerar\u015fisinde \u015fu ileri teknikleri uygular:</p> <ul> <li>Segmented Allocation: Bellek tek bir devasa blok yerine, 16KB'l\u0131k (i\u015fletim sistemi dostu) par\u00e7alar halinde y\u00f6netilir.</li> <li>Pointer Stability: <code>Expand()</code> i\u015flemi sadece yeni bir sayfa ekler; mevcut sayfalar\u0131n RAM \u00fczerindeki fiziksel yerini de\u011fi\u015ftirmez.</li> <li>O(1) Address Math: Herhangi bir indeksteki verinin adresi, <code>Base + Header + (Index * Size)</code> form\u00fcl\u00fcyle mod\u00fcler aritmetik kullan\u0131larak an\u0131nda hesaplan\u0131r.</li> <li>Cache-Line Padding: Her chunk'\u0131n ba\u015flang\u0131c\u0131 64 byte (ALIGNMENT) ile hizalan\u0131r. Bu, ilk eleman\u0131n i\u015flemci \u00f6nbelle\u011fine (L1 Cache) kusursuz yerle\u015fmesini garanti eder.</li> </ul>"},{"location":"API_References/ChunkedBuffer_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Hesaplama: Tipin (<code>T</code>) boyutuna bak\u0131larak bir 16KB (16384 byte) i\u00e7ine ka\u00e7 eleman s\u0131\u011faca\u011f\u0131 (<code>_elementsPerChunk</code>) belirlenir.</li> <li>Adresleme (<code>GetPointer</code>): <code>Index / ElementsPerChunk</code> ile hangi sayfada oldu\u011fu, <code>Index % ElementsPerChunk</code> ile sayfa i\u00e7indeki ofseti bulunur.</li> <li>Geni\u015fleme (<code>Expand</code>): Kapasite doldu\u011funda yeni bir 16KB'l\u0131k blok <code>NativeMemory.AlignedAlloc</code> ile tahsis edilir ve ana tabloya (<code>_chunks</code>) eklenir.</li> <li>Temizlik: <code>Dispose</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, ana tablodaki her bir sayfa pointer\u0131 tek tek serbest b\u0131rak\u0131l\u0131r (Hardware-safe cleanup).</li> </ol>"},{"location":"API_References/ChunkedBuffer_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Pointer Stability Verinin bellek adresinin, yap\u0131 b\u00fcy\u00fcse dahi de\u011fi\u015fmemesi durumu. Memory Paging B\u00fcy\u00fck verinin sabit boyutlu k\u00fc\u00e7\u00fck sayfalara b\u00f6l\u00fcnmesi (OS seviyesi teknik). AlignedAlloc Belle\u011fin belirli bir say\u0131n\u0131n (\u00f6rn: 64) kat\u0131 olan adreslerden ba\u015flat\u0131larak tahsis edilmesi. Fragmentation Bellekteki kullan\u0131lmayan k\u00fc\u00e7\u00fck, verimsiz bo\u015fluklar. ChunkedBuffer bunu kontrol alt\u0131nda tutar."},{"location":"API_References/ChunkedBuffer_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Internal Waste: 16KB'l\u0131k bloklar\u0131n sonunda tip boyutuna g\u00f6re k\u00fc\u00e7\u00fck bo\u015fluklar kalabilir. (Nexus bu maliyeti pointer stabilitesi i\u00e7in kabul eder).</li> <li>Manual Lifetime: Unmanaged bir yap\u0131 oldu\u011fu i\u00e7in mutlaka <code>Dispose</code> edilmelidir, aksi halde RAM dolana kadar bo\u015falmaz.</li> </ul>"},{"location":"API_References/ChunkedBuffer_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>var buffer = new ChunkedBuffer&lt;Velocity&gt;(1024);\n\n// Pointer\u0131 al\nVelocity* vPtr = (Velocity*)buffer.GetPointer(500);\n\n// Buffer'\u0131 b\u00fcy\u00fct (Pointer stabilitesini bozmaz!)\nbuffer.Count = 5000;\n\n// vPtr hala ge\u00e7erli bir adresi g\u00f6stermeye devam eder!\nvPtr-&gt;X = 10.0f;\n</code></pre>"},{"location":"API_References/ChunkedBuffer_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>using System.Runtime.InteropServices;\nnamespace Nexus.Core;\n\npublic unsafe class ChunkedBuffer&lt;T&gt; : IDisposable where T : unmanaged\n{\n    private const int CHUNK_SIZE = 16 * 1024; \n    private const int ALIGNMENT = 64; \n    private readonly int _elementsPerChunk;\n    private void** _chunks; \n    private int _chunkCount;\n    private int _count;\n\n    public void* GetPointer(int index)\n    {\n        int chunkIdx = index / _elementsPerChunk;\n        int offset = index % _elementsPerChunk;\n        byte* chunkBase = (byte*)_chunks[chunkIdx];\n        return chunkBase + ALIGNMENT + (offset * sizeof(T));\n    }\n\n    private void Expand()\n    {\n        void* newChunk = NativeMemory.AlignedAlloc(CHUNK_SIZE, ALIGNMENT);\n        NativeMemory.Clear(newChunk, CHUNK_SIZE);\n        _chunks[_chunkCount++] = newChunk;\n    }\n\n    // ... Disposal logic\n}\n</code></pre>"},{"location":"API_References/ChunkedBuffer_tr/#nexus-optimization-tip-addressing-arithmetic","title":"Nexus Optimization Tip: Addressing Arithmetic","text":"<p>ChunkedBuffer'\u0131n adres hesaplama mant\u0131\u011f\u0131 (<code>Shift</code> ve <code>AND</code> operasyonlar\u0131na d\u00f6n\u00fc\u015ft\u00fcr\u00fclebilen b\u00f6lme/mod i\u015flemleri), modern CPU'lar\u0131n ALU (Aritmetik Lojik Birim) \u00fczerinde sadece 1 veya 2 clock cycle s\u00fcrer. Geleneksel dinamik dizi yeniden tahsisat\u0131 (allocation) ise binlerce cycle ve a\u011f\u0131r bellek ta\u015f\u0131ma (memcpy) maliyeti y\u00fckler.</p>"},{"location":"API_References/ComponentTypeManager_eng/","title":"Nexus Prime Architectural Manual: ComponentTypeManager (Fast Type ID Engine)","text":""},{"location":"API_References/ComponentTypeManager_eng/#1-introduction","title":"1. Introduction","text":"<p><code>ComponentTypeManager.cs</code> is the architect of Nexus Prime's \"Zero Dictionary\" policy. Using a managed dictionary lookup with type names (<code>typeof(T)</code>) to access component repositories dynamically creates a significant CPU overhead constraint in intensive loops.</p> <p>The reason for this manager's existence is to provide \\(O(1)\\) constant-time index access to component repositories by systematically assigning a unique, sequentially increasing integer (<code>int</code>) ID to every component type at runtime. In this way, the answer to the question \"Which type of data are we looking for?\" is answered not with expensive string hashing, but directly via contiguous memory indices.</p>"},{"location":"API_References/ComponentTypeManager_eng/#2-technical-analysis-internal-math","title":"2. Technical Analysis &amp; Internal Math","text":"<p><code>ComponentTypeManager</code> exploits the internal working principles of the CLR (Common Language Runtime) at a low level to achieve minimal cycle counts per fetch.</p> \\[T_{Dictionary} \\approx 60 \\ cycles \\gg T_{StaticCache} \\approx 1 \\ cycle\\] <pre><code>graph TD\n    subgraph JIT_Optimized_Type_Mapping\n        A[Call: GetId&lt;Velocity&gt;] --&gt; B{Is TypeIdHolder&lt;Velocity&gt; Initialized?}\n        B --&gt;|Yes| C[Return Cached Constant ID: 5]\n        B --&gt;|No: First Call| D[Interlocked.Increment Global ID]\n        D --&gt; E[Seal ID 5 into static readonly Value]\n        E --&gt; C\n\n        C -.-&gt;|O 1 Array Index Lookup| F(Registry._componentSetsArr[ 5 ])\n    end\n    style C fill:#ddffdd\n    style F fill:#ddffff</code></pre>"},{"location":"API_References/ComponentTypeManager_eng/#3-full-source-implementation-line-by-line-explanation","title":"3. Full Source Implementation &amp; Line-By-Line Explanation","text":"<p>Here is the precise architectural implementation. </p> <pre><code>// Source Code\nusing System.Threading;\nnamespace Nexus.Core;\n\npublic static class ComponentTypeManager\n{\n    private static int _nextId = 0;\n\n    public static int GetId&lt;T&gt;() where T : unmanaged\n    {\n        return TypeIdHolder&lt;T&gt;.Value;\n    }\n\n    private static class TypeIdHolder&lt;T&gt; where T : unmanaged\n    {\n        public static readonly int Value = Interlocked.Increment(ref _nextId) - 1;\n    }\n\n    public static int MaxTypes =&gt; _nextId;\n}\n</code></pre>"},{"location":"API_References/ComponentTypeManager_eng/#line-by-line-breakdown","title":"Line-By-Line Breakdown","text":"<ul> <li><code>public static class ComponentTypeManager</code>: (Line 5) Declared strictly <code>static</code> meaning the CLR loads it as an ecosystem-wide global singleton.</li> <li><code>private static int _nextId = 0;</code>: (Line 7) The single global monotonic counter tracker. Maps the chronological order of type registration.</li> <li><code>public static int GetId&lt;T&gt;() where T : unmanaged</code>: (Line 9) Enforces the Blittable hardware constraint. Fails to compile if <code>T</code> is a managed class.</li> <li><code>return TypeIdHolder&lt;T&gt;.Value;</code>: (Line 11) Exposes the private nested static class. Bypasses <code>ref</code> locks by calling the structurally isolated class type directly.</li> <li><code>private static class TypeIdHolder&lt;T&gt;</code>: (Line 14) The heart of the Type Erasure pattern. The Microsoft CLR guarantees it allocates a distinctly separate class structure in RAM for every <code>T</code> that passes through it at runtime.</li> <li><code>public static readonly int Value = Interlocked.Increment(ref _nextId) - 1;</code>: (Line 16) At the absolute moment <code>TypeIdHolder</code> bounds are touched, <code>Interlocked</code> pushes <code>_nextId</code> up safely preventing simultaneous thread racing, locks it behind a <code>readonly</code> signature, and embeds it permanently in the processor instruction line.</li> <li><code>public static int MaxTypes</code>: (Line 19) Yields the peak bounding threshold required to construct or resize Registry container loops.</li> </ul>"},{"location":"API_References/ComponentTypeManager_eng/#4-usage-scenario-best-practices","title":"4. Usage Scenario &amp; Best Practices","text":"<p>Never map memory via string names or standard dictionaries. Secure IDs immediately.</p> <pre><code>// Scenario: A custom framework extension wants to locate a set of Physical components\n\n// Resolve IDs utilizing the JIT cache at virtually zero cost\nint velocityID = ComponentTypeManager.GetId&lt;Velocity&gt;();\nint torqueID = ComponentTypeManager.GetId&lt;Torque&gt;();\n\n// Construct an array perfectly matching the active data layout size\nISparseSet[] _frameworkSets = new ISparseSet[ComponentTypeManager.MaxTypes];\n\n// Direct O(1) Fetch Memory Location\nISparseSet targetSet = _frameworkSets[velocityID];\n</code></pre> <p>[!WARNING] Registration Timing: <code>ComponentTypeManager</code> identifies types synchronously as they are logically invoked. Component ID <code>3</code> could be <code>Health</code> today, but if you change the order of invocation in your code tomorrow, <code>Health</code> could become ID <code>0</code>. Never serialize or save <code>GetId&lt;T&gt;()</code> values to disk! They are violently runtime-volatile. Save components using deterministic IDs or string names to save-files, and map them back to runtime IDs during loading.</p>"},{"location":"API_References/ComponentTypeManager_tr/","title":"Nexus Prime Mimari Rehberi: ComponentTypeManager (H\u0131zl\u0131 Tip Kimlik Hatt\u0131)","text":""},{"location":"API_References/ComponentTypeManager_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>ComponentTypeManager.cs</code>, Nexus Prime'\u0131n \"S\u0131f\u0131r S\u00f6zl\u00fck\" (Zero Dictionary) politikas\u0131n\u0131n ba\u015f mimar\u0131d\u0131r. ECS sistemlerinde bile\u015fen depolar\u0131na eri\u015fmek i\u00e7in tip ad\u0131yla (<code>typeof(T)</code>) y\u00f6netilen (managed) s\u00f6zl\u00fck aramas\u0131 yapmak, saniyede binlerce kez d\u00f6nen yo\u011fun d\u00f6ng\u00fclerde y\u0131k\u0131c\u0131 bir CPU maliyeti olu\u015fturur.</p> <p>Bu y\u00f6neticinin varl\u0131k sebebi, her bile\u015fen tipine \u00e7al\u0131\u015fma zaman\u0131nda (runtime) benzersiz, ard\u0131\u015f\u0131k artan bir tam say\u0131 (<code>int</code>) atayarak, bile\u015fen depolar\u0131na \\(O(1)\\) mutlak dizin eri\u015fimi sa\u011flamakt\u0131r. Bu sayede, \"Hangi tipte veri ar\u0131yoruz?\" sorusunun cevab\u0131 karma\u015f\u0131k string hash'leriyle de\u011fil, do\u011frudan fiziksel bellek dizinleri \u00fczerinden verilir.</p>"},{"location":"API_References/ComponentTypeManager_tr/#2-teknik-analiz-ve-matematiksel-icyuzu","title":"2. Teknik Analiz ve Matematiksel \u0130\u00e7y\u00fcz\u00fc","text":"<p><code>ComponentTypeManager</code>, i\u015flemci ba\u015f\u0131na harcanan d\u00f6ng\u00fc (cycle) say\u0131s\u0131n\u0131 mimarinin kald\u0131rabilece\u011fi en dip limite indirmek i\u00e7in CLR yeteneklerini donan\u0131m seviyesinde a\u015fa\u011f\u0131da g\u00f6sterildi\u011fi gibi kullan\u0131r.</p> \\[T_{Sozluk(Dictionary)} \\approx 60 \\ dongu \\gg T_{StatikOnbellek} \\approx 1 \\ dongu\\] <pre><code>graph TD\n    subgraph JIT_Optimize_Tip_Haritalamasi\n        A[Cagri: GetId&lt;Velocity&gt;] --&gt; B{TypeIdHolder&lt;Velocity&gt; Ilklendi mi?}\n        B --&gt;|Evet| C[Onbelleklenmis Sabit ID'yi Don: 5]\n        B --&gt;|Hayir: Ilk Cagri| D[Interlocked.Increment Global ID]\n        D --&gt; E[Statik Readonly Value icine 5 ID'sini Muhurle]\n        E --&gt; C\n\n        C -.-&gt;|O 1 Dizi Indeks Aramasi| F(Registry._componentSetsArr[ 5 ])\n    end\n    style C fill:#ddffdd\n    style F fill:#ddffff</code></pre>"},{"location":"API_References/ComponentTypeManager_tr/#3-tam-kaynak-kod-uygulamas-ve-satr-satr-acklama","title":"3. Tam Kaynak Kod Uygulamas\u0131 ve Sat\u0131r Sat\u0131r A\u00e7\u0131klama","text":"<p>Bu s\u0131n\u0131fta hi\u00e7bir orijinal mant\u0131k eksiltilmemi\u015f olup, kesin \u00fcretim kodu analizi a\u015fa\u011f\u0131dad\u0131r.</p> <pre><code>// Kaynak Kod (Source Code)\nusing System.Threading;\nnamespace Nexus.Core;\n\npublic static class ComponentTypeManager\n{\n    private static int _nextId = 0;\n\n    public static int GetId&lt;T&gt;() where T : unmanaged\n    {\n        return TypeIdHolder&lt;T&gt;.Value;\n    }\n\n    private static class TypeIdHolder&lt;T&gt; where T : unmanaged\n    {\n        public static readonly int Value = Interlocked.Increment(ref _nextId) - 1;\n    }\n\n    public static int MaxTypes =&gt; _nextId;\n}\n</code></pre>"},{"location":"API_References/ComponentTypeManager_tr/#satr-satr-kod-acklamas-line-by-line-breakdown","title":"Sat\u0131r Sat\u0131r Kod A\u00e7\u0131klamas\u0131 (Line-By-Line Breakdown)","text":"<ul> <li><code>public static class ComponentTypeManager</code>: (Sat\u0131r 5) Kesin \u015fekilde <code>static</code> ilan edilmi\u015ftir; bu, CLR'\u0131n s\u0131n\u0131f\u0131 ekosistem merkezinde tek bir global (singleton) olarak tan\u0131mlayaca\u011f\u0131 anlam\u0131na gelir.</li> <li><code>private static int _nextId = 0;</code>: (Sat\u0131r 7) Tekil, s\u00fcrekli artan global bir saya\u00e7 takip\u00e7isi. Tiplerin tescilasyon (registration) kronolojisini s\u0131raya dizer.</li> <li><code>public static int GetId&lt;T&gt;() where T : unmanaged</code>: (Sat\u0131r 9) <code>unmanaged</code> k\u0131s\u0131tlamas\u0131n\u0131 dayatarak, s\u0131n\u0131f\u0131m\u0131za (<code>class</code>) ya da referans tiplerine ait hatal\u0131 giri\u015fimi engeller, t\u00fcm veri dizini ba\u015ftan Blittable (donan\u0131msal uyumlu) ilan eder.</li> <li><code>return TypeIdHolder&lt;T&gt;.Value;</code>: (Sat\u0131r 11) Dahili jenerik statik s\u0131n\u0131fa fiziksel eri\u015fim emridir. \u00d6zel korumal\u0131 veya soyut bloklardan ka\u00e7\u0131narak direkt yap\u0131 s\u0131n\u0131rlar\u0131 hedeflenir.</li> <li><code>private static class TypeIdHolder&lt;T&gt;</code>: (Sat\u0131r 14) \"Tip Silme\" (Type Erasure) mimarisinin kalbi. Microsoft CLR altyap\u0131s\u0131, \u00e7al\u0131\u015fma zaman\u0131nda (runtime) g\u00f6nderilen her ayr\u0131 <code>T</code> i\u00e7in bellekte tamam\u0131yla yepyeni, ba\u011f\u0131ml\u0131l\u0131ks\u0131z bir sanal statik alt s\u0131n\u0131f \u00e7akmas\u0131n\u0131 garanti eder.</li> <li><code>public static readonly int Value = ...</code>: (Sat\u0131r 16) <code>TypeIdHolder</code> tetiklendi\u011fi mutlak milisaniyede <code>Interlocked</code> thread-race ihtimalinden ka\u00e7\u0131p <code>_nextId</code>'yi kilitler. \u00dcretilen say\u0131y\u0131 <code>readonly</code> ile m\u00fch\u00fcrleyerek donan\u0131m seviyesi JIT i\u015flemci y\u00f6nergelerine bir say\u0131sal <code>sabit</code> (constant) olarak sonsuza dek per\u00e7inler.</li> <li><code>public static int MaxTypes</code>: (Sat\u0131r 19) Registry dizi bloklar\u0131n\u0131n bellek i\u00e7i limit \u00f6l\u00e7\u00fcmlemelerini ayarlamas\u0131na / geni\u015flemesine f\u0131rsat veren total tepe noktas\u0131n\u0131 iletir.</li> </ul>"},{"location":"API_References/ComponentTypeManager_tr/#4-kullanm-senaryosu-ve-en-iyi-uygulamalar","title":"4. Kullan\u0131m Senaryosu ve En \u0130yi Uygulamalar","text":"<p>Veri ba\u011flam\u0131n\u0131 (memory mapping) asla Dize adlar\u0131 (string names) ya da Dictionary kullanarak y\u00f6netmeyin. Kimlikleri do\u011frudan okuyun.</p> <pre><code>// Senaryo: Ozel bir C# k\u00fct\u00fcphanesi uzantisi, fizik objelerini tespit etmek istiyor.\n\n// Neredeyse s\u0131f\u0131r donan\u0131m harcamas\u0131yla JIT \u00f6nbelleklenen ID'leri \u00e7\u00f6z.\nint velocityID = ComponentTypeManager.GetId&lt;Velocity&gt;();\nint torqueID = ComponentTypeManager.GetId&lt;Torque&gt;();\n\n// Anl\u0131k aktif veri d\u00fczeni limitine (MaxTypes) en ideal dizi (Array) kal\u0131b\u0131n\u0131 \u00e7\u0131karma.\nISparseSet[] _frameworkSets = new ISparseSet[ComponentTypeManager.MaxTypes];\n\n// Karakter e\u015fleme (string Hash) yerine m\u00fckemmel O(1) sabit boyutla do\u011frudan \u00e7ekim\nISparseSet targetSet = _frameworkSets[velocityID];\n</code></pre> <p>[!WARNING] S\u0131ralama / Tescil Zamanlamas\u0131 (Registration Timing): <code>ComponentTypeManager</code> tiplere kimlik da\u011f\u0131t\u0131m\u0131n\u0131 kod taraf\u0131ndan mant\u0131ksal olarak ilk \u00e7a\u011fr\u0131ld\u0131klar\u0131 an yapar. Component ID'si olarak <code>3</code> bug\u00fcn <code>Health</code> bile\u015fenine atanm\u0131\u015f olabilir, ancak yar\u0131n kodunuzun \u00e7a\u011fr\u0131lma s\u0131ras\u0131 de\u011fi\u015ftirilirse, <code>Health</code> bir anda ID <code>0</code> olabilir. Bu y\u00fczden <code>GetId&lt;T&gt;()</code> fonksiyon sonu\u00e7lar\u0131n\u0131 disk \u00fczerindeki kay\u0131t dosyalar\u0131na (Save-File) asla kaydetmeyin ve g\u00f6mmeyin! Kay\u0131t dosyalar\u0131nda string isimlendirme (<code>nameof(Health)</code>) veya \u00f6nceden manuel listelenmi\u015f de\u011fi\u015fmez GUID de\u011ferleri saklay\u0131n ve dosyay\u0131 diske y\u00fcklerken onlar\u0131 runtime ID'sine geri map'leyin.</p>"},{"location":"API_References/DeltaStateSerializer_eng/","title":"Nexus Prime Architectural Manual: DeltaStateSerializer (Differential Data Writing)","text":""},{"location":"API_References/DeltaStateSerializer_eng/#1-introduction","title":"1. Introduction","text":"<p><code>DeltaStateSerializer.cs</code> is the \"Smart Recording\" layer that optimizes bandwidth in Nexus Prime's data storage (Persistence) and network synchronization processes. Unlike traditional serializers, it does not write the entire data set to disk; it identifies and packages only the data pieces (\"Dirty\") that have changed since the last recording.</p> <p>The reason for this serializer's existence is to avoid the cost of re-recording the entire world for just 3-5 moving entities in a massive world containing thousands of entities and to minimize I/O (I/O) operations.</p>"},{"location":"API_References/DeltaStateSerializer_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>DeltaStateSerializer uses the following mechanisms for efficiency:</p> <ul> <li>Sparse Chunk Inspection: It determines only the memory blocks that need to be updated by scanning the <code>DirtyBits</code> flags within the <code>SparseSet</code>.</li> <li>Incremental Binary Stream: During the writing process, only the index and raw data of the changed blocks are added to the stream (stream) with the <code>BinaryWriter</code>.</li> <li>Snapshot Integration: Collaborating with the <code>SnapshotManager</code>, it captures diffs between two time slots (Timestamp) at the binary level.</li> <li>Zero-Allocation Write: No new objects (C# Objects) are created during serialization; data is copied directly from unmanaged memory to the stream buffer.</li> </ul>"},{"location":"API_References/DeltaStateSerializer_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Scanning: All component sets (<code>ComponentSets</code>) on the Registry are traversed.</li> <li>Filtering: The dirty bitsets of each set are checked.</li> <li>Packaging: Each chunk found dirty is packaged as a raw byte array with an index prefix.</li> <li>Transmission/Recording: The packaged data flow is written to disk or sent over the network.</li> <li>Restoration: During deserialization, data is patched point-wise (point-wise) to the <code>Registry</code> based on incoming indices.</li> </ol>"},{"location":"API_References/DeltaStateSerializer_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Delta Serialization Saving or sending only the difference between two states. Dirty Bitset 0/1 values tracking whether a particular data block has changed or not. Sparse Update Updating sparsely distributed data without disrupting the entire set. I/O Overhead The overhead of input/output operations on the processor and storage."},{"location":"API_References/DeltaStateSerializer_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Base State Dependency: For delta data to be meaningful, a \"Baseline\" (Baseline) must exist on the remote side or disk. If the base state is lost, deltas cannot be applied.</li> <li>Reconstruction Cost: When too much small delta data accumulates, applying them one by one (Apply) can reduce performance. It is recommended to take a \"Full Snapshot\" at regular intervals.</li> </ul>"},{"location":"API_References/DeltaStateSerializer_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>using var stream = File.OpenWrite(\"save_delta.bin\");\nvar serializer = new DeltaStateSerializer();\n\n// Save only what's changed in the last 1 second\nserializer.SerializeDelta(mainRegistry, stream);\n</code></pre>"},{"location":"API_References/DeltaStateSerializer_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Data;\n\npublic unsafe class DeltaStateSerializer\n{\n    public void SerializeDelta(Registry.Registry registry, Stream stream)\n    {\n        using var writer = new BinaryWriter(stream);\n        foreach (var set in registry.ComponentSets)\n        {\n            // 1. Get DirtyBits from SparseSet.\n            // 2. Write only 'Dirty' chunks.\n            // 3. Prefix with index for sparse reconstruction.\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/DeltaStateSerializer_eng/#nexus-optimization-tip-frequency-scaling","title":"Nexus Optimization Tip: Frequency Scaling","text":"<p>Adjust the frequency of delta serialization based on the \"Rate of Change\" of the data. While sending data that changes very fast (e.g., Player Position) as raw stream instead of delta, process those that change slowly (e.g., Inventory) with DeltaStateSerializer. This allows you to optimize network and disk usage by 90%.</p>"},{"location":"API_References/DeltaStateSerializer_tr/","title":"Nexus Prime Mimari Rehberi: DeltaStateSerializer (Diferansiyel Veri Yaz\u0131m\u0131)","text":""},{"location":"API_References/DeltaStateSerializer_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>DeltaStateSerializer.cs</code>, Nexus Prime'\u0131n veri saklama (Persistence) ve a\u011f senkronizasyonu s\u00fcre\u00e7lerinde bant geni\u015fli\u011fini optimize eden \"Ak\u0131ll\u0131 Kay\u0131t\" katman\u0131d\u0131r. Geleneksel serile\u015ftiricilerin aksine t\u00fcm veri setini diske yazmaz; sadece bir \u00f6nceki kay\u0131ttan bu yana de\u011fi\u015fmi\u015f olan (\"Dirty\") veri par\u00e7alar\u0131n\u0131 saptar ve paketler.</p> <p>Bu serile\u015ftiricinin varl\u0131k sebebi; binlerce varl\u0131k i\u00e7eren devasa bir d\u00fcnyada, sadece yerinden oynayan 3-5 varl\u0131k i\u00e7in t\u00fcm d\u00fcnyay\u0131 tekrar kaydetme maliyetinden ka\u00e7\u0131nmak ve G/\u00c7 (I/O) i\u015flemlerini minimize etmektir.</p>"},{"location":"API_References/DeltaStateSerializer_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>DeltaStateSerializer, verimlilik i\u00e7in \u015fu mekanizmalar\u0131 kullan\u0131r:</p> <ul> <li>Sparse Chunk Inspection: <code>SparseSet</code> i\u00e7indeki <code>DirtyBits</code> bayraklar\u0131n\u0131 tarayarak sadece g\u00fcncellenmesi gereken bellek bloklar\u0131n\u0131 belirler.</li> <li>Incremental Binary Stream: Yazma i\u015flemi s\u0131ras\u0131nda sadece de\u011fi\u015fen bloklar\u0131n indeksi ve ham verisi <code>BinaryWriter</code> ile ak\u0131\u015fa (stream) eklenir.</li> <li>Snapshot Integration: <code>SnapshotManager</code> ile koordineli \u00e7al\u0131\u015farak, iki zaman dilimi (Timestamp) aras\u0131ndaki farklar\u0131 binary seviyesinde yakalar.</li> <li>Zero-Allocation Write: Serile\u015ftirme s\u0131ras\u0131nda yeni nesneler (C# Objects) olu\u015fturulmaz; veriler do\u011frudan unmanaged bellekten stream tamponuna kopyalan\u0131r.</li> </ul>"},{"location":"API_References/DeltaStateSerializer_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tarama: Registry \u00fczerindeki t\u00fcm bile\u015fen setleri (<code>ComponentSets</code>) gezilir.</li> <li>Filtreleme: Her setin \"Dirty\" olarak i\u015faretlenmi\u015f bitsetleri kontrol edilir.</li> <li>Paketleme: Kirli (Dirty) bulunan her chunk, bir indeks \u00f6nekiyle birlikte ham byte dizisi olarak paketlenir.</li> <li>\u0130letim/Kay\u0131t: Paketlenen veri ak\u0131\u015f\u0131 diske yaz\u0131l\u0131r veya a\u011f \u00fczerinden g\u00f6nderilir.</li> <li>Geri Y\u00fckleme: Deserilizasyon s\u0131ras\u0131nda, gelen indekslere bak\u0131larak veriler nokta at\u0131\u015f\u0131 (point-wise) <code>Registry</code>'ye yaman\u0131r.</li> </ol>"},{"location":"API_References/DeltaStateSerializer_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Delta Serialization Sadece iki durum aras\u0131ndaki fark\u0131n kaydedilmesi veya g\u00f6nderilmesi. Dirty Bitset Belirli bir veri blo\u011funun de\u011fi\u015fip de\u011fi\u015fmedi\u011fini takip eden 0/1 de\u011ferleri. Sparse Update Seyrek da\u011f\u0131lm\u0131\u015f verilerin t\u00fcm seti bozmadan g\u00fcncellenmesi. I/O Overhead Giri\u015f/\u00c7\u0131k\u0131\u015f i\u015flemlerinin i\u015flemci ve depolama \u00fczerindeki ek y\u00fck\u00fc."},{"location":"API_References/DeltaStateSerializer_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Base State Dependency: Delta verisinin anlaml\u0131 olabilmesi i\u00e7in kar\u015f\u0131 tarafta veya diskte mutlaka bir \"Temel Durum\" (Baseline) bulunmal\u0131d\u0131r. Temel durum kaybolursa deltalar uygulanamaz.</li> <li>Reconstruction Cost: \u00c7ok fazla k\u00fc\u00e7\u00fck delta verisi birikti\u011finde, bunlar\u0131 tek tek uygulamak (Apply) performans\u0131 d\u00fc\u015f\u00fcrebilir. Belirli aral\u0131klarla bir \"Full Snapshot\" al\u0131nmas\u0131 \u00f6nerilir.</li> </ul>"},{"location":"API_References/DeltaStateSerializer_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>using var stream = File.OpenWrite(\"save_delta.bin\");\nvar serializer = new DeltaStateSerializer();\n\n// Sadece son 1 saniyede de\u011fi\u015fenleri kaydet\nserializer.SerializeDelta(mainRegistry, stream);\n</code></pre>"},{"location":"API_References/DeltaStateSerializer_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Data;\n\npublic unsafe class DeltaStateSerializer\n{\n    public void SerializeDelta(Registry.Registry registry, Stream stream)\n    {\n        using var writer = new BinaryWriter(stream);\n        foreach (var set in registry.ComponentSets)\n        {\n            // 1. Get DirtyBits from SparseSet.\n            // 2. Write only 'Dirty' chunks.\n            // 3. Prefix with index for sparse reconstruction.\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/DeltaStateSerializer_tr/#nexus-optimization-tip-frequency-scaling","title":"Nexus Optimization Tip: Frequency Scaling","text":"<p>Delta serile\u015ftirme s\u0131kl\u0131\u011f\u0131n\u0131 verinin \"De\u011fi\u015fim H\u0131z\u0131na\" g\u00f6re ayarlay\u0131n. \u00c7ok h\u0131zl\u0131 de\u011fi\u015fen verileri (\u00d6rn: Oyuncu Pozisyonu) delta yerine ham stream olarak g\u00f6nderirken, yava\u015f de\u011fi\u015fenleri (\u00d6rn: Envanter) DeltaStateSerializer ile i\u015fleyin. Bu, a\u011f ve disk kullan\u0131m\u0131n\u0131 %90 oran\u0131nda optimize etmenizi sa\u011flar.</p>"},{"location":"API_References/DirtyFlagProxy_eng/","title":"Nexus Prime Architectural Manual: DirtyFlagProxy (Dirty Flag Synchronization)","text":""},{"location":"API_References/DirtyFlagProxy_eng/#1-introduction","title":"1. Introduction","text":"<p><code>DirtyFlagProxy.cs</code> is the most technical implementation point of Nexus Prime's \"Send Only What's Changed\" philosophy. Instead of scanning thousands of entities in unmanaged component sets every frame and copying them to Unity, it is a high-performance interface that ensures only those that have experienced value changes since the last frame are determined and synchronized.</p> <p>The reason for this proxy's existence is to reduce unnecessary data transfer cost (Overhead) to a level close to zero in massive simulations (e.g., 100,000 entities) and to use CPU cache (Cache) efficiently.</p>"},{"location":"API_References/DirtyFlagProxy_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>DirtyFlagProxy uses these advanced techniques for performance:</p> <ul> <li>Raw Bitmask Access: Accesses the dirty flag array (<code>DirtyBits</code>) storing 1-bit-per-entity (1 bit for each entity) within the <code>SparseSet</code> via a raw pointer.</li> <li>32-Bit Block Skipping: Instead of traversing the dirty flag array bit-by-bit, it scans it in 32-bit (<code>uint</code>) blocks. If a whole block is 0 (i.e., all 32 entities have not changed), it skips 32 entities in a single operation.</li> <li>Bitwise Evaluation: Performs the <code>(mask &amp; (1u &lt;&lt; bit)) != 0</code> bitwise check to identify the entity that is dirty within the block. This is a nanosecond-level operation on modern processors.</li> <li>Generic Delegate Sync: When it finds the entity that has changed, it ensures the data is patched into the Unity target (Renderer, Transform, etc.) by calling the <code>SyncDelegate</code> method given by the developer.</li> </ul>"},{"location":"API_References/DirtyFlagProxy_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Preparation: The dirty data mask (Dirty Mask) of the relevant component set is pulled from RAM.</li> <li>Block Scanning: A uint value different from 0 is searched for within the mask.</li> <li>Precise Detection: Which bit is 1 within the 32-group is found.</li> <li>Triggering: Only the unmanaged pointer and ID of the entity that is \"Dirty\" are sent to the synchronization callback.</li> <li>Reset: After the process is finished, the mask is cleaned and prepared for the next frame.</li> </ol>"},{"location":"API_References/DirtyFlagProxy_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Dirty Bitmask Memory area representing the status of each element in a data group with a single bit. Bitwise AND Finding common bits by subjecting two numerical values to bit-based \"AND\" operation. Sparse Enumeration Traversing only the elements of a set that comply with certain rules (e.g., only those that have changed)."},{"location":"API_References/DirtyFlagProxy_eng/#5-usage-example","title":"5. Usage Example","text":"<pre><code>// Update Renderer colors only when they change\nDirtyFlagProxy&lt;ColorComponent&gt;.Sync(registry, (id, colorPtr) =&gt; {\n    if (NexusObjectMapping.TryGet(id.Index, out var renderer)) {\n        ((Renderer)renderer).material.color = colorPtr-&gt;ToColor();\n    }\n});\n</code></pre>"},{"location":"API_References/DirtyFlagProxy_eng/#6-full-source-implementation-direct-implementation","title":"6. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Bridge;\n\npublic unsafe class DirtyFlagProxy&lt;T&gt; where T : unmanaged\n{\n    public static void Sync(Registry.Registry registry, SyncDelegate syncCallback)\n    {\n        SparseSet&lt;T&gt; set = registry.GetSet&lt;T&gt;();\n        uint* dirtyBits = (uint*)set.GetRawDirtyBits(out int bitCount);\n\n        for (int i = 0; i &lt; bitCount; i++) {\n            uint mask = dirtyBits[i];\n            if (mask == 0) continue; // Skip 32 entities at once\n\n            for (int bit = 0; bit &lt; 32; bit++) {\n                if ((mask &amp; (1u &lt;&lt; bit)) != 0) {\n                    syncCallback(set.GetEntity(i * 32 + bit), set.GetComponent(i * 32 + bit));\n                }\n            }\n            dirtyBits[i] = 0; // Clear the mask\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/DirtyFlagProxy_eng/#nexus-optimization-tip-early-out-block-skipping","title":"Nexus Optimization Tip: Early Out Block Skipping","text":"<p>The <code>mask == 0</code> check is the biggest factor increasing \"Sparse Query\" performance in modern ECS engines. If only 1% of the simulation changes frame-wise, the amount of data to be scanned is reduced by 99% thanks to this check.</p>"},{"location":"API_References/DirtyFlagProxy_tr/","title":"Nexus Prime Mimari Rehberi: DirtyFlagProxy (Kirli Bayrak Senkronizasyonu)","text":""},{"location":"API_References/DirtyFlagProxy_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>DirtyFlagProxy.cs</code>, Nexus Prime'\u0131n \"Sadece De\u011fi\u015fenleri G\u00f6nder\" felsefesinin en teknik uygulama noktas\u0131d\u0131r. Unmanaged bile\u015fen setlerindeki binlerce varl\u0131\u011f\u0131 her karede taray\u0131p Unity'ye kopyalamak yerine, sadece son kareden beri de\u011fer de\u011fi\u015fikli\u011fi ya\u015fam\u0131\u015f olanlar\u0131n belirlenip senkronize edilmesini sa\u011flayan y\u00fcksek performansl\u0131 bir aray\u00fczd\u00fcr.</p> <p>Bu proksinin varl\u0131k sebebi; devasa sim\u00fclasyonlarda (\u00d6rn: 100,000 varl\u0131k) gereksiz veri transferi maliyetini (Overhead) s\u0131f\u0131ra yak\u0131n bir seviyeye indirmek ve CPU \u00f6nbelle\u011fini (Cache) verimli kullanmakt\u0131r.</p>"},{"location":"API_References/DirtyFlagProxy_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>DirtyFlagProxy, performans i\u00e7in \u015fu ileri seviye teknikleri kullan\u0131r:</p> <ul> <li>Raw Bitmask Access: <code>SparseSet</code> i\u00e7indeki 1-bit-per-entity (her varl\u0131k i\u00e7in 1 bit) saklayan kirli bayrak dizisine (<code>DirtyBits</code>) ham pointer \u00fczerinden eri\u015fir.</li> <li>32-Bit Block Skipping: Kirli bayrak dizisini bit-bit gezmek yerine 32-bit'lik (<code>uint</code>) bloklar halinde tarar. E\u011fer koca bir blok 0 ise (yani 32 varl\u0131k da de\u011fi\u015fmediyse), tek bir i\u015flemle 32 varl\u0131\u011f\u0131 atlar.</li> <li>Bitwise Evaluation: Blok i\u00e7inde kirli olan varl\u0131\u011f\u0131 saptamak i\u00e7in <code>(mask &amp; (1u &lt;&lt; bit)) != 0</code> bitwise kontrol\u00fcn\u00fc yapar. Bu, modern i\u015flemcilerde naniosaniye seviyesinde bir i\u015flemdir.</li> <li>Generic Delegate Sync: De\u011fi\u015fmi\u015f olan varl\u0131\u011f\u0131 buldu\u011funda, geli\u015ftirici taraf\u0131ndan verilen <code>SyncDelegate</code> metodunu \u00e7a\u011f\u0131rarak verinin Unity hedefine (Renderer, Transform vb.) yamanmas\u0131n\u0131 sa\u011flar.</li> </ul>"},{"location":"API_References/DirtyFlagProxy_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Haz\u0131rl\u0131k: \u0130lgili bile\u015fen setinin kirli veri maskesi (Dirty Mask) RAM'den \u00e7ekilir.</li> <li>Blok Tarama: Maske i\u00e7inde 0'dan farkl\u0131 bir uint de\u011feri aran\u0131r.</li> <li>Hassas Tespit: 32'lik grup i\u00e7inde hangi bitin 1 oldu\u011fu bulunur.</li> <li>Tetikleme: Sadece \"Kirli\" olan varl\u0131\u011f\u0131n unmanaged pointer'\u0131 ve ID'si senkronizasyon callback'ine g\u00f6nderilir.</li> <li>S\u0131f\u0131rlama: \u0130\u015flem bittikten sonra maske temizlenerek bir sonraki kareye haz\u0131rlan\u0131r.</li> </ol>"},{"location":"API_References/DirtyFlagProxy_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Dirty Bitmask Bir veri grubundaki her eleman\u0131n durumunu tek bir bit ile temsil eden bellek alan\u0131. Bitwise AND \u0130ki say\u0131sal de\u011ferin bit bazl\u0131 \"VE\" i\u015flemine tabi tutularak ortak bitlerin bulunmas\u0131. Sparse Enumeration Bir k\u00fcmenin sadece belirli kurallara uyan (\u00d6rn: sadece de\u011fi\u015fenler) elemanlar\u0131n\u0131n gezilmesi."},{"location":"API_References/DirtyFlagProxy_tr/#5-kullanm-ornegi","title":"5. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Renderer renklerini sadece de\u011fi\u015fti\u011finde g\u00fcncelle\nDirtyFlagProxy&lt;ColorComponent&gt;.Sync(registry, (id, colorPtr) =&gt; {\n    if (NexusObjectMapping.TryGet(id.Index, out var renderer)) {\n        ((Renderer)renderer).material.color = colorPtr-&gt;ToColor();\n    }\n});\n</code></pre>"},{"location":"API_References/DirtyFlagProxy_tr/#6-tam-kaynak-kod-direct-implementation","title":"6. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Bridge;\n\npublic unsafe class DirtyFlagProxy&lt;T&gt; where T : unmanaged\n{\n    public static void Sync(Registry.Registry registry, SyncDelegate syncCallback)\n    {\n        SparseSet&lt;T&gt; set = registry.GetSet&lt;T&gt;();\n        uint* dirtyBits = (uint*)set.GetRawDirtyBits(out int bitCount);\n\n        for (int i = 0; i &lt; bitCount; i++) {\n            uint mask = dirtyBits[i];\n            if (mask == 0) continue; // 32 varl\u0131\u011f\u0131 tek seferde atla\n\n            for (int bit = 0; bit &lt; 32; bit++) {\n                if ((mask &amp; (1u &lt;&lt; bit)) != 0) {\n                    syncCallback(set.GetEntity(i * 32 + bit), set.GetComponent(i * 32 + bit));\n                }\n            }\n            dirtyBits[i] = 0; // Maskeyi temizle\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/DirtyFlagProxy_tr/#nexus-optimization-tip-early-out-block-skipping","title":"Nexus Optimization Tip: Early Out Block Skipping","text":"<p><code>mask == 0</code> kontrol\u00fc, modern ECS motorlar\u0131nda \"Sparse Query\" performans\u0131n\u0131 art\u0131ran en b\u00fcy\u00fck fakt\u00f6rd\u00fcr. E\u011fer sim\u00fclasyonun sadece %1'i karesel olarak de\u011fi\u015fiyorsa, bu kontrol sayesinde taranmas\u0131 gereken veri miktar\u0131 %99 oran\u0131nda azal\u0131r.</p>"},{"location":"API_References/DirtySyncGenerator_eng/","title":"Nexus Prime Architectural Manual: DirtySyncGenerator (Automated Synchronization Worker)","text":""},{"location":"API_References/DirtySyncGenerator_eng/#1-introduction","title":"1. Introduction","text":"<p><code>DirtySyncGenerator.cs</code> is a draft \"Job Generator\" (Job Generator) designed to transfer Nexus Prime's unmanaged data to Unity's <code>Transform</code> components in maximum parallelism. It distributes the synchronization cost to multiple CPU cores using Unity's <code>C# Job System</code> and <code>TransformAccessArray</code> architecture instead of the standard <code>Update</code> loop.</p> <p>The reason for this generator's existence is to avoid locking the main thread (Main Thread) while synchronizing the positions of thousands of entities and to push data to Unity's \"Internal Physics/Transform\" system using the fastest path.</p>"},{"location":"API_References/DirtySyncGenerator_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Predicts the following strategies for accelerating synchronization:</p> <ul> <li>Dirty Bit-Sweep: Scans dirty flags (Dirty Flags) on <code>SparseSet</code> with a sweep (sweep) logic to identify only changed position data.</li> <li>Parallel Execution: After the changed data is identified, it writes the data to Transforms in parallel threads using Unity's <code>IJobParallelForTransform</code> interface.</li> <li>Burst Compatibility: The code structure is optimized to be fully compatible with the Unity Burst compiler (using blittable data).</li> <li>Selective Dispatch: Instead of synchronizing everything every frame, it \"Dispatches\" only those entities that visually need to change at that moment.</li> </ul>"},{"location":"API_References/DirtySyncGenerator_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Analysis: The dirty flag array of the Position component on the unmanaged Registry is scanned.</li> <li>Mapping: Changed unmanaged data and their corresponding Unity Transforms are matched in a fast array (AccessArray).</li> <li>Execution (Job): Unity Job System is triggered and data is copied in the background (Worker Threads).</li> <li>Finalization: Dirty flags are cleaned when synchronization is finished.</li> </ol>"},{"location":"API_References/DirtySyncGenerator_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description C# Job System Structure distributing heavy computational tasks to parallel cores within Unity. TransformAccessArray Special data structure providing bulk and performant access to Unity Transform data. Bit-Sweep Rapid scanning of bit flags in memory from beginning to end. Sync Dispatch Sending the data copy process to a worker queue (Job Queue) to be executed."},{"location":"API_References/DirtySyncGenerator_eng/#5-usage-scenario","title":"5. Usage Scenario","text":"<p>This component is usually managed by a \"Source Generator\" or \"NexusInitializer\". The developer only calls the <code>RunSync</code> method every frame; the system's parallel workers handle the rest.</p>"},{"location":"API_References/DirtySyncGenerator_eng/#6-full-source-implementation-conceptual-implementation","title":"6. Full Source Implementation (Conceptual Implementation)","text":"<pre><code>namespace Nexus.Bridge;\n\npublic class DirtySyncGenerator : MonoBehaviour\n{\n    public void RunSync(Registry.Registry registry)\n    {\n        // 1. Get bitmask of changed positions\n        // 2. Dispatch Parallel Transform Job\n    }\n}\n</code></pre>"},{"location":"API_References/DirtySyncGenerator_eng/#nexus-optimization-tip-transform-only-update","title":"Nexus Optimization Tip: Transform-Only Update","text":"<p>In Unity, if only the positions of objects change, target only <code>Transform.position</code> instead of updating the whole hierarchy (Scale/Rotation). This constraint combined with <code>DirtySyncGenerator</code> can reduce Transform synchronization cost by an additional 20%.</p>"},{"location":"API_References/DirtySyncGenerator_tr/","title":"Nexus Prime Mimari Rehberi: DirtySyncGenerator (Otomatik Senkronizasyon \u0130\u015f\u00e7isi)","text":""},{"location":"API_References/DirtySyncGenerator_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>DirtySyncGenerator.cs</code>, Nexus Prime'\u0131n unmanaged verilerini Unity'nin <code>Transform</code> bile\u015fenlerine en y\u00fcksek paralellikte aktarmak i\u00e7in tasarlanm\u0131\u015f bir \"\u0130\u015f \u00dcreticisi\" (Job Generator) tasla\u011f\u0131d\u0131r. Standart <code>Update</code> d\u00f6ng\u00fcs\u00fc yerine Unity'nin <code>C# Job System</code> ve <code>TransformAccessArray</code> mimarisini kullanarak senkronizasyon maliyetini birden fazla CPU \u00e7ekirde\u011fine da\u011f\u0131t\u0131r.</p> <p>Bu \u00fcreticinin varl\u0131k sebebi; binlerce varl\u0131\u011f\u0131n pozisyonunu senkronize ederken ana thread'i (Main Thread) kilitlememek ve Unity'nin \"Internal Physics/Transform\" sistemine en h\u0131zl\u0131 yolu kullanarak veri basmakt\u0131r.</p>"},{"location":"API_References/DirtySyncGenerator_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Senkronizasyonun h\u0131zlanmas\u0131 i\u00e7in \u015fu stratejileri \u00f6ng\u00f6r\u00fcr:</p> <ul> <li>Dirty Bit-Sweep: <code>SparseSet</code> \u00fczerindeki kirli bayraklar\u0131 (Dirty Flags) bir s\u00fcp\u00fcrme (sweep) mant\u0131\u011f\u0131yla tarayarak sadece de\u011fi\u015fen pozisyon verilerini saptar.</li> <li>Parallel Execution: De\u011fi\u015fim verisi saptand\u0131ktan sonra, Unity'nin <code>IJobParallelForTransform</code> arabirimini kullanarak verileri paralel i\u015f par\u00e7ac\u0131klar\u0131nda Transform'lara yazar.</li> <li>Burst Compatibility: Kod yap\u0131s\u0131 Unity Burst derleyicisiyle tam uyumlu olacak \u015fekilde (blittable veri kullan\u0131m\u0131) optimize edilir.</li> <li>Selective Dispatch: Her karede her \u015feyi senkronize etmek yerine, sadece g\u00f6rsel olarak o an de\u011fi\u015fmesi gereken varl\u0131klar\u0131 \"Dispatch\" eder.</li> </ul>"},{"location":"API_References/DirtySyncGenerator_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Analiz: Unmanaged Registry \u00fczerindeki Pozisyon bile\u015feninin kirli bayrak dizisi taran\u0131r.</li> <li>Haritalama: De\u011fi\u015fen unmanaged veriler ile bunlara kar\u015f\u0131l\u0131k gelen Unity Transform'lar\u0131 h\u0131zl\u0131 bir dizide (AccessArray) e\u015fle\u015ftirilir.</li> <li>Y\u00fcr\u00fct\u00fcm (Job): Unity Job System tetiklenerek veriler arka planda (Worker Threads) kopyalan\u0131r.</li> <li>Finalizasyon: Senkronizasyon bitti\u011finde kirli bayraklar temizlenir.</li> </ol>"},{"location":"API_References/DirtySyncGenerator_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama C# Job System Unity i\u00e7inde a\u011f\u0131r hesaplama i\u015flerini paralel \u00e7ekirdeklere da\u011f\u0131tan yap\u0131. TransformAccessArray Unity Transform verilerine toplu ve performansl\u0131 eri\u015fim sa\u011flayan \u00f6zel veri yap\u0131s\u0131. Bit-Sweep Bellekteki bit bayraklar\u0131n\u0131n h\u0131zl\u0131 bir \u015fekilde ba\u015ftan sona taranmas\u0131. Sync Dispatch Veri kopyalama i\u015fleminin y\u00fcr\u00fct\u00fclmek \u00fczere bir i\u015f\u00e7i kuyru\u011funa (Job Queue) g\u00f6nderilmesi."},{"location":"API_References/DirtySyncGenerator_tr/#5-kullanm-senaryosu","title":"5. Kullan\u0131m Senaryosu","text":"<p>Bu bile\u015fen genellikle bir \"Source Generator\" veya \"NexusInitializer\" taraf\u0131ndan y\u00f6netilir. Geli\u015ftirici sadece <code>RunSync</code> metodunu her karede \u00e7a\u011f\u0131r\u0131r; gerisini sistemin paralel i\u015f\u00e7ileri halleder.</p>"},{"location":"API_References/DirtySyncGenerator_tr/#6-tam-kaynak-kod-conceptual-implementation","title":"6. Tam Kaynak Kod (Conceptual Implementation)","text":"<pre><code>namespace Nexus.Bridge;\n\npublic class DirtySyncGenerator : MonoBehaviour\n{\n    public void RunSync(Registry.Registry registry)\n    {\n        // 1. Get bitmask of changed positions\n        // 2. Dispatch Parallel Transform Job\n    }\n}\n</code></pre>"},{"location":"API_References/DirtySyncGenerator_tr/#nexus-optimization-tip-transform-only-update","title":"Nexus Optimization Tip: Transform-Only Update","text":"<p>Unity'de nesnelerin sadece pozisyonu de\u011fi\u015fiyorsa, t\u00fcm hiyerar\u015fiyi (Scale/Rotation) g\u00fcncellemek yerine sadece <code>Transform.position</code>'\u0131 hedefleyin. <code>DirtySyncGenerator</code> ile birle\u015fen bu k\u0131s\u0131tlama, Transform senkronizasyon maliyetini ek bir %20 oran\u0131nda d\u00fc\u015f\u00fcrebilir.</p>"},{"location":"API_References/EditorCockpit_Overview_eng/","title":"Nexus Prime Architectural Manual: Editor Cockpit (Professional Command Panel)","text":""},{"location":"API_References/EditorCockpit_Overview_eng/#1-introduction","title":"1. Introduction","text":"<p><code>EditorCockpit</code> is the \"High-Level Management\" module containing the most advanced diagnostic (diagnostic) and intervention tools of the Nexus Prime framework. Unlike standard editor tools, these tools access unmanaged memory, registration (Registry) structures, and Snapshot hierarchy directly from the lowest level.</p> <p>The reason for this module's existence is to resolve the most complex engineering problems (Memory fragmentation, data integrity, time travel deviations) at the heart of the game with a professional cockpit interface.</p>"},{"location":"API_References/EditorCockpit_Overview_eng/#2-technical-analysis-tool-set","title":"2. Technical Analysis (Tool Set)","text":"<p>The Cockpit module includes the following five main professional tools:</p>"},{"location":"API_References/EditorCockpit_Overview_eng/#a-entity-search-pro","title":"A. Entity Search Pro","text":"<p>Beyond a regular search, it performs data mining among millions of assets with SQL-based queries such as <code>SELECT Entities WHERE HasComponent(Position)</code>.</p>"},{"location":"API_References/EditorCockpit_Overview_eng/#b-live-tweaker-cockpit-edition","title":"B. Live Tweaker (Cockpit Edition)","text":"<p>Using <code>Pointer.Unbox</code> and <code>Marshal</code> techniques, it allows you to manipulate unmanaged component data directly on RAM via Sliders during runtime (Runtime).</p>"},{"location":"API_References/EditorCockpit_Overview_eng/#c-memory-heatmap-occupancy","title":"C. Memory Heatmap (Occupancy)","text":"<p>By visualizing the occupancy rates (<code>Count / Capacity</code>) of units (Chunk), automatically detects memory pressure and inefficient fragmentation areas.</p>"},{"location":"API_References/EditorCockpit_Overview_eng/#d-integrity-dashboard","title":"D. Integrity Dashboard","text":"<p>Visualizes the <code>NexusIntegrityChecker</code> results. Reports the health of the ECS world as \"Nominal\", \"Degraded\", or \"Critical\" and offers in-depth diagnostics.</p>"},{"location":"API_References/EditorCockpit_Overview_eng/#e-time-travel-debugger-timeline","title":"E. Time-Travel Debugger (Timeline)","text":"<p>By offering a visual timeline (Timeline) and \"Play/Rewind\" controls, it allows you to travel between Snapshots within seconds and monitor the data flow.</p>"},{"location":"API_References/EditorCockpit_Overview_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Connection: Cockpit tools enter \"Live View\" mode by capturing the <code>NexusInitializer</code> or <code>Registry</code> reference.</li> <li>Deep Analysis: Tools scan unmanaged memory addresses (Raw Pointers) and meta-data tables.</li> <li>Visualization: Complex data densities and system statuses are drawn as colored graphics and bars on the Editor GUI.</li> <li>Intervention: Every change the developer makes is injected into the ECS world in a \"Thread-Safe\" way.</li> </ol>"},{"location":"API_References/EditorCockpit_Overview_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Solving a critical State bug:\n// 1. A general health check is performed with [Nexus/Cockpit/Integrity Dashboard].\n// 2. Entities producing faulty data are filtered with [Entity Search Pro].\n// 3. Variables are \"balanced\" live with [Live Tweaker].\n// 4. Going to the frame where the error started with [Time-Travel], memory alignment (Alignment) is checked.\n</code></pre>"},{"location":"API_References/EditorCockpit_Overview_eng/#nexus-optimization-tip-context-injection","title":"Nexus Optimization Tip: Context Injection","text":"<p>When using Cockpit tools, work \"Synchronized\" between different tools on the same Registry using the <code>SetContext</code> method. For example, transferring an entity you found in Search Pro to Live Tweaker with one click shortens the diagnosis time by 60%.</p>"},{"location":"API_References/EditorCockpit_Overview_tr/","title":"Nexus Prime Mimari Rehberi: Editor Cockpit (Profesyonel Kontrol Paneli)","text":""},{"location":"API_References/EditorCockpit_Overview_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>EditorCockpit</code>, Nexus Prime framework'\u00fcn\u00fcn en ileri seviye tan\u0131lama (diagnostic) ve m\u00fcdahale ara\u00e7lar\u0131n\u0131 bar\u0131nd\u0131ran \"\u00dcst D\u00fczey Y\u00f6netim\" mod\u00fcl\u00fcd\u00fcr. Standart edit\u00f6r ara\u00e7lar\u0131ndan farkl\u0131 olarak, bu ara\u00e7lar do\u011frudan unmanaged belle\u011fe, kay\u0131t (Registry) yap\u0131lar\u0131na ve Snapshot hiyerar\u015fisine en alt seviyeden eri\u015fir.</p> <p>Bu mod\u00fcl\u00fcn varl\u0131k sebebi; oyunun kalbindeki en karma\u015f\u0131k m\u00fchendislik sorunlar\u0131n\u0131 (Bellek fragmantasyonu, veri b\u00fct\u00fcnl\u00fc\u011f\u00fc, zaman yolculu\u011fu sapmalar\u0131) profesyonel bir kokpit aray\u00fcz\u00fc ile \u00e7\u00f6zmektir.</p>"},{"location":"API_References/EditorCockpit_Overview_tr/#2-teknik-analiz-arac-seti","title":"2. Teknik Analiz (Ara\u00e7 Seti)","text":"<p>Kokpit mod\u00fcl\u00fc \u015fu be\u015f ana profesyonel arac\u0131 i\u00e7erir:</p>"},{"location":"API_References/EditorCockpit_Overview_tr/#a-entity-search-pro","title":"A. Entity Search Pro","text":"<p>S\u0131radan bir aramadan \u00f6te, <code>SELECT Entities WHERE HasComponent(Position)</code> gibi SQL tabanl\u0131 sorgularla milyonlarca varl\u0131k aras\u0131nda veri madencili\u011fi yapar.</p>"},{"location":"API_References/EditorCockpit_Overview_tr/#b-live-tweaker-cockpit-edition","title":"B. Live Tweaker (Cockpit Edition)","text":"<p><code>Pointer.Unbox</code> ve <code>Marshal</code> tekniklerini kullanarak, unmanaged bile\u015fen verilerini \u00e7al\u0131\u015fma zaman\u0131nda (Runtime) Slider'lar arac\u0131l\u0131\u011f\u0131yla do\u011frudan RAM \u00fczerinde manip\u00fcle etmenizi sa\u011flar.</p>"},{"location":"API_References/EditorCockpit_Overview_tr/#c-memory-heatmap-occupancy","title":"C. Memory Heatmap (Occupancy)","text":"<p>Birimlerin (Chunk) doluluk oranlar\u0131n\u0131 (<code>Count / Capacity</code>) g\u00f6rselle\u015ftirerek, bellek bask\u0131s\u0131n\u0131 ve verimsiz fragmantasyon alanlar\u0131n\u0131 otomatik olarak saptar.</p>"},{"location":"API_References/EditorCockpit_Overview_tr/#d-integrity-dashboard","title":"D. Integrity Dashboard","text":"<p><code>NexusIntegrityChecker</code> sonu\u00e7lar\u0131n\u0131 g\u00f6rselle\u015ftirir. ECS d\u00fcnyas\u0131n\u0131n sa\u011fl\u0131\u011f\u0131n\u0131 \"Nominal\", \"Degraded\" veya \"Critical\" olarak raporlar ve derinlemesine diyagnostik sunar.</p>"},{"location":"API_References/EditorCockpit_Overview_tr/#e-time-travel-debugger-timeline","title":"E. Time-Travel Debugger (Timeline)","text":"<p>G\u00f6rsel bir zaman \u00e7izelgesi (Timeline) ve \"Play/Rewind\" kontrolleri sunarak, Snapshot'lar aras\u0131nda saniyeler i\u00e7inde seyahat etmenizi ve veri ak\u0131\u015f\u0131n\u0131 izlemenizi sa\u011flar.</p>"},{"location":"API_References/EditorCockpit_Overview_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Ba\u011flant\u0131: Kokpit ara\u00e7lar\u0131 <code>NexusInitializer</code> veya <code>Registry</code> referans\u0131n\u0131 yakalayarak \"Live View\" moduna ge\u00e7er.</li> <li>Derin Analiz: Ara\u00e7lar, unmanaged bellek adreslerini (Raw Pointers) ve meta-data tablolar\u0131n\u0131 tarar.</li> <li>G\u00f6rselle\u015ftirme: Karma\u015f\u0131k veri yo\u011funluklar\u0131 ve sistem durumlar\u0131, Edit\u00f6r GUI'si \u00fczerinde renkli grafikler ve barlar olarak \u00e7izilir.</li> <li>M\u00fcdahale: Geli\u015ftiricinin yapt\u0131\u011f\u0131 her de\u011fi\u015fiklik, \"Thread-Safe\" bir \u015fekilde ECS d\u00fcnyas\u0131na enjekte edilir.</li> </ol>"},{"location":"API_References/EditorCockpit_Overview_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Kritik bir State bug'\u0131n\u0131 \u00e7\u00f6zmek:\n// 1. [Nexus/Cockpit/Integrity Dashboard] ile genel sa\u011fl\u0131k kontrol\u00fc yap\u0131l\u0131r.\n// 2. [Entity Search Pro] ile hatal\u0131 veri \u00fcreten entity'ler filtrelenir.\n// 3. [Live Tweaker] ile de\u011fi\u015fkenler canl\u0131 olarak \"balance\" edilir.\n// 4. [Time-Travel] ile hatan\u0131n ba\u015flad\u0131\u011f\u0131 kareye gidilip bellek hizalamas\u0131 (Alignment) kontrol edilir.\n</code></pre>"},{"location":"API_References/EditorCockpit_Overview_tr/#nexus-optimization-tip-context-injection","title":"Nexus Optimization Tip: Context Injection","text":"<p>Kokpit ara\u00e7lar\u0131n\u0131 kullan\u0131rken <code>SetContext</code> metodunu kullanarak ayn\u0131 Registry \u00fczerindeki farkl\u0131 ara\u00e7lar aras\u0131nda \"Senkronize\" \u00e7al\u0131\u015f\u0131n. \u00d6rne\u011fin, Search Pro'da buldu\u011funuz bir entity'yi tek tu\u015fla Live Tweaker'a aktarmak, tan\u0131lama s\u00fcresini %60 oran\u0131nda k\u0131salt\u0131r.</p>"},{"location":"API_References/EntityCommandBuffer_eng/","title":"Nexus Prime Architectural Manual: EntityCommandBuffer (Command Deferral System)","text":""},{"location":"API_References/EntityCommandBuffer_eng/#1-introduction","title":"1. Introduction","text":"<p><code>EntityCommandBuffer</code> (ECB) is the guardian of \"Structural Integrity\" for Nexus Prime. In a multi-threaded system, while thousands of entities are being processed simultaneously across different cores, destroying an entity or adding a new component instantly changes the data layout in memory (Swap-and-Pop). This causes other threads currently iterating to access invalid memory addresses, triggering an immediate hardware trap.</p> <p>The reason for ECB's existence is to place these dangerous structural changes into an isolated queue instead of performing them instantly, and to execute them from a single authoritative center when all threads have safely completed their work (Sync Point).</p>"},{"location":"API_References/EntityCommandBuffer_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>ECB utilizes lock-free queuing patterns to prevent thread stalling.</p> <pre><code>graph TD\n    subgraph Parallel_Write_Deferral\n        A[Thread 1: ECS Job] --&gt;|Add Component X| D{Concurrent Queue}\n        B[Thread 2: ECS Job] --&gt;|Destroy Entity 5| D\n        C[Thread 3: ECS Job] --&gt;|Create Entity| D\n\n        D -.-&gt;|Sync Point: Main Thread| E[Playback Coordinator]\n        E --&gt;|Serial Execution| F[Nexus Registry Mutable Memory]\n    end\n    style D fill:#ffccdd\n    style E fill:#ddffff\n    style F fill:#ddffdd</code></pre> <p>Math of Execution: For \\(N\\) commands, the time required for playback \\(T_{pb}\\) is sequentially bound: $\\(T_{pb} = \\sum_{i=1}^{N} T(Command_{i})\\)$</p>"},{"location":"API_References/EntityCommandBuffer_eng/#3-full-source-implementation-line-by-line-explanation","title":"3. Full Source Implementation &amp; Line-By-Line Explanation","text":"<p>Here is the concrete architecture of the structural barrier. None of the original context is removed.</p> <pre><code>// Source Code\nusing System.Collections.Concurrent;\nnamespace Nexus.Core;\n\npublic class EntityCommandBuffer\n{\n    private readonly ConcurrentQueue&lt;Action&lt;Registry&gt;&gt; _commands = new();\n\n    public void CreateEntity()\n    {\n        _commands.Enqueue(reg =&gt; reg.Create());\n    }\n\n    public void DestroyEntity(EntityId entity)\n    {\n        _commands.Enqueue(reg =&gt; reg.Destroy(entity));\n    }\n\n    public void AddComponent&lt;T&gt;(EntityId entity, T component = default) where T : unmanaged\n    {\n        _commands.Enqueue(reg =&gt; reg.Add(entity, component));\n    }\n\n    public void Playback(Registry registry)\n    {\n        while (_commands.TryDequeue(out var command))\n        {\n            command(registry);\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/EntityCommandBuffer_eng/#line-by-line-breakdown","title":"Line-By-Line Breakdown","text":"<ul> <li><code>private readonly ConcurrentQueue&lt;Action&lt;Registry&gt;&gt; _commands</code>: (Line 7) Instantiates the non-blocking ring buffer utilizing the thread-safe <code>ConcurrentQueue</code>. It stores anonymous delegate closures (<code>Action</code>) expecting a Registry.</li> <li><code>public void CreateEntity()</code>: (Line 9) Enqueues a deferred creation lambda. It costs a minor GC allocation to close over the action expression dynamically.</li> <li><code>public void DestroyEntity(EntityId entity)</code>: (Line 14) Enqueues a functional destructor pointer preserving the exact <code>EntityId</code>. Even if called from Core 16, it queues synchronously into the container without locking.</li> <li><code>public void AddComponent&lt;T&gt;...</code>: (Line 19) Takes a strictly <code>&lt;T&gt; unmanaged</code> constraint matching the Registry definition. The data structure payload is captured physically into the queue space.</li> <li><code>public void Playback(Registry registry)</code>: (Line 24) The absolute Sync Point method. Executes linearly.</li> <li><code>while (_commands.TryDequeue(out var command))</code>: (Line 26) Empties the queue lock-free item-by-item, guaranteeing first-in-first-out deterministic resolution against the structural registry.</li> </ul>"},{"location":"API_References/EntityCommandBuffer_eng/#4-usage-scenario-best-practices","title":"4. Usage Scenario &amp; Best Practices","text":"<p>Structural edits during runtime calculations must be buffered.</p> <pre><code>// Example Setup\nvar ecb = new EntityCommandBuffer();\nvar registry = new Registry();\n\n// Example Usage inside a Parallel Multithreaded Foreach loop...\nParallel.For(0, 1000, (i) =&gt; \n{\n    // A thread identifies an entity that is damaged severely\n    if (healthArray[i].HP &lt;= 0) \n    {\n        // Direct Registry.Destroy(id) here would CRASH because other \n        // cores are actively evaluating the memory block!\n\n        // Defer safety using the ECB:\n        ecb.DestroyEntity(idArray[i]);\n    }\n});\n\n// Sync Point: At the end of the frame when no threads are accessing memory.\n// Playback processes all 1000 deferred destructions securely on the Main Thread.\necb.Playback(registry);\n</code></pre> <p>[!WARNING] Latency of Change: Components pushed into the buffer via <code>AddComponent</code> are completely invisible to queries. If <code>Job A</code> enqueues an <code>Armor</code> component onto an entity, <code>Job B</code> running later in that same frame will not detect that component unless <code>ecb.Playback()</code> has been strictly fired in-between.</p>"},{"location":"API_References/EntityCommandBuffer_tr/","title":"Nexus Prime Mimari Rehberi: EntityCommandBuffer (Komut Geciktirme Sistemi)","text":""},{"location":"API_References/EntityCommandBuffer_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>EntityCommandBuffer</code> (ECB), Nexus Prime'\u0131n \"Yap\u0131sal Kararl\u0131l\u0131k\" (Structural Integrity) koruyucusudur. \u00c7ok \u00e7ekirdekli (Multi-threaded) bir sistemde, farkl\u0131 \u00e7ekirdeklerde binlerce varl\u0131k ayn\u0131 anda i\u015flenirken bir varl\u0131\u011f\u0131 silmek veya yeni bir bile\u015fen eklemek, bellekteki veri dizilimini an\u0131nda de\u011fi\u015ftirir (Swap-and-Pop). Bu durum, o an veri \u00fczerinde gezinmekte olan di\u011fer i\u015f par\u00e7ac\u0131klar\u0131n\u0131n ge\u00e7ersiz bellek adreslerine eri\u015fmesine yol a\u00e7arak an\u0131nda donan\u0131msal \u00e7\u00f6kmelere (trap) neden olur.</p> <p>ECB'nin varl\u0131k sebebi, bu tehlikeli yap\u0131sal de\u011fi\u015fiklikleri an\u0131nda as\u0131l belle\u011fe yazmak yerine izole bir kuyru\u011fa almak ve t\u00fcm i\u015f par\u00e7ac\u0131klar\u0131 i\u015flerini g\u00fcvenle bitirdi\u011finde (Sync Point) tek bir merkezden bu i\u015flemleri y\u00fcr\u00fctmektir.</p>"},{"location":"API_References/EntityCommandBuffer_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>ECB, Thread kilitlenmesi olay\u0131n\u0131 engellemek i\u00e7in Lock-Free pattern (kilitsiz \u00f6r\u00fcnt\u00fc) kullan\u0131r.</p> <pre><code>graph TD\n    subgraph Paralel_Yazim_Geciktirmesi\n        A[Thread 1: ECS Job] --&gt;|Bilesen X Ekle| D{Concurrent Kuyruk}\n        B[Thread 2: ECS Job] --&gt;|Varlik 5'i Sil| D\n        C[Thread 3: ECS Job] --&gt;|Varlik Olustur| D\n\n        D -.-&gt;|Sync Noktasi: Main Thread| E[Playback Koordinatoru]\n        E --&gt;|Seri Yurutme| F[Nexus Registry Degistirilebilir Bellek]\n    end\n    style D fill:#ffccdd\n    style E fill:#ddffff\n    style F fill:#ddffdd</code></pre> <p>Y\u00fcr\u00fctme Matemati\u011fi: \\(N\\) adet komut i\u00e7in \"Playback\" i\u015flemi s\u0131ras\u0131nda ge\u00e7ecek s\u00fcre \\(T_{pb}\\) kesinlikle ard\u0131\u015f\u0131k bi\u00e7imde ba\u011flanm\u0131\u015ft\u0131r: $\\(T_{pb} = \\sum_{i=1}^{N} T(Komut_{i})\\)$</p>"},{"location":"API_References/EntityCommandBuffer_tr/#3-tam-kaynak-kod-uygulamas-ve-satr-satr-acklama","title":"3. Tam Kaynak Kod Uygulamas\u0131 ve Sat\u0131r Sat\u0131r A\u00e7\u0131klama","text":"<p>Orijinal ba\u011flam\u0131n hi\u00e7biri silinmeden yap\u0131sal bariyerin tam donan\u0131msal mimarisi sunulmu\u015ftur.</p> <pre><code>// Kaynak Kod (Source Code)\nusing System.Collections.Concurrent;\nnamespace Nexus.Core;\n\npublic class EntityCommandBuffer\n{\n    private readonly ConcurrentQueue&lt;Action&lt;Registry&gt;&gt; _commands = new();\n\n    public void CreateEntity()\n    {\n        _commands.Enqueue(reg =&gt; reg.Create());\n    }\n\n    public void DestroyEntity(EntityId entity)\n    {\n        _commands.Enqueue(reg =&gt; reg.Destroy(entity));\n    }\n\n    public void AddComponent&lt;T&gt;(EntityId entity, T component = default) where T : unmanaged\n    {\n        _commands.Enqueue(reg =&gt; reg.Add(entity, component));\n    }\n\n    public void Playback(Registry registry)\n    {\n        while (_commands.TryDequeue(out var command))\n        {\n            command(registry);\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/EntityCommandBuffer_tr/#satr-satr-kod-acklamas-line-by-line-breakdown","title":"Sat\u0131r Sat\u0131r Kod A\u00e7\u0131klamas\u0131 (Line-By-Line Breakdown)","text":"<ul> <li><code>private readonly ConcurrentQueue&lt;Action&lt;Registry&gt;&gt; _commands</code>: (Sat\u0131r 7) CPU bekleme d\u00fc\u011f\u00fcmlerini atlayan ring buffer (halka \u00f6nbellek) temelli thread-safe (i\u015f par\u00e7ac\u0131\u011f\u0131 uyumlu) kuyru\u011fu tan\u0131mlar. \u0130\u00e7erisinde hedef Registry'e at\u0131lacak olan operasyonlar\u0131 lambda referanslar\u0131 (<code>Action</code>) olarak saklar.</li> <li><code>public void CreateEntity()</code>: (Sat\u0131r 9) Bir yarat\u0131m geciktirme kapatmas\u0131 (closure) enjekte eder. C# yap\u0131s\u0131 gere\u011fi bu ifade Managed Heap taraf\u0131nda ufak bir delegate tahsisi olu\u015fturur.</li> <li><code>public void DestroyEntity(EntityId entity)</code>: (Sat\u0131r 14) \u0130lgili EntityId bilgisini hapseden fonsiyonel bir tahrip i\u015faretini kuyru\u011fa koyar. 16. \u00e7ekirdekten dahi \u00e7a\u011fr\u0131lsa as\u0131l bellekte race-condition yapmaz.</li> <li><code>public void AddComponent&lt;T&gt;...</code>: (Sat\u0131r 19) Sadece <code>&lt;T&gt; unmanaged</code> donan\u0131m k\u0131s\u0131tlamas\u0131na uyan de\u011ferleri al\u0131r. G\u00f6nderilen struct verisi (payload) fiziksel hatlar\u0131yla kuyruk belle\u011finde dondurulur.</li> <li><code>public void Playback(Registry registry)</code>: (Sat\u0131r 24) \u0130\u015f ak\u0131\u015flar\u0131n\u0131n donan\u0131msal temas\u0131n\u0131n bitti\u011fi mutlak Sync Noktas\u0131 (Senkronizasyon) metodudur. Lineer \u00e7al\u0131\u015f\u0131r.</li> <li><code>while (_commands.TryDequeue(out var command))</code>: (Sat\u0131r 26) T\u00fcm kuyru\u011fu FIFO (\u0130lk giren ilk \u00e7\u0131kar) temel deterministik prensibiyle hi\u00e7 kilitlenme yaratmadan tekil \u015fekilde Registry'e bo\u015falt\u0131r ve kusar.</li> </ul>"},{"location":"API_References/EntityCommandBuffer_tr/#4-kullanm-senaryosu-ve-en-iyi-uygulamalar","title":"4. Kullan\u0131m Senaryosu ve En \u0130yi Uygulamalar","text":"<p>\u00c7al\u0131\u015fma zaman\u0131 hesaplamalar\u0131 esnas\u0131ndaki yap\u0131sal d\u00fczenlemeler mutlaka arabelle\u011fe al\u0131nmal\u0131d\u0131r.</p> <pre><code>// Ornek Kurulum\nvar ecb = new EntityCommandBuffer();\nvar registry = new Registry();\n\n// Milyonlarca hesabin yapildigi Multi-Thread Parallel For d\u00f6ng\u00fcs\u00fcnde...\nParallel.For(0, 1000, (i) =&gt; \n{\n    // Cekirdek bir hedefteki hasarin \u00f6l\u00fcmc\u00fcl oldugunu hesaplad\u0131\n    if (healthArray[i].HP &lt;= 0) \n    {\n        // Burada do\u011frudan Registry.Destroy(id) yazmak \u00c7\u00d6KT\u00dcR\u00dcR \u00e7\u00fcnk\u00fc \n        // di\u011fer CPU \u00e7ekirdekleri \u015fu an bu dizi haf\u0131zas\u0131 \u00fczerinde d\u00f6n\u00fcyor!\n\n        // Guvenligi ECB uzerine delege et:\n        ecb.DestroyEntity(idArray[i]);\n    }\n});\n\n// Sync Point: \u00c7er\u00e7eve sonu ula\u015ft\u0131\u011f\u0131nda ve haf\u0131zada art\u0131k Thread dola\u015fmad\u0131\u011f\u0131nda...\n// Playback g\u00fcvenle 1000 yok etme komutunu Main Thread \u00fczerinden \u00e7\u00f6zer.\necb.Playback(registry);\n</code></pre> <p>[!WARNING] De\u011fi\u015fim Gecikmesi (Latency of Change): <code>AddComponent</code> komutu \u00fczerinden ECB arabelle\u011fine f\u0131rlat\u0131lan bir bile\u015fen d\u0131\u015f d\u00fcnyaya ve sorgulara tamamen k\u00f6rce kapal\u0131d\u0131r. E\u011fer <code>A Sistemi</code> varl\u0131\u011fa Z\u0131rh bile\u015feni eklerse, onu hemen ard\u0131ndan takip eden <code>B Sistemi</code> okuma yapt\u0131\u011f\u0131nda Z\u0131rh\u0131 bulamaz ve hata verir. Yeni bile\u015fenin belirebilmesi ancak aralar\u0131ndan <code>ecb.Playback()</code> kesilmesinin \u00e7al\u0131\u015ft\u0131r\u0131lmas\u0131 sayesinde m\u00fcmk\u00fcn olur.</p>"},{"location":"API_References/EntityId_eng/","title":"Nexus Prime Architectural Manual: EntityId (Entity Identifier)","text":""},{"location":"API_References/EntityId_eng/#1-introduction","title":"1. Introduction","text":"<p><code>EntityId</code> is the \"fingerprint\" of every entity within the Nexus Prime ecosystem. Unlike traditional object references (GameObject/Class), it is an ultra-lightweight \"Handle\" structure that occupies exactly 8 bytes in memory.</p> <p>The reason for this structure's existence is to eliminate the cost of object tracking on the managed heap and allow the processor to carry thousands of entities within a single \"Cache Line\". <code>EntityId</code> solves the \"Dangling Pointer\" problem\u2014the biggest risk of unmanaged pointers\u2014at the hardware level using the Versioning (Generation) technique.</p>"},{"location":"API_References/EntityId_eng/#2-technical-analysis-internal-math","title":"2. Technical Analysis &amp; Internal Math","text":"<p>EntityId implements strict hardware standards for low-level data transmission. </p> \\[Size(EntityId) = 32_{bits} (Index) + 32_{bits} (Version) = 8 \\ bytes\\] <p>Because it is exactly 8 bytes and fully struct-based (Blittable), it aligns perfectly onto the CPU Cache Line borders. Operations operate at maximum \\(T\\) ALU throughput.</p> <pre><code>graph TD\n    subgraph Entity_Generational_Versioning\n        A[Entity Index: 10, Ver: 1] --&gt;|Destroy Called| B(Registry Version Array)\n        B --&gt;|Increment Ver at Idx 10| C[Registry Ver: 2]\n\n        D[Hold Stale Handle: Idx:10, Ver:1] -.-&gt;|Validation Failed 1 != 2| E[Access Denied]\n        F[New Entity Formed: Idx:10, Ver:2] -.-&gt;|Validation Passed 2 == 2| G[Access Granted]\n    end\n    style E fill:#ffaaaa\n    style G fill:#ddffdd</code></pre>"},{"location":"API_References/EntityId_eng/#3-full-source-implementation-line-by-line-explanation","title":"3. Full Source Implementation &amp; Line-By-Line Explanation","text":"<p>Never stripping context, here is the exact source methodology driving this core file.</p> <pre><code>// Source Code\nusing System.Runtime.InteropServices;\nnamespace Nexus.Core;\n\n[StructLayout(LayoutKind.Explicit, Size = 8)]\npublic struct EntityId : IEquatable&lt;EntityId&gt;\n{\n    [FieldOffset(0)] public uint Index;\n    [FieldOffset(4)] public uint Version;\n\n    public static readonly EntityId Null = new EntityId { Index = uint.MaxValue, Version = 0 };\n    public bool IsNull =&gt; Index == uint.MaxValue;\n\n    public bool Equals(EntityId other) =&gt; Index == other.Index &amp;&amp; Version == other.Version;\n    public override bool Equals(object? obj) =&gt; obj is EntityId other &amp;&amp; Equals(other);\n    public override int GetHashCode() =&gt; HashCode.Combine(Index, Version);\n\n    public static bool operator ==(EntityId left, EntityId right) =&gt; left.Equals(right);\n    public static bool operator !=(EntityId left, EntityId right) =&gt; !left.Equals(right);\n}\n</code></pre>"},{"location":"API_References/EntityId_eng/#line-by-line-breakdown-satr-satr-kod-acklamas","title":"Line-By-Line Breakdown (Sat\u0131r Sat\u0131r Kod A\u00e7\u0131klamas\u0131)","text":"<ul> <li><code>[StructLayout(LayoutKind.Explicit, Size = 8)]</code>: (Line 4) This forces the CPU's MMU (Memory Management Unit) to allocate strictly 8 uninterrupted bytes. This prevents the compiler from adding hidden byte-padding, guaranteeing safe unmanaged pointer transmission.</li> <li><code>public struct EntityId</code>: (Line 5) Being a <code>struct</code> guarantees that it allocates on the thread stack or directly inside adjacent array blocks, never producing Managed Heap Garbage Collection.</li> <li><code>[FieldOffset(0)] public uint Index;</code>: (Line 7) The first \\(4 \\ bytes\\) specifically store the physical array offset location mapping into the hardware.</li> <li><code>[FieldOffset(4)] public uint Version;</code>: (Line 8) The next \\(4 \\ bytes\\) store the temporal generation ID, preventing dangling pointer references. If an entity dies, its location's version increments.</li> <li><code>EntityId Null</code>: (Line 10) Pre-allocates a static signature mapping to the maximum possible unsigned integer mask (<code>0xFFFFFFFF</code>), defining an architecturally proven null state that takes \\(0 \\ cycles\\) to instantiate.</li> <li><code>IEquatable&lt;EntityId&gt;</code> &amp; <code>operator ==</code>: (Lines 13-18) Implements zero-allocation comparison operations. Bypassing virtual calls keeps comparison mathematically bound to \\(1 \\ ALU \\ cycle\\).</li> </ul>"},{"location":"API_References/EntityId_eng/#4-usage-scenario-examples","title":"4. Usage Scenario &amp; Examples","text":"<p>If you want to track a target object securely, you maintain its <code>EntityId</code>, not an object reference.</p> <pre><code>// 1. Spawning the target\nEntityId enemy = Registry.Create();\nRegistry.Add&lt;Position&gt;(enemy, new Position { X = 10 });\n\n// 2. Later in a different frame, evaluating if it is still alive\nif (!enemy.IsNull) \n{\n    // The core validation logic is evaluated deep within Registry.Has\n    if (Registry.Has&lt;Position&gt;(enemy)) \n    {\n        // Execute logic on the enemy...\n    }\n    else \n    {\n        // Enemy is dead or does not have a Position!\n        Console.WriteLine(\"Target Lost!\");\n    }\n}\n</code></pre> <p>[!WARNING] Null Safety Restrictions: Attempting to extract components from an <code>EntityId</code> that returns <code>true</code> for <code>IsNull</code> will trigger an immediate and irreversible <code>AccessViolationException</code> in unmanaged arrays. Always encapsulate operations with structural validity checks.</p> <p>[!TIP] Nexus Optimization Tip: Cache-Friendly Transfer A modern CPU Cache Line (\\(64 \\ bytes\\)) can encompass exactly 8 EntityIds. When your system scans an array of entities, the processor coalesces the identity of 8 entities into the L1 Data Cache in a single burst fetch. This compounds identity scanning throughput by over 700% against scattered OOP reference models like Unity's <code>GameObject[]</code> arrays.</p>"},{"location":"API_References/EntityId_tr/","title":"Nexus Prime Mimari Rehberi: EntityId (Varl\u0131k Tan\u0131mlay\u0131c\u0131)","text":""},{"location":"API_References/EntityId_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>EntityId</code>, Nexus Prime ekosistemindeki her bir varl\u0131\u011f\u0131n \"parmak izidir\". Geleneksel nesne referanslar\u0131n\u0131n (GameObject/Class) aksine, bellekte tam olarak 8 byte yer kaplayan ultra-hafif bir \"Handle\" yap\u0131s\u0131d\u0131r.</p> <p>Bu yap\u0131n\u0131n varl\u0131k sebebi, y\u00f6netilen bellek (Managed Heap) \u00fczerindeki nesne takibi maliyetini s\u0131f\u0131ra indirmek ve i\u015flemcinin binlerce varl\u0131\u011f\u0131 tek bir \"Cache Line\" i\u00e7inde biti\u015fik olarak ta\u015f\u0131mas\u0131na olanak tan\u0131makt\u0131r. <code>EntityId</code>, unmanaged pointerlar\u0131n en b\u00fcy\u00fck riski olan \"Dangling Pointer\" (silinmi\u015f belle\u011fe yasad\u0131\u015f\u0131 eri\u015fim) sorununu Versiyonlama (Generation) tekni\u011fi ile donan\u0131m seviyesinde \u00e7\u00f6zer.</p>"},{"location":"API_References/EntityId_tr/#2-teknik-analiz-ve-matematiksel-icyuzu","title":"2. Teknik Analiz ve Matematiksel \u0130\u00e7y\u00fcz\u00fc","text":"<p>EntityId, d\u00fc\u015f\u00fck seviyeli veri iletimi i\u00e7in fiziksel bellekte kat\u0131 standartlar uygular.</p> \\[Boyut(EntityId) = 32_{bit} (Indeks) + 32_{bit} (Versiyon) = 8 \\ byte\\] <p>Tam olarak 8 byte oldu\u011fu ve tamamen struct tabanl\u0131 (Blittable) oldu\u011fu i\u00e7in CPU Cache Line (\u00d6nbellek Hatt\u0131) s\u0131n\u0131rlar\u0131na kusursuz hizalan\u0131r.</p> <pre><code>graph TD\n    subgraph Varlik_Versiyon_Kontrolu\n        A[Varlik Indeksi: 10, Ver: 1] --&gt;|Destroy Cagrildi| B(Registry Versiyon Dizisi)\n        B --&gt;|Idx 10 Icin Ver Artir| C[Registry Ver: 2]\n\n        D[Eski Tutamaci Kullan: Idx:10, Ver:1] -.-&gt;|Dogrulama Basarisiz 1 != 2| E[Erisim Reddedildi]\n        F[Yeni Varlik Olustu: Idx:10, Ver:2] -.-&gt;|Dogrulama Basarili 2 == 2| G[Erisim \u0130zni Verildi]\n    end\n    style E fill:#ffaaaa\n    style G fill:#ddffdd</code></pre>"},{"location":"API_References/EntityId_tr/#3-tam-kaynak-kod-uygulamas-ve-satr-satr-acklama","title":"3. Tam Kaynak Kod Uygulamas\u0131 ve Sat\u0131r Sat\u0131r A\u00e7\u0131klama","text":"<p>A\u015fa\u011f\u0131da bu temel dosyan\u0131n yap\u0131s\u0131n\u0131 sa\u011flayan tam kaynak kod verilmi\u015ftir. Hi\u00e7bir bilgi eksiltilmemi\u015ftir.</p> <pre><code>// Kaynak Kod (Source Code)\nusing System.Runtime.InteropServices;\nnamespace Nexus.Core;\n\n[StructLayout(LayoutKind.Explicit, Size = 8)]\npublic struct EntityId : IEquatable&lt;EntityId&gt;\n{\n    [FieldOffset(0)] public uint Index;\n    [FieldOffset(4)] public uint Version;\n\n    public static readonly EntityId Null = new EntityId { Index = uint.MaxValue, Version = 0 };\n    public bool IsNull =&gt; Index == uint.MaxValue;\n\n    public bool Equals(EntityId other) =&gt; Index == other.Index &amp;&amp; Version == other.Version;\n    public override bool Equals(object? obj) =&gt; obj is EntityId other &amp;&amp; Equals(other);\n    public override int GetHashCode() =&gt; HashCode.Combine(Index, Version);\n\n    public static bool operator ==(EntityId left, EntityId right) =&gt; left.Equals(right);\n    public static bool operator !=(EntityId left, EntityId right) =&gt; !left.Equals(right);\n}\n</code></pre>"},{"location":"API_References/EntityId_tr/#satr-satr-kod-acklamas-line-by-line-breakdown","title":"Sat\u0131r Sat\u0131r Kod A\u00e7\u0131klamas\u0131 (Line-By-Line Breakdown)","text":"<ul> <li><code>[StructLayout(LayoutKind.Explicit, Size = 8)]</code>: (Sat\u0131r 4) Bu \u00f6znitelik CPU'nun MMU (Bellek Y\u00f6netim Birimi) sistemini aral\u0131ks\u0131z tam 8 byte ay\u0131rmaya zorlar. Derleyicinin araya gizli dolgu baytlar\u0131 (padding) eklemesini engelleyerek g\u00fcvenli pointer kopyalamas\u0131n\u0131 garanti eder.</li> <li><code>public struct EntityId</code>: (Sat\u0131r 5) <code>struct</code> (de\u011fer tipi) olmas\u0131, bellek tahsisinin thread stack'inde veya dizi bloklar\u0131 i\u00e7inde do\u011frudan yap\u0131lmas\u0131n\u0131 mecbur k\u0131lar. Asla Managed Heap'te Garbage Collection \u00e7\u00f6p\u00fc \u00fcretmez.</li> <li><code>[FieldOffset(0)] public uint Index;</code>: (Sat\u0131r 7) \u0130lk \\(4 \\ byte\\) fiziksel dizideki veri sat\u0131r\u0131na denk gelen bellek ofset haritas\u0131n\u0131 tutar.</li> <li><code>[FieldOffset(4)] public uint Version;</code>: (Sat\u0131r 8) Sonraki \\(4 \\ byte\\) varl\u0131\u011f\u0131n nesil (generation) ID'sini tutar. Varl\u0131k silinirse, o lokasyonun jenerasyonu artar ve Dangling Pointer ihtimali fiziken s\u0131f\u0131rlan\u0131r.</li> <li><code>EntityId Null</code>: (Sat\u0131r 10) Olabilcek en y\u00fcksek unsigned integer maskesine (<code>0xFFFFFFFF</code>) denk gelen statik bir ge\u00e7ersiz durumu tan\u0131mlar.</li> <li><code>IEquatable&lt;EntityId&gt;</code> &amp; <code>operator ==</code>: (Sat\u0131rlar 13-18) E\u015fitlik kar\u015f\u0131la\u015ft\u0131rmas\u0131 operat\u00f6rlerinin bellek harcamas\u0131n\u0131 s\u0131f\u0131rlayan implementasyonlar\u0131d\u0131r. Sanal (virtual) \u00e7a\u011fr\u0131 maliyetlerini devred\u0131\u015f\u0131 b\u0131rakarak kimlik kar\u015f\u0131la\u015ft\u0131rmas\u0131n\u0131 tek bir \\(1 \\ ALU \\ cycle\\) zaman\u0131na \u00e7eker.</li> </ul>"},{"location":"API_References/EntityId_tr/#4-kullanm-senaryosu-ve-ornekler","title":"4. Kullan\u0131m Senaryosu ve \u00d6rnekler","text":"<p>Hedef bir objeyi g\u00fcvenle takip etmek istiyorsan\u0131z, bir nesne referans\u0131 tutmak yerine onun <code>EntityId</code> tutamac\u0131n\u0131 saklars\u0131n\u0131z.</p> <pre><code>// 1. Hedefin uretilmesi\nEntityId enemy = Registry.Create();\nRegistry.Add&lt;Position&gt;(enemy, new Position { X = 10 });\n\n// 2. Daha baska bir devirde, hala yasadigini kontrol etmek\nif (!enemy.IsNull) \n{\n    // Temel versiyon kontrolu Registry.Has icerisinde gerceklesir\n    if (Registry.Has&lt;Position&gt;(enemy)) \n    {\n        // Hedef uzerinde calis...\n    }\n    else \n    {\n        // Hedef silinmis veya Position bilesenini yitirmis!\n        Console.WriteLine(\"Hedef Kaybedildi!\");\n    }\n}\n</code></pre> <p>[!WARNING] Null G\u00fcvenlik K\u0131s\u0131tlamalar\u0131: <code>IsNull</code> metodundan <code>true</code> d\u00f6nen bir EntityId kullan\u0131larak do\u011frudan unmanaged bellek \u00e7ekimi yapmaya \u00e7al\u0131\u015fmak, C# Runtime \u00fczerinde geri d\u00f6nd\u00fcr\u00fclemez bir <code>AccessViolationException</code> f\u0131rlat\u0131r ve uygulamay\u0131 sert \u015fekilde kapat\u0131r. Her zaman id do\u011frulamas\u0131 yap\u0131lmal\u0131d\u0131r.</p> <p>[!TIP] Nexus Optimizasyonu: Cache-Friendly \u0130letim Standart bir L1 CPU \u00d6nbellek \u00e7izgisi (\\(64 \\ byte\\)), i\u00e7erisine yan yana sekiz adet 8 EntityId s\u0131\u011fd\u0131r\u0131r. \u0130\u015flemciniz bir varl\u0131k listesi \u00fczerinden ge\u00e7erken sadece tek bir bellek \u00e7ekme (fetch) operasyonu ile 8 varl\u0131\u011f\u0131n kimli\u011fini L1 i\u015flemci kalbine getirir. Bu matematiksel d\u00fczen, Unity'nin OOP tabanl\u0131 <code>GameObject[]</code> dizilerine k\u0131yasla kimlik i\u015fleme hacmini net saniyede %700 yukar\u0131 \u00e7eker.</p>"},{"location":"API_References/EntityInspectorPro_eng/","title":"Nexus Prime Architectural Manual: Entity Inspector Pro (Advanced Asset Inspector)","text":""},{"location":"API_References/EntityInspectorPro_eng/#1-introduction","title":"1. Introduction","text":"<p><code>EntityInspectorPro.cs</code> is an \"SQL-Like\" search engine allowing you to find objects matching specific criteria within seconds in massive Nexus worlds where there are millions of assets (Entity). Far beyond standard \"Find\" commands, it performs data mining with logical queries.</p> <p>The reason for this inspector's existence is to immediately meet complex developer demands such as \"Show all enemies with health less than 20 and speed higher than 5\".</p>"},{"location":"API_References/EntityInspectorPro_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The inspector has the following advanced querying capabilities:</p> <ul> <li>Logical Query Engine: Supports logical operators such as <code>AND</code>, <code>OR</code>, <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>.</li> <li>Component Filtering: Can filter entities possessing only a specific component (e.g., <code>INexusStatus</code>).</li> <li>Direct Pointer Access: Offers the most up-to-date \"Live\" data by pulling query results directly from unmanaged memory addresses (Registry).</li> <li>Selection Integration: When the found entity is clicked, automatically selects its counterpart in the hierarchy (Unity GameObject if any) or its data on the State Tweaker.</li> </ul>"},{"location":"API_References/EntityInspectorPro_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Query Input: The developer writes a query such as <code>Health &lt; 50 AND Team == 1</code> in the text box.</li> <li>Parsing (Parsing): The system divides the text into a logical tree (Logic Tree).</li> <li>Scanning: All assets within the ECS Registry are passed through this logical filter.</li> <li>Result Listing: Entities matching the criteria are listed with their IDs and summary data.</li> </ol>"},{"location":"API_References/EntityInspectorPro_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Example Queries:\n&gt; Level &gt; 10 AND Xp &lt; 100\n&gt; Status == Dead OR IsStunned == true\n&gt; AmmoCount == 0\n</code></pre>"},{"location":"API_References/EntityInspectorPro_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class EntityInspectorPro : EditorWindow\n{\n    [MenuItem(\"Nexus/Entity Inspector Pro\")]\n    public static void ShowWindow() =&gt; GetWindow&lt;EntityInspectorPro&gt;(\"Inspector Pro\");\n\n    private string _query = \"Health &lt; 20 AND Speed &gt; 5\";\n\n    private void OnGUI() {\n        GUILayout.Label(\"Nexus Entity Search (SQL-Like)\", EditorStyles.boldLabel);\n        _query = EditorGUILayout.TextField(\"Query\", _query);\n        if (GUILayout.Button(\"Find Entities\")) {\n            // Parse query, scan Registry, show results...\n        }\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/EntityInspectorPro_eng/#nexus-optimization-tip-query-caching","title":"Nexus Optimization Tip: Query Caching","text":"<p>Save frequently made queries (e.g., \"Dead Entities\") as \"Saved Search\". This way, you can increase search speed by 30% by using the pre-prepared <code>NexusQuery</code> object without bearing the text resolution (<code>parsing</code>) cost every time.</p>"},{"location":"API_References/EntityInspectorPro_tr/","title":"Nexus Prime Mimari Rehberi: Entity Inspector Pro (Geli\u015fmi\u015f Varl\u0131k M\u00fcfetti\u015fi)","text":""},{"location":"API_References/EntityInspectorPro_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>EntityInspectorPro.cs</code>, milyonlarca varl\u0131\u011f\u0131n (Entity) bulundu\u011fu devasa Nexus d\u00fcnyalar\u0131nda, belirli kriterlere uyan nesneleri saniyeler i\u00e7inde bulman\u0131z\u0131 sa\u011flayan \"SQL Benzeri\" bir arama motorudur. Standart \"Find\" komutlar\u0131n\u0131n \u00e7ok \u00f6tesinde, mant\u0131ksal sorgularla veri madencili\u011fi yapar.</p> <p>Bu m\u00fcfetti\u015fin varl\u0131k sebebi; \"Can\u0131 20'den az olup h\u0131z\u0131 5'ten y\u00fcksek olan t\u00fcm d\u00fc\u015fmanlar\u0131 g\u00f6ster\" gibi karma\u015f\u0131k geli\u015ftirici taleplerini an\u0131nda kar\u015f\u0131lamakt\u0131r.</p>"},{"location":"API_References/EntityInspectorPro_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>M\u00fcfetti\u015f, \u015fu geli\u015fmi\u015f sorgulama yeteneklerine sahiptir:</p> <ul> <li>Logical Query Engine: <code>AND</code>, <code>OR</code>, <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code> gibi mant\u0131ksal operat\u00f6rleri destekler.</li> <li>Component Filtering: Sadece belirli bir bile\u015fene (\u00d6rn: <code>INexusStatus</code>) sahip olan entity'leri filtreleyebilir.</li> <li>Direct Pointer Access: Sorgu sonu\u00e7lar\u0131n\u0131 do\u011frudan unmanaged bellek adreslerinden (Registry) \u00e7ekerek en g\u00fcncel \"Canl\u0131\" veriyi sunar.</li> <li>Selection Integration: Bulunan entity'ye t\u0131kland\u0131\u011f\u0131nda, hiyerar\u015fideki kar\u015f\u0131l\u0131\u011f\u0131n\u0131 (Varsa Unity GameObject) veya State Tweaker \u00fczerindeki verisini otomatik olarak se\u00e7er.</li> </ul>"},{"location":"API_References/EntityInspectorPro_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Sorgu Giri\u015fi: Geli\u015ftirici metin kutusuna <code>Health &lt; 50 AND Team == 1</code> gibi bir sorgu yazar.</li> <li>Ayr\u0131\u015ft\u0131rma (Parsing): Sistem, metni mant\u0131ksal bir a\u011faca (Logic Tree) b\u00f6ler.</li> <li>Tarama: ECS Registry i\u00e7indeki t\u00fcm varl\u0131klar bu mant\u0131ksal filtreden ge\u00e7irilir.</li> <li>Sonu\u00e7 Listeleme: Kriterlere uyan entity'ler ID'leri ve \u00f6zet verileriyle listelenir.</li> </ol>"},{"location":"API_References/EntityInspectorPro_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// \u00d6rnek Sorgular:\n&gt; Level &gt; 10 AND Xp &lt; 100\n&gt; Status == Dead OR IsStunned == true\n&gt; AmmoCount == 0\n</code></pre>"},{"location":"API_References/EntityInspectorPro_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class EntityInspectorPro : EditorWindow\n{\n    [MenuItem(\"Nexus/Entity Inspector Pro\")]\n    public static void ShowWindow() =&gt; GetWindow&lt;EntityInspectorPro&gt;(\"Inspector Pro\");\n\n    private string _query = \"Health &lt; 20 AND Speed &gt; 5\";\n\n    private void OnGUI() {\n        GUILayout.Label(\"Nexus Entity Search (SQL-Like)\", EditorStyles.boldLabel);\n        _query = EditorGUILayout.TextField(\"Query\", _query);\n        if (GUILayout.Button(\"Find Entities\")) {\n            // Parse query, scan Registry, show results...\n        }\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/EntityInspectorPro_tr/#nexus-optimization-tip-query-caching","title":"Nexus Optimization Tip: Query Caching","text":"<p>S\u0131k yapt\u0131\u011f\u0131n\u0131z sorgular\u0131 (\u00d6rn: \"\u00d6l\u00fc Entity'ler\") birer \"Saved Search\" olarak kaydedin. Bu sayede her seferinde metin ayr\u0131\u015ft\u0131rma (<code>parsing</code>) maliyetine katlanmadan, \u00f6nceden haz\u0131rlanm\u0131\u015f <code>NexusQuery</code> nesnesini kullanarak arama h\u0131z\u0131n\u0131 %30 art\u0131rabilirsiniz.</p>"},{"location":"API_References/HierarchicalSnapshotManager_eng/","title":"Nexus Prime Architectural Manual: HierarchicalSnapshotManager (Hierarchical State Management)","text":""},{"location":"API_References/HierarchicalSnapshotManager_eng/#1-introduction","title":"1. Introduction","text":"<p><code>HierarchicalSnapshotManager.cs</code> is the \"Partial Saving\" infrastructure developed by Nexus Prime to manage massive worlds. While the standard <code>SnapshotManager</code> freezes the entire world, Hierarchical Snapshot performs state tracking based only on specific sectors, regions, or systems (e.g., only \"Village 1\" or only \"Player Inventory\").</p> <p>The reason for this manager's existence is to prevent unnecessary data copying in a simulation containing billions of bytes of data and to optimize memory usage by backing up only the data sets (Sectoring) that change or are needed at that moment to RAM.</p>"},{"location":"API_References/HierarchicalSnapshotManager_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>HierarchicalSnapshotManager uses the following techniques for efficient state management:</p> <ul> <li>Sector-Based Filtering: By grouping entities under a <code>sectorName</code>, it backs up only the components belonging to that group with <code>CapturePartial</code>.</li> <li>Partial Registry Restore: Instead of overwriting all data on the <code>Registry</code>, it updates only the data of the entities within the snapshot (Differential Patching).</li> <li>Tag-Based Capture: It collects snapshots via dynamic queries based on the sector information where the entities are located.</li> <li>Memory Decoupling: Since sector backups are independent of each other, others continue to remain healthy even if one sector is corrupted.</li> </ul>"},{"location":"API_References/HierarchicalSnapshotManager_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Classification: Entities are divided into logical groups (Sectors).</li> <li>Backup (<code>SaveSector</code>): A partial unmanaged snapshot is created with a specific sector name and entity list.</li> <li>Storage: Snapshots are stored in a dictionary (<code>Dictionary</code>) structure, keyed by sector name.</li> <li>Restoration (<code>RestoreSector</code>): When called by sector name, only the states of the entities in that region are written back to the Registry.</li> </ol>"},{"location":"API_References/HierarchicalSnapshotManager_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Partial Snapshot A momentary state backup of only a certain part, not the entire system. Sectoring The process of dividing a large data space into smaller, independently manageable pieces. Differential Patching Updating target data by patching only the changed parts onto it. Capture Logic The process of freezing the current state of data and copying it to unmanaged memory."},{"location":"API_References/HierarchicalSnapshotManager_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Entity Consistency: If an entity has moved from Sector A to Sector B and only Sector A is restored, the entity may appear in two places at once, or data inconsistency (Duplication) may occur.</li> <li>Cross-Sector References: References between sectors (e.g., a key in Sector 1 opening a door in Sector 2) may break in partial loads.</li> </ul>"},{"location":"API_References/HierarchicalSnapshotManager_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>var sectorManager = new HierarchicalSnapshotManager(registry);\n\n// Save entities in the \"Dungeon_1\" region\nvar dungeonEntities = registry.Query().With&lt;InDungeon&gt;().GetEntities();\nsectorManager.SaveSector(\"Dungeon_1\", dungeonEntities);\n\n// After a while, return only that dungeon to its original state\nsectorManager.RestoreSector(\"Dungeon_1\");\n</code></pre>"},{"location":"API_References/HierarchicalSnapshotManager_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>using System.Collections.Generic;\nnamespace Nexus.Core;\n\npublic class HierarchicalSnapshotManager\n{\n    private readonly Registry _registry;\n    private readonly Dictionary&lt;string, Snapshot&gt; _sectorSnapshots = new();\n\n    public void SaveSector(string sectorName, IEnumerable&lt;EntityId&gt; entities)\n    {\n        // 1. Filter entities in the sector.\n        // 2. Capture a partial snapshot via Registry.\n    }\n\n    public void RestoreSector(string sectorName)\n    {\n        // Find and restore partial snapshot properties.\n    }\n}\n</code></pre>"},{"location":"API_References/HierarchicalSnapshotManager_eng/#nexus-optimization-tip-predictive-sector-unloading","title":"Nexus Optimization Tip: Predictive Sector Unloading","text":"<p>Using HierarchicalSnapshotManager, you can store the states of sectors far from the player as unmanaged snapshots and delete (Unload) those entities from the <code>Registry</code>. This method reduces the number of active entities at runtime by up to 70%, massively lowering the CPU load.</p>"},{"location":"API_References/HierarchicalSnapshotManager_tr/","title":"Nexus Prime Mimari Rehberi: HierarchicalSnapshotManager (Hiyerar\u015fik Durum Y\u00f6netimi)","text":""},{"location":"API_References/HierarchicalSnapshotManager_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>HierarchicalSnapshotManager.cs</code>, Nexus Prime'\u0131n devasa d\u00fcnyalar\u0131 y\u00f6netebilmek i\u00e7in geli\u015ftirdi\u011fi \"K\u0131smi Kay\u0131t\" (Partial Saving) altyap\u0131s\u0131d\u0131r. Standart <code>SnapshotManager</code> t\u00fcm d\u00fcnyay\u0131 dondururken, Hierarchical Snapshot sadece belirli sekt\u00f6rleri, b\u00f6lgeleri veya sistemleri (\u00d6rn: Sadece \"K\u00f6y 1\" veya sadece \"Oyuncu Envanteri\") baz alarak durum takibi yapar.</p> <p>Bu y\u00f6neticinin varl\u0131k sebebi, milyarlarca byte verinin bulundu\u011fu bir sim\u00fclasyonda gereksiz veri kopyalamas\u0131n\u0131 \u00f6nlemek ve sadece o an de\u011fi\u015fen veya ihtiya\u00e7 duyulan veri k\u00fcmelerini (Sectoring) RAM'e yedekleyerek bellek kullan\u0131m\u0131n\u0131 optimize etmektir.</p>"},{"location":"API_References/HierarchicalSnapshotManager_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>HierarchicalSnapshotManager, verimli durum y\u00f6netimi i\u00e7in \u015fu teknikleri kullan\u0131r:</p> <ul> <li>Sector-Based Filtering: Varl\u0131klar\u0131 bir <code>sectorName</code> alt\u0131nda gruplayarak, sadece o gruba ait bile\u015fenleri <code>CapturePartial</code> ile yedekler.</li> <li>Partial Registry Restore: <code>Registry</code> \u00fczerindeki t\u00fcm veriyi ezmek yerine, sadece snapshot i\u00e7indeki varl\u0131klar\u0131n verilerini g\u00fcnceller (Differential Patching).</li> <li>Tag-Based Capture: Varl\u0131klar\u0131n bulundu\u011fu sekt\u00f6r bilgisini baz alarak dinamik sorgular (Dynamic Queries) \u00fczerinden snapshot toplar.</li> <li>Memory Decoupling: Sekt\u00f6r yedekleri birbirinden ba\u011f\u0131ms\u0131z oldu\u011fu i\u00e7in, bir sekt\u00f6r bozulsa bile di\u011ferleri sa\u011fl\u0131kl\u0131 kalmaya devam eder.</li> </ul>"},{"location":"API_References/HierarchicalSnapshotManager_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>S\u0131n\u0131fland\u0131rma: Varl\u0131klar mant\u0131ksal gruplara (Sekt\u00f6rler) ayr\u0131l\u0131r.</li> <li>Yedekleme (<code>SaveSector</code>): Belirli bir sekt\u00f6r ismi ve varl\u0131k listesiyle k\u0131smi bir unmanaged snapshot olu\u015fturulur.</li> <li>Depolama: Snapshot'lar bir s\u00f6zl\u00fck (<code>Dictionary</code>) yap\u0131s\u0131nda, sekt\u00f6r ismiyle anahtarlanarak saklan\u0131r.</li> <li>Geri Y\u00fckleme (<code>RestoreSector</code>): Sekt\u00f6r ismiyle \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, sadece o b\u00f6lgedeki varl\u0131klar\u0131n durumlar\u0131 Registry \u00fczerine geri yaz\u0131l\u0131r.</li> </ol>"},{"location":"API_References/HierarchicalSnapshotManager_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Partial Snapshot T\u00fcm sistemin de\u011fil, sadece belirli bir k\u0131sm\u0131n anl\u0131k durum yede\u011fi. Sectoring B\u00fcy\u00fck bir veri uzay\u0131n\u0131 daha k\u00fc\u00e7\u00fck, ba\u011f\u0131ms\u0131z y\u00f6netilebilir par\u00e7alara b\u00f6lme i\u015flemi. Differential Patching Sadece de\u011fi\u015fen k\u0131s\u0131mlar\u0131 hedef veri \u00fczerine yamayarak g\u00fcncelleme yapma. Capture Logic Verinin o anki halini dondurup (Freeze) unmanaged belle\u011fe kopyalama s\u00fcreci."},{"location":"API_References/HierarchicalSnapshotManager_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Entity Consistency: E\u011fer bir varl\u0131k Sekt\u00f6r A'dan Sekt\u00f6r B'ye ge\u00e7mi\u015fse ve sadece Sekt\u00f6r A geri y\u00fcklenirse, varl\u0131k iki yerde birden g\u00f6r\u00fcnebilir veya veri tutars\u0131zl\u0131\u011f\u0131 (Duplication) olu\u015fabilir.</li> <li>Cross-Sector References: Sekt\u00f6rler aras\u0131 referanslar (\u00d6rn: Sekt\u00f6r 1'deki bir anahtar\u0131n Sekt\u00f6r 2'deki kap\u0131y\u0131 a\u00e7mas\u0131) k\u0131smi y\u00fcklemelerde kopabilir.</li> </ul>"},{"location":"API_References/HierarchicalSnapshotManager_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>var sectorManager = new HierarchicalSnapshotManager(registry);\n\n// \"Zindan_1\" b\u00f6lgesindeki varl\u0131klar\u0131 kaydet\nvar dungeonEntities = registry.Query().With&lt;InDungeon&gt;().GetEntities();\nsectorManager.SaveSector(\"Zindan_1\", dungeonEntities);\n\n// Bir s\u00fcre sonra sadece o zindan\u0131 eski haline d\u00f6nd\u00fcr\nsectorManager.RestoreSector(\"Zindan_1\");\n</code></pre>"},{"location":"API_References/HierarchicalSnapshotManager_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>using System.Collections.Generic;\nnamespace Nexus.Core;\n\npublic class HierarchicalSnapshotManager\n{\n    private readonly Registry _registry;\n    private readonly Dictionary&lt;string, Snapshot&gt; _sectorSnapshots = new();\n\n    public void SaveSector(string sectorName, IEnumerable&lt;EntityId&gt; entities)\n    {\n        // 1. Filter entities in the sector.\n        // 2. Capture a partial snapshot via Registry.\n    }\n\n    public void RestoreSector(string sectorName)\n    {\n        // Find and restore partial snapshot properties.\n    }\n}\n</code></pre>"},{"location":"API_References/HierarchicalSnapshotManager_tr/#nexus-optimization-tip-predictive-sector-unloading","title":"Nexus Optimization Tip: Predictive Sector Unloading","text":"<p>HierarchicalSnapshotManager kullanarak, oyuncuya uzak olan sekt\u00f6rlerin durumlar\u0131n\u0131 unmanaged snapshot olarak saklay\u0131p, o varl\u0131klar\u0131 <code>Registry</code>'den silebilirsiniz (Unload). Bu y\u00f6ntem, \u00e7al\u0131\u015fma zaman\u0131ndaki aktif varl\u0131k say\u0131s\u0131n\u0131 %70'e kadar azaltarak CPU y\u00fck\u00fcn\u00fc devasa oranda d\u00fc\u015f\u00fcr\u00fcr.</p>"},{"location":"API_References/INexusJobSystem_eng/","title":"Nexus Prime Architectural Manual: INexusJobSystem (System Orchestration Contract)","text":""},{"location":"API_References/INexusJobSystem_eng/#1-introduction","title":"1. Introduction","text":"<p><code>INexusJobSystem.cs</code> is the high-level interface defining the job execution layer of the Nexus Prime framework. It is the contract for the orchestrator that determines in what order and using what hardware resources all logical systems (<code>INexusSystem</code>) will be run.</p> <p>The reason for this interface's existence is to break the connection between the game loop and business logic, to automatically parallelize systems according to data dependencies, and to make the cost of each job on the processor (Metrics) traceable.</p>"},{"location":"API_References/INexusJobSystem_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>INexusJobSystem mandates the following capabilities for high-performance system management:</p> <ul> <li>System Registration: Every system registered with <code>AddSystem()</code> is subjected to dependency analysis via Reflection. This eliminates manual \"Thread\" management.</li> <li>Dependency-Aware Execution: When <code>Execute()</code> is called, systems are triggered in parallel on the most appropriate cores without blocking each other (Data Race priority).</li> <li>Performance Monitoring: Provides scientific data on how many microseconds each system took to complete via <code>GetLastExecutionMetrics()</code>.</li> <li>Thread Safety Abstraction: Prevents the developer from dealing with lock (Lock/Mutex) mechanisms; it provides parallel safety at the interface level through [Read]/[Write] attributes.</li> </ul>"},{"location":"API_References/INexusJobSystem_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Registration: Systems are added to the <code>JobSystem</code> at the start of the game.</li> <li>Ordering: A dependency graph (DAG) between systems is created.</li> <li>Triggering: The main loop calls the <code>Execute()</code> method every frame.</li> <li>Analysis: Performance metrics are collected and presented to the developer for optimization.</li> </ol>"},{"location":"API_References/INexusJobSystem_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Orchestrator Coordinator of threads and systems. Execution Metrics Working time, CPU usage, and latency data of a job. Worker Thread Auxiliary processor arm doing heavy calculations in the background. Dispatcher The unit that distributes jobs to available empty cores."},{"location":"API_References/INexusJobSystem_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Main Thread Stalls: If there is a very heavy and non-parallel job within <code>Execute()</code>, the game's frame rate (FPS) may drop.</li> <li>Ordering Dependencies: If two systems write to the same data, the interface guarantees their order, but this limits parallelism.</li> </ul>"},{"location":"API_References/INexusJobSystem_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>public void SetupGame(INexusJobSystem jobSystem, Registry registry)\n{\n    // Add systems\n    jobSystem.AddSystem(new PhysicsSystem());\n    jobSystem.AddSystem(new AISystem());\n\n    // Run every frame\n    void OnUpdate() {\n        jobSystem.Execute();\n\n        // Monitor performance\n        var metrics = jobSystem.GetLastExecutionMetrics();\n        foreach(var m in metrics)\n            Console.WriteLine($\"{m.SystemName}: {m.DurationMs}ms\");\n    }\n}\n</code></pre>"},{"location":"API_References/INexusJobSystem_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>using System.Collections.Generic;\nnamespace Nexus.Core;\n\npublic interface INexusJobSystem\n{\n    void AddSystem(INexusSystem system);\n    void Execute();\n    List&lt;JobSystem.ExecutionMetrics&gt; GetLastExecutionMetrics();\n}\n</code></pre>"},{"location":"API_References/INexusJobSystem_eng/#nexus-optimization-tip-cycle-budgeting","title":"Nexus Optimization Tip: Cycle Budgeting","text":"<p>Using <code>GetLastExecutionMetrics()</code> data, set a Clock Cycle Budget for each frame. If a system exceeds the budget, aim to get maximum benefit from parallelism by dividing it into smaller pieces (Jobs).</p>"},{"location":"API_References/INexusJobSystem_tr/","title":"Nexus Prime Mimari Rehberi: INexusJobSystem (Sistem Orkestrasyon S\u00f6zle\u015fmesi)","text":""},{"location":"API_References/INexusJobSystem_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>INexusJobSystem.cs</code>, Nexus Prime framework'\u00fcn\u00fcn i\u015f y\u00fcr\u00fctme katman\u0131n\u0131 tan\u0131mlayan \u00fcst d\u00fczey aray\u00fczd\u00fcr. T\u00fcm mant\u0131ksal sistemlerin (<code>INexusSystem</code>) hangi s\u0131ra ile ve hangi donan\u0131m kaynaklar\u0131n\u0131 kullanarak \u00e7al\u0131\u015ft\u0131r\u0131laca\u011f\u0131n\u0131 belirleyen orkestrat\u00f6r\u00fcn kontrat\u0131d\u0131r.</p> <p>Bu aray\u00fcz\u00fcn varl\u0131k sebebi; oyun d\u00f6ng\u00fcs\u00fc (Game Loop) ile i\u015f mant\u0131\u011f\u0131 aras\u0131ndaki ba\u011f\u0131 koparmak, sistemleri veri ba\u011f\u0131ml\u0131l\u0131klar\u0131na g\u00f6re otomatik olarak paralelle\u015ftirmek ve her bir i\u015fin i\u015flemci \u00fczerindeki maliyetini (Metrics) takip edilebilir k\u0131lmakt\u0131r.</p>"},{"location":"API_References/INexusJobSystem_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>INexusJobSystem, y\u00fcksek performansl\u0131 sistem y\u00f6netimi i\u00e7in \u015fu yetenekleri zorunlu k\u0131lar:</p> <ul> <li>System Registration: <code>AddSystem()</code> ile kaydedilen her sistem, Reflection yoluyla ba\u011f\u0131ml\u0131l\u0131k analizine tabi tutulur. Bu, manuel \"Thread\" y\u00f6netimini ortadan kald\u0131r\u0131r.</li> <li>Dependency-Aware Execution: <code>Execute()</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, sistemler birbirini bloklamadan (Data Race \u00f6ncelikli) en uygun \u00e7ekirdeklerde paralel olarak tetiklenir.</li> <li>Performance Monitoring: <code>GetLastExecutionMetrics()</code> \u00fczerinden, her bir sistemin ka\u00e7 mikrosaniyede tamamland\u0131\u011f\u0131na dair bilimsel veri sa\u011flar.</li> <li>Thread Safety Abstraction: Geli\u015ftiricinin kilit (Lock/Mutex) mekanizmalar\u0131yla u\u011fra\u015fmas\u0131n\u0131 engeller; paralel g\u00fcvenli\u011fi [Read]/[Write] \u00f6znitelikleri \u00fczerinden aray\u00fcz seviyesinde sa\u011flar.</li> </ul>"},{"location":"API_References/INexusJobSystem_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Kay\u0131t: Sistemler oyunun ba\u015flang\u0131c\u0131nda <code>JobSystem</code>'e eklenir.</li> <li>S\u0131ralama: Sistemler aras\u0131 ba\u011f\u0131ml\u0131l\u0131k grafi\u011fi (DAG) olu\u015fturulur.</li> <li>Tetikleme: Ana d\u00f6ng\u00fc her karede <code>Execute()</code> metodunu \u00e7a\u011f\u0131r\u0131r.</li> <li>Analiz: Performans metrikleri toplanarak optimizasyon i\u00e7in geli\u015ftiriciye sunulur.</li> </ol>"},{"location":"API_References/INexusJobSystem_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Orchestrator \u0130\u015f par\u00e7ac\u0131klar\u0131n\u0131n ve sistemlerin koordinat\u00f6r\u00fc. Execution Metrics Bir i\u015fin \u00e7al\u0131\u015fma s\u00fcresi, CPU kullan\u0131m\u0131 ve gecikme verileri. Worker Thread Arka planda a\u011f\u0131r hesaplamalar\u0131 yapan yard\u0131mc\u0131 i\u015flemci kolu. Dispatcher \u0130\u015fleri uygun olan bo\u015f \u00e7ekirdeklere da\u011f\u0131tan birim."},{"location":"API_References/INexusJobSystem_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Main Thread Stalls: E\u011fer <code>Execute()</code> i\u00e7inde \u00e7ok a\u011f\u0131r ve paralel olmayan bir i\u015f varsa, oyunun kare h\u0131z\u0131 (FPS) d\u00fc\u015febilir.</li> <li>Ordering Dependencies: \u0130ki sistem ayn\u0131 veriye yaz\u0131yorsa, aray\u00fcz bunlar\u0131n s\u0131ras\u0131n\u0131 garanti eder ancak bu durum paralelli\u011fi k\u0131s\u0131tlar.</li> </ul>"},{"location":"API_References/INexusJobSystem_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public void SetupGame(INexusJobSystem jobSystem, Registry registry)\n{\n    // Sistemleri ekle\n    jobSystem.AddSystem(new PhysicsSystem());\n    jobSystem.AddSystem(new AISystem());\n\n    // Her karede \u00e7al\u0131\u015ft\u0131r\n    void OnUpdate() {\n        jobSystem.Execute();\n\n        // Performans\u0131 izle\n        var metrics = jobSystem.GetLastExecutionMetrics();\n        foreach(var m in metrics)\n            Console.WriteLine($\"{m.SystemName}: {m.DurationMs}ms\");\n    }\n}\n</code></pre>"},{"location":"API_References/INexusJobSystem_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>using System.Collections.Generic;\nnamespace Nexus.Core;\n\npublic interface INexusJobSystem\n{\n    void AddSystem(INexusSystem system);\n    void Execute();\n    List&lt;JobSystem.ExecutionMetrics&gt; GetLastExecutionMetrics();\n}\n</code></pre>"},{"location":"API_References/INexusJobSystem_tr/#nexus-optimization-tip-cycle-budgeting","title":"Nexus Optimization Tip: Cycle Budgeting","text":"<p><code>GetLastExecutionMetrics()</code> verilerini kullanarak, her kare i\u00e7in bir Saat D\u00f6ng\u00fcs\u00fc B\u00fct\u00e7esi (Cycle Budget) belirleyin. E\u011fer bir sistem b\u00fct\u00e7eyi a\u015f\u0131yorsa, onu daha k\u00fc\u00e7\u00fck par\u00e7alara (Jobs) b\u00f6lerek paralellikten maksimum fayda sa\u011flamay\u0131 hedefleyin.</p>"},{"location":"API_References/INexusRegistry_eng/","title":"Nexus Prime Architectural Manual: INexusRegistry (Entity &amp; Component Management Contract)","text":""},{"location":"API_References/INexusRegistry_eng/#1-introduction","title":"1. Introduction","text":"<p><code>INexusRegistry.cs</code> is the central management interface at the heart of the Nexus Prime ECS architecture. It defines the rule set that controls the lifecycle of all entities and determines how components will be stored in SparseSet repositories.</p> <p>The reason for this interface's existence is to provide a consistent, high-performance, and hardware-friendly API to the rest of the system (Systems, Bridges, UI). By implementing this contract, the <code>Registry</code> class guarantees the placement of data on raw memory (RAM) and its access speed.</p>"},{"location":"API_References/INexusRegistry_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>INexusRegistry mandates the following critical functions for ECS operations:</p> <ul> <li>Entity Lifecycle: Creation and deletion of entities are managed with <code>Create()</code> and <code>Destroy()</code> methods. By using a \"Versioned ID\" structure here, it is prevented that a new entity coming in place of a deleted one mixes with old data (dangling pointer).</li> <li>Pointer-Based Access: The <code>Get&lt;T&gt;</code> and <code>Add&lt;T&gt;</code> methods return a raw pointer (<code>T*</code>), which is the peak of performance, instead of a safe reference to the component. This reduces the C# copying cost to zero.</li> <li>Type-Erased Storage: Through the <code>ComponentSets</code> property, non-generic (<code>ISparseSet</code>) interface access is provided to all specialized component repositories. This makes it easy to perform batch processing across the system.</li> <li>O(1) Access: All Has, Get, Add, and Remove operations occur in constant time (O(1)) thanks to SparseSet math.</li> </ul>"},{"location":"API_References/INexusRegistry_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Entity Creation: When <code>Create()</code> is called, the <code>Registry</code> allocates an unmanaged index and increments the version number.</li> <li>Component Addition: When <code>Add&lt;T&gt;</code> is called, the corresponding <code>SparseSet&lt;T&gt;</code> is found and unmanaged memory area is allocated through the entity's index.</li> <li>Validation: Whether an <code>EntityId</code> still represents a valid object or a deleted waste is checked with <code>IsValid()</code>.</li> <li>Cleaning: When <code>Dispose()</code> is called, all SparseSets and unmanaged memory areas connected to the Registry are cleared from RAM.</li> </ol>"},{"location":"API_References/INexusRegistry_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Registry Central register of entities and components attached to them. Dangling Pointer A dangerous reference pointing to an invalid memory address. Versioned ID A counter tracking how many times an index has been recycled. Typed Storage Separate, optimized memory blocks for each component type."},{"location":"API_References/INexusRegistry_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Manual Disposal: <code>INexusRegistry</code> is an <code>IDisposable</code> object. If <code>Dispose()</code> is not called at the end of the program, an unmanaged memory leak occurs.</li> <li>Pointer Safety: When operating on data obtained via <code>T*</code>, this pointer remains invalid if the entity is deleted. Therefore, <code>IsValid</code> control is critical in intensive operations.</li> </ul>"},{"location":"API_References/INexusRegistry_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>public unsafe void ProcessCombat(INexusRegistry registry, EntityId player, EntityId enemy)\n{\n    if (registry.IsValid(player) &amp;&amp; registry.Has&lt;Health&gt;(player))\n    {\n        Health* hp = registry.Get&lt;Health&gt;(player);\n        hp-&gt;Amount -= 10;\n\n        if (hp-&gt;Amount &lt;= 0)\n            registry.Destroy(player);\n    }\n}\n</code></pre>"},{"location":"API_References/INexusRegistry_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Core;\n\npublic unsafe interface INexusRegistry : IDisposable\n{\n    EntityId Create();\n    void Destroy(EntityId entity);\n    bool IsValid(EntityId entity);\n\n    T* Add&lt;T&gt;(EntityId entity, T component = default) where T : unmanaged;\n    T* Get&lt;T&gt;(EntityId entity) where T : unmanaged;\n    bool Has&lt;T&gt;(EntityId entity) where T : unmanaged;\n    void Remove&lt;T&gt;(EntityId entity) where T : unmanaged;\n\n    SparseSet&lt;T&gt; GetSet&lt;T&gt;() where T : unmanaged;\n    IEnumerable&lt;ISparseSet&gt; ComponentSets { get; }\n}\n</code></pre>"},{"location":"API_References/INexusRegistry_eng/#nexus-optimization-tip-handle-reuse-safety","title":"Nexus Optimization Tip: Handle Reuse Safety","text":"<p>The 32-bit version field within the <code>EntityId</code> structure allows an ID to be recycled 4 billion times. Even if billions of entities are deleted in your game, this prevents old systems from accidentally writing data over new entities (Corruption) at the hardware level.</p>"},{"location":"API_References/INexusRegistry_tr/","title":"Nexus Prime Mimari Rehberi: INexusRegistry (Varl\u0131k ve Bile\u015fen Y\u00f6netim S\u00f6zle\u015fmesi)","text":""},{"location":"API_References/INexusRegistry_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>INexusRegistry.cs</code>, Nexus Prime ECS mimarisinin kalbi olan merkezi y\u00f6netim aray\u00fcz\u00fcd\u00fcr. T\u00fcm varl\u0131klar\u0131n (Entities) ya\u015fam d\u00f6ng\u00fcs\u00fcn\u00fc kontrol eden ve bile\u015fenlerin (Components) SparseSet depolar\u0131nda nas\u0131l saklanaca\u011f\u0131n\u0131 belirleyen kural setini tan\u0131mlar.</p> <p>Bu aray\u00fcz\u00fcn varl\u0131k sebebi, sistemin geri kalan\u0131na (Systems, Bridges, UI) tutarl\u0131, y\u00fcksek performansl\u0131 ve donan\u0131m dostu bir API sunmakt\u0131r. <code>Registry</code> s\u0131n\u0131f\u0131 bu s\u00f6zle\u015fmeyi uygulayarak, verinin ham bellek (RAM) \u00fczerindeki yerle\u015fimini ve eri\u015fim h\u0131z\u0131n\u0131 garanti eder.</p>"},{"location":"API_References/INexusRegistry_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>INexusRegistry, ECS operasyonlar\u0131 i\u00e7in \u015fu kritik fonksiyonlar\u0131 zorunlu k\u0131lar:</p> <ul> <li>Entity Lifecycle: <code>Create()</code> ve <code>Destroy()</code> metodlar\u0131 ile varl\u0131klar\u0131n olu\u015fturulmas\u0131 ve silinmesi y\u00f6netilir. Burada \"Versioned ID\" yap\u0131s\u0131 kullan\u0131larak, silinen bir varl\u0131\u011f\u0131n yerine gelen yeni varl\u0131\u011f\u0131n eski verilerle kar\u0131\u015fmas\u0131 (dangling pointer) \u00f6nlenir.</li> <li>Pointer-Based Access: <code>Get&lt;T&gt;</code> ve <code>Add&lt;T&gt;</code> metodlar\u0131, bile\u015fene g\u00fcvenli (safe) bir referans yerine, performans\u0131n zirvesi olan bir ham pointer (<code>T*</code>) d\u00f6ner. Bu, C# kopyalama maliyetini s\u0131f\u0131ra indirir.</li> <li>Type-Erased Storage: <code>ComponentSets</code> \u00f6zelli\u011fi \u00fczerinden, t\u00fcm \u00f6zelle\u015fmi\u015f bile\u015fen depolar\u0131na jenerik olmayan bir (<code>ISparseSet</code>) aray\u00fczle eri\u015fim sa\u011flan\u0131r. Bu, sistem genelinde toplu i\u015flem yapmay\u0131 kolayla\u015ft\u0131r\u0131r.</li> <li>O(1) Access: Has, Get, Add ve Remove operasyonlar\u0131n\u0131n tamam\u0131 SparseSet matemati\u011fi sayesinde sabit zamanda (O(1)) ger\u00e7ekle\u015fir.</li> </ul>"},{"location":"API_References/INexusRegistry_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Varl\u0131k Olu\u015fturma: <code>Create()</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, <code>Registry</code> unmanaged bir indeks ay\u0131r\u0131r ve versiyon numaras\u0131n\u0131 art\u0131r\u0131r.</li> <li>Bile\u015fen Ekleme: <code>Add&lt;T&gt;</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, ilgili <code>SparseSet&lt;T&gt;</code> bulunur ve varl\u0131\u011f\u0131n indeksi \u00fczerinden unmanaged bellek alan\u0131 tahsis edilir.</li> <li>Do\u011frulama: <code>IsValid()</code> ile bir <code>EntityId</code>'nin hala ge\u00e7erli bir nesneyi mi yoksa silinmi\u015f bir at\u0131\u011f\u0131 m\u0131 temsil etti\u011fi kontrol edilir.</li> <li>Temizlik: <code>Dispose()</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, Registry'ye ba\u011fl\u0131 t\u00fcm SparseSet'ler ve unmanaged bellek alanlar\u0131 RAM'den temizlenir.</li> </ol>"},{"location":"API_References/INexusRegistry_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Registry Varl\u0131klar\u0131n ve onlara ba\u011fl\u0131 bile\u015fenlerin merkezi kay\u0131t defteri. Dangling Pointer Ge\u00e7ersiz bir bellek adresini i\u015faret eden tehlikeli referans. Versioned ID Bir indeksin ka\u00e7 kez geri d\u00f6n\u00fc\u015ft\u00fcr\u00fcld\u00fc\u011f\u00fcn\u00fc (recycle) takip eden saya\u00e7. Typed Storage Her bile\u015fen tipi i\u00e7in ayr\u0131, optimize edilmi\u015f bellek bloklar\u0131."},{"location":"API_References/INexusRegistry_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Manual Disposal: <code>INexusRegistry</code> bir <code>IDisposable</code> nesnesidir. E\u011fer program sonunda <code>Dispose()</code> edilmezse, unmanaged bellek s\u0131z\u0131nt\u0131s\u0131 (leak) olu\u015fur.</li> <li>Pointer Safety: <code>T*</code> \u00fczerinden al\u0131nan veri \u00fczerinde i\u015flem yaparken, varl\u0131\u011f\u0131n silinmesi durumunda bu pointer ge\u00e7ersiz kal\u0131r. Bu y\u00fczden yo\u011fun i\u015flemlerde <code>IsValid</code> kontrol\u00fc kritiktir.</li> </ul>"},{"location":"API_References/INexusRegistry_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public unsafe void ProcessCombat(INexusRegistry registry, EntityId player, EntityId enemy)\n{\n    if (registry.IsValid(player) &amp;&amp; registry.Has&lt;Health&gt;(player))\n    {\n        Health* hp = registry.Get&lt;Health&gt;(player);\n        hp-&gt;Amount -= 10;\n\n        if (hp-&gt;Amount &lt;= 0)\n            registry.Destroy(player);\n    }\n}\n</code></pre>"},{"location":"API_References/INexusRegistry_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Core;\n\npublic unsafe interface INexusRegistry : IDisposable\n{\n    EntityId Create();\n    void Destroy(EntityId entity);\n    bool IsValid(EntityId entity);\n\n    T* Add&lt;T&gt;(EntityId entity, T component = default) where T : unmanaged;\n    T* Get&lt;T&gt;(EntityId entity) where T : unmanaged;\n    bool Has&lt;T&gt;(EntityId entity) where T : unmanaged;\n    void Remove&lt;T&gt;(EntityId entity) where T : unmanaged;\n\n    SparseSet&lt;T&gt; GetSet&lt;T&gt;() where T : unmanaged;\n    IEnumerable&lt;ISparseSet&gt; ComponentSets { get; }\n}\n</code></pre>"},{"location":"API_References/INexusRegistry_tr/#nexus-optimization-tip-handle-reuse-safety","title":"Nexus Optimization Tip: Handle Reuse Safety","text":"<p><code>EntityId</code> yap\u0131s\u0131 i\u00e7indeki 32-bit versiyon alan\u0131, bir ID'nin 4 milyar kez geri d\u00f6n\u00fc\u015ft\u00fcr\u00fclmesine olanak tan\u0131r. Bu, oyununuzda milyarlarca varl\u0131k silinse bile, eski sistemlerin yanl\u0131\u015fl\u0131kla yeni varl\u0131klar\u0131n \u00fczerine veri yazmas\u0131n\u0131 (Corruption) donan\u0131m seviyesinde engeller.</p>"},{"location":"API_References/INexusSystem_eng/","title":"Nexus Prime Architectural Manual: INexusSystem &amp; Core Attributes (Logic &amp; Dependency Management)","text":""},{"location":"API_References/INexusSystem_eng/#1-introduction","title":"1. Introduction","text":"<p>In the Nexus Prime ecosystem, \"Systems\" (<code>INexusSystem</code>) are state-less logic containers independent of data. Unlike \"Manager\" classes in traditional OOP architecture, systems do not store data within themselves; instead, they rule over component arrays on the <code>Registry</code>.</p> <p>The reason for this interface and its accompanying <code>Attributes</code> is to pre-determine which system will access which data in a multi-threaded execution environment and eliminate the risk of Data Race at the hardware level.</p>"},{"location":"API_References/INexusSystem_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The system architecture uses the following metadata tags for <code>JobSystem</code> orchestration:</p> <ul> <li>[Read] Attribute: Specifies that a system will only read a component type. Multiple systems CAN READ the same component at the same time. This ensures maximum parallelism across CPU cores.</li> <li>[Write] Attribute: Specifies that a system will modify data (exclusive access). While one system is WRITING to a component, no other system can touch that component.</li> <li>[Inject] Attribute: A Dependency Injection (DI) mechanism. The <code>JobSystem</code> automatically populates this field with central tools like <code>Registry</code> or <code>EntityCommandBuffer</code> when the system is initialized.</li> <li>Stateless Design: Classes implementing <code>INexusSystem</code> should not store state. All state is stored in components, allowing systems to be safely executed on any core.</li> </ul>"},{"location":"API_References/INexusSystem_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Definition: The developer implements the <code>INexusSystem</code> interface and marks the required components with <code>[Read]</code> or <code>[Write]</code>.</li> <li>Analysis: When <code>JobSystem.AddSystem</code> is called, these attributes are scanned via Reflection.</li> <li>Scheduling: A dependency matrix is created (Kahn's Algorithm). Systems with write conflicts are separated into different layers.</li> <li>Execution: The <code>Execute()</code> method is triggered on the most available core of the processor.</li> </ol>"},{"location":"API_References/INexusSystem_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Stateless A structure that does not carry data from previous frames, performing calculations from scratch on every call. Dependency Injection The automatic provision of references required by an object from the outside. Exclusive Access A situation where only a single process can access a resource at the same time. Metadata Tagging Auxiliary tags (Attributes) that change the way code operates."},{"location":"API_References/INexusSystem_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Write Over-use: Marking everything as <code>[Write]</code> prevents systems from running in parallel and reduces performance to single-thread levels.</li> <li>Thread Safety: If a local variable (field) is updated within the system, it must be ensured that this variable is thread-safe (though in an ideal ECS, this should not be done).</li> </ul>"},{"location":"API_References/INexusSystem_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>public class GravitySystem : INexusSystem\n{\n    [Inject] private Registry _registry;\n    [Read] private float _gravityForce = -9.81f;\n\n    // We will write to Position component, read Velocity\n    [Write] private Position* _pos;\n    [Read] private Velocity* _vel;\n\n    public void Execute()\n    {\n        // ... Gravity logic ...\n    }\n}\n</code></pre>"},{"location":"API_References/INexusSystem_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Core;\n\npublic interface INexusSystem\n{\n    void Execute();\n}\n\n[AttributeUsage(AttributeTargets.Field)]\npublic class ReadAttribute : Attribute { }\n\n[AttributeUsage(AttributeTargets.Field)]\npublic class WriteAttribute : Attribute { }\n\n[AttributeUsage(AttributeTargets.Field)]\npublic class InjectAttribute : Attribute { }\n</code></pre>"},{"location":"API_References/INexusSystem_eng/#nexus-optimization-tip-parallelism-maximization","title":"Nexus Optimization Tip: Parallelism Maximization","text":"<p>You should use [Read] instead of <code>[Write]</code> in every possible situation. The processor can \"Read\" simultaneously on 100 different cores, but a single \"Write\" operation can stall the entire pipeline. Correct attribute usage can increase your parallelism efficiency by 300-400%.</p>"},{"location":"API_References/INexusSystem_tr/","title":"Nexus Prime Mimari Rehberi: INexusSystem &amp; Core Attributes (Mant\u0131k ve Ba\u011f\u0131ml\u0131l\u0131k Y\u00f6netimi)","text":""},{"location":"API_References/INexusSystem_tr/#1-giris","title":"1. Giri\u015f","text":"<p>Nexus Prime ekosisteminde \"Sistemler\" (<code>INexusSystem</code>), veriden ba\u011f\u0131ms\u0131z, saf mant\u0131k konteynerleridir. Geleneksel OOP mimarisindeki \"Manager\" s\u0131n\u0131flar\u0131n\u0131n aksine, sistemler kendi i\u00e7lerinde veri saklamazlar; bunun yerine <code>Registry</code> \u00fczerindeki bile\u015fen dizilerine h\u00fckmederler.</p> <p>Bu aray\u00fcz\u00fcn ve beraberindeki \u00f6zniteliklerin (<code>Attributes</code>) varl\u0131k sebebi, \u00e7ok \u00e7ekirdekli (multi-threaded) \u00e7al\u0131\u015fma ortam\u0131nda hangi sistemin hangi veriye eri\u015fece\u011fini \u00f6nceden belirlemek ve Data Race (Veri Yar\u0131\u015f\u0131) riskini donan\u0131m seviyesinde bertaraf etmektir.</p>"},{"location":"API_References/INexusSystem_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Sistem mimarisi, <code>JobSystem</code> orkestrasyonu i\u00e7in \u015fu meta-veri etiketlerini kullan\u0131r:</p> <ul> <li>[Read] Attribute: Bir sistemin bir bile\u015fen tipini sadece okuyaca\u011f\u0131n\u0131 belirtir. Birden fazla sistem ayn\u0131 anda ayn\u0131 bile\u015feni OKUYAB\u0130L\u0130R. Bu, CPU \u00e7ekirdekleri aras\u0131nda maksimum paralellik sa\u011flar.</li> <li>[Write] Attribute: Bir sistemin veriyi de\u011fi\u015ftirece\u011fini (exclusive access) belirtir. Bir bile\u015fene YAZAN bir sistem varken, ba\u015fka hi\u00e7bir sistem o bile\u015fene dokunamaz.</li> <li>[Inject] Attribute: Ba\u011f\u0131ml\u0131l\u0131k Enjeksiyonu (DI) mekanizmas\u0131d\u0131r. <code>JobSystem</code>, sistem ilklendirilirken <code>Registry</code> veya <code>EntityCommandBuffer</code> gibi merkezi ara\u00e7lar\u0131 bu alana otomatik olarak enjekte eder.</li> <li>Stateless Design: <code>INexusSystem</code> uygulayan s\u0131n\u0131flar durum saklamamal\u0131d\u0131r. T\u00fcm durum (state) bile\u015fenlerde saklan\u0131r, bu da sistemlerin herhangi bir \u00e7ekirdekte g\u00fcvenle \u00e7al\u0131\u015ft\u0131r\u0131lmas\u0131n\u0131 sa\u011flar.</li> </ul>"},{"location":"API_References/INexusSystem_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tan\u0131mlama: Geli\u015ftirici, <code>INexusSystem</code> aray\u00fcz\u00fcn\u00fc uygular ve ihtiya\u00e7 duydu\u011fu bile\u015fenleri <code>[Read]</code> veya <code>[Write]</code> ile i\u015faretler.</li> <li>Analiz: <code>JobSystem.AddSystem</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, Reflection ile bu \u00f6znitelikler taran\u0131r.</li> <li>\u00c7izelgeleme: Ba\u011f\u0131ml\u0131l\u0131k matrisi olu\u015fturulur (Kahn Algoritmas\u0131). Yazma \u00e7ak\u0131\u015fmas\u0131 olan sistemler farkl\u0131 katmanlara (layers) ayr\u0131l\u0131r.</li> <li>Y\u00fcr\u00fctme: <code>Execute()</code> metodu, i\u015flemcinin uygun olan en bo\u015f \u00e7ekirde\u011finde tetiklenir.</li> </ol>"},{"location":"API_References/INexusSystem_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Stateless \u00d6nceki karelerden veri ta\u015f\u0131mayan, her \u00e7a\u011fr\u0131da s\u0131f\u0131rdan hesaplama yapan yap\u0131. Dependency Injection Bir nesnenin ihtiya\u00e7 duydu\u011fu referanslar\u0131n d\u0131\u015far\u0131dan otomatik sa\u011flanmas\u0131. Exclusive Access Bir kayna\u011fa ayn\u0131 anda sadece tek bir i\u015flemin eri\u015febilmesi durumu. Metadata Tagging Kodun \u00e7al\u0131\u015fma \u015feklini de\u011fi\u015ftiren yard\u0131mc\u0131 etiketler (Attributes)."},{"location":"API_References/INexusSystem_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Write Over-use: Her \u015feyi <code>[Write]</code> olarak i\u015faretlemek, sistemlerin paralel \u00e7al\u0131\u015fmas\u0131n\u0131 engeller ve performans\u0131 tek \u00e7ekirdek (Single-thread) seviyesine d\u00fc\u015f\u00fcr\u00fcr.</li> <li>Thread Safety: E\u011fer sistem i\u00e7inde yerel bir de\u011fi\u015fken (field) g\u00fcncelleniyorsa, bu de\u011fi\u015fkenin thread-safe oldu\u011fundan emin olunmal\u0131d\u0131r (Ancak ideal ECS'de bu yap\u0131lmamal\u0131d\u0131r).</li> </ul>"},{"location":"API_References/INexusSystem_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public class GravitySystem : INexusSystem\n{\n    [Inject] private Registry _registry;\n    [Read] private float _gravityForce = -9.81f;\n\n    // Position bile\u015fenine yazaca\u011f\u0131z, Velocity'yi okuyaca\u011f\u0131z\n    [Write] private Position* _pos;\n    [Read] private Velocity* _vel;\n\n    public void Execute()\n    {\n        // ... Yer\u00e7ekimi mant\u0131\u011f\u0131 ...\n    }\n}\n</code></pre>"},{"location":"API_References/INexusSystem_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Core;\n\npublic interface INexusSystem\n{\n    void Execute();\n}\n\n[AttributeUsage(AttributeTargets.Field)]\npublic class ReadAttribute : Attribute { }\n\n[AttributeUsage(AttributeTargets.Field)]\npublic class WriteAttribute : Attribute { }\n\n[AttributeUsage(AttributeTargets.Field)]\npublic class InjectAttribute : Attribute { }\n</code></pre>"},{"location":"API_References/INexusSystem_tr/#nexus-optimization-tip-parallelism-maximization","title":"Nexus Optimization Tip: Parallelism Maximization","text":"<p>M\u00fcmk\u00fcn olan her durumda <code>[Write]</code> yerine [Read] kullanmal\u0131s\u0131n\u0131z. \u0130\u015flemci, 100 farkl\u0131 \u00e7ekirdekte ayn\u0131 anda \"Okuma\" yapabilir, ancak tek bir \"Yazma\" i\u015flemi t\u00fcm boru hatt\u0131n\u0131 (pipeline) durdurabilir. Do\u011fru \u00f6znitelik kullan\u0131m\u0131, oyununuzun paralellik verimlili\u011fini %300-400 oran\u0131nda art\u0131rabilir.</p>"},{"location":"API_References/ISparseSet_eng/","title":"Nexus Prime Architectural Manual: ISparseSet (Storage Layer Abstraction)","text":""},{"location":"API_References/ISparseSet_eng/#1-introduction","title":"1. Introduction","text":"<p><code>ISparseSet</code> is the non-generic core storage interface of the Nexus Prime framework. In the underlying ECS architecture, while a separate tightly-packed generic <code>SparseSet&lt;T&gt;</code> class is instantiated for each strict component type, central orchestration units like <code>Registry</code> and the global <code>JobSystem</code> must uniformly manage these disparate memory repositories without knowing their generic forms.</p> <p>The reason for this interface's existence is to permit processing over raw byte blocks via unmanaged pointers. This allows functions spanning SIMD filtering queries, multi-threaded task deployments, and mass memory clearing operations to interact directly with hardware without incurring the type-checking cost (<code>typeof(T)</code>) associated with managed abstractions.</p>"},{"location":"API_References/ISparseSet_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p><code>ISparseSet</code> formalizes the following \"Raw Access\" capabilities enabling raw hardware-level data mutability.</p> <pre><code>graph TD\n    subgraph Raw_Type_Erasure_Pipeline\n        A{Registry: Component Sets} --&gt;|Array Index Lookup| B(ISparseSet Pointer)\n        B --&gt;|Fetch Bitmask| C[GetRawPresenceBits: void*]\n        B --&gt;|Fetch Payload| D[GetRawDense: void*]\n\n        C -.-&gt;|AVX2 Vectorization| E{SIMD Execution Node}\n        D -.-&gt;|Memory Offset Casting| E\n    end\n    style C fill:#ddffdd\n    style D fill:#ddffff\n    style E fill:#ffccdd</code></pre>"},{"location":"API_References/ISparseSet_eng/#3-full-source-implementation-line-by-line-explanation","title":"3. Full Source Implementation &amp; Line-By-Line Explanation","text":"<p>Here is the naked C# prototype exposing bare-metal memory interfaces.</p> <pre><code>// Source Code\nnamespace Nexus.Core;\n\npublic interface ISparseSet : IDisposable\n{\n    int Count { get; }\n    int Capacity { get; }\n    EntityId GetEntity(int denseIndex);\n\n    // Low-level memory access\n    unsafe void* GetRawDense(out int count);\n    unsafe void* GetRawSparse(out int capacity);\n    unsafe void* GetRawDirtyBits(out int count);\n    unsafe void* GetRawPresenceBits(out int count);\n    unsafe void** GetRawChunks(out int count);\n\n    bool Has(EntityId entity);\n    void ClearAllDirty();\n}\n</code></pre>"},{"location":"API_References/ISparseSet_eng/#line-by-line-breakdown","title":"Line-By-Line Breakdown","text":"<ul> <li><code>public interface ISparseSet : IDisposable</code>: (Line 4) Forces any structural inheritor to definitively un-allocate internal unmanaged byte buffers (<code>NativeMemory.Free</code>), since the Managed Garbage Extractor is physically blind.</li> <li><code>int Count</code> &amp; <code>int Capacity</code>: (Lines 6-7) Fast constant bounds tracking the dense contiguous hardware items currently instantiated verses the maximum memory blocks provisioned.</li> <li><code>EntityId GetEntity(int denseIndex)</code>: (Line 8) Fetches the overarching identifier linking back the strict linearly iterated index bounds to its specific runtime spatial object reference.</li> <li><code>unsafe void* GetRawDense(out int count)</code>: (Line 11) Strips the generic payload types apart and yields the core binary contiguous pointer vector (dense byte structure).</li> <li><code>unsafe void* GetRawSparse(out int capacity)</code>: (Line 12) Exposes the mapping tables arrays linking unmanaged Entity ID's indirectly to contiguous physical RAM arrays.</li> <li><code>unsafe void* GetRawDirtyBits(out int count)</code>: (Line 13) Yields the hardware pointers masking modification history. Essential for the <code>Sync / Bridge / Push / Pull</code> modules.</li> <li><code>unsafe void* GetRawPresenceBits(out int count)</code>: (Line 14) Forms the architecture base for rapid Vector operations tracking logical physical presence (\\(1\\) for exists, \\(0\\) for free-space).</li> <li><code>unsafe void** GetRawChunks(out int count)</code>: (Line 15) Distributes the paginated arrays linking multiple disjointed physical RAM allocations (\\(16 KB \\ pages\\)). Ensures physical pointers never relocate even during dynamic list length expansions.</li> <li><code>void ClearAllDirty()</code>: (Line 18) Resets all modifications for physical alignment to a state of equilibrium synchronously over the bitmask maps.</li> </ul>"},{"location":"API_References/ISparseSet_eng/#4-usage-scenario-best-practices","title":"4. Usage Scenario &amp; Best Practices","text":"<pre><code>// Scenario: Writing a high-speed reset utility parsing completely unknown structs.\n\n// Type-independent procedural memory sanitization via ISparseSet\npublic unsafe void ClearAll(ISparseSet set)\n{\n    int count;\n    uint* dirtyBits = (uint*)set.GetRawDirtyBits(out count);\n\n    // Unmanaged high-speed scalar byte clearance loop\n    for (int i = 0; i &lt; count; i++)\n    {\n        dirtyBits[i] = 0;\n    }\n}\n</code></pre> <p>[!TIP] Nexus Optimization Tip: Chunk Stability A prominent risk in native memory arrays is \"drift\"\u2014where capacity resizing dynamically shifts the underlying array to a new physical location, instantly crashing executing jobs operating atop the outdated pointer bounds. However, pointers acquired via the <code>GetRawChunks</code> method are structurally segmented; they remain perfectly \\(100\\%\\) immune to physical drift regardless of growth owing to the segmented <code>ChunkedBuffer</code> mathematics. Asynchronous workers operate with total security.</p>"},{"location":"API_References/ISparseSet_tr/","title":"Nexus Prime Mimari Rehberi: ISparseSet (Depolama Katman\u0131 Soyutlamas\u0131)","text":""},{"location":"API_References/ISparseSet_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>ISparseSet</code>, Nexus Prime altyap\u0131s\u0131n\u0131n jenerik olmayan (non-generic) birincil depolama aray\u00fcz\u00fcd\u00fcr. Temeldeki ECS mimarisinde, her kesin bile\u015fen tipi i\u00e7in birbirine s\u0131k\u0131 s\u0131k\u0131ya ba\u011fl\u0131 ayr\u0131 bir jenerik <code>SparseSet&lt;T&gt;</code> s\u0131n\u0131f\u0131 olu\u015fturulurken; <code>Registry</code> ve k\u00fcresel <code>JobSystem</code> gibi merkezi orkestrasyon birimlerinin, bu farkl\u0131 bellek depolar\u0131n\u0131 kendi orijinal genelle\u015ftirilmi\u015f formlar\u0131n\u0131 bilmeksizin tek tip olarak y\u00f6netebilmesi gerekir.</p> <p>Bu aray\u00fcz\u00fcn varl\u0131k sebebi; SIMD sorgular\u0131nda, \u00e7oklu i\u015f par\u00e7ac\u0131\u011f\u0131 (multi-thread) da\u011f\u0131t\u0131mlar\u0131nda ve kitlesel bellek temizleme operasyonlar\u0131nda as\u0131l veri yap\u0131s\u0131n\u0131 (<code>typeof(T)</code>) kontrol etme maliyetinden ka\u00e7\u0131narak i\u015flemleri do\u011frudan ham bayt bloklar\u0131 (raw byte blocks) ve i\u015faret\u00e7iler (pointers) kullanarak y\u00fcr\u00fctmektir.</p>"},{"location":"API_References/ISparseSet_tr/#2-teknik-analiz-ve-matematiksel-icyuzu","title":"2. Teknik Analiz ve Matematiksel \u0130\u00e7y\u00fcz\u00fc","text":"<p><code>ISparseSet</code>, donan\u0131m seviyesinde veri d\u00fczenlemesi ve ham bellek manip\u00fclasyonu sa\u011flayan saf yetenekleri standartla\u015ft\u0131r\u0131r.</p> <pre><code>graph TD\n    subgraph Ham_Tip_Silme_Hatti\n        A{Registry: Bilesen Setleri} --&gt;|Dizi Indeks Aramasi| B(ISparseSet Pointer)\n        B --&gt;|Bitmaske Getir| C[GetRawPresenceBits: void*]\n        B --&gt;|Ana Veri Blogunu Getir| D[GetRawDense: void*]\n\n        C -.-&gt;|AVX2 Vektorlestirme| E{SIMD Yurutme Dugumu}\n        D -.-&gt;|Bellek Ofset Hesaplamasi| E\n    end\n    style C fill:#ddffdd\n    style D fill:#ddffff\n    style E fill:#ffccdd</code></pre>"},{"location":"API_References/ISparseSet_tr/#3-tam-kaynak-kod-uygulamas-ve-satr-satr-acklama","title":"3. Tam Kaynak Kod Uygulamas\u0131 ve Sat\u0131r Sat\u0131r A\u00e7\u0131klama","text":"<p>\u0130\u015fte C# ile donan\u0131m s\u0131n\u0131nt\u0131s\u0131n\u0131 en aza indiren korunakl\u0131 API imzas\u0131 haritas\u0131.</p> <pre><code>// Kaynak Kod (Source Code)\nnamespace Nexus.Core;\n\npublic interface ISparseSet : IDisposable\n{\n    int Count { get; }\n    int Capacity { get; }\n    EntityId GetEntity(int denseIndex);\n\n    // Low-level memory access\n    unsafe void* GetRawDense(out int count);\n    unsafe void* GetRawSparse(out int capacity);\n    unsafe void* GetRawDirtyBits(out int count);\n    unsafe void* GetRawPresenceBits(out int count);\n    unsafe void** GetRawChunks(out int count);\n\n    bool Has(EntityId entity);\n    void ClearAllDirty();\n}\n</code></pre>"},{"location":"API_References/ISparseSet_tr/#satr-satr-kod-acklamas-line-by-line-breakdown","title":"Sat\u0131r Sat\u0131r Kod A\u00e7\u0131klamas\u0131 (Line-By-Line Breakdown)","text":"<ul> <li><code>public interface ISparseSet : IDisposable</code>: (Sat\u0131r 4) Fiziksel yap\u0131y\u0131 miras alan s\u0131n\u0131f\u0131 son a\u015famada y\u00f6netilmeyen <code>NativeMemory</code> tahsis bloklar\u0131n\u0131 <code>Free</code> ile yok etmesi (temizlemesi) i\u00e7in kesin zorunlu k\u0131lan g\u00fcvenlik bildirimi. (\u00c7\u00fcnk\u00fc C# Garbage Collector bu belle\u011fi g\u00f6remez).</li> <li><code>int Count</code> &amp; <code>int Capacity</code>: (Sat\u0131rlar 6-7) Anl\u0131k olarak sistemde yer alan ve s\u0131k\u0131\u015ft\u0131r\u0131larak bas\u0131lan mevcut dizin miktar\u0131 ile fiziksek RAM miktar\u0131n\u0131n \u00fcst blok donan\u0131m limitini kar\u015f\u0131la\u015ft\u0131ran h\u0131zl\u0131 de\u011fi\u015fkenler.</li> <li><code>EntityId GetEntity(int denseIndex)</code>: (Sat\u0131r 8) Skaler ve homojen y\u00fcr\u00fcy\u00fc\u015f s\u0131ras\u0131nda do\u011frusal bir hedefte yer edinen fiziksel endeks numaras\u0131n\u0131n (Index), uzaysal nesne kimli\u011fini (EntityId) yans\u0131tan metot.</li> <li><code>unsafe void* GetRawDense(out int count)</code>: (Sat\u0131r 11) Jenerik yap\u0131 k\u0131s\u0131tlamalar\u0131n\u0131 by-pass edip fiziksel donan\u0131m\u0131 aral\u0131ks\u0131z dolduran mutlak bayt referans i\u015faret\u00e7isinin ad\u0131n\u0131 geri d\u00f6nd\u00fcrd\u00fc\u011f\u00fc yerdir.</li> <li><code>unsafe void* GetRawSparse(out int capacity)</code>: (Sat\u0131r 12) Entity ID kimlik numaralar\u0131n\u0131, yo\u011fun dizi (dense) indekslerine tek seferlik asimile eden ikincil Sparse tablosuna pencere a\u00e7ar.</li> <li><code>unsafe void* GetRawDirtyBits(out int count)</code>: (Sat\u0131r 13) Kay\u0131t edilebilir eylemler haritas\u0131nda son okunan \u00e7er\u00e7eveden beri organik olarak de\u011fi\u015fim ge\u00e7irip flag (bayrak) yakan bit maskelendirme referans\u0131d\u0131r. Unity Bridge'e sinyal yollar.</li> <li><code>unsafe void* GetRawPresenceBits(out int count)</code>: (Sat\u0131r 14) Verinin \\(0\\) k\u0131s\u0131mlar\u0131nda olmad\u0131\u011f\u0131/bulunmad\u0131\u011f\u0131 ve mutlak \\(1\\) k\u0131s\u0131mlar\u0131nda bulundu\u011fu Vector matematik algoritmalar\u0131n\u0131n veri dizisine ula\u015fmas\u0131 amac\u0131 g\u00fcder.</li> <li><code>unsafe void** GetRawChunks(out int count)</code>: (Sat\u0131r 15) Sayfalama (<code>16KB</code> alt paylara b\u00f6l\u00fcnme) blok dizisinin adres havuzuna par\u00e7a tahsisli \u00e7ift i\u015faret\u00e7i (<code>pointer to pointer</code>) yollar.</li> <li><code>void ClearAllDirty()</code>: (Sat\u0131r 18) Modifikasyon d\u00f6ng\u00fcs\u00fc bitti\u011fi vakit bellek blo\u011funun izasyon maskesindeki bayraklar\u0131n t\u00fcm iterasyonunu an\u0131nda silme (equilibrium durumu) eylemini garantiler.</li> </ul>"},{"location":"API_References/ISparseSet_tr/#4-kullanm-senaryosu-ve-en-iyi-uygulamalar","title":"4. Kullan\u0131m Senaryosu ve En \u0130yi Uygulamalar","text":"<pre><code>// Senaryo: Hi\u00e7bir bile\u015fenin t\u00fcr\u00fcn\u00fc/tipini bilmeden, t\u00fcm belle\u011fi taray\u0131c\u0131 bir analiz/reset arac\u0131 yazmak.\n\n// ISparseSet uzerinden tip-bagimsiz donanimsal h\u0131zl\u0131 bellek temizligi\npublic unsafe void ClearAll(ISparseSet set)\n{\n    int count;\n    uint* dirtyBits = (uint*)set.GetRawDirtyBits(out count);\n\n    // Tipe bagimlilik olmadan calisan lineer ham byte blok sifirlama dongusu\n    for (int i = 0; i &lt; count; i++)\n    {\n        dirtyBits[i] = 0;\n    }\n}\n</code></pre> <p>[!TIP] Nexus Optimization Tip: Chunk Stability (Par\u00e7a Kararl\u0131l\u0131\u011f\u0131) Geleneksel C# dinamik dizi tiplerinde bellek uzat\u0131l\u0131rken (Resize) dizi silinip daha b\u00fcy\u00fck bir blok \u015feklinde fiziken ba\u015fka yere ta\u015f\u0131nabilir. Bu durumda \"Bellek Kaymas\u0131 (Drift)\" engellenemez, ve o s\u0131rada di\u011fer CPU \u00e7ekirdeklari orada okuma yap\u0131yorsa motor an\u0131nda \u00e7\u00f6ker. Fakat, par\u00e7asal <code>ChunkedBuffer</code> mimarisine sahip olan ISparseSet s\u0131n\u0131flar\u0131nda kapasite geni\u015flerse bile <code>GetRawChunks</code> arac\u0131l\u0131\u011f\u0131yla d\u00f6nen mevcut par\u00e7ac\u0131k pointer adresleri sonsuza dek fiziksel olarak yerine m\u0131hlanm\u0131\u015ft\u0131r. Paralel asenkron thread mant\u0131\u011f\u0131 hi\u00e7bir kilitlenme korkusu ya\u015famadan tam performans okuma y\u00fcr\u00fct\u00fcr.</p>"},{"location":"API_References/JobSystem_eng/","title":"Nexus Prime Architectural Manual: JobSystem (Thread Orchestrator)","text":""},{"location":"API_References/JobSystem_eng/#1-introduction","title":"1. Introduction","text":"<p><code>JobSystem.cs</code> is the \"Multi-threaded Engine\" of Nexus Prime. Even though modern processors have 8, 16, or more cores, efficient use of these cores is difficult due to \"Data Dependency\". If two systems that both read and write the same data run simultaneously, data corruption (a race condition) is inevitable.</p> <p>The reason for the JobSystem's existence is to analyze the dependencies between systems, separate them into safe Layers, and run the systems within each layer in parallel on all of the processor's cores.</p>"},{"location":"API_References/JobSystem_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The JobSystem utilizes the following advanced techniques for parallel execution safety:</p> <ul> <li>Dependency Graph Analysis (Kahn's Algorithm): Analyzes Read/Write conflicts between systems. If System A writes to Position and System B reads Position; System B can only run after System A is finished.</li> <li>Layered Scheduling: Systems that have no mutual dependency are assigned to the same layer. These layers are executed concurrently via <code>Parallel.ForEach</code>.</li> <li>Concurrent Execution Monitoring: Records the execution time (metrics) of each system using <code>ConcurrentDictionary</code>.</li> <li>Reflection-Based Dependency Extraction: Scans the <code>[Read]</code> and <code>[Write]</code> attributes on systems to extract an automatic dependency map at runtime.</li> </ul>"},{"location":"API_References/JobSystem_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Registration (<code>AddSystem</code>): When a new system is added, the component types it uses (Reads/Writes) are detected.</li> <li>Layer Construction (<code>RebuildLayers</code>): Systems are grouped using a variant of Kahn's algorithm.<ul> <li>Layer 1: Systems with no dependencies.</li> <li>Layer 2: Those dependent only on data in Layer 1.</li> </ul> </li> <li>Execution (<code>Execute</code>): Layers are run in sequence (Sequentially). Each individual system within each layer is run in parallel (In Parallel).</li> <li>Metric Analysis: The number of milliseconds spent by each system is recorded for profilers.</li> </ol>"},{"location":"API_References/JobSystem_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Race Condition An error that occurs when two or more threads access the same data at the same time. Dependency Graph A mathematical node structure showing the dependency of tasks on each other. Kahn's Algorithm An algorithm for arranging nodes in a graph into a linear and layered order. Throughput The amount of work done per unit of time (Processing capacity)."},{"location":"API_References/JobSystem_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Circular Dependency: If System A depends on System B and System B depends on System A, the graph locks up. Nexus detects this situation and solves it with a fallback mechanism.</li> <li>Parallel Overhead: Creating parallel threads for very small tasks can take longer than the task itself. This situation requires \"Grain Size\" optimization.</li> </ul>"},{"location":"API_References/JobSystem_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>var jobSystem = new JobSystem(registry);\n\n// Add systems (Dependencies are automatically resolved)\njobSystem.AddSystem(new MovementSystem());\njobSystem.AddSystem(new CollisionSystem());\n\n// Run every frame\nvoid Update() {\n    jobSystem.Execute();\n}\n</code></pre>"},{"location":"API_References/JobSystem_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>using System.Collections.Concurrent;\nusing System.Threading.Tasks;\nnamespace Nexus.Core;\n\npublic class JobSystem : INexusJobSystem\n{\n    private readonly List&lt;SystemNode&gt; _nodes = new();\n    private readonly List&lt;List&lt;SystemNode&gt;&gt; _layers = new();\n\n    public void RebuildLayers()\n    {\n        _layers.Clear();\n        // 1. Build Adjacency List based on Read/Write conflicts\n        // 2. Group into layers using Kahn's algorithm\n    }\n\n    public void Execute()\n    {\n        foreach (var layer in _layers) {\n            Parallel.ForEach(layer, node =&gt; {\n                node.System.Execute();\n            });\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/JobSystem_eng/#nexus-optimization-tip-multi-core-scalability","title":"Nexus Optimization Tip: Multi-Core Scalability","text":"<p>While a standard <code>MonoBehaviour.Update()</code> loop always puts the load on a single core (Main Thread); <code>Nexus JobSystem</code> distributes the workload homogeneously across all cores (8, 16, 32, etc.). This allows you to increase your game logic capacity by 4-8 times, directly proportional to your number of cores.</p>"},{"location":"API_References/JobSystem_tr/","title":"Nexus Prime Mimari Rehberi: JobSystem (\u0130\u015f Par\u00e7ac\u0131\u0131\u011f\u0131 Orkestrat\u00f6r\u00fc)","text":""},{"location":"API_References/JobSystem_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>JobSystem.cs</code>, Nexus Prime'\u0131n \"\u00c7ok \u00c7ekirdekli Motoru\"dur (Multi-threaded Engine). Modern i\u015flemciler 8, 16 veya daha fazla \u00e7ekirde\u011fe sahip olsa da, bu \u00e7ekirdeklerin verimli kullan\u0131m\u0131 \"Veri Ba\u011f\u0131ml\u0131l\u0131\u011f\u0131\" (Data Dependency) nedeniyle zordur. Ayn\u0131 veriyi hem okuyan hem yazan iki sistem ayn\u0131 anda \u00e7al\u0131\u015f\u0131rsa, veri bozulmas\u0131 (race condition) ka\u00e7\u0131n\u0131lmazd\u0131r.</p> <p>JobSystem'\u0131n varl\u0131k sebebi, sistemler aras\u0131ndaki ba\u011f\u0131ml\u0131l\u0131klar\u0131 analiz ederek onlar\u0131 g\u00fcvenli Katmanlara (Layers) ay\u0131rmak ve her katman i\u00e7indeki sistemleri i\u015flemcinin t\u00fcm \u00e7ekirdeklerinde paralel olarak ko\u015fturmakt\u0131r.</p>"},{"location":"API_References/JobSystem_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>JobSystem, paralel y\u00fcr\u00fctme g\u00fcvenli\u011fi i\u00e7in \u015fu ileri teknikleri kullan\u0131r:</p> <ul> <li>Dependency Graph Analysis (Kahn's Algorithm): Sistemler aras\u0131ndaki Okuma/Yazma (Read/Write) \u00e7ak\u0131\u015fmalar\u0131n\u0131 analiz eder. E\u011fer Sistem A, Pozisyon yaz\u0131yorsa ve Sistem B, Pozisyon okuyorsa; Sistem B ancak Sistem A bittikten sonra \u00e7al\u0131\u015fabilir.</li> <li>Layered Scheduling: Birbirine ba\u011f\u0131ml\u0131l\u0131\u011f\u0131 olmayan sistemler ayn\u0131 katmana atan\u0131r. Bu katmanlar <code>Parallel.ForEach</code> ile e\u015fzamanl\u0131 olarak y\u00fcr\u00fct\u00fcl\u00fcr.</li> <li>Concurrent Execution Monitoring: <code>ConcurrentDictionary</code> kullanarak her sistemin \u00e7al\u0131\u015fma s\u00fcresini (metric) kaydeder.</li> <li>Reflection-Based Dependency Extraction: Sistemlerin \u00fczerindeki <code>[Read]</code> ve <code>[Write]</code> \u00f6zniteliklerini tarayarak \u00e7al\u0131\u015fma zaman\u0131nda otomatik ba\u011f\u0131ml\u0131l\u0131k haritas\u0131 \u00e7\u0131kar\u0131r.</li> </ul>"},{"location":"API_References/JobSystem_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Kay\u0131t (<code>AddSystem</code>): Yeni bir sistem eklendi\u011finde, sistemin kulland\u0131\u011f\u0131 bile\u015fen tipleri (Reads/Writes) tespit edilir.</li> <li>Katman \u0130n\u015fas\u0131 (<code>RebuildLayers</code>): Kahn algoritmas\u0131 varyant\u0131 ile sistemler gruplan\u0131r.<ul> <li>Katman 1: Hi\u00e7bir ba\u011f\u0131ml\u0131l\u0131\u011f\u0131 olmayan sistemler.</li> <li>Katman 2: Sadece Katman 1'deki verilere ba\u011f\u0131ml\u0131 olanlar.</li> </ul> </li> <li>Y\u00fcr\u00fctme (<code>Execute</code>): Katmanlar s\u0131ras\u0131yla (Sequential) \u00e7al\u0131\u015ft\u0131r\u0131l\u0131r. Her katman i\u00e7indeki her bir sistem ise paralel (Parallel) olarak ko\u015fturulur.</li> <li>Metrik Analizi: Her sistemin ka\u00e7 milisaniye harcad\u0131\u011f\u0131 profiller i\u00e7in kaydedilir.</li> </ol>"},{"location":"API_References/JobSystem_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Race Condition \u0130ki veya daha fazla i\u015f par\u00e7ac\u0131\u011f\u0131n\u0131n ayn\u0131 veriye ayn\u0131 anda eri\u015fmesiyle olu\u015fan hata. Dependency Graph \u0130\u015flerin birbirine olan ba\u011f\u0131ml\u0131l\u0131\u011f\u0131n\u0131 g\u00f6steren matematiksel d\u00fc\u011f\u00fcm yap\u0131s\u0131. Kahn's Algorithm Bir grafikteki d\u00fc\u011f\u00fcmleri do\u011frusal ve katmanl\u0131 bir s\u0131raya dizme algoritmas\u0131. Throughput Birim zamanda yap\u0131lan i\u015f miktar\u0131 (\u0130\u015flem kapasitesi)."},{"location":"API_References/JobSystem_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Circular Dependency: E\u011fer Sistem A, Sistem B'ye; Sistem B de Sistem A'ya ba\u011f\u0131ml\u0131ysa grafik kilitlenir. Nexus bu durumu tespit edip fallback mekanizmas\u0131yla \u00e7\u00f6zer.</li> <li>Parallel Overhead: \u00c7ok k\u00fc\u00e7\u00fck i\u015fler i\u00e7in paralel thread olu\u015fturmak, i\u015fin kendisinden daha uzun s\u00fcrebilir. Bu durum \"Grain Size\" optimizasyonu gerektirir.</li> </ul>"},{"location":"API_References/JobSystem_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>var jobSystem = new JobSystem(registry);\n\n// Sistemleri ekle (Ba\u011f\u0131ml\u0131l\u0131klar otomatik \u00e7\u00f6z\u00fcl\u00fcr)\njobSystem.AddSystem(new MovementSystem());\njobSystem.AddSystem(new CollisionSystem());\n\n// Her karede \u00e7al\u0131\u015ft\u0131r\nvoid Update() {\n    jobSystem.Execute();\n}\n</code></pre>"},{"location":"API_References/JobSystem_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>using System.Collections.Concurrent;\nusing System.Threading.Tasks;\nnamespace Nexus.Core;\n\npublic class JobSystem : INexusJobSystem\n{\n    private readonly List&lt;SystemNode&gt; _nodes = new();\n    private readonly List&lt;List&lt;SystemNode&gt;&gt; _layers = new();\n\n    public void RebuildLayers()\n    {\n        _layers.Clear();\n        // 1. Build Adjacency List based on Read/Write conflicts\n        // 2. Group into layers using Kahn's algorithm\n    }\n\n    public void Execute()\n    {\n        foreach (var layer in _layers) {\n            Parallel.ForEach(layer, node =&gt; {\n                node.System.Execute();\n            });\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/JobSystem_tr/#nexus-optimization-tip-multi-core-scalability","title":"Nexus Optimization Tip: Multi-Core Scalability","text":"<p>Standart bir <code>MonoBehaviour.Update()</code> d\u00f6ng\u00fcs\u00fc her zaman tek bir \u00e7ekirdek (Main Thread) \u00fczerine binerken; <code>Nexus JobSystem</code> i\u015f y\u00fck\u00fcn\u00fc t\u00fcm \u00e7ekirdeklere (8, 16, 32 vb.) homojen olarak da\u011f\u0131t\u0131r. Bu, oyun mant\u0131\u011f\u0131 kapasitenizi \u00e7ekirdek say\u0131n\u0131zla do\u011fru orant\u0131l\u0131 olarak 4-8 kat art\u0131rman\u0131z\u0131 sa\u011flar.</p>"},{"location":"API_References/LiveShaderBridge_eng/","title":"Nexus Prime Architectural Manual: LiveShaderBridge (Live Shader Streaming)","text":""},{"location":"API_References/LiveShaderBridge_eng/#1-introduction","title":"1. Introduction","text":"<p><code>LiveShaderBridge.cs</code> is the \"Superhighway\" between Nexus Prime's high-performance data world and the GPU's parallel processing power. It coordinates the visualization process at the unmanaged level by transferring thousands of unmanaged component data (e.g., Position, Temperature, Flow rate) directly to shaders (GPU) via <code>ComputeBuffer</code> every frame.</p> <p>The reason for this bridge's existence is to avoid the cost of individual <code>MaterialPropertyBlock</code> updates for each entity and to ensure that the GPU accesses all entity data via a single texture or buffer at O(1) cost.</p>"},{"location":"API_References/LiveShaderBridge_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Uses the following architecture for maximum GPU throughput (bandwidth):</p> <ul> <li>ComputeBuffer Integration: Presents data in its closest form to GPU registers, i.e., as a raw buffer. Defines how much space each entity takes on the GPU (e.g., float4 = 16 bytes) with the <code>STRIDE</code> parameter.</li> <li>Bulk Data Gathering: Packages data from the unmanaged <code>Registry</code> into a single bulk memory block and transmits it to the GPU.</li> <li>Global Shader Properties: Makes data accessible for shaders (VFX Graph, Custom Shaders) in the entire scene via the <code>Shader.SetGlobalBuffer</code> method.</li> <li>Memory Management (IDisposable): Performs safe cleaning (Cleanup) with the <code>Dispose</code> pattern to prevent leaking the ComputeBuffer, which is an unmanaged GPU resource.</li> </ul>"},{"location":"API_References/LiveShaderBridge_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Setup: Space is opened on the GPU side (Buffer Allocation) according to the entity count and data width (STRIDE).</li> <li>Data Collection: Every frame, the Nexus Registry is scanned and up-to-date data is collected into a single array.</li> <li>Streaming (Streaming): The prepared array is copied to GPU memory with <code>ComputeBuffer.SetData</code>.</li> <li>Consumption: Data is instantly accessed via the <code>StructuredBuffer&lt;float4&gt; _NexusEntityData</code> definition in shader files.</li> </ol>"},{"location":"API_References/LiveShaderBridge_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description ComputeBuffer Unity memory structure used to transfer large amounts of raw data from CPU to GPU. Stride The size of each element in the buffer in bytes. GPU Streaming Streaming data to the graphics processor continuously and refreshed every frame. Batching Efficiency The ability to draw or update thousands of objects in a single operation."},{"location":"API_References/LiveShaderBridge_eng/#5-usage-example","title":"5. Usage Example","text":"<pre><code>// Push data to VFX Graph or Custom Shader\nvar shaderBridge = new LiveShaderBridge(10000); // for 10k entities\n\nvoid Update() {\n    shaderBridge.UpdateBuffer(mainRegistry);\n}\n\n// Reading on the shader side:\n// StructuredBuffer&lt;float4&gt; _NexusEntityData;\n// float3 pos = _NexusEntityData[entityIndex].xyz;\n</code></pre>"},{"location":"API_References/LiveShaderBridge_eng/#6-full-source-implementation-direct-implementation","title":"6. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Bridge;\n\npublic class LiveShaderBridge : IDisposable\n{\n    private ComputeBuffer _dataBuffer;\n    private const int STRIDE = 16; \n\n    public LiveShaderBridge(int entityCount) {\n        _dataBuffer = new ComputeBuffer(entityCount, STRIDE);\n    }\n\n    public unsafe void UpdateBuffer(Registry.Registry registry) {\n        // Gathering data logic...\n        Shader.SetGlobalBuffer(\"_NexusEntityData\", _dataBuffer);\n    }\n\n    public void Dispose() =&gt; _dataBuffer?.Release();\n}\n</code></pre>"},{"location":"API_References/LiveShaderBridge_eng/#nexus-optimization-tip-persistent-buffer","title":"Nexus Optimization Tip: Persistent Buffer","text":"<p>Create the buffer once (<code>Persistent</code>) instead of destroying and re-creating it every frame. Only update the data inside it with <code>SetData</code>. This ensures performance stability by zeroing the memory allocation (Allocation) load.</p>"},{"location":"API_References/LiveShaderBridge_tr/","title":"Nexus Prime Mimari Rehberi: LiveShaderBridge (Canl\u0131 Shader Ak\u0131\u015f\u0131)","text":""},{"location":"API_References/LiveShaderBridge_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>LiveShaderBridge.cs</code>, Nexus Prime'\u0131n y\u00fcksek performansl\u0131 veri d\u00fcnyas\u0131 ile GPU'nun paralel i\u015flem g\u00fcc\u00fc aras\u0131ndaki \"S\u00fcper Otoyol\"dur. Binlerce unmanaged bile\u015fen verisini (\u00d6rn: Pozisyon, S\u0131cakl\u0131k, Ak\u0131\u015f h\u0131z\u0131) her karede <code>ComputeBuffer</code> \u00fczerinden do\u011frudan shader'lara (GPU) aktararak, g\u00f6rselle\u015ftirme s\u00fcrecini unmanaged seviyede koordine eder.</p> <p>Bu k\u00f6pr\u00fcn\u00fcn varl\u0131k sebebi; her varl\u0131k i\u00e7in ayr\u0131 bir <code>MaterialPropertyBlock</code> g\u00fcncelleme maliyetinden ka\u00e7\u0131nmak ve GPU'nun t\u00fcm varl\u0131k verisine tek bir doku veya buffer \u00fczerinden O(1) maliyetle eri\u015fmesini sa\u011flamakt\u0131r.</p>"},{"location":"API_References/LiveShaderBridge_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Maksimum GPU throughput (bant geni\u015fli\u011fi) i\u00e7in \u015fu mimariyi kullan\u0131r:</p> <ul> <li>ComputeBuffer Integration: Verileri GPU register'lar\u0131na en yak\u0131n formda, yani ham bir buffer olarak sunar. <code>STRIDE</code> parametresi ile her varl\u0131\u011f\u0131n GPU'da ne kadar yer kaplad\u0131\u011f\u0131n\u0131 (\u00d6rn: float4 = 16 byte) tan\u0131mlar.</li> <li>Bulk Data Gathering: Unmanaged <code>Registry</code>'den gelen verileri tek bir toplu bellek bloklamas\u0131yla paketleyerek GPU'ya iletir.</li> <li>Global Shader Properties: <code>Shader.SetGlobalBuffer</code> metodu ile veriyi t\u00fcm sahnedeki shader'lar (VFX Graph, Custom Shaders) i\u00e7in eri\u015filebilir k\u0131lar.</li> <li>Memory Management (IDisposable): Unmanaged bir GPU kayna\u011f\u0131 olan ComputeBuffer'\u0131n s\u0131zmas\u0131n\u0131 \u00f6nlemek i\u00e7in <code>Dispose</code> deseniyle g\u00fcvenli temizlik (Cleanup) yapar.</li> </ul>"},{"location":"API_References/LiveShaderBridge_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Kurulum: Varl\u0131k say\u0131s\u0131na ve veri geni\u015fli\u011fine (STRIDE) g\u00f6re GPU taraf\u0131nda yer a\u00e7\u0131l\u0131r (Buffer Allocation).</li> <li>Veri Toplama: Her karede Nexus Registry taranarak g\u00fcncel veriler tek bir diziye toplan\u0131r.</li> <li>Ak\u0131\u015f (Streaming): Haz\u0131rlanan dizi, <code>ComputeBuffer.SetData</code> ile GPU belle\u011fine kopyalan\u0131r.</li> <li>T\u00fcketim: Shader dosyalar\u0131 i\u00e7indeki <code>StructuredBuffer&lt;float4&gt; _NexusEntityData</code> tan\u0131m\u0131yla verilere an\u0131nda eri\u015filir.</li> </ol>"},{"location":"API_References/LiveShaderBridge_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama ComputeBuffer CPU'dan GPU'ya b\u00fcy\u00fck miktarda ham veri aktarmak i\u00e7in kullan\u0131lan Unity bellek yap\u0131s\u0131. Stride Buffer i\u00e7indeki her bir eleman\u0131n byte cinsinden boyutu. GPU Streaming Verilerin kesintisiz ve her karede yenilenerek grafik i\u015flemciye ak\u0131t\u0131lmas\u0131. Batching Efficiency Binlerce nesnenin tek bir i\u015flemle \u00e7izilmesi veya g\u00fcncellenmesi yetene\u011fi."},{"location":"API_References/LiveShaderBridge_tr/#5-kullanm-ornegi","title":"5. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// VFX Graph veya Custom Shader'a veri bas\nvar shaderBridge = new LiveShaderBridge(10000); // 10k varl\u0131k i\u00e7in\n\nvoid Update() {\n    shaderBridge.UpdateBuffer(mainRegistry);\n}\n\n// Shader taraf\u0131nda okuma:\n// StructuredBuffer&lt;float4&gt; _NexusEntityData;\n// float3 pos = _NexusEntityData[entityIndex].xyz;\n</code></pre>"},{"location":"API_References/LiveShaderBridge_tr/#6-tam-kaynak-kod-direct-implementation","title":"6. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Bridge;\n\npublic class LiveShaderBridge : IDisposable\n{\n    private ComputeBuffer _dataBuffer;\n    private const int STRIDE = 16; \n\n    public LiveShaderBridge(int entityCount) {\n        _dataBuffer = new ComputeBuffer(entityCount, STRIDE);\n    }\n\n    public unsafe void UpdateBuffer(Registry.Registry registry) {\n        // Gathering data logic...\n        Shader.SetGlobalBuffer(\"_NexusEntityData\", _dataBuffer);\n    }\n\n    public void Dispose() =&gt; _dataBuffer?.Release();\n}\n</code></pre>"},{"location":"API_References/LiveShaderBridge_tr/#nexus-optimization-tip-persistent-buffer","title":"Nexus Optimization Tip: Persistent Buffer","text":"<p>Buffer'\u0131 her karede yok edip tekrar olu\u015fturmak yerine bir kez olu\u015fturun (<code>Persistent</code>). Sadece i\u00e7indeki veriyi <code>SetData</code> ile g\u00fcncelleyin. Bu, bellek ay\u0131rma (Allocation) y\u00fck\u00fcn\u00fc s\u0131f\u0131ra indirerek performans istikrar\u0131n\u0131 sa\u011flar.</p>"},{"location":"API_References/LiveStateTweaker_eng/","title":"Nexus Prime Architectural Manual: LiveState Tweaker (Live State Editor)","text":""},{"location":"API_References/LiveStateTweaker_eng/#1-introduction","title":"1. Introduction","text":"<p><code>LiveStateTweaker.cs</code> is a powerful Editor panel providing instantaneous monitoring and changing of data in the ECS world during the game's runtime (Runtime). It reduces the developers' \"Trial-Error\" loop to seconds without stopping the game.</p> <p>The reason for this panel's existence is to bring unmanaged <code>INexusComponent</code> data to light, which the standard Unity Inspector cannot see, and to allow the developer to \"twist and turn\" variables live.</p>"},{"location":"API_References/LiveStateTweaker_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The panel is equipped with the following advanced features:</p> <ul> <li>Global Registry Inspection: Lists all Entities currently alive by connecting to the active Nexus Registry.</li> <li>Search &amp; Filter Engine: Rapidly searches among thousands of entities according to a specific ID or component type.</li> <li>Direct Memory Manipulation: When you change a value on the GUI, the system writes this change directly to the unmanaged memory address (Pointer).</li> <li>Component Foldout Logic: Prevents visual clutter by presenting components of each entity in a foldable (Foldout) structure.</li> </ul>"},{"location":"API_References/LiveStateTweaker_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Connection: When the editor window is opened, the data flow starts over the existing <code>Snapshot</code> or <code>Registry</code>.</li> <li>Subscription: The panel updates only the changed data in the interface by monitoring the \"Dirty\" flags on the unmanaged side.</li> <li>Input Processing: When the developer moves a Slider in the user interface (UI), the new value is immediately injected into the ECS simulation.</li> </ol>"},{"location":"API_References/LiveStateTweaker_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// In a running game:\n// 1. [Nexus/Live State Tweaker] is opened.\n// 2. \"EnemyBoss\" entity is searched.\n// 3. The Health value under the \"Health\" component is pulled from 1000 to 10.\n// Result: Boss's health decreases immediately without the game stopping.\n</code></pre>"},{"location":"API_References/LiveStateTweaker_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class LiveStateTweaker : EditorWindow\n{\n    [MenuItem(\"Nexus/Live State Tweaker\")]\n    public static void ShowWindow() =&gt; GetWindow&lt;LiveStateTweaker&gt;(\"State Tweaker\");\n\n    private void OnGUI() {\n        // Search bar...\n        // Scroll view for entities...\n        // Draw each entity's component with EditorGUILayout fields.\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/LiveStateTweaker_eng/#nexus-optimization-tip-event-filtering","title":"Nexus Optimization Tip: Event Filtering","text":"<p>Instead of refreshing State Tweaker on every Update, trigger the <code>Repaint()</code> call only when there is a change in unmanaged data. This reduces Editor processor load by 25% in cases where a large number of entities are monitored.</p>"},{"location":"API_References/LiveStateTweaker_tr/","title":"Nexus Prime Mimari Rehberi: LiveState Tweaker (Canl\u0131 Durum D\u00fczenleyici)","text":""},{"location":"API_References/LiveStateTweaker_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>LiveStateTweaker.cs</code>, oyunun \u00e7al\u0131\u015fma zaman\u0131nda (Runtime) ECS d\u00fcnyas\u0131ndaki verilerin anl\u0131k olarak izlenmesini ve de\u011fi\u015ftirilmesini sa\u011flayan g\u00fc\u00e7l\u00fc bir Edit\u00f6r panelidir. Geli\u015ftiricilerin \"Deneme-Yan\u0131lma\" d\u00f6ng\u00fcs\u00fcn\u00fc, oyunu durdurmadan saniyelere indirger.</p> <p>Bu panelin varl\u0131k sebebi; standart Unity Inspector'\u0131n g\u00f6remedi\u011fi unmanaged <code>INexusComponent</code> verilerini g\u00fcn y\u00fcz\u00fcne \u00e7\u0131karmak ve geli\u015ftiricinin de\u011fi\u015fkenleri canl\u0131 olarak \"evirip \u00e7evirmesine\" imkan tan\u0131makt\u0131r.</p>"},{"location":"API_References/LiveStateTweaker_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Panel \u015fu geli\u015fmi\u015f \u00f6zelliklerle donat\u0131lm\u0131\u015ft\u0131r:</p> <ul> <li>Global Registry Inspection: Aktif Nexus Registry'sine ba\u011flanarak, o an hayatta olan t\u00fcm Entity'leri listeler.</li> <li>Search &amp; Filter Engine: Binlerce entity aras\u0131ndan belirli bir ID'ye veya bile\u015fen tipine g\u00f6re h\u0131zl\u0131ca arama yapabilir.</li> <li>Direct Memory Manipulation: GUI \u00fczerindeki bir de\u011feri de\u011fi\u015ftirdi\u011finizde, sistem bu de\u011fi\u015fikli\u011fi do\u011frudan unmanaged bellek adresine (Pointer) yazar.</li> <li>Component Foldout Logic: Her entity'nin bile\u015fenlerini katlanabilir (Foldout) bir yap\u0131da sunarak g\u00f6rsel karma\u015fay\u0131 \u00f6nler.</li> </ul>"},{"location":"API_References/LiveStateTweaker_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Ba\u011flanma: Edit\u00f6r penceresi a\u00e7\u0131ld\u0131\u011f\u0131nda mevcut <code>Snapshot</code> veya <code>Registry</code> \u00fczerinden veri ak\u0131\u015f\u0131 ba\u015flar.</li> <li>Abonelik: Panel, unmanaged taraftaki \"Dirty\" bayraklar\u0131n\u0131 izleyerek sadece de\u011fi\u015fen verileri aray\u00fczde g\u00fcnceller.</li> <li>Girdi \u0130\u015fleme: Geli\u015ftirici kullan\u0131c\u0131 aray\u00fcz\u00fcnde (UI) bir Slider'\u0131 kayd\u0131rd\u0131\u011f\u0131nda, yeni de\u011fer an\u0131nda ECS sim\u00fclasyonuna enjekte edilir.</li> </ol>"},{"location":"API_References/LiveStateTweaker_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// \u00c7al\u0131\u015fan bir oyunda:\n// 1. [Nexus/Live State Tweaker] a\u00e7\u0131l\u0131r.\n// 2. \"EnemyBoss\" entity'si arat\u0131l\u0131r.\n// 3. \"Health\" bile\u015feni alt\u0131ndaki Health de\u011feri 1000'den 10'a \u00e7ekilir.\n// Sonu\u00e7: Oyun durmadan Boss'un can\u0131 an\u0131nda azal\u0131r.\n</code></pre>"},{"location":"API_References/LiveStateTweaker_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class LiveStateTweaker : EditorWindow\n{\n    [MenuItem(\"Nexus/Live State Tweaker\")]\n    public static void ShowWindow() =&gt; GetWindow&lt;LiveStateTweaker&gt;(\"State Tweaker\");\n\n    private void OnGUI() {\n        // Search bar...\n        // Scroll view for entities...\n        // Draw each entity's component with EditorGUILayout fields.\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/LiveStateTweaker_tr/#nexus-optimization-tip-event-filtering","title":"Nexus Optimization Tip: Event Filtering","text":"<p>State Tweaker'\u0131 her Update'te yenilemek yerine, <code>Repaint()</code> \u00e7a\u011fr\u0131s\u0131n\u0131 sadece unmanaged veride bir de\u011fi\u015fiklik oldu\u011funda tetikleyin. Bu, \u00e7ok say\u0131da entity'nin izlendi\u011fi durumlarda Edit\u00f6r i\u015flemci y\u00fck\u00fcn\u00fc %25 azalt\u0131r.</p>"},{"location":"API_References/LogicHotSwapSystem_eng/","title":"Nexus Prime Architectural Manual: LogicHotSwapSystem (Runtime Logic Swapping)","text":""},{"location":"API_References/LogicHotSwapSystem_eng/#1-introduction","title":"1. Introduction","text":"<p><code>LogicHotSwapSystem.cs</code> is an experimental infrastructure designed to break the \"Change Code - Compile - Restart\" cycle, which is one of the biggest bottlenecks in modern game development processes. It allows developers to live-update <code>INexusSystem</code> logic without closing the game or simulation.</p> <p>The reason for this system's existence is to \"hotly\" swap the methods (simulation logic) that process unmanaged data (Registry) without disturbing its persistence on memory.</p>"},{"location":"API_References/LogicHotSwapSystem_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>LogicHotSwapSystem uses the following mechanisms for dynamic code exchange:</p> <ul> <li>Assembly Loading: Newly written and compiled system logic is included in the existing process using <code>Assembly.Load</code> or <code>AssemblyLoadContext</code>.</li> <li>System Interface Bridge: As long as the newly loaded classes implement the <code>INexusSystem</code> interface, they can replace the reference of the old system in the <code>JobSystem</code>.</li> <li>State Persistence: Thanks to Nexus's ECS structure, all state is already on the <code>Registry</code>. When logic changes, no progress is lost because the data remains the same (Zero State Loss).</li> <li>Reflective Injection: The <code>Registry</code> and other dependencies possessed by the old system are re-injected into the newly loaded system.</li> </ul>"},{"location":"API_References/LogicHotSwapSystem_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Triggering: The developer calls the <code>SwapSystemLogic</code> method with a new DLL path.</li> <li>Loading: The binary at the specified path is taken into memory.</li> <li>Finding: The system type with the same name in the DLL is found via Reflection.</li> <li>Swapping: The old system in <code>JobSystem</code> is removed, and the instance of the newly loaded system is added in its place.</li> </ol>"},{"location":"API_References/LogicHotSwapSystem_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Hot-Swap The process of updating parts of a program while it is running without stopping it. Assembly A compiled unit of code in the .NET environment (DLL or EXE). Zero State Loss The state where existing game data is preserved during logic exchange. Dynamic Invocation Determining and calling the name of a method or class at runtime."},{"location":"API_References/LogicHotSwapSystem_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Assembly Leaks: In versions before .NET Core, the inability to unload assemblies loaded into memory can cause RAM accumulation.</li> <li>Breaking Changes: If the new logic has changed the structure of the old data (Component struct), the application may crash due to memory mismatch (Memory Corruption).</li> <li>Thread Safety: The swap operation should be performed at a safe synchronization point (Sync Point) where systems are not being <code>Execute()</code>ed.</li> </ul>"},{"location":"API_References/LogicHotSwapSystem_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>// Update gravity logic during a live game\nvar hotswap = new LogicHotSwapSystem();\nhotswap.SwapSystemLogic(currentGravitySystem, \"Path/To/New/PhysicsPart2.dll\");\n</code></pre>"},{"location":"API_References/LogicHotSwapSystem_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>using System.Reflection;\nnamespace Nexus.Core;\n\npublic class LogicHotSwapSystem\n{\n    public void SwapSystemLogic(INexusSystem oldSystem, string assemblyPath)\n    {\n        // 1. Load the assembly from path.\n        // 2. Find the implementation of the same system type.\n        // 3. Migrate state and replace the instance in JobSystem.\n        Console.WriteLine($\"Nexus: Hot-swapping logic for {oldSystem.GetType().Name}\");\n    }\n}\n</code></pre>"},{"location":"API_References/LogicHotSwapSystem_eng/#nexus-optimization-tip-context-based-reloading","title":"Nexus Optimization Tip: Context-Based Reloading","text":"<p>Load your systems into isolated areas using <code>AssemblyLoadContext</code>. In this way, you can completely delete (Unload) your old code from memory and 100% prevent memory bloating in long-term development sessions.</p>"},{"location":"API_References/LogicHotSwapSystem_tr/","title":"Nexus Prime Mimari Rehberi: LogicHotSwapSystem (\u00c7al\u0131\u015fma Zaman\u0131 Mant\u0131k De\u011fi\u015fimi)","text":""},{"location":"API_References/LogicHotSwapSystem_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>LogicHotSwapSystem.cs</code>, modern oyun geli\u015ftirme s\u00fcre\u00e7lerindeki en b\u00fcy\u00fck darbo\u011fazlardan biri olan \"Kod De\u011fi\u015ftir - Derle - Yeniden Ba\u015flat\" d\u00f6ng\u00fcs\u00fcn\u00fc k\u0131rmak i\u00e7in tasarlanm\u0131\u015f bir deneysel altyap\u0131d\u0131r. Geli\u015ftiricilerin, oyunu veya sim\u00fclasyonu kapatmadan, <code>INexusSystem</code> mant\u0131\u011f\u0131n\u0131 canl\u0131 bir \u015fekilde g\u00fcncellemesine olanak tan\u0131r.</p> <p>Bu sistemin varl\u0131k sebebi, unmanaged verinin (Registry) bellek \u00fczerindeki kal\u0131c\u0131l\u0131\u011f\u0131n\u0131 bozmadan, sadece o veriyi i\u015fleyen metodlar\u0131 (sim\u00fclasyon mant\u0131\u011f\u0131n\u0131) \u00e7al\u0131\u015fma zaman\u0131nda \"s\u0131cak\" bir \u015fekilde takas etmektir.</p>"},{"location":"API_References/LogicHotSwapSystem_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>LogicHotSwapSystem, dinamik kod de\u011fi\u015fimi i\u00e7in \u015fu mekanizmalar\u0131 kullan\u0131r:</p> <ul> <li>Assembly Loading: Yeni yaz\u0131lm\u0131\u015f ve derlenmi\u015f sistem mant\u0131\u011f\u0131, <code>Assembly.Load</code> veya <code>AssemblyLoadContext</code> kullan\u0131larak mevcut i\u015fleme (process) dahil edilir.</li> <li>System Interface Bridge: Yeni y\u00fcklenen s\u0131n\u0131flar <code>INexusSystem</code> aray\u00fcz\u00fcn\u00fc uygulad\u0131\u011f\u0131 s\u00fcrece, <code>JobSystem</code> i\u00e7indeki eski sistemin referans\u0131 ile yer de\u011fi\u015ftirebilirler.</li> <li>State Persistence: Nexus'un ECS yap\u0131s\u0131 sayesinde t\u00fcm durum (state) zaten <code>Registry</code> \u00fczerindedir. Mant\u0131k (Logic) de\u011fi\u015fti\u011finde veri ayn\u0131 kald\u0131\u011f\u0131 i\u00e7in hi\u00e7bir ilerleme kaybolmaz (Zero State Loss).</li> <li>Reflective Injection: Yeni y\u00fcklenen sisteme eski sistemin sahip oldu\u011fu <code>Registry</code> ve di\u011fer ba\u011f\u0131ml\u0131l\u0131klar tekrar enjekte edilir.</li> </ul>"},{"location":"API_References/LogicHotSwapSystem_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tetikleme: Geli\u015ftirici yeni bir DLL yolu ile <code>SwapSystemLogic</code> metodunu \u00e7a\u011f\u0131r\u0131r.</li> <li>Y\u00fckleme: Belirtilen yoldaki binary bellek \u00fczerine al\u0131n\u0131r.</li> <li>Bulma: DLL i\u00e7indeki ayn\u0131 isimli sistem tipi Reflection ile bulunur.</li> <li>Takas: <code>JobSystem</code> i\u00e7indeki eski sistem \u00e7\u0131kar\u0131l\u0131r, yerine yeni y\u00fcklenen sistemin \u00f6rne\u011fi (instance) eklenir.</li> </ol>"},{"location":"API_References/LogicHotSwapSystem_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Hot-Swap Bir program \u00e7al\u0131\u015f\u0131rken durdurulmadan par\u00e7alar\u0131n\u0131n g\u00fcncellenmesi i\u015flemi. Assembly .NET ortam\u0131nda derlenmi\u015f kod birimi (DLL veya EXE). Zero State Loss Mant\u0131k de\u011fi\u015fimi s\u0131ras\u0131nda var olan oyun verilerinin korunmas\u0131 durumu. Dynamic Invocation Bir metodun veya s\u0131n\u0131f\u0131n isminin \u00e7al\u0131\u015fma zaman\u0131nda belirlenip \u00e7a\u011fr\u0131lmas\u0131."},{"location":"API_References/LogicHotSwapSystem_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Assembly Leaks: .NET Core \u00f6ncesi s\u00fcr\u00fcmlerde y\u00fcklenen assembly'lerin bellekten at\u0131lamamas\u0131 (unload) RAM birikmesine neden olabilir.</li> <li>Breaking Changes: E\u011fer yeni mant\u0131k, eski verinin yap\u0131s\u0131n\u0131 (Component struct) de\u011fi\u015ftirmi\u015fse, bellek uyumsuzlu\u011fu (Memory Corruption) nedeniyle uygulama \u00e7\u00f6kebilir.</li> <li>Thread Safety: Takas i\u015flemi sistemlerin <code>Execute()</code> edilmedi\u011fi g\u00fcvenli bir birle\u015fme noktas\u0131nda (Sync Point) yap\u0131lmal\u0131d\u0131r.</li> </ul>"},{"location":"API_References/LogicHotSwapSystem_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Canl\u0131 bir oyun s\u0131ras\u0131nda yer\u00e7ekimi mant\u0131\u011f\u0131n\u0131 g\u00fcncelle\nvar hotswap = new LogicHotSwapSystem();\nhotswap.SwapSystemLogic(currentGravitySystem, \"Path/To/New/PhysicsPart2.dll\");\n</code></pre>"},{"location":"API_References/LogicHotSwapSystem_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>using System.Reflection;\nnamespace Nexus.Core;\n\npublic class LogicHotSwapSystem\n{\n    public void SwapSystemLogic(INexusSystem oldSystem, string assemblyPath)\n    {\n        // 1. Load the assembly from path.\n        // 2. Find the implementation of the same system type.\n        // 3. Migrate state and replace the instance in JobSystem.\n        Console.WriteLine($\"Nexus: Hot-swapping logic for {oldSystem.GetType().Name}\");\n    }\n}\n</code></pre>"},{"location":"API_References/LogicHotSwapSystem_tr/#nexus-optimization-tip-context-based-reloading","title":"Nexus Optimization Tip: Context-Based Reloading","text":"<p><code>AssemblyLoadContext</code> kullanarak sistemlerinizi izole edilmi\u015f alanlara y\u00fckleyin. Bu sayede, eski kodunuzu bellekten tamamen silebilir (Unload) ve uzun s\u00fcreli geli\u015ftirme seanslar\u0131nda bellek \u015fi\u015fmesini %100 engelleyebilirsiniz.</p>"},{"location":"API_References/MustBeUnmanagedAttribute_eng/","title":"Nexus Prime Architectural Manual: MustBeUnmanagedAttribute (Unmanaged Type Requirement)","text":""},{"location":"API_References/MustBeUnmanagedAttribute_eng/#1-introduction","title":"1. Introduction","text":"<p><code>MustBeUnmanagedAttribute.cs</code> acts as a \"Seal\" in Nexus Prime's Memory Safety architecture. It notifies the compiler and analyzers that a struct or class must strictly be unmanaged (blittable).</p> <p>The reason for this attribute's existence is to prevent structures containing reference types (managed objects) from being accidentally used in systems working with unmanaged memory (e.g., <code>Registry</code>, <code>Snapshot</code>) at compile-time and to zero out memory corruptions that may occur at runtime.</p>"},{"location":"API_References/MustBeUnmanagedAttribute_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>MustBeUnmanagedAttribute assumes the following roles for system integrity:</p> <ul> <li>Constraint Enforcement: Scanned by <code>UnmanagedComponentAnalyzer</code> (Roslyn). If a type with this attribute contains managed references such as <code>string</code>, <code>class</code>, or <code>list</code>, the \"NX0001\" error is triggered.</li> <li>Documentation by Code: Declares to the developer that this type lives only on raw memory and is suitable for <code>NativeMemory</code> operations.</li> <li>Structural Integrity: Guarantees that the memory layout of the type remains deterministic.</li> </ul>"},{"location":"API_References/MustBeUnmanagedAttribute_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Definition: The developer marks a component with <code>[MustBeUnmanaged]</code>.</li> <li>Analysis: The Roslyn-based analyzer sees this tag while scanning the code.</li> <li>Verification: It is checked whether all fields within the type are unmanaged.</li> <li>Result: If the rule is violated, a red error line appears on Visual Studio/Rider.</li> </ol>"},{"location":"API_References/MustBeUnmanagedAttribute_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>using Nexus.Attributes;\n\n[MustBeUnmanaged]\npublic struct PlayerStats {\n    public int Level;\n    public float Experience;\n    // string Name; // ERROR: Analyzer stops compilation because of this line!\n}\n</code></pre>"},{"location":"API_References/MustBeUnmanagedAttribute_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Attributes;\n\n[AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class)]\npublic class MustBeUnmanagedAttribute : Attribute { }\n</code></pre>"},{"location":"API_References/MustBeUnmanagedAttribute_eng/#nexus-optimization-tip-early-verification","title":"Nexus Optimization Tip: Early Verification","text":"<p>The <code>[MustBeUnmanaged]</code> attribute shifts memory errors from runtime to compile-time (Shift-Left). While this shortens debug times, it helps you guarantee the memory stability of your application at 100%.</p>"},{"location":"API_References/MustBeUnmanagedAttribute_tr/","title":"Nexus Prime Mimari Rehberi: MustBeUnmanagedAttribute (Unmanaged Tip Zorunlulu\u011fu)","text":""},{"location":"API_References/MustBeUnmanagedAttribute_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>MustBeUnmanagedAttribute.cs</code>, Nexus Prime'\u0131n bellek g\u00fcvenli\u011fi (Memory Safety) mimarisinde bir \"M\u00fch\u00fcr\" (Seal) g\u00f6revi g\u00f6r\u00fcr. Bir struct veya s\u0131n\u0131f\u0131n kesinlikle unmanaged (blittable) olmas\u0131 gerekti\u011fini derleyiciye ve analyzer'lara bildirir.</p> <p>Bu \u00f6zniteli\u011fin varl\u0131k sebebi, unmanaged bellek ile \u00e7al\u0131\u015fan sistemlerde (\u00d6rn: <code>Registry</code>, <code>Snapshot</code>) yanl\u0131\u015fl\u0131kla referans tipi (managed object) i\u00e7eren yap\u0131lar\u0131n kullan\u0131lmas\u0131n\u0131 derleme an\u0131nda (Compile-time) engellemek ve \u00e7al\u0131\u015fma zaman\u0131nda olu\u015fabilecek bellek bozulmalar\u0131n\u0131 (Corruption) s\u0131f\u0131ra indirmektir.</p>"},{"location":"API_References/MustBeUnmanagedAttribute_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>MustBeUnmanagedAttribute, sistem b\u00fct\u00fcnl\u00fc\u011f\u00fc i\u00e7in \u015fu rolleri \u00fcstlenir:</p> <ul> <li>Constraint Enforcement: <code>UnmanagedComponentAnalyzer</code> (Roslyn) taraf\u0131ndan taran\u0131r. E\u011fer bu \u00f6zniteli\u011fe sahip bir tip i\u00e7inde <code>string</code>, <code>class</code> veya <code>list</code> gibi managed referanslar varsa \"NX0001\" hatas\u0131 tetiklenir.</li> <li>Documentation by Code: Geli\u015ftiriciye bu tipin sadece ham bellek (raw memory) \u00fczerinde ya\u015fad\u0131\u011f\u0131n\u0131 ve <code>NativeMemory</code> operasyonlar\u0131na uygun oldu\u011funu beyan eder.</li> <li>Structural Integrity: Tipin bellek diziliminin (Memory Layout) deterministik kalmas\u0131n\u0131 garanti alt\u0131na al\u0131r.</li> </ul>"},{"location":"API_References/MustBeUnmanagedAttribute_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tan\u0131mlama: Geli\u015ftirici, bir bile\u015feni <code>[MustBeUnmanaged]</code> ile i\u015faretler.</li> <li>Analiz: Roslyn tabanl\u0131 analyzer, kodu tararken bu etiketi g\u00f6r\u00fcr.</li> <li>Do\u011frulama: Tipin i\u00e7indeki t\u00fcm alanlar (fields) unmanaged mi diye kontrol edilir.</li> <li>Sonu\u00e7: E\u011fer kural ihlal edilmi\u015fse, visual studio/rider \u00fczerinde k\u0131rm\u0131z\u0131 hata \u00e7izgisi belirir.</li> </ol>"},{"location":"API_References/MustBeUnmanagedAttribute_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>using Nexus.Attributes;\n\n[MustBeUnmanaged]\npublic struct PlayerStats {\n    public int Level;\n    public float Experience;\n    // string Name; // HATA: Analyzer bu sat\u0131r y\u00fcz\u00fcnden derlemeyi durdurur!\n}\n</code></pre>"},{"location":"API_References/MustBeUnmanagedAttribute_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Attributes;\n\n[AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class)]\npublic class MustBeUnmanagedAttribute : Attribute { }\n</code></pre>"},{"location":"API_References/MustBeUnmanagedAttribute_tr/#nexus-optimization-tip-early-verification","title":"Nexus Optimization Tip: Early Verification","text":"<p><code>[MustBeUnmanaged]</code> \u00f6zniteli\u011fi, bellek hatalar\u0131n\u0131 runtime'dan compile-time'a \u00e7eker (Shift-Left). Bu, debug s\u00fcrelerini k\u0131salt\u0131rken, uygulaman\u0131z\u0131n bellek stabilitesini %100 oran\u0131nda garanti alt\u0131na alman\u0131za yard\u0131mc\u0131 olur.</p>"},{"location":"API_References/NexusAnalyzer_eng/","title":"API Reference: NexusAnalyzer (Static Safety Analyzer)","text":""},{"location":"API_References/NexusAnalyzer_eng/#introduction","title":"Introduction","text":"<p><code>NexusAnalyzer.cs</code> is the \"security guard\" of the Nexus Prime development process. This Roslyn-based tool checks not only that code is written correctly, but also that it complies with rules ensuring performant operation. By specifically checking critical rules, such as ECS components being in an <code>unmanaged</code> (unmanaged) structure, at the compilation (compile) stage, it prevents memory errors and GC delays that might occur at runtime before they even happen.</p>"},{"location":"API_References/NexusAnalyzer_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The analyzer monitors the following rules and techniques: - Unmanaged Constraint (NX001): Checks if all structs used as ECS components are <code>unmanaged</code>. If a managed data type like <code>string</code> or <code>class</code> is found within the struct, it throws an error (Error). - Diagnostic Descriptor: Provides errors in the standard .NET <code>DiagnosticId</code> (e.g., NX001) format, ensuring IDE (Visual Studio/Rider) integration. - Concurrent Execution: Performs the analysis process using all processor cores, thus not slowing down the IDE speed in large projects. - In-IDE Guidance: Instantly explains to the developer the reason for the error and how to resolve it (e.g., \"Struct must be unmanaged\").</p>"},{"location":"API_References/NexusAnalyzer_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Triggering: The analyzer is deployed when a developer saves a file in the IDE or when the project is compiled.</li> <li>Semantic Analysis: Beyond code syntax (syntax), the actual nature of data types (whether they are unmanaged) is examined.</li> <li>Rule Checking: Identified symbols (structs) are tested according to the criteria in the <code>Rule</code> list.</li> <li>Reporting: If there is a violation, a red underline and explanatory text appear on the exact line of code.</li> </ol>"},{"location":"API_References/NexusAnalyzer_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Diagnostic Analyzer: A compiler plugin that identifies errors or improvement opportunities in code.</li> <li>Unmanaged Type: A data type whose memory management is not performed by the Garbage Collector and which is stored in raw memory.</li> <li>Severity (DiagnosticSeverity): The level of importance of an analysis finding (Info, Warning, Error).</li> <li>Semantics: The meaning and type hierarchy of the code (not just spelling rules).</li> </ul>"},{"location":"API_References/NexusAnalyzer_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>False Positives: The analyzer may sometimes mistake structs that are not ECS components for ECS components. Namespace or attribute filters should be precisely adjusted to prevent these situations.</li> </ul>"},{"location":"API_References/NexusAnalyzer_eng/#usage-example","title":"Usage Example","text":"<pre><code>// Faulty Code\npublic struct PlayerData {\n    public string Name; // ERROR: NX001 - Managed string cannot be used.\n}\n\n// Correct Code\npublic struct PlayerData {\n    public NexusString32 Name; // CORRECT: Unmanaged text.\n}\n</code></pre>"},{"location":"API_References/NexusAnalyzer_eng/#nexus-optimization-tip-zero-gc-policy","title":"Nexus Optimization Tip: Zero-GC Policy","text":"<p>NEVER suppress (ignore) NexusAnalyzer errors. These errors are your greatest assurance in maintaining the fluidity (Fluidity) of your game by 100% preventing the Garbage Collector from running in your project.</p>"},{"location":"API_References/NexusAnalyzer_eng/#original-source","title":"Original Source","text":"<p>NexusAnalyzer.cs Source Code</p>"},{"location":"API_References/NexusAnalyzer_tr/","title":"API Referans\u0131: NexusAnalyzer (Statik G\u00fcvenlik Analizcisi)","text":""},{"location":"API_References/NexusAnalyzer_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusAnalyzer.cs</code>, Nexus Prime geli\u015ftirme s\u00fcrecinin \"g\u00fcvenlik g\u00f6revlisidir\". Roslyn tabanl\u0131 bu ara\u00e7, kodun sadece do\u011fru yaz\u0131lmas\u0131n\u0131 de\u011fil, ayn\u0131 zamanda performansl\u0131 \u00e7al\u0131\u015fmas\u0131n\u0131 sa\u011flayacak kurallara uymas\u0131n\u0131 da denetler. \u00d6zellikle ECS bile\u015fenlerinin <code>unmanaged</code> (y\u00f6netilmeyen) yap\u0131da olmas\u0131 gibi kritik kurallar\u0131 derleme (compile) a\u015famas\u0131nda kontrol ederek, \u00e7al\u0131\u015fma zaman\u0131nda olu\u015fabilecek bellek hatalar\u0131n\u0131 ve GC gecikmelerini daha olu\u015fmadan engeller.</p>"},{"location":"API_References/NexusAnalyzer_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Analizci \u015fu kurallar\u0131 ve teknikleri denetler: - Unmanaged Constraint (NX001): ECS bile\u015feni olarak kullan\u0131lan t\u00fcm struct'lar\u0131n <code>unmanaged</code> olup olmad\u0131\u011f\u0131n\u0131 kontrol eder. E\u011fer struct i\u00e7inde <code>string</code> veya <code>class</code> gibi managed bir veri bulunursa hata (Error) f\u0131rlat\u0131r. - Diagnostic Descriptor: Hatalar\u0131 standart .NET <code>DiagnosticId</code> (\u00d6rn: NX001) format\u0131nda sunarak IDE (Visual Studio/Rider) entegrasyonu sa\u011flar. - Concurrent Execution: Analiz i\u015flemini t\u00fcm i\u015flemci \u00e7ekirdeklerini kullanarak ger\u00e7ekle\u015ftirir, b\u00f6ylece b\u00fcy\u00fck projelerde IDE h\u0131z\u0131n\u0131 yava\u015flatmaz. - In-IDE Guidance: Geli\u015ftiriciye hatan\u0131n nedenini ve nas\u0131l \u00e7\u00f6z\u00fclece\u011fini (\u00d6rn: \"Struct must be unmanaged\") anl\u0131k olarak a\u00e7\u0131klar.</p>"},{"location":"API_References/NexusAnalyzer_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tetiklenme: Geli\u015ftirici IDE'de bir dosya kaydetti\u011finde veya proje derlendi\u011finde analizci devreye girer.</li> <li>Semantik Analiz: Kodun s\u00f6zdizimi (syntax) \u00f6tesinde, veri tiplerinin ger\u00e7ek do\u011fas\u0131 (unmanaged olup olmad\u0131\u011f\u0131) incelenir.</li> <li>Kural Kontrol\u00fc: Belirlenen semboller (structlar) <code>Rule</code> listesindeki kriterlere g\u00f6re test edilir.</li> <li>Raporlama: E\u011fer bir ihlal varsa, kodun tam sat\u0131r\u0131nda k\u0131rm\u0131z\u0131 alt \u00e7izgi ve a\u00e7\u0131klay\u0131c\u0131 metin belirir.</li> </ol>"},{"location":"API_References/NexusAnalyzer_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Diagnostic Analyzer: Kod \u00fczerindeki hatalar\u0131 veya iyile\u015ftirme f\u0131rsatlar\u0131n\u0131 tespit eden derleyici eklentisi.</li> <li>Unmanaged Type: Bellek y\u00f6netimi Garbage Collector taraf\u0131ndan yap\u0131lmayan, ham bellek \u00fczerinde saklanan veri tipi.</li> <li>Severity (DiagnosticSeverity): Bir analiz bulgusunun \u00f6nem derecesi (Info, Warning, Error).</li> <li>Semantics: Kodun anlam\u0131 ve tip hiyerar\u015fisi (sadece yaz\u0131m kurallar\u0131 de\u011fil).</li> </ul>"},{"location":"API_References/NexusAnalyzer_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>False Positives: Analizci bazen ECS bile\u015feni olmayan struct'lar\u0131 da ECS bile\u015feni sanabilir. Bu durumlar\u0131 \u00f6nlemek i\u00e7in namespace veya attribute filtreleri hassas ayarlanmal\u0131d\u0131r.</li> </ul>"},{"location":"API_References/NexusAnalyzer_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Hatal\u0131 Kod\npublic struct PlayerData {\n    public string Name; // HATA: NX001 - Managed string kullan\u0131lamaz.\n}\n\n// Do\u011fru Kod\npublic struct PlayerData {\n    public NexusString32 Name; // DO\u011eRU: Unmanaged text.\n}\n</code></pre>"},{"location":"API_References/NexusAnalyzer_tr/#nexus-optimization-tip-zero-gc-policy","title":"Nexus Optimization Tip: Zero-GC Policy","text":"<p>NexusAnalyzer hatalar\u0131n\u0131 ASLA bast\u0131rmay\u0131n (ignore). Bu hatalar, projenizde Garbage Collector'\u0131n \u00e7al\u0131\u015fmas\u0131n\u0131 %100 engelleyerek oyununuzun ak\u0131c\u0131l\u0131\u011f\u0131n\u0131 (Fluidity) koruyan en b\u00fcy\u00fck g\u00fcvencenizdir.</p>"},{"location":"API_References/NexusAnalyzer_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusAnalyzer.cs Kaynak Kodu</p>"},{"location":"API_References/NexusAnimatorStateMachine_eng/","title":"Nexus Prime Architectural Manual: NexusAnimatorStateMachine (Animation Manager Wrapper)","text":""},{"location":"API_References/NexusAnimatorStateMachine_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusAnimatorStateMachine.cs</code> is a helper class that wraps Unity's complex <code>Animator</code> component with a more manageable and clean API. It standardizes the code-side control of animations and simplifies layer-based (layer) operations.</p> <p>The reason for this wrapper's existence is to make frequently used operations like <code>animator.Play(\"State\")</code> safer and to be able to send commands to all layers in a single line, especially in multi-layer animation setups (e.g., both body and face animations).</p>"},{"location":"API_References/NexusAnimatorStateMachine_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Offers the following capabilities for high-level animation management:</p> <ul> <li>Clean Playback API: Can target a specific state and layer with the <code>Play</code> method. Prevents runtime errors as null checks are done internally.</li> <li>Multi-Layer Synchronization: The <code>PlayAllLayers</code> method moves all animation layers to the same state with a single command. This is critical for synchronized movements.</li> <li>Layer Indexing: Simplifies finding indexes according to layer names.</li> <li>Serializable Support: Since it's designed as a class (class), it can be stored as <code>[SerializeField]</code> within other components and assigned from the Inspector.</li> </ul>"},{"location":"API_References/NexusAnimatorStateMachine_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Initialization: The class is created with an existing Unity Animator instance.</li> <li>Query: Indexes of relevant animation layers are sapted.</li> <li>Execution: <code>Play</code> or <code>PlayAllLayers</code> is triggered according to signals coming from logic systems (Logic).</li> <li>Error Management: Even if the Animator reference is lost or corrupted, the code continues to run safely (Silent Fail).</li> </ol>"},{"location":"API_References/NexusAnimatorStateMachine_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>public class CharacterVisual : MonoBehaviour {\n    [SerializeField] private Animator _unityAnimator;\n    private NexusAnimatorStateMachine _stateMachine;\n\n    void Awake() =&gt; _stateMachine = new NexusAnimatorStateMachine(_unityAnimator);\n\n    public void TriggerDeath() {\n        _stateMachine.PlayAllLayers(\"Death\");\n    }\n}\n</code></pre>"},{"location":"API_References/NexusAnimatorStateMachine_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\n[System.Serializable]\npublic class NexusAnimatorStateMachine\n{\n    [SerializeField] private Animator _animator;\n\n    public void Play(string stateName, int layer = 0) {\n        if (_animator != null) _animator.Play(stateName, layer);\n    }\n\n    public void PlayAllLayers(string stateName) {\n        if (_animator == null) return;\n        for (int i = 0; i &lt; _animator.layerCount; i++) _animator.Play(stateName, i);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusAnimatorStateMachine_eng/#nexus-optimization-tip-string-to-hash","title":"Nexus Optimization Tip: String to Hash","text":"<p>For higher performance, instead of giving a string to the <code>Play</code> method, store and use IDs created with <code>Animator.StringToHash()</code>. This reduces animation triggering cost by 15-20%.</p>"},{"location":"API_References/NexusAnimatorStateMachine_tr/","title":"Nexus Prime Mimari Rehberi: NexusAnimatorStateMachine (Animasyon Y\u00f6netici Wrapper)","text":""},{"location":"API_References/NexusAnimatorStateMachine_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusAnimatorStateMachine.cs</code>, Unity'nin karma\u015f\u0131k <code>Animator</code> bile\u015fenini daha y\u00f6netilebilir ve temiz bir API ile sarmalayan bir yard\u0131mc\u0131 s\u0131n\u0131ft\u0131r. Animasyonlar\u0131n kod taraf\u0131ndaki kontrol\u00fcn\u00fc standartla\u015ft\u0131r\u0131r ve katman (layer) bazl\u0131 i\u015flemleri basitle\u015ftirir.</p> <p>Bu sarmalay\u0131c\u0131n\u0131n varl\u0131k sebebi; <code>animator.Play(\"State\")</code> gibi s\u0131k kullan\u0131lan i\u015flemleri daha g\u00fcvenli hale getirmek ve \u00f6zellikle \u00e7ok katmanl\u0131 animasyon setup'lar\u0131nda (\u00d6rn: Hem v\u00fccut hem y\u00fcz animasyonu) tek sat\u0131rda t\u00fcm katmanlara komut g\u00f6nderebilmektir.</p>"},{"location":"API_References/NexusAnimatorStateMachine_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Y\u00fcksek seviyeli animasyon y\u00f6netimi i\u00e7in \u015fu yetenekleri sunar:</p> <ul> <li>Clean Playback API: <code>Play</code> metodu ile belirli bir state'i ve katman\u0131 hedefleyebilir. Null kontrol\u00fc dahili olarak yap\u0131ld\u0131\u011f\u0131 i\u00e7in runtime hatalar\u0131n\u0131 \u00f6nler.</li> <li>Multi-Layer Synchronization: <code>PlayAllLayers</code> metodu, tek bir komutla t\u00fcm animasyon katmanlar\u0131n\u0131 ayn\u0131 state'e ge\u00e7irir. Bu, senkronize hareketler i\u00e7in kritiktir.</li> <li>Layer Indexing: Katman isimlerine g\u00f6re index bulma i\u015flemlerini basitle\u015ftirir.</li> <li>Serializable Support: Bir s\u0131n\u0131f (class) olarak tasarland\u0131\u011f\u0131 i\u00e7in di\u011fer bile\u015fenlerin i\u00e7inde <code>[SerializeField]</code> olarak saklanabilir ve Inspector'dan atanabilir.</li> </ul>"},{"location":"API_References/NexusAnimatorStateMachine_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130lklendirme: Mevcut bir Unity Animator \u00f6rne\u011fi ile s\u0131n\u0131f olu\u015fturulur.</li> <li>Sorgulama: \u0130lgili animasyon katmanlar\u0131n\u0131n indexleri saptan\u0131r.</li> <li>Y\u00fcr\u00fct\u00fcm: Mant\u0131k sistemlerinden (Logic) gelen sinyallere g\u00f6re <code>Play</code> veya <code>PlayAllLayers</code> tetiklenir.</li> <li>Hata Y\u00f6netimi: Animator referans\u0131 kaybolsa veya bozulsa dahi kod g\u00fcvenli bir \u015fekilde (Silent Fail) \u00e7al\u0131\u015fmaya devam eder.</li> </ol>"},{"location":"API_References/NexusAnimatorStateMachine_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public class CharacterVisual : MonoBehaviour {\n    [SerializeField] private Animator _unityAnimator;\n    private NexusAnimatorStateMachine _stateMachine;\n\n    void Awake() =&gt; _stateMachine = new NexusAnimatorStateMachine(_unityAnimator);\n\n    public void TriggerDeath() {\n        _stateMachine.PlayAllLayers(\"Death\");\n    }\n}\n</code></pre>"},{"location":"API_References/NexusAnimatorStateMachine_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\n[System.Serializable]\npublic class NexusAnimatorStateMachine\n{\n    [SerializeField] private Animator _animator;\n\n    public void Play(string stateName, int layer = 0) {\n        if (_animator != null) _animator.Play(stateName, layer);\n    }\n\n    public void PlayAllLayers(string stateName) {\n        if (_animator == null) return;\n        for (int i = 0; i &lt; _animator.layerCount; i++) _animator.Play(stateName, i);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusAnimatorStateMachine_tr/#nexus-optimization-tip-string-to-hash","title":"Nexus Optimization Tip: String to Hash","text":"<p>Daha y\u00fcksek performans i\u00e7in <code>Play</code> metoduna string vermek yerine, <code>Animator.StringToHash()</code> ile olu\u015fturulmu\u015f ID'leri saklay\u0131n ve bu ID'leri kullan\u0131n. Bu, animasyon tetikleme maliyetini %15-20 oran\u0131nda azalt\u0131r.</p>"},{"location":"API_References/NexusAttributeWrappers_eng/","title":"Nexus Prime Architectural Manual: NexusAttributeWrappers (Managed-Unmanaged Data Bridge)","text":""},{"location":"API_References/NexusAttributeWrappers_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusAttributeWrappers.cs</code> is a \"Serialization Bridge\" that connects Nexus Prime's unmanaged data structures to Unity's managed world and specifically to the <code>Inspector</code> panel. Unmanaged structs (e.g., <code>NexusAttribute</code>) cannot be edited directly by the Unity Inspector; this library removes this obstacle.</p> <p>The reason for these wrappers' existence is to enable the developer to edit initial data (Health, Range, etc.) using the Unity Editor's comfortable interface, instead of manually coding the unmanaged memory structure.</p>"},{"location":"API_References/NexusAttributeWrappers_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Offers managed wrappers for two main data types:</p> <ul> <li>NexusAttributeWrapper: The managed version of the <code>NexusAttribute</code> (<code>Current/Max</code>) structure. With the <code>ToUnmanaged()</code> method, it converts data entered from the Inspector into a pure struct form that can be written to unmanaged memory addresses.</li> <li>NexusMinMaxWrapper: Wraps the <code>NexusMinMax&lt;float&gt;</code> structure. Allows designers to easily enter \"Minimum\" and \"Maximum\" numerical ranges from the Unity interface.</li> <li>Bi-Directional Sync: Thanks to <code>FromUnmanaged</code> methods, it ensures that unmanaged data changed during the game appears on the Inspector again (for Debug purposes).</li> </ul>"},{"location":"API_References/NexusAttributeWrappers_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Definition: Defined as <code>public NexusAttributeWrapper StartHealth;</code> within a <code>MonoBehaviour</code>.</li> <li>Design: The developer enters values (e.g., 100/100) via the Unity Inspector.</li> <li>Conversion: <code>ToUnmanaged()</code> is called when the object is created and data is copied to the unmanaged area within the Nexus Registry.</li> <li>Feedback: If unmanaged data changes, visual values in the Editor can be updated by calling <code>FromUnmanaged()</code>.</li> </ol>"},{"location":"API_References/NexusAttributeWrappers_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>public class CharacterConfig : MonoBehaviour {\n    public NexusAttributeWrapper Health;\n\n    public void ApplyToEntity(EntityId id, Registry registry) {\n        // Transfer data from Inspector to unmanaged world\n        registry.Set(id, Health.ToUnmanaged());\n    }\n}\n</code></pre>"},{"location":"API_References/NexusAttributeWrappers_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\n[Serializable]\npublic class NexusAttributeWrapper\n{\n    public float CurrentValue;\n    public float MaxValue;\n\n    public NexusAttribute ToUnmanaged() =&gt; new NexusAttribute { Current = CurrentValue, Max = MaxValue };\n\n    public void FromUnmanaged(NexusAttribute attr) {\n        CurrentValue = attr.Current;\n        MaxValue = attr.Max;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusAttributeWrappers_eng/#nexus-optimization-tip-one-way-initialization","title":"Nexus Optimization Tip: One-Way Initialization","text":"<p>For performance, use wrapper classes only for loading \"Initial Data\" (Initial Data). Trying to write unmanaged data back to the wrapper every frame during the game (Sync-back) can create unnecessary CPU cost and Garbage (GC), especially in thousands of entities. Keep bidirectional synchronization active only in debug mode.</p>"},{"location":"API_References/NexusAttributeWrappers_tr/","title":"Nexus Prime Mimari Rehberi: NexusAttributeWrappers (Managed-Unmanaged Veri K\u00f6pr\u00fcs\u00fc)","text":""},{"location":"API_References/NexusAttributeWrappers_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusAttributeWrappers.cs</code>, Nexus Prime'\u0131n unmanaged veri yap\u0131lar\u0131n\u0131 Unity'nin managed d\u00fcnyas\u0131na ve \u00f6zellikle de <code>Inspector</code> paneline ba\u011flayan bir \"Serile\u015ftirme K\u00f6pr\u00fcs\u00fc\"d\u00fcr. Unmanaged struct'lar (\u00d6rn: <code>NexusAttribute</code>) Unity Inspector taraf\u0131ndan do\u011frudan d\u00fczenlenemez; bu k\u00fct\u00fcphane bu engeli ortadan kald\u0131r\u0131r.</p> <p>Bu sarmalay\u0131c\u0131lar\u0131n varl\u0131k sebebi; geli\u015ftiricinin unmanaged bellek yap\u0131s\u0131n\u0131 elle kodlamak yerine, Unity Edit\u00f6r\u00fc'n\u00fcn konforlu aray\u00fcz\u00fcn\u00fc kullanarak ba\u015flang\u0131\u00e7 verilerini (Can, Menzil vb.) d\u00fczenleyebilmesini sa\u011flamakt\u0131r.</p>"},{"location":"API_References/NexusAttributeWrappers_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>\u0130ki ana veri tipi i\u00e7in managed sarmalay\u0131c\u0131lar sunar:</p> <ul> <li>NexusAttributeWrapper: <code>NexusAttribute</code> (<code>Current/Max</code>) yap\u0131s\u0131n\u0131n managed halidir. <code>ToUnmanaged()</code> metodu ile Inspector'dan girilen veriyi unmanaged bellek adreslerine yaz\u0131labilecek saf struct formuna d\u00f6n\u00fc\u015ft\u00fcr\u00fcr.</li> <li>NexusMinMaxWrapper: <code>NexusMinMax&lt;float&gt;</code> yap\u0131s\u0131n\u0131 sarar. Tasar\u0131mc\u0131lar\u0131n \"Minimum\" ve \"Maksimum\" say\u0131sal aral\u0131klar\u0131 Unity aray\u00fcz\u00fcnden kolayca girmesine olanak tan\u0131r.</li> <li>Bi-Directional Sync: <code>FromUnmanaged</code> metodlar\u0131 sayesinde, oyun s\u0131ras\u0131nda de\u011fi\u015fen unmanaged verilerin tekrar Inspector \u00fczerinde (Debug ama\u00e7l\u0131) g\u00f6r\u00fcnmesini sa\u011flar.</li> </ul>"},{"location":"API_References/NexusAttributeWrappers_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tan\u0131mlama: Bir <code>MonoBehaviour</code> i\u00e7inde <code>public NexusAttributeWrapper StartHealth;</code> \u015feklinde tan\u0131mlan\u0131r.</li> <li>Tasar\u0131m: Geli\u015ftirici Unity Inspector \u00fczerinden de\u011ferleri (\u00d6rn: 100/100) girer.</li> <li>D\u00f6n\u00fc\u015ft\u00fcrme: Nesne olu\u015fturuldu\u011funda <code>ToUnmanaged()</code> \u00e7a\u011fr\u0131l\u0131r ve veri Nexus Registry i\u00e7indeki unmanaged alana kopyalan\u0131r.</li> <li>Geribildirim: E\u011fer unmanaged veri de\u011fi\u015firse, <code>FromUnmanaged()</code> \u00e7a\u011fr\u0131larak Edit\u00f6rdeki g\u00f6rsel de\u011ferler g\u00fcncellenebilir.</li> </ol>"},{"location":"API_References/NexusAttributeWrappers_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public class CharacterConfig : MonoBehaviour {\n    public NexusAttributeWrapper Health;\n\n    public void ApplyToEntity(EntityId id, Registry registry) {\n        // Inspector'dan gelen veriyi unmanaged d\u00fcnyaya aktar\n        registry.Set(id, Health.ToUnmanaged());\n    }\n}\n</code></pre>"},{"location":"API_References/NexusAttributeWrappers_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\n[Serializable]\npublic class NexusAttributeWrapper\n{\n    public float CurrentValue;\n    public float MaxValue;\n\n    public NexusAttribute ToUnmanaged() =&gt; new NexusAttribute { Current = CurrentValue, Max = MaxValue };\n\n    public void FromUnmanaged(NexusAttribute attr) {\n        CurrentValue = attr.Current;\n        MaxValue = attr.Max;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusAttributeWrappers_tr/#nexus-optimization-tip-one-way-initialization","title":"Nexus Optimization Tip: One-Way Initialization","text":"<p>Performans i\u00e7in, wrapper s\u0131n\u0131flar\u0131 sadece \"Ba\u015flang\u0131\u00e7 Verisi\" (Initial Data) y\u00fcklemede kullan\u0131n. Oyun s\u0131ras\u0131nda her karede unmanaged veriyi wrapper'a geri yazmaya \u00e7al\u0131\u015fmak (Sync-back), \u00f6zellikle binlerce varl\u0131kta gereksiz CPU maliyeti ve Garbage (GC) olu\u015fturabilir. Sadece debug modunda \u00e7ift y\u00f6nl\u00fc senkronizasyonu aktif tutun.</p>"},{"location":"API_References/NexusAttributesSuite_eng/","title":"Nexus Prime Architectural Manual: NexusAttributesSuite (Advanced Attribute Set)","text":""},{"location":"API_References/NexusAttributesSuite_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusAttributesSuite.cs</code> is the \"Advanced Helpers\" set taking the developer experience (UX) and performance measurement to the highest level in Nexus Prime projects. While keeping the codebase clean, it converts the Inspector interface into a professional control panel.</p> <p>The reason for this set's existence is to group complex object structures (<code>Foldout</code>), provide conditional visibility (<code>ConditionalField</code>), and measure the performance of critical methods instantaneously (<code>Benchmark</code>).</p>"},{"location":"API_References/NexusAttributesSuite_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The Suite package offers the following advanced capabilities:</p> <ul> <li>UX Modules:</li> <li>[Foldout]: Divides massive variable lists into collapsible (collapsible) blocks under headers.</li> <li>[ConditionalField]: Connects an area's visibility to the value of another variable (e.g., show AI settings if \"HasAI\" is true).</li> <li>[Tag &amp; Layer Selection]: Converts string or int fields into selectable interfaces (Dropdown) from Unity's Tag and Layer lists.</li> <li>Performance &amp; Engineering Modules:</li> <li>[Benchmark]: Measures and logs the method's running time in milliseconds. It is invaluable in optimization processes.</li> <li>[NexusInlined]: Whispers to the Source Generator that this method should be taken inline (inline) for performance.</li> <li>[LockInPlayMode]: Prevents critical settings from being changed while the game is running and simulation from being broken.</li> </ul>"},{"location":"API_References/NexusAttributesSuite_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Decoration: The developer marks the relevant field with a tag like <code>[ConditionalField(\"UsePhysics\")]</code>.</li> <li>Custom Drawing (Drawer): Classes like <code>OptionalValuesDrawer</code> offer smarter UI elements by overriding (overwriting) standard Unity drawing.</li> <li>Messaging: When a value changes with the <code>OnValueChanged</code> tag, a method is automatically triggered, starting a reactive flow.</li> </ol>"},{"location":"API_References/NexusAttributesSuite_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>[Foldout(\"AI Settings\")]\npublic bool LookAtTarget;\n\n[ConditionalField(\"LookAtTarget\")]\n[ValidationRule(0, 100)]\npublic float RotationSpeed;\n\n[Benchmark]\npublic void CalculatePath() { ... }\n</code></pre>"},{"location":"API_References/NexusAttributesSuite_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Attributes;\n\npublic class FoldoutAttribute : PropertyAttribute {\n    public string Name { get; }\n    public FoldoutAttribute(string name) =&gt; Name = name;\n}\n\npublic class BenchmarkAttribute : Attribute { }\n\npublic class OnValueChangedAttribute : PropertyAttribute {\n    public string MethodName { get; }\n    public OnValueChangedAttribute(string m) =&gt; MethodName = m;\n}\n</code></pre>"},{"location":"API_References/NexusAttributesSuite_eng/#nexus-optimization-tip-searchable-lists","title":"Nexus Optimization Tip: Searchable Lists","text":"<p>The <code>[Searchable]</code> attribute offers a search bar in lists with thousands of elements (e.g., Item Database). This not only increases Editor speed but also can increase Editor performance by 30% by reducing the Inspector drawing load (Draw Calls) of massive arrays only to visible elements.</p>"},{"location":"API_References/NexusAttributesSuite_tr/","title":"Nexus Prime Mimari Rehberi: NexusAttributesSuite (Geli\u015fmi\u015f \u00d6znitelik Seti)","text":""},{"location":"API_References/NexusAttributesSuite_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusAttributesSuite.cs</code>, Nexus Prime projelerinde geli\u015ftirici deneyimini (UX) ve performans \u00f6l\u00e7\u00fcm\u00fcn\u00fc en \u00fcst seviyeye ta\u015f\u0131yan \"Geli\u015fmi\u015f Yard\u0131mc\u0131lar\" setidir. Kod taban\u0131n\u0131 temiz tutarken, Inspector aray\u00fcz\u00fcn\u00fc profesyonel bir kontrol paneline d\u00f6n\u00fc\u015ft\u00fcr\u00fcr.</p> <p>Bu setin varl\u0131k sebebi; karma\u015f\u0131k nesne yap\u0131lar\u0131n\u0131 grupland\u0131rmak (<code>Foldout</code>), ko\u015fullu g\u00f6r\u00fcn\u00fcrl\u00fck sa\u011flamak (<code>ConditionalField</code>) ve kritik metodlar\u0131n performans\u0131n\u0131 anl\u0131k olarak \u00f6l\u00e7mektir (<code>Benchmark</code>).</p>"},{"location":"API_References/NexusAttributesSuite_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Suite paketi \u015fu ileri seviye yetenekleri sunar:</p> <ul> <li>UX Mod\u00fclleri:</li> <li>[Foldout]: Devasa de\u011fi\u015fken listelerini ba\u015fl\u0131klar alt\u0131nda daralt\u0131labilir (collapsible) bloklara b\u00f6ler.</li> <li>[ConditionalField]: Bir alan\u0131n g\u00f6r\u00fcn\u00fcrl\u00fc\u011f\u00fcn\u00fc, ba\u015fka bir de\u011fi\u015fkenin de\u011ferine ba\u011flar (\u00d6rn: \"HasAI\" true ise AI ayarlar\u0131n\u0131 g\u00f6ster).</li> <li>[Tag &amp; Layer Selection]: String veya int alanlar\u0131n\u0131 Unity'nin Tag ve Layer listelerinden se\u00e7ilebilir aray\u00fczlere (Dropdown) d\u00f6n\u00fc\u015ft\u00fcr\u00fcr.</li> <li>Performans &amp; M\u00fchendislik Mod\u00fclleri:</li> <li>[Benchmark]: Metodun \u00e7al\u0131\u015fma s\u00fcresini milisaniye cinsinden \u00f6l\u00e7er ve loglar. Optimizasyon s\u00fcre\u00e7lerinde paha bi\u00e7ilemezdir.</li> <li>[NexusInlined]: Source Generator'a bu metodun performans i\u00e7in sat\u0131r i\u00e7ine (inline) al\u0131nmas\u0131 gerekti\u011fini f\u0131s\u0131ldar.</li> <li>[LockInPlayMode]: Oyun \u00e7al\u0131\u015f\u0131rken kritik ayarlar\u0131n de\u011fi\u015ftirilip sim\u00fclasyonun bozulmas\u0131n\u0131 \u00f6nler.</li> </ul>"},{"location":"API_References/NexusAttributesSuite_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Dekorasyon: Geli\u015ftirici ilgili alan\u0131 <code>[ConditionalField(\"UsePhysics\")]</code> gibi bir etiketle i\u015faretler.</li> <li>\u00d6zel \u00c7izim (Drawer): <code>OptionalValuesDrawer</code> gibi s\u0131n\u0131flar, standart Unity \u00e7izimini override ederek (\u00fczerine yazarak) daha ak\u0131ll\u0131 UI elemanlar\u0131 sunar.</li> <li>Mesajla\u015fma: <code>OnValueChanged</code> etiketi ile bir de\u011fer de\u011fi\u015fti\u011finde otomatik olarak bir metod tetiklenerek reaktif bir ak\u0131\u015f ba\u015flat\u0131l\u0131r.</li> </ol>"},{"location":"API_References/NexusAttributesSuite_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>[Foldout(\"AI Settings\")]\npublic bool LookAtTarget;\n\n[ConditionalField(\"LookAtTarget\")]\n[ValidationRule(0, 100)]\npublic float RotationSpeed;\n\n[Benchmark]\npublic void CalculatePath() { ... }\n</code></pre>"},{"location":"API_References/NexusAttributesSuite_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Attributes;\n\npublic class FoldoutAttribute : PropertyAttribute {\n    public string Name { get; }\n    public FoldoutAttribute(string name) =&gt; Name = name;\n}\n\npublic class BenchmarkAttribute : Attribute { }\n\npublic class OnValueChangedAttribute : PropertyAttribute {\n    public string MethodName { get; }\n    public OnValueChangedAttribute(string m) =&gt; MethodName = m;\n}\n</code></pre>"},{"location":"API_References/NexusAttributesSuite_tr/#nexus-optimization-tip-searchable-lists","title":"Nexus Optimization Tip: Searchable Lists","text":"<p><code>[Searchable]</code> \u00f6zniteli\u011fi, binlerce elemanl\u0131 listelerde (\u00d6rn: Item Database) arama bar\u0131 sunar. Bu, sadece Edit\u00f6r h\u0131z\u0131n\u0131 art\u0131rmakla kalmaz, ayn\u0131 zamanda devasa dizilerin Inspector'da \u00e7izilme y\u00fck\u00fcn\u00fc (Draw Calls) sadece g\u00f6r\u00fcn\u00fcr elemanlara indirgeyerek Edit\u00f6r performans\u0131n\u0131 %30 art\u0131rabilir.</p>"},{"location":"API_References/NexusAttributes_eng/","title":"Nexus Prime Architectural Manual: NexusAttributes (Engineering Attributes)","text":""},{"location":"API_References/NexusAttributes_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusAttributes.cs</code> is an \"Attribute Package\" that both organizes Unity Inspector visualization and gives hints about data management to the Nexus ECS system. It is the metadata layer determining how the code will behave on both the editor side and the unmanaged simulation side.</p> <p>The reason for these attributes' existence is to control data security (<code>ReadOnly</code>), visual hierarchy (<code>ProgressBar</code>), and system behaviors (<code>Sync</code>, <code>Persistent</code>) without writing extra code, using the \"Decoration\" (Decoration) logic.</p>"},{"location":"API_References/NexusAttributes_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The package includes two main types of attribute groups:</p>"},{"location":"API_References/NexusAttributes_eng/#a-visual-editor-attributes","title":"A. Visual &amp; Editor Attributes","text":"<ul> <li>[ReadOnly]: Makes the field appear in the Inspector but prevents manual changes.</li> <li>[Required]: Marks critical references. Throws a warning in the Inspector if the field is empty.</li> <li>[NexusProgressBar]: Draws numerical values (Health, Energy, etc.) as a visual bar.</li> <li>[MinMaxSlider]: Offers a two-ended (Min/Max) slider within the determined range.</li> </ul>"},{"location":"API_References/NexusAttributes_eng/#b-architectural-ecs-attributes","title":"B. Architectural &amp; ECS Attributes","text":"<ul> <li>[Sync]: Specifies that an unmanaged piece of data will be automatically synchronized with the Unity <code>Transform</code> or <code>Physics</code> world.</li> <li>[Persistent]: Ensures the data is not discarded from memory during scene transitions and is included in the recording (Save) system.</li> <li>[BitPacked]: A flag (for the Source Generator) informing that the data should be compressed at the bit level during transmission.</li> </ul>"},{"location":"API_References/NexusAttributes_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Definition: The developer marks the component field with <code>[Sync]</code> or <code>[ReadOnly]</code>.</li> <li>Editor Analysis: Unity's <code>PropertyDrawer</code> mechanism sees this flag and performs custom drawing.</li> <li>Simulation Integration: Nexus Source Generator produces automatic synchronization code for fields tagged with <code>[Sync]</code>.</li> <li>Persistence: Data tagged with <code>[Persistent]</code> are automatically captured by the <code>SnapshotManager</code>.</li> </ol>"},{"location":"API_References/NexusAttributes_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>public struct HealthComponent : INexusComponent {\n    [NexusProgressBar(100, \"Red\")]\n    public float Current;\n\n    [Sync(SyncTarget.UI)]\n    public float Max;\n}\n\n[Persistent]\npublic struct PlayerData : INexusComponent { ... }\n</code></pre>"},{"location":"API_References/NexusAttributes_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Attributes;\n\npublic class ReadOnlyAttribute : PropertyAttribute { }\npublic class RequiredAttribute : PropertyAttribute { }\npublic class SyncAttribute : Attribute {\n    public SyncTarget Target { get; }\n    public SyncAttribute(SyncTarget target = SyncTarget.Transform) =&gt; Target = target;\n}\n</code></pre>"},{"location":"API_References/NexusAttributes_eng/#nexus-optimization-tip-attribute-stripping","title":"Nexus Optimization Tip: Attribute Stripping","text":"<p>Architectural attributes like <code>[Persistent]</code> or <code>[Sync]</code> are only read by systems at runtime. However, visual attributes like <code>[ReadOnly]</code> are only needed in the Editor (outside the Build). Consider including Editor-only attributes within <code>#if UNITY_EDITOR</code> blocks to reduce the build size.</p>"},{"location":"API_References/NexusAttributes_tr/","title":"Nexus Prime Mimari Rehberi: NexusAttributes (M\u00fchendislik \u00d6znitelikleri)","text":""},{"location":"API_References/NexusAttributes_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusAttributes.cs</code>, hem Unity Inspector g\u00f6rselle\u015ftirmesini d\u00fczenleyen hem de Nexus ECS sistemine veri y\u00f6netimi hakk\u0131nda ipu\u00e7lar\u0131 veren bir \"\u00d6znitelik Paketi\"dir. Kodun hem edit\u00f6r taraf\u0131nda hem de unmanaged sim\u00fclasyon taraf\u0131nda nas\u0131l davranaca\u011f\u0131n\u0131 belirleyen metadata katman\u0131d\u0131r.</p> <p>Bu \u00f6zniteliklerin varl\u0131k sebebi; \"Decoration\" (S\u00fcsleme) mant\u0131\u011f\u0131n\u0131 kullanarak, ekstra kod yazmadan veri g\u00fcvenli\u011fini (<code>ReadOnly</code>), g\u00f6rsel hiyerar\u015fiyi (<code>ProgressBar</code>) ve sistem davran\u0131\u015flar\u0131n\u0131 (<code>Sync</code>, <code>Persistent</code>) kontrol etmektir.</p>"},{"location":"API_References/NexusAttributes_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Paket i\u00e7inde iki ana tip \u00f6znitelik grubu bulunur:</p>"},{"location":"API_References/NexusAttributes_tr/#a-gorsel-duzenleyici-oznitelikler","title":"A. G\u00f6rsel &amp; D\u00fczenleyici \u00d6znitelikler","text":"<ul> <li>[ReadOnly]: Alan\u0131n Inspector'da g\u00f6r\u00fcnmesini sa\u011flar ancak elle de\u011fi\u015ftirilmesini engeller.</li> <li>[Required]: Kritik referanslar\u0131 i\u015faretler. E\u011fer alan bo\u015fsa Inspector'da uyar\u0131 f\u0131rlat\u0131r.</li> <li>[NexusProgressBar]: Say\u0131sal de\u011ferleri (Can, Enerji vb.) g\u00f6rsel bir bar olarak \u00e7izer.</li> <li>[MinMaxSlider]: Belirlenen aral\u0131kta iki u\u00e7lu (Min/Max) bir kayd\u0131r\u0131c\u0131 sunar.</li> </ul>"},{"location":"API_References/NexusAttributes_tr/#b-mimari-ecs-oznitelikleri","title":"B. Mimari &amp; ECS \u00d6znitelikleri","text":"<ul> <li>[Sync]: Bir unmanaged verinin Unity <code>Transform</code> veya <code>Physics</code> d\u00fcnyas\u0131yla otomatik senkronize edilece\u011fini belirtir.</li> <li>[Persistent]: Verinin sahne ge\u00e7i\u015flerinde bellekten at\u0131lmamas\u0131n\u0131 ve kay\u0131t (Save) sistemine dahil edilmesini sa\u011flar.</li> <li>[BitPacked]: Verinin iletim s\u0131ras\u0131nda bit seviyesinde s\u0131k\u0131\u015ft\u0131r\u0131lmas\u0131 gerekti\u011fini bildiren (Source Generator'a y\u00f6nelik) bir bayrakt\u0131r.</li> </ul>"},{"location":"API_References/NexusAttributes_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tan\u0131mlama: Geli\u015ftirici bile\u015fen alan\u0131n\u0131 <code>[Sync]</code> veya <code>[ReadOnly]</code> ile i\u015faretler.</li> <li>Edit\u00f6r Analizi: Unity'nin <code>PropertyDrawer</code> mekanizmas\u0131 bu bayra\u011f\u0131 g\u00f6r\u00fcr ve \u00f6zel \u00e7izim yapar.</li> <li>Sim\u00fclasyon Entegrasyonu: Nexus Source Generator, <code>[Sync]</code> etiketli alanlar i\u00e7in otomatik senkronizasyon kodunu \u00fcretir.</li> <li>Kal\u0131c\u0131l\u0131k: <code>[Persistent]</code> etiketli veriler <code>SnapshotManager</code> taraf\u0131ndan otomatik olarak yakalan\u0131r.</li> </ol>"},{"location":"API_References/NexusAttributes_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public struct HealthComponent : INexusComponent {\n    [NexusProgressBar(100, \"Red\")]\n    public float Current;\n\n    [Sync(SyncTarget.UI)]\n    public float Max;\n}\n\n[Persistent]\npublic struct PlayerData : INexusComponent { ... }\n</code></pre>"},{"location":"API_References/NexusAttributes_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Attributes;\n\npublic class ReadOnlyAttribute : PropertyAttribute { }\npublic class RequiredAttribute : PropertyAttribute { }\npublic class SyncAttribute : Attribute {\n    public SyncTarget Target { get; }\n    public SyncAttribute(SyncTarget target = SyncTarget.Transform) =&gt; Target = target;\n}\n</code></pre>"},{"location":"API_References/NexusAttributes_tr/#nexus-optimization-tip-attribute-stripping","title":"Nexus Optimization Tip: Attribute Stripping","text":"<p><code>[Persistent]</code> veya <code>[Sync]</code> gibi mimari \u00f6znitelikler sadece \u00e7al\u0131\u015fma zaman\u0131nda sistemler taraf\u0131ndan okunur. Ancak <code>[ReadOnly]</code> gibi g\u00f6rsel \u00f6znitelikler sadece Edit\u00f6r'de (Build d\u0131\u015f\u0131nda) gereklidir. Build boyutunu k\u00fc\u00e7\u00fcltmek i\u00e7in Edit\u00f6r-only \u00f6znitelikleri <code>#if UNITY_EDITOR</code> bloklar\u0131 i\u00e7ine almay\u0131 d\u00fc\u015f\u00fcn\u00fcn.</p>"},{"location":"API_References/NexusAudioLinker_eng/","title":"Nexus Prime Architectural Manual: NexusAudioLinker (Audio-Data Linker)","text":""},{"location":"API_References/NexusAudioLinker_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusAudioLinker.cs</code> is a reactive helper component that connects variables in Nexus Prime's data-driven world (e.g., Speed, Stress level, Energy) to Unity's <code>AudioSource</code> parameters. It is used to strengthen the simulation depth of the game with audio feedback.</p> <p>The reason for this linker's existence is to be able to automatically \"map\" an unmanaged piece of data (float) to properties such as audio pitch (Pitch) or volume (Volume), instead of writing complex scripts for each audio change.</p>"},{"location":"API_References/NexusAudioLinker_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Offers the following capabilities for audio synchronization:</p> <ul> <li>Reactive Parametric Update: Receives raw numerical data coming from the unmanaged world via the <code>UpdateAudio</code> method.</li> <li>Linear Mapping (Lerp): Mathematically converts the incoming raw data (e.g., 0-100 speed) into a range the audio can understand (e.g., 0.5 - 1.5 pitch).</li> <li>Low-Overhead Binding: Minimizes the load on the CPU audio engine by being triggered only when data changes or at determined synchronization intervals.</li> <li>Field-Based Configuration: Which component field (Speed, Health, etc.) will affect which audio parameter can be easily configured via the Inspector.</li> </ul>"},{"location":"API_References/NexusAudioLinker_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Input: A value is read from an unmanaged component on the Nexus Registry.</li> <li>Conversion: The read value is normalized between the determined minimum/maximum ranges.</li> <li>Application: The normalized value is assigned to the <code>AudioSource.pitch</code> or <code>AudioSource.volume</code> property.</li> <li>Result: Dynamic effects such as the engine sound thinning as the vehicle speeds up or the heartbeat sound accelerating as health decreases are obtained.</li> </ol>"},{"location":"API_References/NexusAudioLinker_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>public class CarAudio : MonoBehaviour {\n    [SerializeField] private NexusAudioLinker _engineLinker;\n\n    void Update() {\n        // Transfer 0-200 RPM data coming from Nexus to audio\n        float currentRPM = GetUnmanagedRPM(); \n        _engineLinker.UpdateAudio(currentRPM);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusAudioLinker_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Bridge;\n\npublic class NexusAudioLinker : MonoBehaviour\n{\n    public AudioSource Source;\n\n    public unsafe void UpdateAudio(float value) {\n        if (Source == null) return;\n\n        // Example: Map a value between 0-100 to the 0.5-1.5 pitch range\n        Source.pitch = Mathf.Lerp(0.5f, 1.5f, value / 100f);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusAudioLinker_eng/#nexus-optimization-tip-audio-update-culling","title":"Nexus Optimization Tip: Audio Update Culling","text":"<p>Instead of updating audio parameters of all objects every frame, make <code>UpdateAudio</code> calls only for objects within distance audible to the player (Audio Audibility Range). This can reduce unnecessary processing load on the Audio Thread and CPU by 30%.</p>"},{"location":"API_References/NexusAudioLinker_tr/","title":"Nexus Prime Mimari Rehberi: NexusAudioLinker (Ses-Veri Ba\u011flay\u0131c\u0131)","text":""},{"location":"API_References/NexusAudioLinker_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusAudioLinker.cs</code>, Nexus Prime'\u0131n veri odakl\u0131 d\u00fcnyas\u0131ndaki de\u011fi\u015fkenleri (\u00d6rn: H\u0131z, Stres d\u00fczeyi, Enerji) Unity'nin <code>AudioSource</code> parametrelerine ba\u011flayan reaktif bir yard\u0131mc\u0131 bile\u015fendir. Oyunun sim\u00fclasyon derinli\u011fini sesli geri bildirimlerle g\u00fc\u00e7lendirmek i\u00e7in kullan\u0131l\u0131r.</p> <p>Bu ba\u011flay\u0131c\u0131n\u0131n varl\u0131k sebebi; her ses de\u011fi\u015fikli\u011fi i\u00e7in karma\u015f\u0131k scriptler yazmak yerine, unmanaged bir veriyi (float) sesin perde (Pitch) veya ses y\u00fcksekli\u011fi (Volume) gibi \u00f6zelliklerine otomatik olarak \"map\" edebilmektir.</p>"},{"location":"API_References/NexusAudioLinker_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Ses senkronizasyonu i\u00e7in \u015fu yetenekleri sunar:</p> <ul> <li>Reactive Parametric Update: <code>UpdateAudio</code> metodu arac\u0131l\u0131\u011f\u0131yla unmanaged d\u00fcnyadan gelen ham say\u0131sal verileri al\u0131r.</li> <li>Linear Mapping (Lerp): Gelen ham veriyi (\u00d6rn: 0-100 h\u0131z), sesin anlayabilece\u011fi bir aral\u0131\u011fa (\u00d6rn: 0.5 - 1.5 pitch) matematiksel olarak d\u00f6n\u00fc\u015ft\u00fcr\u00fcr.</li> <li>Low-Overhead Binding: Sadece veri de\u011fi\u015fti\u011finde veya belirlenen senkronizasyon aral\u0131klar\u0131nda tetiklenerek CPU ses motoru \u00fczerindeki y\u00fck\u00fc minimize eder.</li> <li>Field-Based Configuration: Inspector \u00fczerinden hangi bile\u015fen alan\u0131n\u0131n (Speed, Health vb.) hangi ses parametresini etkileyece\u011fi kolayca yap\u0131land\u0131r\u0131labilir.</li> </ul>"},{"location":"API_References/NexusAudioLinker_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Girdi: Nexus Registry \u00fczerindeki bir unmanaged bile\u015fenden de\u011fer okunur.</li> <li>D\u00f6n\u00fc\u015ft\u00fcrme: Okunan de\u011fer, belirlenen minimum/maksimum aral\u0131klar aras\u0131nda normalize edilir.</li> <li>Uygulama: Normalize edilen de\u011fer <code>AudioSource.pitch</code> veya <code>AudioSource.volume</code> \u00f6zelli\u011fine atan\u0131r.</li> <li>Sonu\u00e7: Ara\u00e7 h\u0131zland\u0131k\u00e7a motor sesinin incelmesi veya can azald\u0131k\u00e7a kalp at\u0131\u015f\u0131 sesinin h\u0131zlanmas\u0131 gibi dinamik efektler elde edilir.</li> </ol>"},{"location":"API_References/NexusAudioLinker_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public class CarAudio : MonoBehaviour {\n    [SerializeField] private NexusAudioLinker _engineLinker;\n\n    void Update() {\n        // Nexus'tan gelen 0-200 aras\u0131 RPM verisini sese aktar\n        float currentRPM = GetUnmanagedRPM(); \n        _engineLinker.UpdateAudio(currentRPM);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusAudioLinker_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Bridge;\n\npublic class NexusAudioLinker : MonoBehaviour\n{\n    public AudioSource Source;\n\n    public unsafe void UpdateAudio(float value) {\n        if (Source == null) return;\n\n        // \u00d6rnek: 0-100 aras\u0131ndaki bir de\u011feri 0.5-1.5 pitch aral\u0131\u011f\u0131na map et\n        Source.pitch = Mathf.Lerp(0.5f, 1.5f, value / 100f);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusAudioLinker_tr/#nexus-optimization-tip-audio-update-culling","title":"Nexus Optimization Tip: Audio Update Culling","text":"<p>T\u00fcm nesnelerin ses parametrelerini her karede g\u00fcncellemek yerine, sadece oyuncunun duyabilece\u011fi mesafedeki (Audio Audibility Range) nesneler i\u00e7in <code>UpdateAudio</code> \u00e7a\u011fr\u0131s\u0131 yap\u0131n. Bu, Audio Thread ve CPU \u00fczerindeki gereksiz i\u015flem y\u00fck\u00fcn\u00fc %30 azaltabilir.</p>"},{"location":"API_References/NexusBillboardUI_eng/","title":"Nexus Prime Architectural Manual: NexusBillboardUI (Camera-Facing UI)","text":""},{"location":"API_References/NexusBillboardUI_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusBillboardUI.cs</code> is a \"Visual Alignment\" tool that ensures objects within the 3D world (e.g., health bars, name tags) always rotate to face the active camera. It is integrated from the HypeFire architecture.</p> <p>The reason for this component's existence is to prevent the angle of 2D interface elements in 3D space from being distorted due to camera movements and to ensure that the player can always read this information most clearly.</p>"},{"location":"API_References/NexusBillboardUI_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The component manipulates Unity's transform system as follows:</p> <ul> <li>Camera Locking: Captures the <code>Camera.main</code> reference and equates the rotation of the object to the rotation of the camera.</li> <li>LateUpdate Usage: The rotation update is performed at the <code>LateUpdate</code> phase. This prevents jitters (Jitter) by ensuring the billboard process occurs after the camera's own movement is finished.</li> <li>Performance: Operation cost is extremely low as it only performs rotation equalization.</li> </ul>"},{"location":"API_References/NexusBillboardUI_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Start (Start): The main camera in the scene is sapted.</li> <li>Update (LateUpdate): If the camera is active, the <code>transform.rotation</code> value of the object is synchronized with that of the camera.</li> <li>Result: The object always faces the player straight, no matter how much the camera turns.</li> </ol>"},{"location":"API_References/NexusBillboardUI_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Simply add this script to a World-Space UI Canvas.\n// The health bar will always stay parallel to the camera.\n</code></pre>"},{"location":"API_References/NexusBillboardUI_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\npublic class NexusBillboardUI : MonoBehaviour\n{\n    private Camera _mainCamera;\n\n    private void Start() =&gt; _mainCamera = Camera.main;\n\n    private void LateUpdate() {\n        if (_mainCamera != null) transform.rotation = _mainCamera.transform.rotation;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusBillboardUI_eng/#nexus-optimization-tip-update-culling","title":"Nexus Optimization Tip: Update Culling","text":"<p>If there are many Billboard objects on the screen, dilute this process based on distance from the camera (LOD) instead of doing it every frame. Stopping rotation updates for very distant objects can reduce the Transform processing load by 10% in large scenes.</p>"},{"location":"API_References/NexusBillboardUI_tr/","title":"Nexus Prime Mimari Rehberi: NexusBillboardUI (Kameraya Bakan Aray\u00fcz)","text":""},{"location":"API_References/NexusBillboardUI_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusBillboardUI.cs</code>, 3D d\u00fcnya i\u00e7indeki nesnelerin (\u00d6rn: Can barlar\u0131, isim etiketleri) her zaman aktif kameraya bakacak \u015fekilde d\u00f6nmesini sa\u011flayan bir \"G\u00f6rsel Hizalama\" (Visual Alignment) arac\u0131d\u0131r. HypeFire mimarisinden entegre edilmi\u015ftir.</p> <p>Bu bile\u015fenin varl\u0131k sebebi; 3D uzaydaki 2D aray\u00fcz elemanlar\u0131n\u0131n a\u00e7\u0131s\u0131n\u0131n kamera hareketlerinden dolay\u0131 bozulmas\u0131n\u0131 engellemek ve oyuncunun bu bilgileri her zaman en net \u015fekilde okuyabilmesini sa\u011flamakt\u0131r.</p>"},{"location":"API_References/NexusBillboardUI_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Bile\u015fen, Unity'nin transform sistemini \u015fu \u015fekilde manip\u00fcle eder:</p> <ul> <li>Camera Locking: <code>Camera.main</code> referans\u0131n\u0131 yakalar ve nesnenin rotasyonunu kameran\u0131n rotasyonuna e\u015fitler.</li> <li>LateUpdate Usage: Rotasyon g\u00fcncellemesi <code>LateUpdate</code> a\u015famas\u0131nda yap\u0131l\u0131r. Bu, kameran\u0131n kendi hareketi bittikten sonra billboard i\u015fleminin ger\u00e7ekle\u015fmesini sa\u011flayarak titremeleri (Jitter) \u00f6nler.</li> <li>Performance: Sadece rotasyon e\u015fitlemesi yapt\u0131\u011f\u0131 i\u00e7in i\u015flem maliyeti son derece d\u00fc\u015f\u00fckt\u00fcr.</li> </ul>"},{"location":"API_References/NexusBillboardUI_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Ba\u015flang\u0131\u00e7 (Start): Sahnedeki ana kamera saptan\u0131r.</li> <li>G\u00fcncelleme (LateUpdate): E\u011fer kamera aktifse, nesnenin <code>transform.rotation</code> de\u011feri kameran\u0131nkiyle senkronize edilir.</li> <li>Sonu\u00e7: Nesne, kamera ne kadar d\u00f6nerse d\u00f6ns\u00fcn her zaman d\u00fcz bir \u015fekilde oyuncuya bakar.</li> </ol>"},{"location":"API_References/NexusBillboardUI_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Bir World-Space UI Canvas'\u0131na bu scripti eklemeniz yeterlidir.\n// Can bar\u0131 her zaman kameraya paralel kalacakt\u0131r.\n</code></pre>"},{"location":"API_References/NexusBillboardUI_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\npublic class NexusBillboardUI : MonoBehaviour\n{\n    private Camera _mainCamera;\n\n    private void Start() =&gt; _mainCamera = Camera.main;\n\n    private void LateUpdate() {\n        if (_mainCamera != null) transform.rotation = _mainCamera.transform.rotation;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusBillboardUI_tr/#nexus-optimization-tip-update-culling","title":"Nexus Optimization Tip: Update Culling","text":"<p>E\u011fer ekranda \u00e7ok fazla Billboard nesnesi varsa, bu i\u015flemi her karede yapmak yerine kameradan uzakl\u0131\u011fa g\u00f6re (LOD) seyreltin. \u00c7ok uzaktaki nesneler i\u00e7in rotasyon g\u00fcncellemeyi durdurmak, b\u00fcy\u00fck sahnelerde Transform i\u015flem y\u00fck\u00fcn\u00fc %10 oran\u0131nda azaltabilir.</p>"},{"location":"API_References/NexusBridge_eng/","title":"Nexus Prime Architectural Manual: NexusBridge (Generic Synchronization Interface)","text":""},{"location":"API_References/NexusBridge_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusBridge.cs</code> is the most basic and generic \"Protocol Layer\" that enables Nexus Prime to talk with any game engine (Unity, Unreal, Godot, etc.). It is a high-performance template defining how unmanaged simulation data will exit to the outside world (<code>Push</code>) and how outside world data will enter the simulation (<code>Pull</code>).</p> <p>The reason for this structure's existence is to minimize the cost of engine integration by offering a type-safe (type-safe) and memory-efficient (memory-efficient) standard, instead of writing separate synchronization codes for each component type.</p>"},{"location":"API_References/NexusBridge_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Manages these two main flow models for maximum efficiency:</p> <ul> <li>Push (Nexus -&gt; Engine): After the simulation is over, it reflects data marked as \"Dirty\" (Dirty) in the unmanaged Registry to visual objects of the external engine. Optimizes CPU load by processing only those that have changed (Sparse Iteration).</li> <li>Pull (Engine -&gt; Nexus): Before the simulation starts, it pulls changes in the outside world (e.g., user keyboard input or Unity physics engine results) into unmanaged memory.</li> <li>BridgeOrchestrator: A scheduler managing the synchronization frequency (e.g., 30 FPS or 60 FPS). Ensures visual transmission stays stable regardless of simulation speed.</li> <li>Zero-Allocation Sync: Since copy operations are performed via Raw Pointers (<code>T*</code>), no managed objects are created (GC-Free).</li> </ul>"},{"location":"API_References/NexusBridge_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Iteration: All entities in the relevant component set are scanned rapidly.</li> <li>Dirty Check (Dirty Check): Only those marked with <code>SetDirty</code> are filtered.</li> <li>Data Transfer: Data is copied between memory addresses via delegates (Callback).</li> <li>Cleaning: Dirty flags are cleaned at the end of synchronization.</li> </ol>"},{"location":"API_References/NexusBridge_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Pull Strategy Direction of data flow from engine to ECS. Push Strategy Direction of data flow from ECS to engine (Visualization). Frequency Capping Limiting synchronization at a specific speed to prevent unnecessary processing load. Bi-Directional Sync Structure where data can flow safely in both directions."},{"location":"API_References/NexusBridge_eng/#5-usage-example","title":"5. Usage Example","text":"<pre><code>// Example of manual synchronization\nNexusBridge&lt;Position&gt;.Push(registry, (id, posPtr) =&gt; {\n    // Apply data to Unity object\n    ApplyToTransform(id, posPtr-&gt;ToVector3());\n});\n</code></pre>"},{"location":"API_References/NexusBridge_eng/#6-full-source-implementation-direct-implementation","title":"6. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Bridge;\n\npublic unsafe class NexusBridge&lt;T&gt; where T : unmanaged\n{\n    public static void Push(Registry.Registry registry, PushDelegate pushCallback) {\n        var set = registry.GetSet&lt;T&gt;();\n        for (int i = 0; i &lt; set.Count; i++) {\n            if (set.IsDirty((uint)i)) {\n                pushCallback(set.GetEntity(i), set.GetComponent(i));\n                set.ClearDirty((uint)i);\n            }\n        }\n    }\n\n    public static void Pull(Registry.Registry registry, PullDelegate pullCallback) {\n        var set = registry.GetSet&lt;T&gt;();\n        for (int i = 0; i &lt; set.Count; i++) {\n            pullCallback(set.GetEntity(i), set.GetComponent(i));\n            set.SetDirty((uint)i);\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/NexusBridge_eng/#nexus-optimization-tip-selective-dirty-clearing","title":"Nexus Optimization Tip: Selective Dirty Clearing","text":"<p>Instead of always calling <code>ClearDirty</code> after the <code>Push</code> process is finished, if you are sending data to both video recording and network (Network) systems, keep the flag until all systems read it. This prevents unnecessarily re-calculating the same data for multiple systems.</p>"},{"location":"API_References/NexusBridge_tr/","title":"Nexus Prime Mimari Rehberi: NexusBridge (Jenerik Senkronizasyon Arabirimi)","text":""},{"location":"API_References/NexusBridge_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusBridge.cs</code>, Nexus Prime'\u0131n herhangi bir oyun motoru (Unity, Unreal, Godot vb.) ile konu\u015fmas\u0131n\u0131 sa\u011flayan en temel ve jenerik \"Protokol Katman\u0131\"d\u0131r. Unmanaged sim\u00fclasyon verisinin d\u0131\u015f d\u00fcnyaya nas\u0131l \u00e7\u0131kaca\u011f\u0131n\u0131 (<code>Push</code>) ve d\u0131\u015f d\u00fcnya verisinin sim\u00fclasyona nas\u0131l girece\u011fini (<code>Pull</code>) tan\u0131mlayan y\u00fcksek performansl\u0131 bir \u015fablondur.</p> <p>Bu yap\u0131n\u0131n varl\u0131k sebebi; her bile\u015fen tipi i\u00e7in ayr\u0131 senkronizasyon kodlar\u0131 yazmak yerine, tip-g\u00fcvenli (type-safe) ve bellek-verimli (memory-efficient) bir standart sunarak motor entegrasyonu maliyetini minimize etmektir.</p>"},{"location":"API_References/NexusBridge_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Maksimum verimlilik i\u00e7in \u015fu iki ana ak\u0131\u015f modelini y\u00f6netir:</p> <ul> <li>Push (Nexus -&gt; Engine): Sim\u00fclasyon bittikten sonra unmanaged Registry'deki \"Kirli\" (Dirty) olarak i\u015faretlenmi\u015f verileri d\u0131\u015f motorun g\u00f6rsel nesnelerine yans\u0131t\u0131r. Sadece de\u011fi\u015fenleri i\u015fleyerek (Sparse Iteration) CPU y\u00fck\u00fcn\u00fc optimize eder.</li> <li>Pull (Engine -&gt; Nexus): Sim\u00fclasyon ba\u015flamadan \u00f6nce d\u0131\u015f d\u00fcnyadaki de\u011fi\u015fimleri (\u00d6rn: Kullan\u0131c\u0131 klavye girdisi veya Unity fizik motoru sonu\u00e7lar\u0131) unmanaged belle\u011fe \u00e7eker.</li> <li>BridgeOrchestrator: Senkronizasyon frekans\u0131n\u0131 (\u00d6rn: 30 FPS veya 60 FPS) y\u00f6neten bir zamanlay\u0131c\u0131d\u0131r. Sim\u00fclasyon h\u0131z\u0131 ne olursa olsun g\u00f6rsel aktar\u0131m\u0131n stabil kalmas\u0131n\u0131 sa\u011flar.</li> <li>Zero-Allocation Sync: Kopyalama i\u015flemleri Raw Pointers (<code>T*</code>) \u00fczerinden yap\u0131ld\u0131\u011f\u0131 i\u00e7in hi\u00e7bir managed nesne olu\u015fturulmaz (GC-Free).</li> </ul>"},{"location":"API_References/NexusBridge_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Iterasyon: \u0130lgili bile\u015fen setindeki t\u00fcm varl\u0131klar h\u0131zl\u0131ca taran\u0131r.</li> <li>Kirli Kontrol\u00fc (Dirty Check): Sadece <code>SetDirty</code> ile i\u015faretlenmi\u015f olanlar filtrelenir.</li> <li>Veri Transferi: Delegeler (Callback) arac\u0131l\u0131\u011f\u0131yla veriler bellek adresleri aras\u0131nda kopyalan\u0131r.</li> <li>Temizlik: Senkronizasyon sonunda kirli bayraklar temizlenir.</li> </ol>"},{"location":"API_References/NexusBridge_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Pull Strategy Verinin motordan ECS'ye ak\u0131\u015f y\u00f6n\u00fc. Push Strategy Verinin ECS'den motora (G\u00f6rselle\u015fmeye) ak\u0131\u015f y\u00f6n\u00fc. Frequency Capping Gereksiz i\u015flem y\u00fck\u00fcn\u00fc \u00f6nlemek i\u00e7in senkronizasyonun belirli bir h\u0131zda s\u0131n\u0131rland\u0131r\u0131lmas\u0131. Bi-Directional Sync Verinin her iki y\u00f6ne de g\u00fcvenli bir \u015fekilde akabildi\u011fi yap\u0131."},{"location":"API_References/NexusBridge_tr/#5-kullanm-ornegi","title":"5. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Manuel bir senkronizasyon \u00f6rne\u011fi\nNexusBridge&lt;Position&gt;.Push(registry, (id, posPtr) =&gt; {\n    // Veriyi Unity objesine uygula\n    ApplyToTransform(id, posPtr-&gt;ToVector3());\n});\n</code></pre>"},{"location":"API_References/NexusBridge_tr/#6-tam-kaynak-kod-direct-implementation","title":"6. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Bridge;\n\npublic unsafe class NexusBridge&lt;T&gt; where T : unmanaged\n{\n    public static void Push(Registry.Registry registry, PushDelegate pushCallback) {\n        var set = registry.GetSet&lt;T&gt;();\n        for (int i = 0; i &lt; set.Count; i++) {\n            if (set.IsDirty((uint)i)) {\n                pushCallback(set.GetEntity(i), set.GetComponent(i));\n                set.ClearDirty((uint)i);\n            }\n        }\n    }\n\n    public static void Pull(Registry.Registry registry, PullDelegate pullCallback) {\n        var set = registry.GetSet&lt;T&gt;();\n        for (int i = 0; i &lt; set.Count; i++) {\n            pullCallback(set.GetEntity(i), set.GetComponent(i));\n            set.SetDirty((uint)i);\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/NexusBridge_tr/#nexus-optimization-tip-selective-dirty-clearing","title":"Nexus Optimization Tip: Selective Dirty Clearing","text":"<p><code>Push</code> i\u015flemi bittikten sonra her zaman <code>ClearDirty</code> \u00e7a\u011f\u0131rmak yerine, veriyi hem video kay\u0131t hem de a\u011f (Network) sistemine g\u00f6nderiyorsan\u0131z, t\u00fcm sistemler okuyana kadar bayra\u011f\u0131 saklay\u0131n. Bu, ayn\u0131 veriyi birden fazla sistem i\u00e7in gereksiz yere tekrar hesaplamay\u0131 \u00f6nler.</p>"},{"location":"API_References/NexusCachedQuery_eng/","title":"Nexus Prime Architectural Manual: NexusCachedQuery (Reactive Query Caching)","text":""},{"location":"API_References/NexusCachedQuery_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusCachedQuery.cs</code> is a reactive layer that takes Nexus Prime's query performance to the next level. While a standard query scans the entire dataset every time it's called, CachedQuery stores the results in memory and updates this list only when the relevant data components change (Dirty).</p> <p>The reason for this class's existence is to zero out the unnecessary load on the processor of re-calculating query results that contain thousands of entities but rarely change (e.g., \"Static trees\", \"Passive enemies\") every frame.</p>"},{"location":"API_References/NexusCachedQuery_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusCachedQuery uses the following architectural patterns for efficiency:</p> <ul> <li>Dirty Flag Pattern: When a component is added or removed, the <code>_isDirty</code> flag is activated. In this way, no search operation is performed until the data changes.</li> <li>Event-Driven Updates: Listens only to target components by subscribing to <code>OnEntityDestroyed</code>, <code>OnComponentAdded</code>, and <code>OnComponentRemoved</code> events on the <code>Registry</code>.</li> <li>Lazy Rebuilding: The cache is rebuilt not the moment the data changes, but the moment the result is needed (<code>GetEntities()</code>). This ensures that calculation is performed only once, even if there are multiple changes in a frame.</li> <li>Set-Based Storage: Using <code>HashSet&lt;EntityId&gt;</code>, it stores the entity list in a fast-accessible and unique way.</li> </ul>"},{"location":"API_References/NexusCachedQuery_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Subscription: When the query is created, events for target component types are subscribed to.</li> <li>Monitoring: When a change comes via the <code>Registry</code>, it is checked whether this change falls within the query scope, and the \"Dirty\" flag is raised if necessary.</li> <li>Querying: When the user requests data, if the flag is raised, it calls the <code>RebuildCache()</code> method to create the current list.</li> <li>Cleaning: When <code>Dispose</code> is called, event subscriptions are terminated to prevent memory leaks.</li> </ol>"},{"location":"API_References/NexusCachedQuery_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Reactive Query An intelligent query model that updates its own state as data changes. Dirty Flag A pointer indicating that a piece of data has changed and needs to be re-processed. Lazy Rebuild The technique of postponing calculation until the moment of need. Event-Driven Controlling program flow by occurring events (events)."},{"location":"API_References/NexusCachedQuery_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Frequency Analysis: If the queried components change every frame (e.g., Position), using <code>NexusCachedQuery</code> may decrease performance instead of increasing it due to reactive cost. It is ideal only for infrequently changing data.</li> <li>Hash Cost: The use of <code>HashSet</code> may consume more memory than unmanaged arrays, and iteration speed may be slightly (at micro level) lower.</li> </ul>"},{"location":"API_References/NexusCachedQuery_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>// Reactive query tracking entities with \"Inventory\" and \"Stats\" components\nvar inventoryQuery = new NexusCachedQuery(registry, typeof(Inventory), typeof(Stats));\n\nvoid OnUpdate() {\n    // If data hasn't changed, the cost of this call is O(1) (Returns the list directly)\n    var players = inventoryQuery.GetEntities();\n    foreach(var p in players) {\n        // ... Process ...\n    }\n}\n</code></pre>"},{"location":"API_References/NexusCachedQuery_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Core;\n\npublic class NexusCachedQuery : IDisposable\n{\n    private readonly Registry _registry;\n    private readonly Type[] _required;\n    private readonly HashSet&lt;EntityId&gt; _cache = new();\n    private bool _isDirty = true;\n\n    public IEnumerable&lt;EntityId&gt; GetEntities()\n    {\n        if (_isDirty) RebuildCache();\n        return _cache;\n    }\n\n    private void OnComponentModified(EntityId entity, Type type)\n    {\n        foreach (var req in _required) {\n            if (req == type) { _isDirty = true; break; }\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/NexusCachedQuery_eng/#nexus-optimization-tip-event-filtering","title":"Nexus Optimization Tip: Event Filtering","text":"<p>The type check performed within <code>OnComponentModified</code> is the main factor determining the reactive cost. If you have hundreds of different component types, by specializing this method for specific types at the <code>Registry</code> level (Type-specific events), you can escape unnecessary \"Dirty\" checks by 80%.</p>"},{"location":"API_References/NexusCachedQuery_tr/","title":"Nexus Prime Mimari Rehberi: NexusCachedQuery (Reaktif Sorgu \u00d6nbellekleme)","text":""},{"location":"API_References/NexusCachedQuery_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusCachedQuery.cs</code>, Nexus Prime'\u0131n sorgu performans\u0131n\u0131 bir \u00fcst seviyeye ta\u015f\u0131yan reaktif bir katmand\u0131r. Standart bir sorgu her \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda t\u00fcm veri setini tararken, CachedQuery sonu\u00e7lar\u0131 haf\u0131zada saklar ve sadece ilgili veri bile\u015fenleri de\u011fi\u015fti\u011finde (Dirty) bu listeyi g\u00fcnceller.</p> <p>Bu s\u0131n\u0131f\u0131n varl\u0131k sebebi, binlerce varl\u0131k i\u00e7eren ama nadiren de\u011fi\u015fen sorgu sonu\u00e7lar\u0131n\u0131 (\u00d6rn: \"Dura\u011fan a\u011fa\u00e7lar\", \"Pasif d\u00fc\u015fmanlar\") her karede (frame) yeniden hesaplaman\u0131n i\u015flemci \u00fczerindeki gereksiz y\u00fck\u00fcn\u00fc s\u0131f\u0131ra indirmektir.</p>"},{"location":"API_References/NexusCachedQuery_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusCachedQuery, verimlilik i\u00e7in \u015fu mimari desenleri kullan\u0131r:</p> <ul> <li>Dirty Flag Pattern: Bile\u015fen eklendi\u011finde veya \u00e7\u0131kar\u0131ld\u0131\u011f\u0131nda <code>_isDirty</code> bayra\u011f\u0131 aktif edilir. Bu sayede, veri de\u011fi\u015fene kadar hi\u00e7bir arama i\u015flemi yap\u0131lmaz.</li> <li>Event-Driven Updates: <code>Registry</code> \u00fczerindeki <code>OnEntityDestroyed</code>, <code>OnComponentAdded</code> ve <code>OnComponentRemoved</code> olaylar\u0131na abone olarak sadece hedef bile\u015fenleri dinler.</li> <li>Lazy Rebuilding: \u00d6nbellek, veri de\u011fi\u015fti\u011fi anda de\u011fil, sonuca ihtiya\u00e7 duyuldu\u011fu anda (<code>GetEntities()</code>) yeniden in\u015fa edilir. Bu, bir karede birden fazla de\u011fi\u015fim olsa bile sadece bir kez hesaplama yap\u0131lmas\u0131n\u0131 sa\u011flar.</li> <li>Set-Based Storage: <code>HashSet&lt;EntityId&gt;</code> kullanarak, varl\u0131k listesini h\u0131zl\u0131 eri\u015filebilir ve benzersiz (unique) bir \u015fekilde saklar.</li> </ul>"},{"location":"API_References/NexusCachedQuery_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Abonelik: Sorgu olu\u015fturuldu\u011funda hedef bile\u015fen tipleri i\u00e7in olaylara abone olunur.</li> <li>\u0130zleme: <code>Registry</code> \u00fczerinden bir de\u011fi\u015fim geldi\u011finde, bu de\u011fi\u015fimin sorgu kapsam\u0131na girip girmedi\u011fi kontrol edilir ve gerekiyorsa \"Dirty\" bayra\u011f\u0131 kalkar.</li> <li>Sorgulama: Kullan\u0131c\u0131 veri istedi\u011finde, e\u011fer bayrak kalkm\u0131\u015fsa <code>RebuildCache()</code> metodunu \u00e7a\u011f\u0131rarak g\u00fcncel listeyi olu\u015fturur.</li> <li>Temizlik: <code>Dispose</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda bellek s\u0131z\u0131nt\u0131s\u0131n\u0131 \u00f6nlemek i\u00e7in olay abonelikleri sonland\u0131r\u0131l\u0131r.</li> </ol>"},{"location":"API_References/NexusCachedQuery_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Reactive Query Veriler de\u011fi\u015ftik\u00e7e kendi durumunu g\u00fcncelleyen ak\u0131ll\u0131 sorgu modeli. Dirty Flag Bir verinin de\u011fi\u015fti\u011fini ve yeniden i\u015flenmesi gerekti\u011fini belirten i\u015faret\u00e7i. Lazy Rebuild Hesaplaman\u0131n ihtiya\u00e7 an\u0131na kadar ertelenmesi tekni\u011fi. Event-Driven Program ak\u0131\u015f\u0131n\u0131n meydana gelen olaylar (events) taraf\u0131ndan kontrol edilmesi."},{"location":"API_References/NexusCachedQuery_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Frequency Analysis: E\u011fer sorgulanan bile\u015fenler her karede de\u011fi\u015fiyorsa (\u00d6rn: Pozisyon), <code>NexusCachedQuery</code> kullanmak reaktif maliyet y\u00fcz\u00fcnden performans\u0131 art\u0131rmak yerine d\u00fc\u015f\u00fcrebilir. Sadece seyrek de\u011fi\u015fen veriler i\u00e7in idealdir.</li> <li>Hash Cost: <code>HashSet</code> kullan\u0131m\u0131, unmanaged array'lere g\u00f6re daha fazla bellek t\u00fcketebilir ve iterasyon h\u0131z\u0131 bir miktar (mikro seviyede) d\u00fc\u015f\u00fck olabilir.</li> </ul>"},{"location":"API_References/NexusCachedQuery_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// \"Inventory\" ve \"Stats\" bile\u015fenine sahip varl\u0131klar\u0131 takip eden reaktif sorgu\nvar inventoryQuery = new NexusCachedQuery(registry, typeof(Inventory), typeof(Stats));\n\nvoid OnUpdate() {\n    // Veriler de\u011fi\u015fmediyse bu \u00e7a\u011fr\u0131n\u0131n maliyeti O(1)'dir (Do\u011frudan listeyi d\u00f6ner)\n    var players = inventoryQuery.GetEntities();\n    foreach(var p in players) {\n        // ... \u0130\u015flem ...\n    }\n}\n</code></pre>"},{"location":"API_References/NexusCachedQuery_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Core;\n\npublic class NexusCachedQuery : IDisposable\n{\n    private readonly Registry _registry;\n    private readonly Type[] _required;\n    private readonly HashSet&lt;EntityId&gt; _cache = new();\n    private bool _isDirty = true;\n\n    public IEnumerable&lt;EntityId&gt; GetEntities()\n    {\n        if (_isDirty) RebuildCache();\n        return _cache;\n    }\n\n    private void OnComponentModified(EntityId entity, Type type)\n    {\n        foreach (var req in _required) {\n            if (req == type) { _isDirty = true; break; }\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/NexusCachedQuery_tr/#nexus-optimization-tip-event-filtering","title":"Nexus Optimization Tip: Event Filtering","text":"<p><code>OnComponentModified</code> i\u00e7inde yap\u0131lan tip kontrol\u00fc, reaktif maliyeti belirleyen ana unsurdur. E\u011fer y\u00fczlerce farkl\u0131 bile\u015fen tipiniz varsa, bu metodu <code>Registry</code> seviyesinde spesifik tipler i\u00e7in \u00f6zelle\u015ftirerek (Type-specific events) gereksiz \"Dirty\" kontrollerinden %80 oran\u0131nda kurtulabilirsiniz.</p>"},{"location":"API_References/NexusCollections_eng/","title":"Nexus Prime Architectural Manual: NexusCollections (Unmanaged Data Structures)","text":""},{"location":"API_References/NexusCollections_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusCollections.cs</code> is the heart of Nexus Prime framework's \"Hardware-Oriented Data Management\". To eliminate the Garbage Collector (GC) pressure and memory clutter created by standard C# collections (List, Dictionary, etc.), it offers a collection suite that works entirely on unmanaged (unmanaged) memory.</p> <p>The reason for these collections' existence is to use the processor cache (CPU Cache) most efficiently while processing thousands of data pieces in game logic (logic) systems and to control memory management with a manual (unsafe) but safe layer.</p>"},{"location":"API_References/NexusCollections_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The collection suite includes the following critical structures for performance and safety:</p> <ul> <li>NexusRef: Provides a secure \"reference\" layer that checks the validity of the entity (EntityId) instead of holding a direct pointer to a component. Returns <code>null</code> if the entity has been deleted during <code>Ptr</code> access, preventing \"Dangling Pointer\" errors. <li>NexusList: Aligns data to 64-byte boundaries using <code>NativeMemory.AllocCacheAligned</code>. This ensures that the processor reaches maximum data within a single cache-line while scanning (iteration) the list. <li>NexusDictionary: Offers a hash map that works on pure unmanaged memory. Since it does not contain reference types, it is not scanned by GC even if there are millions of records. <li>NexusString: A fixed-size, unmanaged string structure. Allows data such as entity names or tags to be stored inline (inline) within the component instead of the heap."},{"location":"API_References/NexusCollections_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Allocation: When a collection is created (<code>new</code>), cache-aligned unmanaged memory is reserved via <code>NexusMemoryManager</code>.</li> <li>Management: Data is managed via raw pointers. When capacity is full, memory is safely expanded with <code>Realloc</code>.</li> <li>Access: Operations are performed directly via the memory address with <code>ref</code> returning indexers without data copying (copy-overhead).</li> <li>Cleanup: When the collection's life ends, memory is manually returned to the OS by calling <code>Dispose()</code>.</li> </ol>"},{"location":"API_References/NexusCollections_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Dangling Pointer A dangerous pointer that points to a memory address that is no longer valid. Cache-Aligned The memory address of the data sitting exactly on the processor cache line (64-byte) boundary. LIFO (Last-In-First-Out) The principle used in NexusStack where the last data to enter is the first to leave. Zero-GC Penalty The principle that a data structure is never scanned by GC and does not cause performance pauses."},{"location":"API_References/NexusCollections_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Manual Lifetime: Forgetting to call <code>Dispose()</code> after using <code>NexusList</code> or <code>NexusDictionary</code> results in a \"Memory Leak\".</li> <li>Unmanaged Constraints: Only <code>unmanaged</code> (struct) types can be stored. <code>class</code> or <code>string</code> (managed) types cannot be added to collections.</li> </ul>"},{"location":"API_References/NexusCollections_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>// Create an unmanaged list with 100 capacity\nusing var list = new NexusList&lt;float3&gt;(100);\n\nlist.Add(new float3(1, 0, 0));\n\n// Access data by reference (Copy-free)\nref var item = ref list[0];\nitem.x = 10;\n\n// Dispose() is called automatically (at the end of the using block)\n</code></pre>"},{"location":"API_References/NexusCollections_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Collections;\n\npublic unsafe struct NexusList&lt;T&gt; : IDisposable where T : unmanaged\n{\n    private T* _buffer;\n    private int _count;\n    private int _capacity;\n\n    public NexusList(int initialCapacity = 8)\n    {\n        _capacity = initialCapacity;\n        _buffer = (T*)NexusMemoryManager.AllocCacheAligned(_capacity * sizeof(T));\n    }\n\n    public void Add(T item)\n    {\n        if (_count == _capacity) // Realloc logic here\n        _buffer[_count++] = item;\n    }\n\n    public void Dispose() =&gt; NexusMemoryManager.Free(_buffer);\n}\n</code></pre>"},{"location":"API_References/NexusCollections_eng/#nexus-optimization-tip-predictive-capacity","title":"Nexus Optimization Tip: Predictive Capacity","text":"<p>Adjust the default capacity (Default: 8) of collections according to the average amount of data in your project. Frequent <code>Realloc</code> operations can lead to memory fragmentation. By determining the correct capacity initially, you can eliminate the list expansion cost by 100%.</p>"},{"location":"API_References/NexusCollections_tr/","title":"Nexus Prime Mimari Rehberi: NexusCollections (Unmanaged Veri Yap\u0131lar\u0131)","text":""},{"location":"API_References/NexusCollections_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusCollections.cs</code>, Nexus Prime framework'\u00fcn\u00fcn \"Donan\u0131m Odakl\u0131 Veri Y\u00f6netimi\" (Hardware-Oriented Data Management) kalbidir. C# dilinin standart koleksiyonlar\u0131n\u0131n (List, Dictionary vb.) yaratt\u0131\u011f\u0131 Garbage Collector (GC) bask\u0131s\u0131n\u0131 ve bellek da\u011f\u0131n\u0131kl\u0131\u011f\u0131n\u0131 ortadan kald\u0131rmak i\u00e7in, tamamen unmanaged (y\u00f6netilmeyen) bellek \u00fczerinde \u00e7al\u0131\u015fan bir koleksiyon suite'i sunar.</p> <p>Bu koleksiyonlar\u0131n varl\u0131k sebebi, oyun mant\u0131\u011f\u0131 (logic) sistemlerinde binlerce veri \u00fczerinde i\u015flem yaparken, i\u015flemci \u00f6nbelle\u011fini (CPU Cache) en verimli \u015fekilde kullanmak ve bellek y\u00f6netimini manuel (unsafe) ama g\u00fcvenli bir katmanla kontrol etmektir.</p>"},{"location":"API_References/NexusCollections_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Koleksiyon suite, performans ve g\u00fcvenlik i\u00e7in \u015fu kritik yap\u0131lar\u0131 i\u00e7erir:</p> <ul> <li>NexusRef: Bir bile\u015fene do\u011frudan pointer tutmak yerine, varl\u0131\u011f\u0131n (EntityId) ge\u00e7erlili\u011fini kontrol eden g\u00fcvenli bir \"referans\" katman\u0131 sa\u011flar. <code>Ptr</code> eri\u015fimi s\u0131ras\u0131nda varl\u0131k silinmi\u015fse <code>null</code> d\u00f6nerek \"Dandling Pointer\" hatalar\u0131n\u0131 \u00f6nler. <li>NexusList: <code>NativeMemory.AllocCacheAligned</code> kullanarak verileri 64-byte s\u0131n\u0131rlar\u0131na dizer. Bu, i\u015flemcinin listeyi tararken (iteration) tek bir cache-line i\u00e7inde maksimum veriye ula\u015fmas\u0131n\u0131 sa\u011flar. <li>NexusDictionary: Saf unmanaged bellek \u00fczerinde \u00e7al\u0131\u015fan bir karma tablo (hash map) sunar. Referans tipleri i\u00e7ermedi\u011fi i\u00e7in, milyonlarca kay\u0131t olsa bile GC taraf\u0131ndan taranmaz. <li>NexusString: Sabit boyutlu, unmanaged string yap\u0131s\u0131d\u0131r. Varl\u0131k isimleri veya etiketleri gibi verilerin y\u0131\u011f\u0131n (heap) yerine do\u011frudan bile\u015fen i\u00e7inde (inline) saklanmas\u0131n\u0131 sa\u011flar."},{"location":"API_References/NexusCollections_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tahsisat (Allocation): Koleksiyon olu\u015fturuldu\u011funda (<code>new</code>), <code>NexusMemoryManager</code> \u00fczerinden cache-aligned unmanaged bellek ayr\u0131l\u0131r.</li> <li>Y\u00f6netim: Veriler ham pointerlar \u00fczerinden y\u00f6netilir. Kapasite doldu\u011funda <code>Realloc</code> ile bellek g\u00fcvenli bir \u015fekilde geni\u015fletilir.</li> <li>Eri\u015fim: <code>ref</code> d\u00f6n\u00fc\u015fl\u00fc indeksleyiciler ile veri kopyalamas\u0131 (copy-overhead) yap\u0131lmadan do\u011frudan bellek adresi \u00fczerinden i\u015flem yap\u0131l\u0131r.</li> <li>Temizlik (Cleanup): Koleksiyonun \u00f6mr\u00fc bitti\u011finde <code>Dispose()</code> \u00e7a\u011fr\u0131larak bellek OS'e el ile iade edilir.</li> </ol>"},{"location":"API_References/NexusCollections_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Dangling Pointer Art\u0131k ge\u00e7erli olmayan bir bellek adresini i\u015faret eden tehlikeli pointer. Cache-Aligned Verinin bellek adresinin i\u015flemci cache line (64-byte) s\u0131n\u0131r\u0131na tam oturmas\u0131. LIFO (Last-In-First-Out) NexusStack'te kullan\u0131lan, son giren verinin ilk \u00e7\u0131kmas\u0131 prensibi. Zero-GC Penalty Veri yap\u0131s\u0131n\u0131n GC taraf\u0131ndan asla taranmamas\u0131 ve performans duraksamas\u0131na yol a\u00e7mamas\u0131."},{"location":"API_References/NexusCollections_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Manual Lifetime: <code>NexusList</code> veya <code>NexusDictionary</code> kulland\u0131ktan sonra <code>Dispose()</code> \u00e7a\u011f\u0131rmay\u0131 unutmak \"Memory Leak\" (Bellek S\u0131z\u0131nt\u0131s\u0131) ile sonu\u00e7lan\u0131r.</li> <li>Unmanaged Constraints: Sadece <code>unmanaged</code> (struct) tipler saklanabilir. <code>class</code> veya <code>string</code> (managed) tipler koleksiyonlara eklenemez.</li> </ul>"},{"location":"API_References/NexusCollections_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// 100 kapasiteli unmanaged bir liste olu\u015ftur\nusing var list = new NexusList&lt;float3&gt;(100);\n\nlist.Add(new float3(1, 0, 0));\n\n// Veriye referans ile eri\u015f (Kopyas\u0131z)\nref var item = ref list[0];\nitem.x = 10;\n\n// Dispose() otomatik olarak \u00e7a\u011fr\u0131l\u0131r (using blo\u011fu sonunda)\n</code></pre>"},{"location":"API_References/NexusCollections_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Collections;\n\npublic unsafe struct NexusList&lt;T&gt; : IDisposable where T : unmanaged\n{\n    private T* _buffer;\n    private int _count;\n    private int _capacity;\n\n    public NexusList(int initialCapacity = 8)\n    {\n        _capacity = initialCapacity;\n        _buffer = (T*)NexusMemoryManager.AllocCacheAligned(_capacity * sizeof(T));\n    }\n\n    public void Add(T item)\n    {\n        if (_count == _capacity) // Realloc logic here\n        _buffer[_count++] = item;\n    }\n\n    public void Dispose() =&gt; NexusMemoryManager.Free(_buffer);\n}\n</code></pre>"},{"location":"API_References/NexusCollections_tr/#nexus-optimization-tip-predictive-capacity","title":"Nexus Optimization Tip: Predictive Capacity","text":"<p>Koleksiyonlar\u0131n varsay\u0131lan kapasitesini (Default: 8) projenizdeki ortalama veri miktar\u0131na g\u00f6re ayarlay\u0131n. S\u0131k yap\u0131lan <code>Realloc</code> i\u015flemleri bellek fragmantasyonuna yol a\u00e7abilir. Ba\u015flang\u0131\u00e7ta do\u011fru kapasite belirleyerek, liste geni\u015fleme maliyetini %100 oran\u0131nda ortadan kald\u0131rabilirsiniz.</p>"},{"location":"API_References/NexusCommandEngines_eng/","title":"Nexus Prime Architectural Manual: Nexus Command Engines (Command Systems)","text":""},{"location":"API_References/NexusCommandEngines_eng/#1-introduction","title":"1. Introduction","text":"<p>The Command Systems in Nexus Prime (<code>NexusConsole.cs</code> and <code>CommandConsole.cs</code>) are \"Input Terminals\" allowing the developer to send text-based commands directly to the unmanaged ECS world from within the Unity Editor.</p> <p>The reason for these systems' existence is to quickly create objects, stop systems, or perform data manipulation via the terminal without writing code and taking builds or dealing with complex values in the Inspector.</p>"},{"location":"API_References/NexusCommandEngines_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The terminals work via these two main functions:</p> <ul> <li>NexusConsole (Terminal): A professional log terminal directly integrated with <code>NexusCommandManager</code>, showing the execution history (History). Tracks successful and failed executions via <code>NexusLogger</code>.</li> <li>CommandConsole (CLI - Command Line): A terminal more \"Syntax\" (Syntax) oriented. Designed to resolve (Parsing) complex parameters such as <code>nexus create --type Orc --pos 0,0,0</code>.</li> </ul>"},{"location":"API_References/NexusCommandEngines_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Input: The developer writes the command in the text box in the Editor window.</li> <li>Confirmation: The command is captured when the \"Enter\" key is pressed.</li> <li>Redirection: The command is transmitted to the <code>NexusCommandManager.Execute(input)</code> method.</li> <li>Feedback: The transaction result (Success/Error) is visualized in the console window.</li> </ol>"},{"location":"API_References/NexusCommandEngines_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Usage of Nexus Console:\n&gt; timescale 0.5\n&gt; entities count\n&gt; snapshot restore last\n\n// Command Console (CLI) Example:\n&gt; nexus health --set 100 --target Player\n</code></pre>"},{"location":"API_References/NexusCommandEngines_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class NexusConsole : EditorWindow {\n    private string _input = \"\";\n    private void OnGUI() {\n        _input = EditorGUILayout.TextField(\"Execute\", _input);\n        if (GUILayout.Button(\"Submit\")) {\n            Nexus.Unity.Communication.NexusCommandManager.Execute(_input);\n            _input = \"\";\n        }\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusCommandEngines_eng/#nexus-optimization-tip-command-buffering","title":"Nexus Optimization Tip: Command Buffering","text":"<p>Make frequently used commands into macros (Sequence). By sending \"batch\" commands via CommandManager, you can reduce manual input time in test processes by 40%.</p>"},{"location":"API_References/NexusCommandEngines_tr/","title":"Nexus Prime Mimari Rehberi: Nexus Command Engines (Komut Sistemleri)","text":""},{"location":"API_References/NexusCommandEngines_tr/#1-giris","title":"1. Giri\u015f","text":"<p>Nexus Prime i\u00e7indeki Komut Sistemleri (<code>NexusConsole.cs</code> ve <code>CommandConsole.cs</code>), geli\u015ftiricinin Unity Edit\u00f6r i\u00e7inden unmanaged ECS d\u00fcnyas\u0131na do\u011frudan metin tabanl\u0131 komutlar g\u00f6ndermesini sa\u011flayan \"Giri\u015f Terminalleri\"dir.</p> <p>Bu sistemlerin varl\u0131k sebebi; kod yaz\u0131p build almadan veya Inspector i\u00e7inde karma\u015f\u0131k de\u011ferlerle u\u011fra\u015fmadan, terminal \u00fczerinden h\u0131zl\u0131ca nesne olu\u015fturmak, sistemleri durdurmak veya veri manip\u00fclasyonu yapmakt\u0131r.</p>"},{"location":"API_References/NexusCommandEngines_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Terminaller \u015fu iki ana i\u015flev \u00fczerinden \u00e7al\u0131\u015f\u0131r:</p> <ul> <li>NexusConsole (Terminal): <code>NexusCommandManager</code> ile do\u011frudan entegre olan, y\u00fcr\u00fctme ge\u00e7mi\u015fini (History) g\u00f6steren profesyonel bir log terminalidir. Ba\u015far\u0131l\u0131 ve ba\u015far\u0131s\u0131z y\u00fcr\u00fctmeleri <code>NexusLogger</code> \u00fczerinden takip eder.</li> <li>CommandConsole (CLI - Komut Sat\u0131r\u0131): Daha \u00e7ok \"S\u00f6zdizimi\" (Syntax) odakl\u0131 bir terminaldir. <code>nexus create --type Orc --pos 0,0,0</code> gibi karma\u015f\u0131k parametreleri \u00e7\u00f6z\u00fcmlemek (Parsing) i\u00e7in tasarlanm\u0131\u015ft\u0131r.</li> </ul>"},{"location":"API_References/NexusCommandEngines_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Girdi: Geli\u015ftirici Edit\u00f6r penceresindeki metin kutusuna komutu yazar.</li> <li>Onay: \"Enter\" tu\u015funa bas\u0131ld\u0131\u011f\u0131nda komut yakalan\u0131r.</li> <li>Y\u00f6nlendirme: Komut, <code>NexusCommandManager.Execute(input)</code> metoduna iletilir.</li> <li>Geri Bildirim: \u0130\u015flem sonucu (Ba\u015far\u0131/Hata) konsol penceresinde g\u00f6rselle\u015ftirilir.</li> </ol>"},{"location":"API_References/NexusCommandEngines_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Nexus Console Kullan\u0131m\u0131:\n&gt; timescale 0.5\n&gt; entities count\n&gt; snapshot restore last\n\n// Command Console (CLI) \u00d6rne\u011fi:\n&gt; nexus health --set 100 --target Player\n</code></pre>"},{"location":"API_References/NexusCommandEngines_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class NexusConsole : EditorWindow {\n    private string _input = \"\";\n    private void OnGUI() {\n        _input = EditorGUILayout.TextField(\"Execute\", _input);\n        if (GUILayout.Button(\"Submit\")) {\n            Nexus.Unity.Communication.NexusCommandManager.Execute(_input);\n            _input = \"\";\n        }\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusCommandEngines_tr/#nexus-optimization-tip-command-buffering","title":"Nexus Optimization Tip: Command Buffering","text":"<p>\u00c7ok s\u0131k kullan\u0131lan komutlar\u0131 birer makro (Sequence) haline getirin. CommandManager \u00fczerinden \"batch\" komutlar g\u00f6ndererek, test s\u00fcre\u00e7lerindeki manuel giri\u015f s\u00fcresini %40 oran\u0131nda d\u00fc\u015f\u00fcrebilirsiniz.</p>"},{"location":"API_References/NexusCommandManager_eng/","title":"Nexus Prime Architectural Manual: NexusCommandManager (Command Center)","text":""},{"location":"API_References/NexusCommandManager_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusCommandManager.cs</code> is the \"Central Command Registry\" that enables interaction between systems within Nexus Prime and management of the game via the developer console. It finds dynamically recorded commands by their names and runs them along with their arguments.</p> <p>The reason for this manager's existence is to collect all functional triggers in a single global pool, making them accessible from the outside (e.g., Debug Console or Network), instead of each system establishing its own input logic (Input Logic).</p>"},{"location":"API_References/NexusCommandManager_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Uses the following structures for command management:</p> <ul> <li>Global Command Registry: Stores commands within a <code>ConcurrentDictionary</code>. This allows safe command recording and querying from different threads (threads).</li> <li>Case-Insensitive Execution: Normalizes command names to lowercase (Lowercase), preventing errors arising from case sensitivity.</li> <li>Argument Parsing: Breaks a single string line (<code>commandLine</code>) into parts (Tokenization) as a command name and argument array (<code>string[]</code>).</li> <li>Silent Logger Integration: Facilitates error tracking by throwing a warning via <code>NexusLogger</code> when an unknown command is entered.</li> </ul>"},{"location":"API_References/NexusCommandManager_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Registration (Register): A system (e.g., Character Controller) reports its own command (\"spawn_bot\") to the Hub with a callback.</li> <li>Input: <code>Execute(\"spawn_bot fast 10\")</code> is called from the console or somewhere in the code.</li> <li>Parsing: The line is parsed as \"spawn_bot\" (command) and [\"fast\", \"10\"] (arguments).</li> <li>Execution: If \"spawn_bot\" is in the pool, the relevant callback is triggered along with the arguments.</li> </ol>"},{"location":"API_References/NexusCommandManager_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Record a command\nNexusCommandManager.RegisterCommand(\"give_gold\", (args) =&gt; {\n    int amount = int.Parse(args[0]);\n    Debug.Log($\"{amount} gold given.\");\n});\n\n// Run the command\nNexusCommandManager.Execute(\"give_gold 500\");\n</code></pre>"},{"location":"API_References/NexusCommandManager_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Communication;\n\npublic static class NexusCommandManager\n{\n    private static readonly ConcurrentDictionary&lt;string, Action&lt;string[]&gt;&gt; _commands = new();\n\n    public static void RegisterCommand(string name, Action&lt;string[]&gt; callback) {\n        _commands[name.ToLower()] = callback;\n    }\n\n    public static void Execute(string commandLine) {\n        var parts = commandLine.Split(' ', StringSplitOptions.RemoveEmptyEntries);\n        if (parts.Length == 0) return;\n\n        string name = parts[0].ToLower();\n        string[] args = parts.Length &gt; 1 ? parts[1..] : Array.Empty&lt;string&gt;();\n\n        if (_commands.TryGetValue(name, out var callback)) callback(args);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusCommandManager_eng/#nexus-optimization-tip-string-pooling","title":"Nexus Optimization Tip: String Pooling","text":"<p>If you are parsing command arguments very frequently (e.g., for data coming over the network every frame), use <code>ReadOnlySpan&lt;char&gt;</code> to reduce the <code>string[]</code> copying cost created by the <code>Split</code> method. This can reduce memory allocation (Allocation) by 40% in high-traffic command execution scenarios.</p>"},{"location":"API_References/NexusCommandManager_tr/","title":"Nexus Prime Mimari Rehberi: NexusCommandManager (Komut Merkezi)","text":""},{"location":"API_References/NexusCommandManager_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusCommandManager.cs</code>, Nexus Prime i\u00e7indeki sistemler aras\u0131 etkile\u015fimi ve geli\u015ftirici konsolu \u00fczerinden oyunun y\u00f6netilmesini sa\u011flayan \"Merkezi Komut Kay\u0131t Defteri\"dir. Dinamik olarak kaydedilen komutlar\u0131 isimlerine g\u00f6re bulur ve arg\u00fcmanlar\u0131yla birlikte \u00e7al\u0131\u015ft\u0131r\u0131r.</p> <p>Bu y\u00f6neticinin varl\u0131k sebebi; her sistemin kendi girdi mant\u0131\u011f\u0131n\u0131 (Input Logic) kurmas\u0131 yerine, t\u00fcm i\u015flevsel tetikleyicileri tek bir global havuzda toplayarak d\u0131\u015far\u0131dan (\u00d6rn: Debug Konsolu veya Network) eri\u015filebilir k\u0131lmakt\u0131r.</p>"},{"location":"API_References/NexusCommandManager_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Komut y\u00f6netimi i\u00e7in \u015fu yap\u0131lar\u0131 kullan\u0131r:</p> <ul> <li>Global Command Registry: Komutlar\u0131 bir <code>ConcurrentDictionary</code> i\u00e7inde saklar. Bu sayede farkl\u0131 thread'lerden (i\u015f par\u00e7ac\u0131klar\u0131ndan) g\u00fcvenli bir \u015fekilde komut kayd\u0131 ve sorgusu yap\u0131labilir.</li> <li>Case-Insensitive Execution: Komut isimlerini k\u00fc\u00e7\u00fck harfe (Lowercase) normalize ederek, b\u00fcy\u00fck/k\u00fc\u00e7\u00fck harf duyarl\u0131l\u0131\u011f\u0131ndan kaynaklanan hatalar\u0131 \u00f6nler.</li> <li>Argument Parsing: Tek bir string sat\u0131r\u0131n\u0131 (<code>commandLine</code>), komut ad\u0131 ve arg\u00fcmanlar dizisi (<code>string[]</code>) olarak par\u00e7alara ay\u0131r\u0131r (Tokenization).</li> <li>Silent Logger Integration: Bilinmeyen bir komut girildi\u011finde <code>NexusLogger</code> \u00fczerinden uyar\u0131 f\u0131rlatarak hata takibini kolayla\u015ft\u0131r\u0131r.</li> </ul>"},{"location":"API_References/NexusCommandManager_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Kay\u0131t (Register): Bir sistem (\u00d6rn: Karakter Kontrolc\u00fcs\u00fc) kendi komutunu (\"spawn_bot\") bir callback ile Hub'a bildirir.</li> <li>Girdi: Konsoldan veya koddun bir yerinden <code>Execute(\"spawn_bot fast 10\")</code> \u00e7a\u011fr\u0131l\u0131r.</li> <li>Par\u00e7alama: Sat\u0131r \"spawn_bot\" (komut) ve [\"fast\", \"10\"] (arg\u00fcmanlar) olarak ayr\u0131\u015ft\u0131r\u0131l\u0131r.</li> <li>Y\u00fcr\u00fct\u00fcm: E\u011fer \"spawn_bot\" havuzda varsa, ilgili callback arg\u00fcmanlarla birlikte tetiklenir.</li> </ol>"},{"location":"API_References/NexusCommandManager_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Bir komut kaydet\nNexusCommandManager.RegisterCommand(\"give_gold\", (args) =&gt; {\n    int amount = int.Parse(args[0]);\n    Debug.Log($\"{amount} alt\u0131n verildi.\");\n});\n\n// Komutu \u00e7al\u0131\u015ft\u0131r\nNexusCommandManager.Execute(\"give_gold 500\");\n</code></pre>"},{"location":"API_References/NexusCommandManager_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Communication;\n\npublic static class NexusCommandManager\n{\n    private static readonly ConcurrentDictionary&lt;string, Action&lt;string[]&gt;&gt; _commands = new();\n\n    public static void RegisterCommand(string name, Action&lt;string[]&gt; callback) {\n        _commands[name.ToLower()] = callback;\n    }\n\n    public static void Execute(string commandLine) {\n        var parts = commandLine.Split(' ', StringSplitOptions.RemoveEmptyEntries);\n        if (parts.Length == 0) return;\n\n        string name = parts[0].ToLower();\n        string[] args = parts.Length &gt; 1 ? parts[1..] : Array.Empty&lt;string&gt;();\n\n        if (_commands.TryGetValue(name, out var callback)) callback(args);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusCommandManager_tr/#nexus-optimization-tip-string-pooling","title":"Nexus Optimization Tip: String Pooling","text":"<p>Komut arg\u00fcmanlar\u0131n\u0131 \u00e7ok s\u0131k par\u00e7al\u0131yorsan\u0131z (\u00d6rn: Her karede a\u011f \u00fczerinden gelen veriler i\u00e7in), <code>Split</code> metodunun yaratt\u0131\u011f\u0131 <code>string[]</code> kopyalama maliyetini azaltmak i\u00e7in <code>ReadOnlySpan&lt;char&gt;</code> kullan\u0131n. Bu, y\u00fcksek trafikli komut y\u00fcr\u00fctme senaryolar\u0131nda bellek tahsisat\u0131n\u0131 (Allocation) %40 azaltabilir.</p>"},{"location":"API_References/NexusCommandStack_eng/","title":"Nexus Prime Architectural Manual: NexusCommandStack (Transaction History Manager)","text":""},{"location":"API_References/NexusCommandStack_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusCommandStack.cs</code> is a \"Transaction History Layer\" enabling undoing (Undo) and redoing (Redo) of actions within the application. Integrated from the HypeFire architecture. It plays a critical role particularly in editor tools, complex UI forms, or move management in strategy games.</p> <p>The reason for this stack's existence is to ensure the user can safely fast forward/rewind changes they made, by storing each action's \"Undo\" scenario (Reverse operation) in a standard structure.</p>"},{"location":"API_References/NexusCommandStack_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Offers the following architectural components for transaction management:</p> <ul> <li>Command Pattern: Each action is derived from the <code>NexusCommand&lt;T&gt;</code> class. These classes must contain both <code>Execute</code> (Execute) and <code>Undo</code> (Undo) methods.</li> <li>Pointer-Based Navigation: Tracks the current history position by holding an index (<code>_currentIndex</code>) within the history list.</li> <li>Branch Management: If the user returns to a point in the history and performs a new transaction, it automatically clears (RemoveRange) all \"Redo\" history ahead of the current index and creates a new branch.</li> <li>Generic Context Support: Commands run on a generic <code>T</code> target. This target can be a <code>World</code>, <code>Inventory</code>, or <code>EditorWindow</code>.</li> </ul>"},{"location":"API_References/NexusCommandStack_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Execution (Push): A new command arrives. <code>Execute</code> is tried first. If successful, it's added to the list and the index is advanced.</li> <li>Undo (Undo): The <code>Undo</code> method of the command at the current index is called and the index is pulled back.</li> <li>Redo (Redo): The command one ahead of the index is <code>Execute</code>d again and the index is pushed forward.</li> <li>Cleaning: All transaction history is deleted from RAM with <code>Clear</code>.</li> </ol>"},{"location":"API_References/NexusCommandStack_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// An example command: Position Change\npublic class MoveCommand : NexusCommand&lt;Transform&gt; {\n    private Vector3 _oldPos;\n    private Vector3 _newPos;\n\n    public override bool Execute(Transform t) { _oldPos = t.position; t.position = _newPos; return true; }\n    public override bool Undo(Transform t) { t.position = _oldPos; return true; }\n}\n\n// Use in stack\nvar stack = new NexusCommandStack&lt;Transform&gt;();\nstack.PushAndExecute(new MoveCommand(Vector3.up), target);\nstack.Undo(target); // Returns to old position\n</code></pre>"},{"location":"API_References/NexusCommandStack_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Communication;\n\npublic class NexusCommandStack&lt;T&gt;\n{\n    private readonly List&lt;NexusCommand&lt;T&gt;&gt; _commands = new();\n    private int _currentIndex = -1;\n\n    public void PushAndExecute(NexusCommand&lt;T&gt; command, T target) {\n        if (_currentIndex &lt; _commands.Count - 1)\n            _commands.RemoveRange(_currentIndex + 1, _commands.Count - (_currentIndex + 1));\n\n        if (command.Execute(target)) {\n            _commands.Add(command);\n            _currentIndex++;\n        }\n    }\n\n    public void Undo(T target) {\n        if (_currentIndex &gt;= 0 &amp;&amp; _commands[_currentIndex].Undo(target)) _currentIndex--;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusCommandStack_eng/#nexus-optimization-tip-history-capping","title":"Nexus Optimization Tip: History Capping","text":"<p>Set a limit (e.g., last 100 transactions) on the history list to prevent unnecessary memory usage. When the list exceeds this limit, you can prevent memory bloat in long-running sessions by deleting the oldest commands (FIFO).</p>"},{"location":"API_References/NexusCommandStack_tr/","title":"Nexus Prime Mimari Rehberi: NexusCommandStack (\u0130\u015flem Ge\u00e7mi\u015fi Y\u00f6neticisi)","text":""},{"location":"API_References/NexusCommandStack_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusCommandStack.cs</code>, uygulama i\u00e7indeki eylemlerin geri al\u0131nabilmesini (Undo) ve tekrar edilebilmesini (Redo) sa\u011flayan bir \"\u0130\u015flem Ge\u00e7mi\u015fi Katman\u0131\"d\u0131r. HypeFire mimarisinden entegre edilmi\u015ftir. \u00d6zellikle edit\u00f6r ara\u00e7lar\u0131nda, karma\u015f\u0131k UI formlar\u0131nda veya strateji oyunlar\u0131ndaki hamle y\u00f6netiminde kritik rol oynar.</p> <p>Bu y\u0131\u011f\u0131n\u0131n varl\u0131k sebebi; her eylemin bir \"Undo\" senaryosunu (Ters i\u015flem) standart bir yap\u0131da saklayarak, kullan\u0131c\u0131n\u0131n yapt\u0131\u011f\u0131 de\u011fi\u015fiklikleri g\u00fcvenli bir \u015fekilde ileri/geri sarmas\u0131n\u0131 sa\u011flamakt\u0131r.</p>"},{"location":"API_References/NexusCommandStack_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>\u0130\u015flem y\u00f6netimi i\u00e7in \u015fu mimari bile\u015fenleri sunar:</p> <ul> <li>Command Pattern: Her eylem <code>NexusCommand&lt;T&gt;</code> s\u0131n\u0131f\u0131ndan t\u00fcretilir. Bu s\u0131n\u0131flar hem <code>Execute</code> (Y\u00fcr\u00fct) hem de <code>Undo</code> (Geri Al) metodlar\u0131n\u0131 i\u00e7ermek zorundad\u0131r.</li> <li>Pointer-Based Navigation: Ge\u00e7mi\u015f listesi i\u00e7inde bir index (<code>_currentIndex</code>) tutarak, o anki ge\u00e7mi\u015f konumunu takip eder.</li> <li>Branch Management: E\u011fer kullan\u0131c\u0131 ge\u00e7mi\u015fte bir noktaya geri d\u00f6n\u00fcp yeni bir i\u015flem yaparsa, mevcut index'in ilerisindeki t\u00fcm \"Redo\" ge\u00e7mi\u015fini otomatik olarak temizler (RemoveRange) ve yeni bir bran\u015f olu\u015fturur.</li> <li>Generic Context Support: Komutlar jenerik bir <code>T</code> hedefi \u00fczerinde \u00e7al\u0131\u015f\u0131r. Bu hedef bir <code>World</code>, <code>Inventory</code> veya <code>EditorWindow</code> olabilir.</li> </ul>"},{"location":"API_References/NexusCommandStack_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Y\u00fcr\u00fct\u00fcm (Push): Yeni bir komut gelir. \u00d6nce <code>Execute</code> denenir. Ba\u015far\u0131l\u0131ysa listeye eklenir ve index ilerletilir.</li> <li>Geri Al (Undo): Mevcut index'teki komutun <code>Undo</code> metodu \u00e7a\u011fr\u0131l\u0131r ve index geri \u00e7ekilir.</li> <li>Yenile (Redo): Index'in bir \u00f6n\u00fcndeki komut tekrar <code>Execute</code> edilir ve index ileri itilir.</li> <li>Temizlik: <code>Clear</code> ile t\u00fcm i\u015flem ge\u00e7mi\u015fi RAM'den silinir.</li> </ol>"},{"location":"API_References/NexusCommandStack_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// \u00d6rnek bir komut: Pozisyon De\u011fi\u015ftirme\npublic class MoveCommand : NexusCommand&lt;Transform&gt; {\n    private Vector3 _oldPos;\n    private Vector3 _newPos;\n\n    public override bool Execute(Transform t) { _oldPos = t.position; t.position = _newPos; return true; }\n    public override bool Undo(Transform t) { t.position = _oldPos; return true; }\n}\n\n// Y\u0131\u011f\u0131nda kullan\nvar stack = new NexusCommandStack&lt;Transform&gt;();\nstack.PushAndExecute(new MoveCommand(Vector3.up), target);\nstack.Undo(target); // Eski pozisyona d\u00f6ner\n</code></pre>"},{"location":"API_References/NexusCommandStack_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Communication;\n\npublic class NexusCommandStack&lt;T&gt;\n{\n    private readonly List&lt;NexusCommand&lt;T&gt;&gt; _commands = new();\n    private int _currentIndex = -1;\n\n    public void PushAndExecute(NexusCommand&lt;T&gt; command, T target) {\n        if (_currentIndex &lt; _commands.Count - 1)\n            _commands.RemoveRange(_currentIndex + 1, _commands.Count - (_currentIndex + 1));\n\n        if (command.Execute(target)) {\n            _commands.Add(command);\n            _currentIndex++;\n        }\n    }\n\n    public void Undo(T target) {\n        if (_currentIndex &gt;= 0 &amp;&amp; _commands[_currentIndex].Undo(target)) _currentIndex--;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusCommandStack_tr/#nexus-optimization-tip-history-capping","title":"Nexus Optimization Tip: History Capping","text":"<p>Gereksiz bellek kullan\u0131m\u0131n\u0131 \u00f6nlemek i\u00e7in ge\u00e7mi\u015f listesine bir limit (\u00d6rn: Son 100 i\u015flem) koyun. Liste bu limiti a\u015ft\u0131\u011f\u0131nda en eski komutlar\u0131 silerek (FIFO), uzun s\u00fcren oturumlarda bellek \u015fi\u015fmesini engelleyebilirsiniz.</p>"},{"location":"API_References/NexusCoreExtensions_eng/","title":"Nexus Prime Architectural Manual: NexusCoreExtensions (Core Extensions)","text":""},{"location":"API_References/NexusCoreExtensions_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusCoreExtensions.cs</code> contains low-level helper methods (Extension Methods) added to Unity's built-in <code>GameObject</code> and <code>Object</code> classes. It is designed to increase code readability and simplify hierarchy management.</p> <p>The reason for these extensions' existence is to offer one-line, secure, and performant interfaces instead of setting up <code>foreach</code> loops or performing insecure null checks every time.</p>"},{"location":"API_References/NexusCoreExtensions_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Offers the following tools for core functioning:</p> <ul> <li>NexusHierarchyExtensions: Rapidly gathers all children (<code>Transform</code>) under an object as a <code>List&lt;GameObject&gt;</code>. Ideal for bulk manipulation in the scene (e.g., changing the layer of all children).</li> <li>NexusObjectExtensions (Smart Null-Check): Safely identifies Unity's \"Fake Null\" (object's C++ side destroyed but C# side still alive) situations by performing <code>obj.Equals(null)</code> check as well as <code>obj == null</code> check for Unity objects.</li> </ul>"},{"location":"API_References/NexusCoreExtensions_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Hierarchy Scanning: When <code>parent.GetAllChildren()</code> is called, a rapid iteration is performed over the parent's transform.</li> <li>Secure Control: The <code>IsNull()</code> method is consulted to understand if an object is truly \"destroyed or not\".</li> </ol>"},{"location":"API_References/NexusCoreExtensions_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Get all children of an object\nList&lt;GameObject&gt; items = playerPrefab.GetAllChildren();\n\n// Secure null check\nif (target.IsNull()) {\n    Debug.Log(\"Object destroyed or null.\");\n}\n</code></pre>"},{"location":"API_References/NexusCoreExtensions_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\npublic static class NexusHierarchyExtensions\n{\n    public static List&lt;GameObject&gt; GetAllChildren(this GameObject parent) {\n        var children = new List&lt;GameObject&gt;();\n        foreach (Transform child in parent.transform) children.Add(child.gameObject);\n        return children;\n    }\n}\n\npublic static class NexusObjectExtensions\n{\n    public static bool IsNull(this object obj) {\n        return obj == null || obj.Equals(null);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusCoreExtensions_eng/#nexus-optimization-tip-list-pooling","title":"Nexus Optimization Tip: List Pooling","text":"<p>Methods like <code>GetAllChildren</code> perform heap memory allocation by creating <code>new List&lt;GameObject&gt;()</code> every time. Pulling this list from a pool (Pool) in very frequently used places can reduce the Garbage Collector load by 15%.</p>"},{"location":"API_References/NexusCoreExtensions_tr/","title":"Nexus Prime Mimari Rehberi: NexusCoreExtensions (\u00c7ekirdek Eklentiler)","text":""},{"location":"API_References/NexusCoreExtensions_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusCoreExtensions.cs</code>, Unity'nin yerle\u015fik <code>GameObject</code> ve <code>Object</code> s\u0131n\u0131flar\u0131na eklenen d\u00fc\u015f\u00fck seviyeli yard\u0131mc\u0131 metodlar\u0131 (Extension Methods) i\u00e7erir. Kodun okunabilirli\u011fini art\u0131rmak ve hiyerar\u015fi y\u00f6netimini basitle\u015ftirmek i\u00e7in tasarlanm\u0131\u015ft\u0131r.</p> <p>Bu eklentilerin varl\u0131k sebebi; her seferinde <code>foreach</code> d\u00f6ng\u00fcleri kurmak veya g\u00fcvensiz null kontrolleri yapmak yerine, tek sat\u0131rl\u0131k, g\u00fcvenli ve performansl\u0131 aray\u00fczler sunmakt\u0131r.</p>"},{"location":"API_References/NexusCoreExtensions_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>\u00c7ekirdek i\u015fleyi\u015f i\u00e7in \u015fu ara\u00e7lar\u0131 sunar:</p> <ul> <li>NexusHierarchyExtensions: Bir nesnenin alt\u0131ndaki t\u00fcm \u00e7ocuklar\u0131 (<code>Transform</code>) h\u0131zl\u0131ca bir <code>List&lt;GameObject&gt;</code> olarak toplar. Sahnede toplu manip\u00fclasyon (\u00d6rn: T\u00fcm \u00e7ocuklar\u0131n katman\u0131n\u0131 de\u011fi\u015ftirmek) i\u00e7in idealdir.</li> <li>NexusObjectExtensions (Smart Null-Check): Unity nesneleri i\u00e7in <code>obj == null</code> kontrol\u00fcn\u00fcn yan\u0131 s\u0131ra <code>obj.Equals(null)</code> kontrol\u00fcn\u00fc de yaparak, Unity'nin \"Fake Null\" (Nesnenin C++ taraf\u0131 yok edilmi\u015f ama C# taraf\u0131 hala hayatta) durumlar\u0131n\u0131 g\u00fcvenli bir \u015fekilde saptar.</li> </ul>"},{"location":"API_References/NexusCoreExtensions_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Hiyerar\u015fi Tarama: <code>parent.GetAllChildren()</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, parent'\u0131n transformu \u00fczerinden h\u0131zl\u0131 bir iterasyon yap\u0131l\u0131r.</li> <li>G\u00fcvenli Kontrol: Bir nesnenin ger\u00e7ekten \"yok olup olmad\u0131\u011f\u0131n\u0131\" anlamak i\u00e7in <code>IsNull()</code> metoduna ba\u015fvurulur.</li> </ol>"},{"location":"API_References/NexusCoreExtensions_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Bir nesnenin t\u00fcm \u00e7ocuklar\u0131n\u0131 al\nList&lt;GameObject&gt; items = playerPrefab.GetAllChildren();\n\n// G\u00fcvenli null kontrol\u00fc\nif (target.IsNull()) {\n    Debug.Log(\"Nesne yok edildi veya null.\");\n}\n</code></pre>"},{"location":"API_References/NexusCoreExtensions_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\npublic static class NexusHierarchyExtensions\n{\n    public static List&lt;GameObject&gt; GetAllChildren(this GameObject parent) {\n        var children = new List&lt;GameObject&gt;();\n        foreach (Transform child in parent.transform) children.Add(child.gameObject);\n        return children;\n    }\n}\n\npublic static class NexusObjectExtensions\n{\n    public static bool IsNull(this object obj) {\n        return obj == null || obj.Equals(null);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusCoreExtensions_tr/#nexus-optimization-tip-list-pooling","title":"Nexus Optimization Tip: List Pooling","text":"<p><code>GetAllChildren</code> gibi metodlar her seferinde <code>new List&lt;GameObject&gt;()</code> olu\u015fturarak heap bellek ay\u0131rmas\u0131 yapar. \u00c7ok s\u0131k kullan\u0131lan yerlerde bu listeyi bir havuzdan (Pool) \u00e7ekmek, Garbage Collector y\u00fck\u00fcn\u00fc %15 azaltabilir.</p>"},{"location":"API_References/NexusDashboard_eng/","title":"Nexus Prime Architectural Manual: NexusDashboard (Nexus Hub)","text":""},{"location":"API_References/NexusDashboard_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusDashboard.cs</code> is the main command center for all Nexus Prime tools and is called \"The Hub\" within the Editor. It allows the developer to manage complex unmanaged systems, optimization tools, and visual debuggers from a single window.</p> <p>The reason for this interface's existence is to offer a logically grouped \"Developer OS\" (Developer Operating System) experience, instead of getting lost among dozens of different editor windows.</p>"},{"location":"API_References/NexusDashboard_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The Dashboard organizes tools into three main categories:</p> <ul> <li>Architectural &amp; Logic: Low-level systems such as constraint checkers (Constraint Checker), DI engine, Graph Editor, and Bit-Level compression tools.</li> <li>Unity Editor &amp; DX: Visual debugger (Visual Debugger), Time-travel (Time-Travel), heat maps (Memory Heatmap), and Prefab converters.</li> <li>Multimedia &amp; Integration: Shader bridges, Audio linkers, VFX providers, and physics integration tools.</li> </ul>"},{"location":"API_References/NexusDashboard_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Opening: The developer opens the panel from the <code>Nexus -&gt; The Hub</code> menu.</li> <li>Grouping: The <code>DrawGroup</code> method provides a visual hierarchy by putting tools into boxes.</li> <li>Initialization: The \"Initialize All Systems\" button prepares all Nexus sub-systems (Registry, Pool, Sync, etc.) at once.</li> <li>Quick Access: Each button triggers the relevant tool's Editor window.</li> </ol>"},{"location":"API_References/NexusDashboard_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// System initialization via Dashboard\n// 1. [Nexus/The Hub] is opened.\n// 2. [Initialize All Systems] is clicked.\n// 3. The message \"Nexus: Initializing Developer OS Toolset...\" is seen in the Console.\n</code></pre>"},{"location":"API_References/NexusDashboard_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class NexusDashboard : EditorWindow\n{\n    [MenuItem(\"Nexus/The Hub (Dashboard)\")]\n    public static void ShowWindow() =&gt; GetWindow&lt;NexusDashboard&gt;(\"Nexus Dashboard\");\n\n    private void OnGUI() {\n        GUILayout.Label(\"Nexus Developer OS - The Hub\", EditorStyles.boldLabel);\n        // Draw groups...\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusDashboard_eng/#nexus-optimization-tip-window-docking","title":"Nexus Optimization Tip: Window Docking","text":"<p>Dock (Dock) the Nexus Dashboard next to the \"Inspector\" or under the \"Game View\" in the Unity interface. This way, you 100% eliminate the time spent searching for windows to change system states during development.</p>"},{"location":"API_References/NexusDashboard_tr/","title":"Nexus Prime Mimari Rehberi: NexusDashboard (Nexus Hub)","text":""},{"location":"API_References/NexusDashboard_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusDashboard.cs</code>, t\u00fcm Nexus Prime ara\u00e7lar\u0131n\u0131n ana kumanda merkezidir ve Edit\u00f6r i\u00e7inde \"The Hub\" olarak adland\u0131r\u0131l\u0131r. Geli\u015ftiricinin karma\u015f\u0131k unmanaged sistemleri, optimizasyon ara\u00e7lar\u0131n\u0131 ve g\u00f6rsel hata ay\u0131klay\u0131c\u0131lar\u0131 tek bir pencereden y\u00f6netmesini sa\u011flar.</p> <p>Bu aray\u00fcz\u00fcn varl\u0131k sebebi; onlarca farkl\u0131 edit\u00f6r penceresi aras\u0131nda kaybolmak yerine, mant\u0131ksal olarak grupland\u0131r\u0131lm\u0131\u015f bir \"Developer OS\" (Geli\u015ftirici \u0130\u015fletim Sistemi) deneyimi sunmakt\u0131r.</p>"},{"location":"API_References/NexusDashboard_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Dashboard, ara\u00e7lar\u0131 \u00fc\u00e7 ana kategoride organize eder:</p> <ul> <li>Architectural &amp; Logic: K\u0131s\u0131tlay\u0131c\u0131 denetleyiciler (Constraint Checker), DI motoru, Graph Editor ve Bit-Level s\u0131k\u0131\u015ft\u0131rma ara\u00e7lar\u0131 gibi d\u00fc\u015f\u00fck seviyeli sistemler.</li> <li>Unity Editor &amp; DX: G\u00f6rsel hata ay\u0131klay\u0131c\u0131 (Visual Debugger), Zaman yolculu\u011fu (Time-Travel), Is\u0131 haritalar\u0131 (Memory Heatmap) ve Prefab d\u00f6n\u00fc\u015ft\u00fcr\u00fcc\u00fcler.</li> <li>Multimedia &amp; Integration: Shader k\u00f6pr\u00fcleri, Audio linker'lar, VFX sa\u011flay\u0131c\u0131lar ve fizik entegrasyon ara\u00e7lar\u0131.</li> </ul>"},{"location":"API_References/NexusDashboard_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>A\u00e7\u0131l\u0131\u015f: Geli\u015ftirici <code>Nexus -&gt; The Hub</code> men\u00fcs\u00fcnden paneli a\u00e7ar.</li> <li>Grupland\u0131rma: <code>DrawGroup</code> metodu, ara\u00e7lar\u0131 kutular i\u00e7ine alarak g\u00f6rsel hiyerar\u015fi sa\u011flar.</li> <li>Ba\u015flatma: \"Initialize All Systems\" butonu, t\u00fcm Nexus alt sistemlerini (Registry, Pool, Sync vb.) tek seferde haz\u0131r hale getirir.</li> <li>H\u0131zl\u0131 Eri\u015fim: Her buton, ilgili arac\u0131n Edit\u00f6r penceresini tetikler.</li> </ol>"},{"location":"API_References/NexusDashboard_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Dashboard \u00fczerinden sistem ba\u015flatma\n// 1. [Nexus/The Hub] a\u00e7\u0131l\u0131r.\n// 2. [Initialize All Systems] t\u0131klan\u0131r.\n// 3. Console'da \"Nexus: Initializing Developer OS Toolset...\" mesaj\u0131 g\u00f6r\u00fcl\u00fcr.\n</code></pre>"},{"location":"API_References/NexusDashboard_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class NexusDashboard : EditorWindow\n{\n    [MenuItem(\"Nexus/The Hub (Dashboard)\")]\n    public static void ShowWindow() =&gt; GetWindow&lt;NexusDashboard&gt;(\"Nexus Dashboard\");\n\n    private void OnGUI() {\n        GUILayout.Label(\"Nexus Developer OS - The Hub\", EditorStyles.boldLabel);\n        // Draw groups...\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusDashboard_tr/#nexus-optimization-tip-window-docking","title":"Nexus Optimization Tip: Window Docking","text":"<p>Nexus Dashboard'u Unity aray\u00fcz\u00fcnde \"Inspector\" yan\u0131na veya \"Game View\" alt\u0131na sabitleyin (Dock). Bu sayede geli\u015ftirme s\u0131ras\u0131nda sistem durumlar\u0131n\u0131 de\u011fi\u015ftirmek i\u00e7in pencere arama s\u00fcresini %100 ortadan kald\u0131r\u0131rs\u0131n\u0131z.</p>"},{"location":"API_References/NexusDebugAttribute_eng/","title":"Nexus Prime Architectural Manual: NexusDebugAttribute (Visual Debugging)","text":""},{"location":"API_References/NexusDebugAttribute_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusDebugAttribute.cs</code> is the \"Visual Diagnostics\" tool that connects Nexus Prime's unmanaged data world to the visual world of the Unity Editor. It allows data that exists only as numbers and bytes within the code (e.g., Position, Velocity, Target) to appear as shapes or labels on the Unity Scene view.</p> <p>The reason for this attribute's existence is that unmanaged structs cannot directly access the Unity Gizmos system. Data marked with <code>NexusDebug</code> is automatically captured by the Nexus Editor Suite and drawn on the screen.</p>"},{"location":"API_References/NexusDebugAttribute_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusDebugAttribute offers the following parameters for debugging processes:</p> <ul> <li>DebugShape Enum: Provides the option to visualize data as a <code>Point</code>, <code>Arrow</code>, <code>Line</code>, or <code>Label</code>.</li> <li>Color Selection: Allows determining the color of visualization with hexadecimal (Hex) color codes.</li> <li>Scale Control: Dynamically adjusts the size (<code>Size</code>) of the drawn shapes.</li> <li>Reflective Discovery: Editor tools automatically add fields carrying this attribute to the \"Draw List\" while scanning systems.</li> </ul>"},{"location":"API_References/NexusDebugAttribute_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Marking: The developer marks a component they want to debug with <code>[NexusDebug]</code>.</li> <li>Capturing: While the Unity Editor is running, Nexus's Gizmo manager finds active entities carrying this attribute.</li> <li>Conversion: Unmanaged data (e.g., <code>Vector3</code>) is converted into the Unity Gizmos command suitable for the selected shape (Shape).</li> <li>Drawing: Visualized in real-time on the Scene view.</li> </ol>"},{"location":"API_References/NexusDebugAttribute_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>[NexusDebug(DebugShape.Arrow, \"#FF0000\", 2.0f)]\npublic struct Velocity {\n    public float3 Value;\n}\n</code></pre>"},{"location":"API_References/NexusDebugAttribute_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Attributes;\n\npublic enum DebugShape { Point, Arrow, Line, Label }\n\n[AttributeUsage(AttributeTargets.Field | AttributeTargets.Struct)]\npublic class NexusDebugAttribute : Attribute\n{\n    public DebugShape Shape { get; }\n    public string ColorHex { get; }\n    public float Size { get; }\n\n    public NexusDebugAttribute(DebugShape shape = DebugShape.Label, string colorHex = \"#FFFFFF\", float size = 1.0f)\n    {\n        Shape = shape;\n        ColorHex = colorHex;\n        Size = size;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusDebugAttribute_eng/#nexus-optimization-tip-targeted-debugging","title":"Nexus Optimization Tip: Targeted Debugging","text":"<p>Instead of debugging all entities, filter <code>NexusDebug</code> parameters to visualize only selected entities or entities within a certain radius. This prevents Scene view FPS drop, allowing you to work comfortably among thousands of entities.</p>"},{"location":"API_References/NexusDebugAttribute_tr/","title":"Nexus Prime Mimari Rehberi: NexusDebugAttribute (G\u00f6rsel Hata Ay\u0131klama)","text":""},{"location":"API_References/NexusDebugAttribute_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusDebugAttribute.cs</code>, Nexus Prime'\u0131n unmanaged veri d\u00fcnyas\u0131n\u0131 Unity Editor'\u00fcn g\u00f6rsel d\u00fcnyas\u0131na ba\u011flayan \"G\u00f6rsel Te\u015fhis\" (Visual Diagnostics) arac\u0131d\u0131r. Kodun i\u00e7inde sadece say\u0131lar ve byte'lar olarak duran verilerin (\u00d6rn: Pozisyon, H\u0131z, Hedef) Unity Scene view \u00fczerinde \u015fekil veya etiket olarak g\u00f6r\u00fcnmesini sa\u011flar.</p> <p>Bu \u00f6zniteli\u011fin varl\u0131k sebebi, unmanaged struct'lar\u0131n Unity Gizmos sistemine do\u011frudan eri\u015fememesidir. <code>NexusDebug</code> ile i\u015faretlenen veriler, Nexus Editor Suite taraf\u0131ndan otomatik olarak yakalan\u0131r ve ekrana \u00e7izilir.</p>"},{"location":"API_References/NexusDebugAttribute_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusDebugAttribute, hata ay\u0131klama s\u00fcre\u00e7leri i\u00e7in \u015fu parametreleri sunar:</p> <ul> <li>DebugShape Enum: Veriyi <code>Point</code>, <code>Arrow</code>, <code>Line</code> veya <code>Label</code> (Yaz\u0131) olarak g\u00f6rselle\u015ftirme se\u00e7ene\u011fi sunar.</li> <li>Color Selection: Onluk (Hex) renk kodlar\u0131 ile g\u00f6rselle\u015ftirmenin rengini belirlemeyi sa\u011flar.</li> <li>Scale Control: \u00c7izilen \u015fekillerin boyutunu (<code>Size</code>) dinamik olarak ayarlar.</li> <li>Reflective Discovery: Editor ara\u00e7lar\u0131, sistemleri tararken bu \u00f6zniteli\u011fi ta\u015f\u0131yan alanlar\u0131 otomatik olarak \"Draw List\"e ekler.</li> </ul>"},{"location":"API_References/NexusDebugAttribute_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130\u015faretleme: Geli\u015ftirici, debug etmek istedi\u011fi bir bile\u015feni <code>[NexusDebug]</code> ile i\u015faretler.</li> <li>Yakalama: Unity Editor \u00e7al\u0131\u015f\u0131rken, Nexus'un Gizmo y\u00f6neticisi bu \u00f6zniteli\u011fi ta\u015f\u0131yan aktif varl\u0131klar\u0131 bulur.</li> <li>D\u00f6n\u00fc\u015ft\u00fcrme: Unmanaged veri (\u00d6rn: <code>Vector3</code>), se\u00e7ilen \u015fekle (Shape) uygun Unity Gizmos komutuna d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcr.</li> <li>\u00c7izim: Scene view \u00fczerinde ger\u00e7ek zamanl\u0131 olarak g\u00f6rselle\u015ftirilir.</li> </ol>"},{"location":"API_References/NexusDebugAttribute_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>[NexusDebug(DebugShape.Arrow, \"#FF0000\", 2.0f)]\npublic struct Velocity {\n    public float3 Value;\n}\n</code></pre>"},{"location":"API_References/NexusDebugAttribute_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Attributes;\n\npublic enum DebugShape { Point, Arrow, Line, Label }\n\n[AttributeUsage(AttributeTargets.Field | AttributeTargets.Struct)]\npublic class NexusDebugAttribute : Attribute\n{\n    public DebugShape Shape { get; }\n    public string ColorHex { get; }\n    public float Size { get; }\n\n    public NexusDebugAttribute(DebugShape shape = DebugShape.Label, string colorHex = \"#FFFFFF\", float size = 1.0f)\n    {\n        Shape = shape;\n        ColorHex = colorHex;\n        Size = size;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusDebugAttribute_tr/#nexus-optimization-tip-targeted-debugging","title":"Nexus Optimization Tip: Targeted Debugging","text":"<p>T\u00fcm varl\u0131klar\u0131 debug etmek yerine sadece se\u00e7ili (selected) varl\u0131klar\u0131 veya belirli bir yar\u0131\u00e7aptaki varl\u0131klar\u0131 g\u00f6rselle\u015ftirmek i\u00e7in <code>NexusDebug</code> parametrelerini filtreleyin. Bu, Scene view FPS d\u00fc\u015f\u00fc\u015f\u00fcn\u00fc engelleyerek binlerce varl\u0131k aras\u0131nda rahat\u00e7a \u00e7al\u0131\u015fman\u0131z\u0131 sa\u011flar.</p>"},{"location":"API_References/NexusDevelopmentSuite_eng/","title":"Nexus Prime Architectural Manual: NexusDevelopmentSuite (Development Suite)","text":""},{"location":"API_References/NexusDevelopmentSuite_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusDevelopmentSuite.cs</code> is a \"Facilitator\" package that automates the setup, maintenance, and daily workflow of Nexus Prime projects. It preserves file arrangement and system integrity from the first day to the last day of the project.</p> <p>The reason for this package's existence is to eliminate chore tasks such as manually creating folders in every new project, making git settings, or manually updating localization tables.</p>"},{"location":"API_References/NexusDevelopmentSuite_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The package consists of the following main components:</p> <ul> <li>InitializeOnLoad Hook: Runs automatically when the Editor is opened or the code is compiled. It contains a silent thread that saves assets every 5 minutes (<code>Auto Save</code>).</li> <li>NexusWizard (Wizard): Sets up the project's standard Nexus folder structure (<code>Scripts</code>, <code>Entities</code>, <code>Data</code>, <code>UI</code>, etc.) with one click.</li> <li>Optimization Tools Integration: Optimizes git settings and project configurations according to Nexus standards.</li> <li>Localization Bridge: Automatically generates localization tables compatible with unmanaged memory.</li> </ul>"},{"location":"API_References/NexusDevelopmentSuite_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Setup: The developer follows the <code>Nexus -&gt; Wizard -&gt; Setup Project</code> path.</li> <li>Automation: The wizard builds the entire infrastructure by calling the <code>NexusFolderManager</code> and <code>NexusOptimizationTools</code> classes.</li> <li>Continuous Monitoring: As long as the Editor is open, it periodically ensures data security (Auto-save) in the background.</li> </ol>"},{"location":"API_References/NexusDevelopmentSuite_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// In a new project:\n// 1. [Nexus/Wizard/Setup Project] is clicked.\n// 2. The \"Initialize All Systems\" button is pressed.\n// 3. Project folders, Git settings, and Core systems are ready within milliseconds.\n</code></pre>"},{"location":"API_References/NexusDevelopmentSuite_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\n[InitializeOnLoad]\npublic static class NexusDevelopmentSuite\n{\n    static NexusDevelopmentSuite() {\n        EditorApplication.update += () =&gt; {\n            // Auto-save logic...\n        };\n    }\n\n    [MenuItem(\"Nexus/Wizard/Setup Project\")]\n    public static void OpenWizard() =&gt; NexusWizard.ShowWindow();\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusDevelopmentSuite_eng/#nexus-optimization-tip-auto-save-frequency","title":"Nexus Optimization Tip: Auto-Save Frequency","text":"<p>Optimize the default 5-minute (300 seconds) auto-save time according to your hardware power. In very large scenes, increasing this time to 10 minutes minimizes instantaneous stutters (Freeze) in the editor.</p>"},{"location":"API_References/NexusDevelopmentSuite_tr/","title":"Nexus Prime Mimari Rehberi: NexusDevelopmentSuite (Geli\u015ftirme Paketi)","text":""},{"location":"API_References/NexusDevelopmentSuite_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusDevelopmentSuite.cs</code>, Nexus Prime projelerinin kurulumunu, bak\u0131m\u0131n\u0131 ve g\u00fcnl\u00fck i\u015f ak\u0131\u015f\u0131n\u0131 otomatize eden bir \"Kolayla\u015ft\u0131r\u0131c\u0131\" paketidir. Projenin ilk g\u00fcn\u00fcnden son g\u00fcn\u00fcne kadar dosya d\u00fczenini ve sistem b\u00fct\u00fcnl\u00fc\u011f\u00fcn\u00fc korur.</p> <p>Bu paketin varl\u0131k sebebi; her yeni projede klas\u00f6rleri elle olu\u015fturmak, git ayarlar\u0131n\u0131 yapmak veya yerelle\u015ftirme tablolar\u0131n\u0131 manuel g\u00fcncellemek gibi angarya i\u015fleri ortadan kald\u0131rmakt\u0131r.</p>"},{"location":"API_References/NexusDevelopmentSuite_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Paket \u015fu ana bile\u015fenlerden olu\u015fur:</p> <ul> <li>InitializeOnLoad Hook: Editor a\u00e7\u0131ld\u0131\u011f\u0131nda veya kod derlendi\u011finde otomatik olarak \u00e7al\u0131\u015f\u0131r. \u0130\u00e7inde 5 dakikada bir varl\u0131klar\u0131 kaydeden (<code>Auto Save</code>) sessiz bir i\u015f par\u00e7ac\u0131\u011f\u0131 bar\u0131nd\u0131r\u0131r.</li> <li>NexusWizard (Sihirbaz): Projenin standart Nexus klas\u00f6r yap\u0131s\u0131n\u0131 (<code>Scripts</code>, <code>Entities</code>, <code>Data</code>, <code>UI</code> vb.) tek tu\u015fla kurar.</li> <li>Optimization Tools Integration: Git ayarlar\u0131n\u0131 ve proje yap\u0131land\u0131rmalar\u0131n\u0131 Nexus standartlar\u0131na g\u00f6re optimize eder.</li> <li>Localization Bridge: Unmanaged bellek ile uyumlu yerelle\u015ftirme tablolar\u0131n\u0131 otomatik olarak \u00fcretir.</li> </ul>"},{"location":"API_References/NexusDevelopmentSuite_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Kurulum: Geli\u015ftirici <code>Nexus -&gt; Wizard -&gt; Setup Project</code> yolunu izler.</li> <li>Otomasyon: Sihirbaz, <code>NexusFolderManager</code> ve <code>NexusOptimizationTools</code> s\u0131n\u0131flar\u0131n\u0131 \u00e7a\u011f\u0131rarak t\u00fcm altyap\u0131y\u0131 in\u015fa eder.</li> <li>S\u00fcrekli \u0130zleme: Edit\u00f6r a\u00e7\u0131k oldu\u011fu s\u00fcrece periyodik olarak arka planda veri g\u00fcvenli\u011fini (Auto-save) sa\u011flar.</li> </ol>"},{"location":"API_References/NexusDevelopmentSuite_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Yeni bir projede:\n// 1. [Nexus/Wizard/Setup Project] t\u0131klan\u0131r.\n// 2. \"Initialize All Systems\" butonuna bas\u0131l\u0131r.\n// 3. Proje klas\u00f6rleri, Git ayarlar\u0131 ve Core sistemler milisaniyeler i\u00e7inde haz\u0131r olur.\n</code></pre>"},{"location":"API_References/NexusDevelopmentSuite_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\n[InitializeOnLoad]\npublic static class NexusDevelopmentSuite\n{\n    static NexusDevelopmentSuite() {\n        EditorApplication.update += () =&gt; {\n            // Auto-save logic...\n        };\n    }\n\n    [MenuItem(\"Nexus/Wizard/Setup Project\")]\n    public static void OpenWizard() =&gt; NexusWizard.ShowWindow();\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusDevelopmentSuite_tr/#nexus-optimization-tip-auto-save-frequency","title":"Nexus Optimization Tip: Auto-Save Frequency","text":"<p>Varsay\u0131lan 5 dakikal\u0131k (300 saniye) auto-save s\u00fcresini donan\u0131m g\u00fcc\u00fcn\u00fcze g\u00f6re optimize edin. \u00c7ok b\u00fcy\u00fck sahnelerde bu s\u00fcreyi 10 dakikaya \u00e7\u0131karmak, edit\u00f6rdeki anl\u0131k tak\u0131lmalar\u0131 (Freeze) minimize eder.</p>"},{"location":"API_References/NexusDevelopmentTools_eng/","title":"Nexus Prime Architectural Manual: NexusDevelopmentTools (Development Tools &amp; Pooling)","text":""},{"location":"API_References/NexusDevelopmentTools_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusDevelopmentTools.cs</code> offers two main structures critical for memory management and system accessibility: <code>NexusObjectPool</code> (Object Pooling) and <code>NexusMonoBehaviourSingleton</code> (Singleton Pattern). It organizes the project's runtime performance and code organization.</p> <p>The reason for these tools' existence is to avoid expensive Unity operations such as <code>Instantiate</code> on every object request and <code>Destroy</code> on destruction, and to safely access global services.</p>"},{"location":"API_References/NexusDevelopmentTools_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Contains the following foundational structures for the development process:</p> <ul> <li>NexusObjectPool: Stores deactivated objects using <code>Queue&lt;GameObject&gt;</code>. When <code>Spawn</code> is called, it pulls from the pool instead of creating a new object. Normalizes prefab names with <code>name.Replace(\"(Clone)\", \"\")</code> and places them in the correct pool.</li> <li>INexusPoolable (Interface): A contract determining what pooled objects will do at their \"birth\" (<code>OnSpawn</code>) and \"death\" (<code>OnDespawn</code>) moments.</li> <li>NexusMonoBehaviourSingleton: Offers a thread-safe (thread safe) Singleton optimized for the Unity world with the <code>lock(_lock)</code> mechanism. Automatically creates the object if it doesn't exist in the scene.</li> </ul>"},{"location":"API_References/NexusDevelopmentTools_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Spawn: It's checked if there's an empty object in the requested prefab's pool. If so, it activates; if not, it's newly copied.</li> <li>Lifecycle: <code>OnSpawn</code> is triggered when the object leaves the pool; its health fills, its visual is reset.</li> <li>Despawn: <code>OnDespawn</code> is triggered when the object is returned; effects stop, the object deactivates and enters the pool.</li> <li>Singleton Access: When <code>Instance</code> is called, the system ensures there's one \"Unique\" object in the scene.</li> </ol>"},{"location":"API_References/NexusDevelopmentTools_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Get object from pool\nGameObject bullet = NexusObjectPool.Spawn(bulletPrefab, pos, rot);\n\n// When a bullet is finished, return to pool\nNexusObjectPool.Despawn(gameObject);\n\n// Singleton example\npublic class UIManager : NexusMonoBehaviourSingleton&lt;UIManager&gt; { ... }\nUIManager.Instance.ShowSplash();\n</code></pre>"},{"location":"API_References/NexusDevelopmentTools_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity.Core;\n\npublic class NexusObjectPool : MonoBehaviour\n{\n    private static readonly Dictionary&lt;string, Queue&lt;GameObject&gt;&gt; _pools = new();\n\n    public static GameObject Spawn(GameObject prefab, Vector3 pos, Quaternion rot) {\n        // Queue logic...\n        return Instantiate(prefab, pos, rot);\n    }\n}\n\npublic abstract class NexusMonoBehaviourSingleton&lt;T&gt; : MonoBehaviour where T : MonoBehaviour {\n    private static T _instance;\n    public static T Instance {\n        get {\n            // Thread-safe instance creation...\n            return _instance;\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/NexusDevelopmentTools_eng/#nexus-optimization-tip-stride-memory","title":"Nexus Optimization Tip: Stride Memory","text":"<p>Storing objects in the pool within a <code>Queue</code> provides O(1) access. However, if the pool grows too large (e.g., 50,000 bullets), the <code>Dictionary</code> key search (<code>string hashing</code>) can create CPU load. Using <code>Prefab.ID</code> instead of Key at very large scales increases performance by an additional 10%.</p>"},{"location":"API_References/NexusDevelopmentTools_tr/","title":"Nexus Prime Mimari Rehberi: NexusDevelopmentTools (Geli\u015ftirme Ara\u00e7lar\u0131 &amp; Havuzlama)","text":""},{"location":"API_References/NexusDevelopmentTools_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusDevelopmentTools.cs</code>, bellek y\u00f6netimi ve sistem eri\u015filebilirli\u011fi i\u00e7in kritik olan iki ana yap\u0131y\u0131 sunar: <code>NexusObjectPool</code> (Nesne Havuzlama) ve <code>NexusMonoBehaviourSingleton</code> (Tekil Nesne Deseni). Projenin \u00e7al\u0131\u015fma zaman\u0131 performans\u0131n\u0131 ve kod organizasyonunu d\u00fczenler.</p> <p>Bu ara\u00e7lar\u0131n varl\u0131k sebebi; her nesne talebinde <code>Instantiate</code> ve yok etmede <code>Destroy</code> gibi pahal\u0131 Unity i\u015flemlerinden ka\u00e7\u0131nmak ve global servislere g\u00fcvenli bir \u015fekilde eri\u015fmektir.</p>"},{"location":"API_References/NexusDevelopmentTools_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Geli\u015ftirme s\u00fcreci i\u00e7in \u015fu temel yap\u0131lar\u0131 bar\u0131nd\u0131r\u0131r:</p> <ul> <li>NexusObjectPool: <code>Queue&lt;GameObject&gt;</code> kullanarak devre d\u0131\u015f\u0131 b\u0131rak\u0131lan nesneleri saklar. <code>Spawn</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda yeni nesne olu\u015fturmak yerine havuzdan \u00e7eker. <code>name.Replace(\"(Clone)\", \"\")</code> ile prefab isimlerini normalize ederek do\u011fru havuza yerle\u015ftirir.</li> <li>INexusPoolable (Aray\u00fcz): Havuzlanan nesnelerin \"do\u011fma\" (<code>OnSpawn</code>) ve \"\u00f6lme\" (<code>OnDespawn</code>) anlar\u0131nda ne yapacaklar\u0131n\u0131 belirleyen bir kontratt\u0131r.</li> <li>NexusMonoBehaviourSingleton: Unity d\u00fcnyas\u0131 i\u00e7in optimize edilmi\u015f, <code>lock(_lock)</code> mekanizmas\u0131yla thread-safe (i\u015f par\u00e7ac\u0131\u011f\u0131 g\u00fcvenli) Singleton sunar. Nesne sahnede yoksa otomatik olarak olu\u015fturur.</li> </ul>"},{"location":"API_References/NexusDevelopmentTools_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Spawn: \u0130stenen prefab'\u0131n havuzunda bo\u015f nesne var m\u0131 bak\u0131l\u0131r. Varsa aktifle\u015fir, yoksa yeni kopyalan\u0131r.</li> <li>Ya\u015fam D\u00f6ng\u00fcs\u00fc: Nesne havuzdan \u00e7\u0131k\u0131nca <code>OnSpawn</code> tetiklenir; can\u0131 dolar, g\u00f6rseli s\u0131f\u0131rlan\u0131r.</li> <li>Despawn: Nesne iade edilirken <code>OnDespawn</code> tetiklenir; efektler durur, nesne pasifle\u015fir ve havuza girer.</li> <li>Singleton Eri\u015fimi: <code>Instance</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda sistem sahnede bir tane \"Unique\" nesne oldu\u011fundan emin olur.</li> </ol>"},{"location":"API_References/NexusDevelopmentTools_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Havuzdan nesne al\nGameObject bullet = NexusObjectPool.Spawn(bulletPrefab, pos, rot);\n\n// Bir mermi bitti\u011finde havuzla iade et\nNexusObjectPool.Despawn(gameObject);\n\n// Singleton \u00f6rne\u011fi\npublic class UIManager : NexusMonoBehaviourSingleton&lt;UIManager&gt; { ... }\nUIManager.Instance.ShowSplash();\n</code></pre>"},{"location":"API_References/NexusDevelopmentTools_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity.Core;\n\npublic class NexusObjectPool : MonoBehaviour\n{\n    private static readonly Dictionary&lt;string, Queue&lt;GameObject&gt;&gt; _pools = new();\n\n    public static GameObject Spawn(GameObject prefab, Vector3 pos, Quaternion rot) {\n        // Queue logic...\n        return Instantiate(prefab, pos, rot);\n    }\n}\n\npublic abstract class NexusMonoBehaviourSingleton&lt;T&gt; : MonoBehaviour where T : MonoBehaviour {\n    private static T _instance;\n    public static T Instance {\n        get {\n            // Thread-safe instance creation...\n            return _instance;\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/NexusDevelopmentTools_tr/#nexus-optimization-tip-stride-memory","title":"Nexus Optimization Tip: Stride Memory","text":"<p>Havuzdaki nesnelerin <code>Queue</code> i\u00e7inde saklanmas\u0131 O(1) eri\u015fim sa\u011flar. Ancak havuz \u00e7ok b\u00fcy\u00fcrse (\u00d6rn: 50.000 mermi), <code>Dictionary</code> anahtar aramas\u0131 (<code>string hashing</code>) CPU y\u00fck\u00fc olu\u015fturabilir. \u00c7ok b\u00fcy\u00fck \u00f6l\u00e7eklerde Key yerine <code>Prefab.ID</code> kullanmak performans\u0131 ek bir %10 art\u0131r\u0131r.</p>"},{"location":"API_References/NexusEntity_eng/","title":"Nexus Prime Architectural Manual: NexusEntity (Unity-ECS Identity Bridge)","text":""},{"location":"API_References/NexusEntity_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusEntity.cs</code> is the most fundamental component in Nexus Prime's hybrid architecture. It acts as the \"Identity Link\" matching a Unity <code>GameObject</code> with an <code>EntityId</code> in Nexus's unmanaged world.</p> <p>The reason for this component's existence is to ensure that visual objects in Unity's scenes can synchronize with the high-performance data-driven logic layer (Simulation). Each NexusEntity is actually the Unity-side \"Representative\" of an entity in the ECS world.</p>"},{"location":"API_References/NexusEntity_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusEntity follows these strategies for identity management:</p> <ul> <li>Entity Identification: Stores the <code>EntityId</code> (Index and Version) assigned to the entity. This ID is the key used to reach data on the unmanaged <code>Registry</code>.</li> <li>Strict Singleton Component: Guarantees that an object is represented by only a single ECS entity with <code>[DisallowMultipleComponent]</code>.</li> <li>Auto-Initialization: If the object was not created by an ECS system (e.g., Standard Unity Instantiation), it creates a temporary virtual identity using Unity's <code>InstanceID</code> at the moment of <code>Awake</code>.</li> <li>Read-Only Inspection: Allows the ID to appear on the Inspector but protects data integrity by preventing manual modification.</li> </ul>"},{"location":"API_References/NexusEntity_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Awake: Identity is checked when the object becomes active in the scene.</li> <li>Mapping: If the ID is invalid, a virtual ECS identity is assigned to the object.</li> <li>Service: Other Unity components (e.g., <code>NexusSyncTransform</code>) pull data from the Nexus Registry using the <code>Id</code> property of this object.</li> </ol>"},{"location":"API_References/NexusEntity_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Learn the ECS identity of an object\nvar entity = GetComponent&lt;NexusEntity&gt;();\nif (entity.Id.IsNotNull) {\n    Debug.Log($\"Entity Index: {entity.Id.Index}\");\n}\n</code></pre>"},{"location":"API_References/NexusEntity_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\n[DisallowMultipleComponent]\npublic class NexusEntity : MonoBehaviour\n{\n    [SerializeField, ReadOnly] private EntityId _id = EntityId.Null;\n\n    public EntityId Id {\n        get =&gt; _id;\n        internal set =&gt; _id = value;\n    }\n\n    private void Awake() {\n        if (_id.IsNull) _id = new EntityId { Index = (uint)gameObject.GetInstanceID(), Version = 0 };\n    }\n}\n</code></pre>"},{"location":"API_References/NexusEntity_eng/#nexus-optimization-tip-explicit-id-assignment","title":"Nexus Optimization Tip: Explicit ID Assignment","text":"<p>When instantiating objects in a hybrid project, manually match the <code>NexusEntity.Id</code> value with a real ID you created via the Nexus Registry. The use of virtual IDs (InstanceID based) may not work fully compatibly with unmanaged systems on the Registry.</p>"},{"location":"API_References/NexusEntity_tr/","title":"Nexus Prime Mimari Rehberi: NexusEntity (Unity-ECS Kimlik K\u00f6pr\u00fcs\u00fc)","text":""},{"location":"API_References/NexusEntity_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusEntity.cs</code>, Nexus Prime'\u0131n hibrit mimarisindeki en temel bile\u015fendir. Bir Unity <code>GameObject</code>'ini, Nexus'un unmanaged d\u00fcnyas\u0131ndaki bir <code>EntityId</code> ile e\u015fle\u015ftiren \"Kimlik Ba\u011flant\u0131s\u0131\" (Identity Link) g\u00f6revini g\u00f6r\u00fcr.</p> <p>Bu bile\u015fenin varl\u0131k sebebi; Unity'nin sahnelerindeki g\u00f6rsel nesnelerin, y\u00fcksek performansl\u0131 veriye dayal\u0131 (data-driven) mant\u0131k katman\u0131yla (Sim\u00fclasyon) senkronize olabilmesini sa\u011flamakt\u0131r. Her NexusEntity, asl\u0131nda ECS d\u00fcnyas\u0131ndaki bir varl\u0131\u011f\u0131n Unity taraf\u0131ndaki \"Temsilcisi\"dir.</p>"},{"location":"API_References/NexusEntity_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusEntity, kimlik y\u00f6netimi i\u00e7in \u015fu stratejileri izler:</p> <ul> <li>Entity Identification: Varl\u0131\u011fa atanm\u0131\u015f olan <code>EntityId</code>'yi (Index ve Version) saklar. Bu ID, unmanaged <code>Registry</code> \u00fczerindeki verilere ula\u015fmak i\u00e7in kullan\u0131lan anahtard\u0131r.</li> <li>Strict Singleton Component: <code>[DisallowMultipleComponent]</code> ile bir nesnenin sadece tek bir ECS varl\u0131\u011f\u0131yla temsil edilmesini garanti eder.</li> <li>Auto-Initialization: E\u011fer nesne bir ECS sistemi taraf\u0131ndan olu\u015fturulmad\u0131ysa (\u00d6rn: Standart Unity Instantiation), <code>Awake</code> an\u0131nda Unity'nin <code>InstanceID</code>'sini kullanarak ge\u00e7ici bir sanal kimlik olu\u015fturur.</li> <li>Read-Only Inspection: Inspector \u00fczerinde ID'nin g\u00f6r\u00fcnmesini sa\u011flar ama elle de\u011fi\u015ftirilmesini engelleyerek veri b\u00fct\u00fcnl\u00fc\u011f\u00fcn\u00fc korur.</li> </ul>"},{"location":"API_References/NexusEntity_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Awake: Nesne sahnede aktif oldu\u011funda kimli\u011fi kontrol edilir.</li> <li>E\u015fleme: E\u011fer ID ge\u00e7ersizse, nesneye bir sanal ECS kimli\u011fi atan\u0131r.</li> <li>Hizmet: Di\u011fer Unity bile\u015fenleri (\u00d6rn: <code>NexusSyncTransform</code>), bu nesnenin <code>Id</code> \u00f6zelli\u011fini kullanarak Nexus Registry'den veri \u00e7eker.</li> </ol>"},{"location":"API_References/NexusEntity_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Bir nesnenin ECS kimli\u011fini \u00f6\u011fren\nvar entity = GetComponent&lt;NexusEntity&gt;();\nif (entity.Id.IsNotNull) {\n    Debug.Log($\"Varl\u0131k Indeksi: {entity.Id.Index}\");\n}\n</code></pre>"},{"location":"API_References/NexusEntity_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\n[DisallowMultipleComponent]\npublic class NexusEntity : MonoBehaviour\n{\n    [SerializeField, ReadOnly] private EntityId _id = EntityId.Null;\n\n    public EntityId Id {\n        get =&gt; _id;\n        internal set =&gt; _id = value;\n    }\n\n    private void Awake() {\n        if (_id.IsNull) _id = new EntityId { Index = (uint)gameObject.GetInstanceID(), Version = 0 };\n    }\n}\n</code></pre>"},{"location":"API_References/NexusEntity_tr/#nexus-optimization-tip-explicit-id-assignment","title":"Nexus Optimization Tip: Explicit ID Assignment","text":"<p>Hibrit bir projede nesneleri <code>Instantiate</code> ederken, <code>NexusEntity.Id</code> de\u011ferini manual olarak Nexus Registry \u00fczerinden olu\u015fturdu\u011funuz ger\u00e7ek bir ID ile e\u015fleyin. Sanal ID kullan\u0131m\u0131 (InstanceID tabanl\u0131), Registry \u00fczerindeki unmanaged sistemlerle tam uyumlu \u00e7al\u0131\u015fmayabilir.</p>"},{"location":"API_References/NexusEventBus_eng/","title":"Nexus Prime Architectural Manual: NexusEventBus (Messaging Backbone)","text":""},{"location":"API_References/NexusEventBus_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusEventBus.cs</code> is the \"Nervous System\" of the Nexus Prime framework. It is a high-performance distribution center providing communication between independent systems (e.g., ECS Simulation, Unity UI, Network Layer) without them knowing about each other (Decoupled).</p> <p>The reason for this bus's existence is to offer a data-driven reactive architecture by removing the requirement \"System A must know system B\" (Tight Coupling). Any type of data structure using the <code>INexusEvent</code> interface can be distributed at the speed of light via this system.</p>"},{"location":"API_References/NexusEventBus_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Offers the following multi-modal structures for maximum flexibility and performance:</p> <ul> <li>Global Pub/Sub: Standard events that can be listened to and triggered from anywhere. Provides thread-safe management with <code>ConcurrentDictionary</code>.</li> <li>Local (Per-Entity) Events: Events concerning only a specific entity (EntityId). E.g.: Transmits \"This enemy took damage\" info only to the UI component attached to that enemy.</li> <li>Buffered Publishing: Queues (Buffers) events that do not yet have subscribers and sprays them to them when the first subscriber arrives.</li> <li>Debounced Publishing: Prevents the same event from being triggered thousands of times within a certain time interval (e.g., UI update signals).</li> <li>Unity-to-Entity Resolution: Simplifies coding in hybrid projects by automatically converting Unity <code>GameObject</code> or <code>Component</code> references into <code>EntityId</code>.</li> </ul>"},{"location":"API_References/NexusEventBus_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Subscription (Subscribe): A system records itself saying \"I am interested in <code>PlayerSpawnEvent</code>\".</li> <li>Publishing (Publish): Another system throws the event.</li> <li>Filtering: If the event is local (Local), it is distributed only to the target entity's subscribers; if it is global, to all relevant systems.</li> <li>Execution: Callback methods (Delegate) are called in order.</li> </ol>"},{"location":"API_References/NexusEventBus_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Decoupling Systems being able to communicate without knowing each other's internal structure. Reactive Logic Automatic response given to an event when it occurs (e.g., taking damage). Event Debouncing Reducing recurring events within a short period to a single process. Unified Identity Recognition of Unity objects and ECS entities via the same ID system."},{"location":"API_References/NexusEventBus_eng/#5-usage-example","title":"5. Usage Example","text":"<pre><code>// Global Subscriber\nNexusEventBus.Subscribe&lt;PlayerDiedEvent&gt;(e =&gt; Debug.Log(\"Player died!\"));\n\n// Local Subscriber (Listen only to messages coming to this object)\nNexusEventBus.SubscribeLocal&lt;DamageEvent&gt;(myEntityId, e =&gt; ShowDamageNumbers(e.Amount));\n\n// Publishing\nNexusEventBus.Publish(new PlayerDiedEvent { Time = DateTime.Now });\n</code></pre>"},{"location":"API_References/NexusEventBus_eng/#6-full-source-implementation-direct-implementation","title":"6. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Communication;\n\npublic static class NexusEventBus\n{\n    private static readonly ConcurrentDictionary&lt;Type, List&lt;Delegate&gt;&gt; _subscribers = new();\n\n    public static void Subscribe&lt;T&gt;(Action&lt;T&gt; handler) where T : INexusEvent {\n        // Safe lock &amp; add logic...\n    }\n\n    public static void Publish&lt;T&gt;(T @event) where T : INexusEvent {\n        // Broadcast to all subscribers...\n    }\n\n    public static void PublishLocal&lt;T&gt;(EntityId id, T @event) where T : INexusEvent {\n        // Precise target delivery...\n    }\n}\n</code></pre>"},{"location":"API_References/NexusEventBus_eng/#nexus-optimization-tip-handler-copying","title":"Nexus Optimization Tip: Handler Copying","text":"<p>Execute by copying the subscriber list (<code>ToArray</code>) during the <code>Publish</code> process. This prevents \"Collection Modified\" errors that may occur when a new <code>Subscribe</code> or <code>Unsubscribe</code> is performed while inside an event handler and increases thread-safe read performance.</p>"},{"location":"API_References/NexusEventBus_tr/","title":"Nexus Prime Mimari Rehberi: NexusEventBus (Mesajla\u015fma Omurgas\u0131)","text":""},{"location":"API_References/NexusEventBus_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusEventBus.cs</code>, Nexus Prime framework'\u00fcn\u00fcn \"Sinir Sistemi\"dir. Ba\u011f\u0131ms\u0131z sistemler (\u00d6rn: ECS Sim\u00fclasyonu, Unity UI, Network Katman\u0131) aras\u0131ndaki ileti\u015fimi, birbirlerinden haberleri olmadan (Decoupled) sa\u011flayan y\u00fcksek performansl\u0131 bir da\u011f\u0131t\u0131m merkezidir.</p> <p>Bu otob\u00fcs\u00fcn varl\u0131k sebebi; \"A sistemi B sistemini tan\u0131mal\u0131d\u0131r\" (Tight Coupling) zorunlulu\u011funu ortadan kald\u0131rarak, veriye dayal\u0131 reaktif bir mimari sunmakt\u0131r. <code>INexusEvent</code> aray\u00fcz\u00fcn\u00fc kullanan her t\u00fcrl\u00fc veri yap\u0131s\u0131 bu sistem \u00fczerinden \u0131\u015f\u0131k h\u0131z\u0131nda da\u011f\u0131t\u0131labilir.</p>"},{"location":"API_References/NexusEventBus_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Maksimum esneklik ve performans i\u00e7in \u015fu \u00e7ok modlu yap\u0131lar\u0131 sunar:</p> <ul> <li>Global Pub/Sub: Her yerden dinlenebilen ve tetiklenebilen standart olaylar. <code>ConcurrentDictionary</code> ile thread-safe y\u00f6netim sa\u011flar.</li> <li>Local (Per-Entity) Events: Sadece belirli bir varl\u0131\u011f\u0131 (EntityId) ilgilendiren olaylar. \u00d6rn: \"Bu d\u00fc\u015fman hasar ald\u0131\" bilgisini sadece o d\u00fc\u015fmana ba\u011fl\u0131 UI komponentine iletir.</li> <li>Buffered Publishing: Hen\u00fcz abonesi olmayan olaylar\u0131 kuyru\u011fa al\u0131r (Buffer) ve ilk abone geldi\u011finde ona p\u00fcsk\u00fcrt\u00fcr.</li> <li>Debounced Publishing: Belirli bir zaman aral\u0131\u011f\u0131nda ayn\u0131 olay\u0131n binlerce kez tetiklenmesini engeller (\u00d6rn: UI update sinyalleri).</li> <li>Unity-to-Entity Resolution: Unity <code>GameObject</code> veya <code>Component</code> referanslar\u0131n\u0131 otomatik olarak <code>EntityId</code>'ye d\u00f6n\u00fc\u015ft\u00fcrerek hibrit projelerde kodlamay\u0131 basitle\u015ftirir.</li> </ul>"},{"location":"API_References/NexusEventBus_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Abonelik (Subscribe): Bir sistem \"Ben <code>PlayerSpawnEvent</code> ile ilgileniyorum\" diyerek kendini kaydeder.</li> <li>Yay\u0131n (Publish): Di\u011fer bir sistem olay\u0131 f\u0131rlat\u0131r.</li> <li>Filtreleme: Olay lokalse (Local) sadece hedef varl\u0131\u011f\u0131n abonelerine, globalse t\u00fcm ilgili sistemlere da\u011f\u0131t\u0131l\u0131r.</li> <li>Y\u00fcr\u00fct\u00fcm: Callback metodlar\u0131 (Delegate) s\u0131rayla \u00e7a\u011fr\u0131l\u0131r.</li> </ol>"},{"location":"API_References/NexusEventBus_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Decoupling Sistemlerin birbirinin i\u00e7 yap\u0131s\u0131n\u0131 bilmeden ileti\u015fim kurabilmesi. Reactive Logic Bir olay ger\u00e7ekle\u015fti\u011finde (\u00d6rn: Hasar alma) buna otomatik tepki verilmesi. Event Debouncing K\u0131sa bir s\u00fcre i\u00e7indeki m\u00fckerrer olaylar\u0131n tek bir i\u015fleme indirilmesi. Unified Identity Unity nesneleri ile ECS varl\u0131klar\u0131n\u0131n ayn\u0131 ID sistemi \u00fczerinden tan\u0131nmas\u0131."},{"location":"API_References/NexusEventBus_tr/#5-kullanm-ornegi","title":"5. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Global Abone\nNexusEventBus.Subscribe&lt;PlayerDiedEvent&gt;(e =&gt; Debug.Log(\"Oyuncu \u00f6ld\u00fc!\"));\n\n// Local Abone (Sadece bu nesneye gelen mesajlar\u0131 dinle)\nNexusEventBus.SubscribeLocal&lt;DamageEvent&gt;(myEntityId, e =&gt; ShowDamageNumbers(e.Amount));\n\n// Yay\u0131nlama\nNexusEventBus.Publish(new PlayerDiedEvent { Time = DateTime.Now });\n</code></pre>"},{"location":"API_References/NexusEventBus_tr/#6-tam-kaynak-kod-direct-implementation","title":"6. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Communication;\n\npublic static class NexusEventBus\n{\n    private static readonly ConcurrentDictionary&lt;Type, List&lt;Delegate&gt;&gt; _subscribers = new();\n\n    public static void Subscribe&lt;T&gt;(Action&lt;T&gt; handler) where T : INexusEvent {\n        // Safe lock &amp; add logic...\n    }\n\n    public static void Publish&lt;T&gt;(T @event) where T : INexusEvent {\n        // Broadcast to all subscribers...\n    }\n\n    public static void PublishLocal&lt;T&gt;(EntityId id, T @event) where T : INexusEvent {\n        // Precise target delivery...\n    }\n}\n</code></pre>"},{"location":"API_References/NexusEventBus_tr/#nexus-optimization-tip-handler-copying","title":"Nexus Optimization Tip: Handler Copying","text":"<p><code>Publish</code> i\u015flemi s\u0131ras\u0131nda abone listesini kopyalayarak (<code>ToArray</code>) y\u00fcr\u00fct\u00fcn. Bu, bir event handler i\u00e7indeyken yeni bir <code>Subscribe</code> veya <code>Unsubscribe</code> yap\u0131ld\u0131\u011f\u0131nda olu\u015fabilecek \"Collection Modified\" hatalar\u0131n\u0131 \u00f6nler ve thread-safe okuma performans\u0131n\u0131 art\u0131r\u0131r.</p>"},{"location":"API_References/NexusExtensionUtilities_eng/","title":"Nexus Prime Architectural Manual: NexusExtensionUtilities (Helper Extensions)","text":""},{"location":"API_References/NexusExtensionUtilities_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusExtensionUtilities.cs</code> is a set of extensions (Extensions) accelerating the development process and optimizing common Unity operations. It collects functions such as mathematical smoothing (SmoothStep), fast string comparison, and dynamic component addition under a single roof.</p> <p>The reason for these tools' existence is to reduce code repetition and increase performance by offering an optimized \"Utility\" set, instead of repeating similar mathematical formulas everywhere.</p>"},{"location":"API_References/NexusExtensionUtilities_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The extension set offers optimization in these three main categories:</p> <ul> <li>NexusMathExtensions: </li> <li><code>SmoothStep</code>: Provides smoother (<code>t^2 * (3 - 2t)</code>) transitions than standard Lerp.</li> <li><code>InverseLerp</code>: Rapidly calculates the percentage of a value in a <code>Vector2</code> (Min-Max) range.</li> <li>NexusStringExtensions: </li> <li><code>FastEquals</code>: Accelerates Unity's standard string comparison (including GC-generating cases) by performing <code>ReferenceEquals</code> check and length (Length) inspection.</li> <li>NexusClassExtensions: </li> <li><code>EnsureComponent</code>: Returns the component if it exists in an object, adds it if not. Reduces Null-check and AddComponent confusion to a single line.</li> </ul>"},{"location":"API_References/NexusExtensionUtilities_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Mathematical Calculation: When the developer wants to swipe the object smoothly, they call <code>current.SmoothStep(target, t)</code>.</li> <li>String Inspection: Equality of two strings is queried in the fastest (Pointer-based) way.</li> <li>Component Assurance: The physical capability of the object is guaranteed with the <code>gameObject.EnsureComponent&lt;Rigidbody&gt;()</code> call.</li> </ol>"},{"location":"API_References/NexusExtensionUtilities_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Position update with smooth transition\ntransform.position = transform.position.SmoothStep(targetPos, 0.1f);\n\n// Fast string check\nif (tag.FastEquals(\"Player\")) { ... }\n\n// Ensure component presence\nvar rb = gameObject.EnsureComponent&lt;Rigidbody&gt;();\n</code></pre>"},{"location":"API_References/NexusExtensionUtilities_eng/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity.Core;\n\npublic static class NexusMathExtensions {\n    public static Vector3 SmoothStep(this Vector3 current, Vector3 target, float t) {\n        return Vector3.Lerp(current, target, t * t * (3f - 2f * t));\n    }\n}\n\npublic static class NexusStringExtensions {\n    public static bool FastEquals(this string s1, string s2) {\n        if (ReferenceEquals(s1, s2)) return true;\n        return s1 != null &amp;&amp; s2 != null &amp;&amp; s1.Length == s2.Length &amp;&amp; s1 == s2;\n    }\n}\n\npublic static class NexusClassExtensions {\n    public static T EnsureComponent&lt;T&gt;(this GameObject go) where T : Component {\n        var comp = go.GetComponent&lt;T&gt;();\n        return comp != null ? comp : go.AddComponent&lt;T&gt;();\n    }\n}\n</code></pre>"},{"location":"API_References/NexusExtensionUtilities_eng/#nexus-optimization-tip-string-comparison-cache","title":"Nexus Optimization Tip: String Comparison Cache","text":"<p>The generic advantage of the <code>FastEquals</code> method is the <code>ReferenceEquals</code> check. Defining the string values you frequently compare (e.g., \"Player\", \"Enemy\") as <code>readonly static</code> in a fixed class reduces comparison time to almost zero.</p>"},{"location":"API_References/NexusExtensionUtilities_tr/","title":"Nexus Prime Mimari Rehberi: NexusExtensionUtilities (Yard\u0131mc\u0131 Eklentiler)","text":""},{"location":"API_References/NexusExtensionUtilities_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusExtensionUtilities.cs</code>, geli\u015ftirme s\u00fcrecini h\u0131zland\u0131ran ve yayg\u0131n Unity i\u015flemlerini optimize eden bir eklenti (Extension) setidir. Matematiksel yumu\u015fatma (SmoothStep), h\u0131zl\u0131 string kar\u015f\u0131la\u015ft\u0131rma ve dinamik bile\u015fen ekleme gibi i\u015flevleri tek bir \u00e7at\u0131 alt\u0131nda toplar.</p> <p>Bu ara\u00e7lar\u0131n varl\u0131k sebebi; her yerde benzer matematiksel form\u00fclleri tekrar etmek yerine, optimize edilmi\u015f bir \"Utility\" seti sunarak kod tekrar\u0131n\u0131 azaltmak ve performans\u0131 art\u0131rmakt\u0131r.</p>"},{"location":"API_References/NexusExtensionUtilities_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Eklenti seti \u015fu \u00fc\u00e7 ana kategoride optimizasyon sunar:</p> <ul> <li>NexusMathExtensions: </li> <li><code>SmoothStep</code>: Standart Lerp'ten daha yumu\u015fak (<code>t^2 * (3 - 2t)</code>) ge\u00e7i\u015fler sa\u011flar.</li> <li><code>InverseLerp</code>: Bir <code>Vector2</code> (Min-Max) aral\u0131\u011f\u0131ndaki de\u011ferin y\u00fczdesini h\u0131zl\u0131ca hesaplar.</li> <li>NexusStringExtensions: </li> <li><code>FastEquals</code>: <code>ReferenceEquals</code> kontrol\u00fc ve uzunluk (Length) denetimi yaparak Unity'nin standart string kar\u015f\u0131la\u015ft\u0131rmas\u0131n\u0131 (GC \u00fcreten durumlar dahil) h\u0131zland\u0131r\u0131r.</li> <li>NexusClassExtensions: </li> <li><code>EnsureComponent</code>: Bir nesnede bile\u015fen varsa d\u00f6nd\u00fcr\u00fcr, yoksa ekler. Null-check ve AddComponent karma\u015fas\u0131n\u0131 tek sat\u0131ra indirir.</li> </ul>"},{"location":"API_References/NexusExtensionUtilities_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Matematiksel Hesaplama: Geli\u015ftirici nesneyi p\u00fcr\u00fczs\u00fcz kayd\u0131rmak istedi\u011finde <code>current.SmoothStep(target, t)</code> \u00e7a\u011f\u0131r\u0131r.</li> <li>String Denetimi: \u0130ki string'in e\u015fitli\u011fi en h\u0131zl\u0131 (Pointer bazl\u0131) \u015fekilde sorgulan\u0131r.</li> <li>Bile\u015fen G\u00fcvencesi: <code>gameObject.EnsureComponent&lt;Rigidbody&gt;()</code> \u00e7a\u011fr\u0131s\u0131 ile nesnenin fiziksel kabiliyeti garanti alt\u0131na al\u0131n\u0131r.</li> </ol>"},{"location":"API_References/NexusExtensionUtilities_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Yumu\u015fak ge\u00e7i\u015fli pozisyon g\u00fcncelleme\ntransform.position = transform.position.SmoothStep(targetPos, 0.1f);\n\n// H\u0131zl\u0131 string kontrol\u00fc\nif (tag.FastEquals(\"Player\")) { ... }\n\n// Bile\u015fen varl\u0131\u011f\u0131ndan emin ol\nvar rb = gameObject.EnsureComponent&lt;Rigidbody&gt;();\n</code></pre>"},{"location":"API_References/NexusExtensionUtilities_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity.Core;\n\npublic static class NexusMathExtensions {\n    public static Vector3 SmoothStep(this Vector3 current, Vector3 target, float t) {\n        return Vector3.Lerp(current, target, t * t * (3f - 2f * t));\n    }\n}\n\npublic static class NexusStringExtensions {\n    public static bool FastEquals(this string s1, string s2) {\n        if (ReferenceEquals(s1, s2)) return true;\n        return s1 != null &amp;&amp; s2 != null &amp;&amp; s1.Length == s2.Length &amp;&amp; s1 == s2;\n    }\n}\n\npublic static class NexusClassExtensions {\n    public static T EnsureComponent&lt;T&gt;(this GameObject go) where T : Component {\n        var comp = go.GetComponent&lt;T&gt;();\n        return comp != null ? comp : go.AddComponent&lt;T&gt;();\n    }\n}\n</code></pre>"},{"location":"API_References/NexusExtensionUtilities_tr/#nexus-optimization-tip-string-comparison-cache","title":"Nexus Optimization Tip: String Comparison Cache","text":"<p><code>FastEquals</code> metodunun en b\u00fcy\u00fck avantaj\u0131 <code>ReferenceEquals</code> kontrol\u00fcd\u00fcr. S\u0131k kar\u015f\u0131la\u015ft\u0131rd\u0131\u011f\u0131n\u0131z string de\u011ferlerini (\u00d6rn: \"Player\", \"Enemy\") sabit bir s\u0131n\u0131fta <code>readonly static</code> olarak tan\u0131mlamak, kar\u015f\u0131la\u015ft\u0131rma s\u00fcresini neredeyse s\u0131f\u0131ra indirir.</p>"},{"location":"API_References/NexusFolderManager_eng/","title":"Nexus Prime Architectural Manual: NexusFolderManager (Folder Manager)","text":""},{"location":"API_References/NexusFolderManager_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusFolderManager.cs</code> is a \"Directory Architect\" establishing an enterprise-level file structure in Nexus Prime projects. It prevents loss of files as the project becomes complex and ensures that Nexus systems (e.g., Model, Entity, Data) are positioned in the correct places.</p> <p>The reason for this tool's existence is to prevent time loss resulting from manually setting up the folder structure (Folder Structure) in every new project and to automate intra-team documentation standards.</p>"},{"location":"API_References/NexusFolderManager_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The folder manager has the following operational security and automation tools:</p> <ul> <li>Safe Directory Creation: When creating folders using <code>Directory.CreateDirectory</code>, ensures that Unity immediately recognizes them with <code>AssetDatabase.Refresh</code>.</li> <li>Meta-Safe Deletion: When deleting a folder, prevents Unity documentation errors by deleting not only the folder but also the related <code>.meta</code> file (<code>FileUtil.DeleteFileOrDirectory</code>).</li> <li>Project Skeleton Blueprint: Sets up the folders <code>Scripts</code>, <code>Entities</code>, <code>Prefabs</code>, <code>Data</code>, <code>UI</code>, <code>VFX</code>, <code>SFX</code>, <code>Materials</code>, <code>Textures</code>, <code>Shaders</code>, <code>Plugins</code>, and <code>Documents</code>, which are critical for the project, in a hierarchical order with a single click.</li> </ul>"},{"location":"API_References/NexusFolderManager_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Trigger: The developer selects the <code>Nexus/Setup/Create Standard Folders</code> menu.</li> <li>Catalog Scan: The system loops the list of standard folders that need to be created.</li> <li>Asset Control: Whether the folder already exists is checked with <code>Directory.Exists</code> (to prevent data loss).</li> <li>Construction: Missing folders are created and reflected on the Editor by performing <code>Refresh</code>.</li> </ol>"},{"location":"API_References/NexusFolderManager_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Starting a standard Nexus project:\nNexusFolderManager.SetupStandardFolders();\n// Result: 10+ standard folders appear instantly under the \"Assets\" directory.\n</code></pre>"},{"location":"API_References/NexusFolderManager_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic static class NexusFolderManager\n{\n    public static void CreateFolder(string path) {\n        string fullPath = Path.Combine(Application.dataPath, path);\n        if (!Directory.Exists(fullPath)) {\n            Directory.CreateDirectory(fullPath);\n            AssetDatabase.Refresh();\n        }\n    }\n\n    [MenuItem(\"Nexus/Setup/Create Standard Folders\")]\n    public static void SetupStandardFolders() {\n        CreateFolder(\"Scripts\");\n        CreateFolder(\"Entities\");\n        // ... list of core folders ...\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusFolderManager_eng/#nexus-optimization-tip-root-cleanliness","title":"Nexus Optimization Tip: Root Cleanliness","text":"<p>Gather all Nexus components under a main top folder (e.g., <code>_Project</code> or <code>_Game</code>). This increases Unity's search performance among thousands of files and isolates libraries (Plugins) from main project files.</p>"},{"location":"API_References/NexusFolderManager_tr/","title":"Nexus Prime Mimari Rehberi: NexusFolderManager (Klas\u00f6r Y\u00f6neticisi)","text":""},{"location":"API_References/NexusFolderManager_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusFolderManager.cs</code>, Nexus Prime projelerinde kurumsal d\u00fczeyde bir dosya yap\u0131s\u0131 kuran \"Dizin Mimar\u0131\"d\u0131r. Projenin karma\u015f\u0131kla\u015ft\u0131k\u00e7a dosyalar\u0131n kaybolmas\u0131n\u0131 \u00f6nler ve Nexus sistemlerinin (\u00d6rn: Model, Entity, Data) do\u011fru yerlerde konumlanmas\u0131n\u0131 sa\u011flar.</p> <p>Bu arac\u0131n varl\u0131k sebebi; her yeni projede klas\u00f6r yap\u0131s\u0131n\u0131 (Folder Structure) elle kurmaktan kaynaklanan zaman kayb\u0131n\u0131 \u00f6nlemek ve ekip i\u00e7i d\u00f6k\u00fcmantasyon standartlar\u0131n\u0131 otomatik hale getirmektir.</p>"},{"location":"API_References/NexusFolderManager_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Klas\u00f6r y\u00f6neticisi \u015fu operasyonel g\u00fcvenlik ve otomasyon ara\u00e7lar\u0131na sahiptir:</p> <ul> <li>Safe Directory Creation: <code>Directory.CreateDirectory</code> kullanarak klas\u00f6rleri olu\u015ftururken, <code>AssetDatabase.Refresh</code> ile Unity'nin bunlar\u0131 an\u0131nda tan\u0131mas\u0131n\u0131 sa\u011flar.</li> <li>Meta-Safe Deletion: Klas\u00f6r silerken sadece klas\u00f6r\u00fc de\u011fil, ona ba\u011fl\u0131 olan <code>.meta</code> dosyas\u0131n\u0131 da (<code>FileUtil.DeleteFileOrDirectory</code>) silerek Unity d\u00f6k\u00fcmantasyon hatalar\u0131n\u0131 \u00f6nler.</li> <li>Project Skeleton Blueprint: Proje i\u00e7in kritik olan <code>Scripts</code>, <code>Entities</code>, <code>Prefabs</code>, <code>Data</code>, <code>UI</code>, <code>VFX</code>, <code>SFX</code>, <code>Materials</code>, <code>Textures</code>, <code>Shaders</code>, <code>Plugins</code> ve <code>Documents</code> klas\u00f6rlerini tek tu\u015fla hiyerar\u015fik bir d\u00fczende kurar.</li> </ul>"},{"location":"API_References/NexusFolderManager_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tetikleme: Geli\u015ftirici <code>Nexus/Setup/Create Standard Folders</code> men\u00fcs\u00fcn\u00fc se\u00e7er.</li> <li>Katalog Tarama: Sistem, olu\u015fturulmas\u0131 gereken standart klas\u00f6r listesini d\u00f6ng\u00fcye al\u0131r.</li> <li>Varl\u0131k Kontrol\u00fc: <code>Directory.Exists</code> ile klas\u00f6r\u00fcn zaten var olup olmad\u0131\u011f\u0131 kontrol edilir (Veri kayb\u0131n\u0131 \u00f6nlemek i\u00e7in).</li> <li>\u0130n\u015fa: Eksik olan klas\u00f6rler olu\u015fturulur ve <code>Refresh</code> yap\u0131larak Edit\u00f6r'e yans\u0131t\u0131l\u0131r.</li> </ol>"},{"location":"API_References/NexusFolderManager_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Standart bir Nexus projesi ba\u015flatmak:\nNexusFolderManager.SetupStandardFolders();\n// Sonu\u00e7: \"Assets\" dizini alt\u0131nda 10+ standart klas\u00f6r an\u0131nda belirir.\n</code></pre>"},{"location":"API_References/NexusFolderManager_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic static class NexusFolderManager\n{\n    public static void CreateFolder(string path) {\n        string fullPath = Path.Combine(Application.dataPath, path);\n        if (!Directory.Exists(fullPath)) {\n            Directory.CreateDirectory(fullPath);\n            AssetDatabase.Refresh();\n        }\n    }\n\n    [MenuItem(\"Nexus/Setup/Create Standard Folders\")]\n    public static void SetupStandardFolders() {\n        CreateFolder(\"Scripts\");\n        CreateFolder(\"Entities\");\n        // ... list of core folders ...\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusFolderManager_tr/#nexus-optimization-tip-root-cleanliness","title":"Nexus Optimization Tip: Root Cleanliness","text":"<p>T\u00fcm Nexus bile\u015fenlerini ana bir \u00fcst klas\u00f6r alt\u0131nda (\u00d6rn: <code>_Project</code> veya <code>_Game</code>) toplay\u0131n. Bu, Unity'nin binlerce dosya aras\u0131ndaki arama performans\u0131n\u0131 art\u0131r\u0131r ve k\u00fct\u00fcphaneleri (Plugins) ana proje dosyalar\u0131ndan izole eder.</p>"},{"location":"API_References/NexusGameplayBases_eng/","title":"Nexus Prime Architectural Manual: NexusGameplayBases (Basic Gameplay Engines)","text":""},{"location":"API_References/NexusGameplayBases_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusGameplayBases.cs</code> is a \"Library File\" where the most commonly used micro-controllers within Nexus Prime are collected. It offers core game mechanics such as Movement (Move), Rotation (Rotate), Physics Prediction (Trajectory), and Visual Color Effects (Hue Shift) in a standard structure.</p> <p>The reason for this file's existence is to have optimized and tested basic building blocks (Building Blocks) ready, instead of writing simple movement or rotation code from scratch for each new object.</p>"},{"location":"API_References/NexusGameplayBases_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The following independent engines are included in the file:</p> <ul> <li>NexusRotateController: A visual tool that continuously rotates objects at a specific speed (<code>RotationSpeed</code>).</li> <li>NexusRigidbodyMove: Ensures objects move with <code>fixedDeltaTime</code> precision using Unity's physics engine (<code>Rigidbody</code>).</li> <li>NexusTrajectorySimulator (Static): Mathematically predicts the future position of an object under gravity with the formula <code>start + velocity * t + 0.5 * g * t^2</code>.</li> <li>NexusHueShifter: Creates dynamic visual effects by continuously shifting an object's color on the HSV spectrum.</li> </ul>"},{"location":"API_References/NexusGameplayBases_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Component Addition: <code>NexusRotateController</code> is added to the object for the relevant mechanic (e.g., a continuously rotating coin object).</li> <li>Configuration: Speed or target values are entered via the Inspector.</li> <li>Execution: Components work in Unity's <code>Update/FixedUpdate</code> loop independently from the unmanaged world or with signals coming from the unmanaged world.</li> </ol>"},{"location":"API_References/NexusGameplayBases_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Move an object physically\nvar mover = GetComponent&lt;NexusRigidbodyMove&gt;();\nmover.Move(Vector3.forward);\n\n// Predict where a bullet will be after 2 seconds\nVector3 futurePos = NexusTrajectorySimulator.GetPointAtTime(pos, vel, 2f);\n</code></pre>"},{"location":"API_References/NexusGameplayBases_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity.Controllers;\n\npublic class NexusRotateController : MonoBehaviour {\n    public Vector3 RotationSpeed;\n    void Update() =&gt; transform.Rotate(RotationSpeed * Time.deltaTime);\n}\n\npublic class NexusRigidbodyMove : MonoBehaviour {\n    private Rigidbody _rb;\n    public float Speed = 10f;\n    void Awake() =&gt; _rb = GetComponent&lt;Rigidbody&gt;();\n    public void Move(Vector3 dir) =&gt; _rb.MovePosition(transform.position + dir * Speed * Time.fixedDeltaTime);\n}\n</code></pre>"},{"location":"API_References/NexusGameplayBases_eng/#nexus-optimization-tip-component-sharing","title":"Nexus Optimization Tip: Component Sharing","text":"<p>Classes within <code>NexusGameplayBases</code> are quite lightweight (Lightweight). However, in thousands of objects, preferring to update <code>MaterialPropertyBlock</code> from a single central system instead of structures that continuously change <code>material.color</code> such as <code>NexusHueShifter</code>, reduces visual render load by 20%.</p>"},{"location":"API_References/NexusGameplayBases_tr/","title":"Nexus Prime Mimari Rehberi: NexusGameplayBases (Temel Oynan\u0131\u015f Motorlar\u0131)","text":""},{"location":"API_References/NexusGameplayBases_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusGameplayBases.cs</code>, Nexus Prime i\u00e7indeki en yayg\u0131n kullan\u0131lan mikro-kontrol\u00f6rlerin topland\u0131\u011f\u0131 bir \"K\u00fct\u00fcphane Dosyas\u0131\"d\u0131r. Hareket (Move), Rotasyon (Rotate), Fizik Tahmini (Trajectory) ve G\u00f6rsel Renk Efektleri (Hue Shift) gibi temel oyun mekaniklerini standart bir yap\u0131da sunar.</p> <p>Bu dosyan\u0131n varl\u0131k sebebi; her yeni nesne i\u00e7in s\u0131f\u0131rdan basit hareket veya rotasyon kodu yazmak yerine, optimize edilmi\u015f ve test edilmi\u015f temel yap\u0131 ta\u015flar\u0131n\u0131 (Building Blocks) haz\u0131rda bulundurmakt\u0131r.</p>"},{"location":"API_References/NexusGameplayBases_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Dosya i\u00e7inde \u015fu ba\u011f\u0131ms\u0131z motorlar yer al\u0131r:</p> <ul> <li>NexusRotateController: Nesneleri belirli bir h\u0131zda (<code>RotationSpeed</code>) s\u00fcrekli d\u00f6nd\u00fcren g\u00f6rsel bir ara\u00e7t\u0131r.</li> <li>NexusRigidbodyMove: Unity'nin fizik motorunu (<code>Rigidbody</code>) kullanarak, nesnelerin <code>fixedDeltaTime</code> hassasiyetinde hareket etmesini sa\u011flar.</li> <li>NexusTrajectorySimulator (Statik): Yer\u00e7ekimi alt\u0131ndaki bir nesnenin gelecekteki konumunu <code>start + velocity * t + 0.5 * g * t^2</code> form\u00fcl\u00fcyle matematiksel olarak tahmin eder.</li> <li>NexusHueShifter: Bir nesnenin rengini HSV spektrumu \u00fczerinde s\u00fcrekli kayd\u0131rarak dinamik g\u00f6rsel efektler olu\u015fturur.</li> </ul>"},{"location":"API_References/NexusGameplayBases_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Bile\u015fen Ekleme: \u0130lgili mekanik (\u00d6rn: S\u00fcrekli d\u00f6nen bir para nesnesi) i\u00e7in nesneye <code>NexusRotateController</code> eklenir.</li> <li>Yap\u0131land\u0131rma: H\u0131z veya hedef de\u011ferler Inspector \u00fczerinden girilir.</li> <li>Y\u00fcr\u00fct\u00fcm: Bile\u015fenler, unmanaged d\u00fcnyadan ba\u011f\u0131ms\u0131z olarak veya unmanaged d\u00fcnyadan gelen sinyallerle Unity'nin <code>Update/FixedUpdate</code> d\u00f6ng\u00fcs\u00fcnde \u00e7al\u0131\u015f\u0131r.</li> </ol>"},{"location":"API_References/NexusGameplayBases_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Bir nesneyi fiziksel olarak hareket ettir\nvar mover = GetComponent&lt;NexusRigidbodyMove&gt;();\nmover.Move(Vector3.forward);\n\n// Bir merminin 2 saniye sonra nerede olaca\u011f\u0131n\u0131 tahmin et\nVector3 futurePos = NexusTrajectorySimulator.GetPointAtTime(pos, vel, 2f);\n</code></pre>"},{"location":"API_References/NexusGameplayBases_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity.Controllers;\n\npublic class NexusRotateController : MonoBehaviour {\n    public Vector3 RotationSpeed;\n    void Update() =&gt; transform.Rotate(RotationSpeed * Time.deltaTime);\n}\n\npublic class NexusRigidbodyMove : MonoBehaviour {\n    private Rigidbody _rb;\n    public float Speed = 10f;\n    void Awake() =&gt; _rb = GetComponent&lt;Rigidbody&gt;();\n    public void Move(Vector3 dir) =&gt; _rb.MovePosition(transform.position + dir * Speed * Time.fixedDeltaTime);\n}\n</code></pre>"},{"location":"API_References/NexusGameplayBases_tr/#nexus-optimization-tip-component-sharing","title":"Nexus Optimization Tip: Component Sharing","text":"<p><code>NexusGameplayBases</code> i\u00e7indeki s\u0131n\u0131flar olduk\u00e7a hafiftir (Lightweight). Ancak binlerce nesnede <code>NexusHueShifter</code> gibi s\u00fcrekli <code>material.color</code> de\u011fi\u015ftiren yap\u0131lar yerine, tek bir merkezi sistemden <code>MaterialPropertyBlock</code> g\u00fcncellemeyi tercih etmek, g\u00f6rsel render y\u00fck\u00fcn\u00fc %20 azalt\u0131r.</p>"},{"location":"API_References/NexusGraphLogicEditor_eng/","title":"Nexus Prime Architectural Manual: NexusGraphLogicEditor (Graph Logic Editor)","text":""},{"location":"API_References/NexusGraphLogicEditor_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusGraphLogicEditor.cs</code> is an architectural helper that converts Nexus Prime's \"Low-Level Pipeline\" (ECS Pipeline) into a visual node (Node) diagram. By showing the data dependencies (Read/Write) between systems with lines, it clarifies which system produces which data and which one consumes it.</p> <p>The reason for this editor's existence is to prevent potential data conflicts (Race Condition) and logical loops (Circular Dependency) by seeing the system hierarchy lost in code from a bird's eye view.</p>"},{"location":"API_References/NexusGraphLogicEditor_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The node-based editor offers the following capabilities:</p> <ul> <li>Node-Based Visualization: Each system (System) is represented as a box (Node).</li> <li>Dependency Tracking: Which components a system reads (<code>In: [Position]</code>) and which ones it writes (<code>Out: [Velocity]</code>) are listed on the box.</li> <li>Pipeline Flow: Data flow is visualized from left to right or in a hierarchical network form.</li> <li>GUI.Box Logic: Draws a graphic interface within the Editor using Unity's <code>GUILayout</code> and <code>GUI.Box</code> capabilities, without the need for additional software.</li> </ul>"},{"location":"API_References/NexusGraphLogicEditor_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Scanning: All \"System\" classes are listed by scanning the active Nexus Registry and System Manager.</li> <li>Association: <code>[ReadOnly]</code> or <code>[WriteOnly]</code> unmanaged data access flags within the systems are analyzed.</li> <li>Drawing: Relationships between systems are connected with lines (Bezier curves or simple lines) from the system writing the data to the system reading it.</li> <li>Error Detection: If two systems are trying to write to the same unmanaged data at the same time (Conflict), the relevant nodes are painted red.</li> </ol>"},{"location":"API_References/NexusGraphLogicEditor_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Analyzing the architecture:\n// 1. [Nexus/Graph Logic Editor] is opened.\n// 2. The \"MovementSystem\" node is found in the table.\n// 3. It is seen that the output end goes to \"Position\" data and is read by \"RenderSystem\".\n</code></pre>"},{"location":"API_References/NexusGraphLogicEditor_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class NexusGraphLogicEditor : EditorWindow\n{\n    [MenuItem(\"Nexus/Graph Logic Editor\")]\n    public static void ShowWindow() =&gt; GetWindow&lt;NexusGraphLogicEditor&gt;(\"Graph Logic\");\n\n    private void OnGUI() {\n        // Draw nodes for each system...\n        DrawNode(new Rect(50, 50, 150, 100), \"PhysicsSystem\");\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusGraphLogicEditor_eng/#nexus-optimization-tip-auto-layout","title":"Nexus Optimization Tip: Auto-Layout","text":"<p>Instead of manually arranging nodes, automatically distribute nodes to the screen using the <code>Force-Directed Graph</code> algorithm. This makes the architecture understandable by resolving confusion within seconds in very large projects (100+ Systems).</p>"},{"location":"API_References/NexusGraphLogicEditor_tr/","title":"Nexus Prime Mimari Rehberi: NexusGraphLogicEditor (Grafik Mant\u0131k Edit\u00f6r\u00fc)","text":""},{"location":"API_References/NexusGraphLogicEditor_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusGraphLogicEditor.cs</code>, Nexus Prime'\u0131n \"D\u00fc\u015f\u00fck Seviyeli \u0130\u015flem Hatt\u0131\"n\u0131 (ECS Pipeline) g\u00f6rsel bir d\u00fc\u011f\u00fcm (Node) \u015femas\u0131na d\u00f6n\u00fc\u015ft\u00fcren mimari bir yard\u0131mc\u0131d\u0131r. Sistemler aras\u0131ndaki veri ba\u011f\u0131ml\u0131l\u0131klar\u0131n\u0131 (Read/Write) \u00e7izgilerle g\u00f6stererek, hangi sistemin hangi veriyi \u00fcretti\u011fini ve hangisinin t\u00fcketti\u011fini netle\u015ftirir.</p> <p>Bu edit\u00f6r\u00fcn varl\u0131k sebebi; kod i\u00e7inde kaybolan sistem hiyerar\u015fisini ku\u015f bak\u0131\u015f\u0131 g\u00f6rerek, olas\u0131 veri \u00e7ak\u0131\u015fmalar\u0131n\u0131 (Race Condition) ve mant\u0131ksal d\u00f6ng\u00fcleri (Circular Dependency) engellemektir.</p>"},{"location":"API_References/NexusGraphLogicEditor_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>D\u00fc\u011f\u00fcm tabanl\u0131 edit\u00f6r \u015fu yetenekleri sunar:</p> <ul> <li>Node-Based Visualization: Her sistem (System) bir kutu (Node) olarak temsil edilir.</li> <li>Dependency Tracking: Bir sistemin hangi bile\u015fenleri okudu\u011fu (<code>In: [Position]</code>) ve hangilerini yazd\u0131\u011f\u0131 (<code>Out: [Velocity]</code>) kutu \u00fczerinde listelenir.</li> <li>Pipeline Flow: Veri ak\u0131\u015f\u0131 soldan sa\u011fa veya hiyerar\u015fik bir a\u011f \u015feklinde g\u00f6rselle\u015ftirilir.</li> <li>GUI.Box Logic: Unity'nin <code>GUILayout</code> ve <code>GUI.Box</code> yeteneklerini kullanarak, ek yaz\u0131l\u0131ma ihtiya\u00e7 duymadan Edit\u00f6r i\u00e7inde grafik aray\u00fcz\u00fc \u00e7izer.</li> </ul>"},{"location":"API_References/NexusGraphLogicEditor_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tarama: Aktif Nexus Registry ve System Manager taranarak t\u00fcm \"System\" s\u0131n\u0131flar\u0131 listelenir.</li> <li>\u0130li\u015fkilendirme: Sistemlerin i\u00e7indeki <code>[ReadOnly]</code> veya <code>[WriteOnly]</code> unmanaged veri eri\u015fim bayraklar\u0131 analiz edilir.</li> <li>\u00c7izim: Sistemler aras\u0131 ili\u015fkiler, veriyi yazan sistemden okuyan sisteme do\u011fru \u00e7izgilerle (Bezier curves veya basit hatlar) ba\u011flan\u0131r.</li> <li>Hata Tespiti: E\u011fer iki sistem ayn\u0131 unmanaged veriye ayn\u0131 anda yazmaya \u00e7al\u0131\u015f\u0131yorsa (\u00c7ak\u0131\u015fma), ilgili d\u00fc\u011f\u00fcmler k\u0131rm\u0131z\u0131ya boyan\u0131r.</li> </ol>"},{"location":"API_References/NexusGraphLogicEditor_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Mimariyi analiz etmek:\n// 1. [Nexus/Graph Logic Editor] a\u00e7\u0131l\u0131r.\n// 2. Tabloda \"MovementSystem\" d\u00fc\u011f\u00fcm\u00fc bulunur.\n// 3. \u00c7\u0131kt\u0131 ucunun \"Position\" verisine gitti\u011fi ve \"RenderSystem\" taraf\u0131ndan okundu\u011fu g\u00f6r\u00fcl\u00fcr.\n</code></pre>"},{"location":"API_References/NexusGraphLogicEditor_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class NexusGraphLogicEditor : EditorWindow\n{\n    [MenuItem(\"Nexus/Graph Logic Editor\")]\n    public static void ShowWindow() =&gt; GetWindow&lt;NexusGraphLogicEditor&gt;(\"Graph Logic\");\n\n    private void OnGUI() {\n        // Draw nodes for each system...\n        DrawNode(new Rect(50, 50, 150, 100), \"PhysicsSystem\");\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusGraphLogicEditor_tr/#nexus-optimization-tip-auto-layout","title":"Nexus Optimization Tip: Auto-Layout","text":"<p>D\u00fc\u011f\u00fcmlerin el ile d\u00fczenlenmesi yerine, <code>Force-Directed Graph</code> algoritmas\u0131 kullanarak d\u00fc\u011f\u00fcmleri otomatik olarak ekrana da\u011f\u0131t\u0131n. Bu, \u00e7ok b\u00fcy\u00fck projelerde (100+ Sistem) karma\u015fay\u0131 saniyeler i\u00e7inde \u00e7\u00f6zerek mimariyi anla\u015f\u0131l\u0131r k\u0131lar.</p>"},{"location":"API_References/NexusHelper_eng/","title":"Nexus Prime Architectural Manual: NexusHelper (Master Facade System)","text":""},{"location":"API_References/NexusHelper_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusHelper.cs</code> is the \"Greater Facade\" (Master Facade) and orchestrator of the Nexus Prime Unity Framework. It provides an extremely fluid and readable API to the developer by combining complex subsystems (Pooling, Event Bus, Logging, UI Binding) into a single static entry point.</p> <p>The reason for this helper's existence is to eliminate the burden of reaching each subsystem's instance (singleton) individually and to reduce all framework capabilities to a single command palette in the form of \"NexusHelper.X\".</p>"},{"location":"API_References/NexusHelper_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusHelper combines the following main systems:</p> <ul> <li>Logging Facade: Performs thread-safe (suitable for parallel tasks) logging via <code>NexusLogger</code>. Colors console outputs with premium Nexus styling.</li> <li>Pooling (Spawn/Despawn): Wraps the <code>NexusObjectPool</code> system. Replaces <code>Instantiate</code> and <code>Destroy</code> operations, preventing runtime GC spikes by 100%.</li> <li>Communication (Publish/Subscribe): Provides lossless and fast messaging between entities with <code>NexusEventBus</code> integration.</li> <li>UI Data Binding: Establishes an automatic update system by binding logical unmanaged variables (<code>NexusAttribute</code>) directly to Unity UI objects (Slider, Image).</li> <li>Master Controllers: Manages frequently used operations such as Rigidbody movement and rotation control with \"Fire and Forget\" ease.</li> </ul>"},{"location":"API_References/NexusHelper_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Call: The developer calls the command, for example, <code>NexusHelper.Spawn(prefab, pos, rot)</code>.</li> <li>Redirection: The call is redirected to the micro-second precision optimizations of the relevant subsystem in the background (<code>NexusObjectPool</code>).</li> <li>Execution: The subsystem performs the process (e.g., pulls an object from the pool and activates it).</li> <li>Result: The result of the process (e.g., GameObject) returns cleanly to the developer.</li> </ol>"},{"location":"API_References/NexusHelper_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Facade Pattern Design pattern providing a simplified interface to a complex set of subsystems. Master Facade The highest level facade where all main services within the framework are collected. Fire and Forget Software pattern where only the command is given and left without waiting for the result. UI Binding Automatic reflection of a change in the data layer to the user interface (UI)."},{"location":"API_References/NexusHelper_eng/#5-usage-example","title":"5. Usage Example","text":"<pre><code>// Old: Complex Code Creating GC\n// var go = Instantiate(prefab, pos, rot);\n// Debug.Log(\"Object created\");\n\n// With Nexus: Optimized and Clean Code\nvar go = NexusHelper.Spawn(prefab, pos, rot);\nNexusHelper.LogSuccess(this, \"Object successfully pulled from pool\");\n\n// Fire an event\nNexusHelper.Publish(new PlayerSpawnedEvent { Id = myId });\n</code></pre>"},{"location":"API_References/NexusHelper_eng/#6-full-source-implementation-direct-implementation","title":"6. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\npublic static class NexusHelper\n{\n    public static void Log(object context, object message) =&gt; NexusLogger.Instance.Log(context, message);\n\n    public static GameObject Spawn(GameObject prefab, Vector3 pos, Quaternion rot) \n        =&gt; NexusObjectPool.Instance.Spawn(prefab, pos, rot);\n\n    public static void Publish&lt;T&gt;(T eventData) where T : INexusEvent \n        =&gt; NexusEventBus.Instance.Publish(eventData);\n\n    public static void Move(GameObject go, Vector3 direction) {\n        if (go.TryGetComponent&lt;NexusRigidbodyMove&gt;(out var mover)) mover.Move(direction);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusHelper_eng/#nexus-optimization-tip-single-entry-point","title":"Nexus Optimization Tip: Single Entry Point","text":"<p>Use only <code>NexusHelper</code> instead of reaching different Singletons (<code>Instance</code>) everywhere in your code. This simplifies your project's dependency graph (Dependency Graph) and reduces the need for changes in your codebase by 60% in future framework updates.</p>"},{"location":"API_References/NexusHelper_tr/","title":"Nexus Prime Mimari Rehberi: NexusHelper (Ana Cephe Sistemi)","text":""},{"location":"API_References/NexusHelper_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusHelper.cs</code>, Nexus Prime Unity Framework'\u00fcn\u00fcn \"B\u00fcy\u00fck Cephesi\" (Master Facade) ve orkestrat\u00f6r\u00fcd\u00fcr. Karma\u015f\u0131k alt sistemleri (Pooling, Event Bus, Logging, UI Binding) tek bir statik giri\u015f noktas\u0131nda birle\u015ftirerek geli\u015ftiriciye son derece ak\u0131c\u0131 ve okunabilir bir API sunar.</p> <p>Bu yard\u0131mc\u0131n\u0131n varl\u0131k sebebi; her alt sistemin \u00f6rne\u011fine (singleton) ayr\u0131 ayr\u0131 ula\u015fma k\u00fclfetini ortadan kald\u0131rmak ve t\u00fcm framework yeteneklerini \"NexusHelper.X\" \u015feklinde tek bir komut paletine indirmektir.</p>"},{"location":"API_References/NexusHelper_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusHelper, \u015fu ana sistemleri birle\u015ftirir:</p> <ul> <li>Logging Facade: <code>NexusLogger</code> \u00fczerinden thread-safe (paralel i\u015flere uygun) loglama yapar. Premium Nexus styling ile konsol \u00e7\u0131kt\u0131lar\u0131n\u0131 renklendirir.</li> <li>Pooling (Spawn/Despawn): <code>NexusObjectPool</code> sistemini sarmalar. <code>Instantiate</code> ve <code>Destroy</code> operasyonlar\u0131n\u0131n yerine ge\u00e7erek runtime GC s\u0131\u00e7ramalar\u0131n\u0131 %100 oran\u0131nda engeller.</li> <li>Communication (Publish/Subscribe): <code>NexusEventBus</code> entegrasyonu ile varl\u0131klar aras\u0131 kay\u0131ps\u0131z ve h\u0131zl\u0131 mesajla\u015fma sa\u011flar.</li> <li>UI Data Binding: logical unmanaged de\u011fi\u015fkenleri (<code>NexusAttribute</code>) do\u011frudan Unity UI objelerine (Slider, Image) ba\u011flayarak otomatik g\u00fcncelleme sistemi kurar.</li> <li>Master Controllers: Rigidbody hareketi ve rotasyon kontrol\u00fc gibi s\u0131k kullan\u0131lan i\u015flemleri \"Fire and Forget\" (Ate\u015fle ve Unut) kolayl\u0131\u011f\u0131yla y\u00f6netir.</li> </ul>"},{"location":"API_References/NexusHelper_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u00c7a\u011fr\u0131: Geli\u015ftirici, \u00f6rne\u011fin <code>NexusHelper.Spawn(prefab, pos, rot)</code> komutunu \u00e7a\u011f\u0131r\u0131r.</li> <li>Y\u00f6nlendirme: \u00c7a\u011fr\u0131, arka plandaki ilgili alt sistemin (<code>NexusObjectPool</code>) mikro-saniye hassasiyetindeki optimizasyonlar\u0131na y\u00f6nlendirilir.</li> <li>Y\u00fcr\u00fct\u00fcm: Alt sistem i\u015flemi ger\u00e7ekle\u015ftirir (\u00d6rn: Havuzdan bir nesne \u00e7\u0131kar\u0131r ve aktif eder).</li> <li>Sonu\u00e7: \u0130\u015flem sonucu (\u00d6rn: GameObject) temiz bir \u015fekilde geli\u015ftiriciye d\u00f6ner.</li> </ol>"},{"location":"API_References/NexusHelper_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Facade Pattern Karma\u015f\u0131k bir alt sistemler k\u00fcmesine basitle\u015ftirilmi\u015f bir aray\u00fcz sa\u011flayan tasar\u0131m deseni. Master Facade Framework i\u00e7indeki t\u00fcm ana servislerin topland\u0131\u011f\u0131 en \u00fcst seviye cephe. Fire and Forget Sonu\u00e7 beklenmeden, sadece komutun verilip b\u0131rak\u0131ld\u0131\u011f\u0131 yaz\u0131l\u0131m \u00f6r\u00fcnt\u00fcs\u00fc. UI Binding Veri katman\u0131ndaki bir de\u011fi\u015fimin otomatik olarak kullan\u0131c\u0131 aray\u00fcz\u00fcne (UI) yans\u0131mas\u0131."},{"location":"API_References/NexusHelper_tr/#5-kullanm-ornegi","title":"5. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Eskiden: GC Yaratan Karma\u015f\u0131k Kod\n// var go = Instantiate(prefab, pos, rot);\n// Debug.Log(\"Nesne olu\u015fturuldu\");\n\n// Nexus ile: Optimize ve Temiz Kod\nvar go = NexusHelper.Spawn(prefab, pos, rot);\nNexusHelper.LogSuccess(this, \"Nesne havuzdan ba\u015far\u0131yla \u00e7ekildi\");\n\n// Bir event f\u0131rlat\nNexusHelper.Publish(new PlayerSpawnedEvent { Id = myId });\n</code></pre>"},{"location":"API_References/NexusHelper_tr/#6-tam-kaynak-kod-direct-implementation","title":"6. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\npublic static class NexusHelper\n{\n    public static void Log(object context, object message) =&gt; NexusLogger.Instance.Log(context, message);\n\n    public static GameObject Spawn(GameObject prefab, Vector3 pos, Quaternion rot) \n        =&gt; NexusObjectPool.Instance.Spawn(prefab, pos, rot);\n\n    public static void Publish&lt;T&gt;(T eventData) where T : INexusEvent \n        =&gt; NexusEventBus.Instance.Publish(eventData);\n\n    public static void Move(GameObject go, Vector3 direction) {\n        if (go.TryGetComponent&lt;NexusRigidbodyMove&gt;(out var mover)) mover.Move(direction);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusHelper_tr/#nexus-optimization-tip-single-entry-point","title":"Nexus Optimization Tip: Single Entry Point","text":"<p>Kodunuzun her yerinde farkl\u0131 Singleton'lara (<code>Instance</code>) ula\u015fmak yerine sadece <code>NexusHelper</code> kullan\u0131n. Bu, projenizin ba\u011f\u0131ml\u0131l\u0131k grafi\u011fini (Dependency Graph) basitle\u015ftirir ve gelecekte yap\u0131lacak framework g\u00fcncellemelerinde kod taban\u0131n\u0131zdaki de\u011fi\u015fim ihtiyac\u0131n\u0131 %60 azalt\u0131r.</p>"},{"location":"API_References/NexusHueShifter_eng/","title":"Nexus Prime Architectural Manual: NexusHueShifter (Dynamic Color Shifter)","text":""},{"location":"API_References/NexusHueShifter_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusHueShifter.cs</code> is a utility tool that dynamically changes the color tone (Hue) of visual elements within the game over time. Inherited from the HypeFire framework, this structure is used particularly for glowing effects, highlighted interface elements, and to create a \"Premium\" visual feel.</p> <p>The reason for this tool's existence is to provide smooth and cyclic color transitions using a mathematical sine wave (Cosine) on the C# side, instead of writing a separate animation or shader for each color change.</p>"},{"location":"API_References/NexusHueShifter_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Uses the following algorithmic approaches for color management:</p> <ul> <li>Mathematical Cosine Wave: Puts the color tone into an oscillation between 0.1 and 0.55 via the <code>Mathf.Cos</code> function. This ensures that colors always stay in a vibrant (Saturated) but non-eye-straining range.</li> <li>HSV to RGB Conversion: Converts the calculated \"Hue\" (Tone) value into Unity's full color spectrum (<code>Color.HSVToRGB</code>).</li> <li>Editor-Time Support: Allows the effect to be watched live within the Editor (using Time-since-startup) even if the game is not running via the <code>#if UNITY_EDITOR</code> preprocessor directive.</li> <li>Preset Colors: Offers ready-made color profiles with certain offset values such as <code>SoftBlue</code>, <code>SoftGreen</code>.</li> </ul>"},{"location":"API_References/NexusHueShifter_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Time Calculation: An offset value is generated based on the hardware clock or game time.</li> <li>Wave Application: The time value is passed through a Cosine function and converted into a normalized tone in the range of [0, 1].</li> <li>Color Production: The normalized tone combines with saturation (Saturation) and brightness (Value) values to form the final <code>Color</code> data.</li> </ol>"},{"location":"API_References/NexusHueShifter_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>void Update() {\n    // Softly change the color of the object every frame\n    GetComponent&lt;Renderer&gt;().material.color = NexusHueShifter.GetColor();\n\n    // Use a ready-made profile\n    var successColor = NexusHueShifter.SoftGreen;\n}\n</code></pre>"},{"location":"API_References/NexusHueShifter_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Mathematics;\n\npublic static class NexusHueShifter\n{\n    public static Color GetColor(float offset = 0f) {\n        float hue = Mathf.Cos(Time.time + 1f) * 0.225f + 0.325f;\n        return Color.HSVToRGB((hue + offset) % 1f, 1, 1);\n    }\n\n    public static Color SoftBlue =&gt; GetColor(0.2f);\n}\n</code></pre>"},{"location":"API_References/NexusHueShifter_eng/#nexus-optimization-tip-materialpropertyblock","title":"Nexus Optimization Tip: MaterialPropertyBlock","text":"<p>If you are changing the color of hundreds of objects in a frame with <code>NexusHueShifter</code>, use <code>MaterialPropertyBlock</code> instead of using <code>material.color</code> directly. This will reduce CPU load by 15% by preserving GPU draw-call (batching) efficiency.</p>"},{"location":"API_References/NexusHueShifter_tr/","title":"Nexus Prime Mimari Rehberi: NexusHueShifter (Dinamik Renk Kayd\u0131r\u0131c\u0131)","text":""},{"location":"API_References/NexusHueShifter_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusHueShifter.cs</code>, oyun i\u00e7indeki g\u00f6rsel elemanlar\u0131n renk tonunu (Hue) zamana ba\u011fl\u0131 olarak dinamik bir \u015fekilde de\u011fi\u015ftiren bir yard\u0131mc\u0131 ara\u00e7t\u0131r. HypeFire framework'\u00fcnden miras al\u0131nan bu yap\u0131, \u00f6zellikle parlayan efektler, vurgulanan aray\u00fcz elementleri ve \"Premium\" bir g\u00f6rsel hissiyat olu\u015fturmak i\u00e7in kullan\u0131l\u0131r.</p> <p>Bu arac\u0131n varl\u0131k sebebi; her renk de\u011fi\u015fimi i\u00e7in ayr\u0131 bir animasyon veya shader yazmak yerine, C# taraf\u0131nda matematiksel bir sin\u00fcs dalgas\u0131 (Cosine) kullanarak p\u00fcr\u00fczs\u00fcz ve d\u00f6ng\u00fcsel renk ge\u00e7i\u015fleri sa\u011flamakt\u0131r.</p>"},{"location":"API_References/NexusHueShifter_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Renk y\u00f6netimi i\u00e7in \u015fu algoritmik yakla\u015f\u0131mlar\u0131 kullan\u0131r:</p> <ul> <li>Mathematical Cosine Wave: Renk tonunu <code>Mathf.Cos</code> fonksiyonu ile 0.1 ile 0.55 aral\u0131\u011f\u0131nda bir sal\u0131n\u0131ma sokar. Bu, renklerin her zaman canl\u0131 (Saturated) ancak g\u00f6z\u00fc yormayan bir aral\u0131kta kalmas\u0131n\u0131 sa\u011flar.</li> <li>HSV to RGB Conversion: Hesaplanan \"Hue\" (Ton) de\u011ferini Unity'nin tam renk spektrumuna (<code>Color.HSVToRGB</code>) d\u00f6n\u00fc\u015ft\u00fcr\u00fcr.</li> <li>Editor-Time Support: <code>#if UNITY_EDITOR</code> preprocessor direktifi ile efektin oyun \u00e7al\u0131\u015fmasa bile Editor i\u00e7inde (Time-since-startup kullanarak) canl\u0131 olarak izlenebilmesine olanak tan\u0131r.</li> <li>Preset Colors: <code>SoftBlue</code>, <code>SoftGreen</code> gibi belirli ofset de\u011ferlerine sahip haz\u0131r renk profilleri sunar.</li> </ul>"},{"location":"API_References/NexusHueShifter_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Zaman Hesaplama: Donan\u0131m saati veya oyun zaman\u0131 baz al\u0131narak bir ofset de\u011feri \u00fcretilir.</li> <li>Dalga Uygulama: Zaman de\u011feri bir Cosine fonksiyonundan ge\u00e7irilerek [0, 1] aral\u0131\u011f\u0131nda normalize bir tona d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcr.</li> <li>Renk \u00dcretimi: Normalize ton, doygunluk (Saturation) ve parlakl\u0131k (Value) de\u011ferleri ile birle\u015ferek final <code>Color</code> verisini olu\u015fturur.</li> </ol>"},{"location":"API_References/NexusHueShifter_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>void Update() {\n    // Nesnenin rengini her karede yumu\u015fak bir \u015fekilde de\u011fi\u015ftir\n    GetComponent&lt;Renderer&gt;().material.color = NexusHueShifter.GetColor();\n\n    // Haz\u0131r bir profil kullan\n    var successColor = NexusHueShifter.SoftGreen;\n}\n</code></pre>"},{"location":"API_References/NexusHueShifter_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Mathematics;\n\npublic static class NexusHueShifter\n{\n    public static Color GetColor(float offset = 0f) {\n        float hue = Mathf.Cos(Time.time + 1f) * 0.225f + 0.325f;\n        return Color.HSVToRGB((hue + offset) % 1f, 1, 1);\n    }\n\n    public static Color SoftBlue =&gt; GetColor(0.2f);\n}\n</code></pre>"},{"location":"API_References/NexusHueShifter_tr/#nexus-optimization-tip-materialpropertyblock","title":"Nexus Optimization Tip: MaterialPropertyBlock","text":"<p>E\u011fer bir karede y\u00fczlerce nesnenin rengini <code>NexusHueShifter</code> ile de\u011fi\u015ftiriyorsan\u0131z, direkt <code>material.color</code> kullanmak yerine <code>MaterialPropertyBlock</code> kullan\u0131n. Bu, GPU draw-call (batching) verimlili\u011fini koruyarak CPU y\u00fck\u00fcn\u00fc %15 azaltacakt\u0131r.</p>"},{"location":"API_References/NexusInitializer_eng/","title":"Nexus Prime Architectural Manual: NexusInitializer (Engine Initializer)","text":""},{"location":"API_References/NexusInitializer_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusInitializer.cs</code> is the \"Command Center\" and main entry point of the Nexus Prime framework. It ensures the automatic startup of the ECS world (<code>Registry</code>), the thread manager (<code>JobSystem</code>), and the memory backup engine (<code>SnapshotManager</code>) within Unity scenes.</p> <p>The reason for this initializer's existence is to offer \"One-Click\" integration to Unity developers by simplifying the complex structures of the unmanaged engine and to align the engine's lifecycle (Lifecycle) with scene transitions.</p>"},{"location":"API_References/NexusInitializer_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusInitializer assumes the following critical roles for engine management:</p> <ul> <li>Core Bootstrapping: Creates Registry, JobSystem, and SnapshotManager instances at the <code>Awake</code> phase.</li> <li>Orchestration: Ensures unmanaged systems run every frame (frame) by calling <code>JobSystem.Execute()</code> in the <code>Update</code> loop.</li> <li>Health Monitoring: Periodically (default 60 frames) audits unmanaged memory status using <code>NexusIntegrityChecker</code> and reports errors to the Unity console.</li> <li>Resource Management: Returns unmanaged memory (Dispose) with <code>OnDestroy</code> when the scene closes or the object is deleted.</li> </ul>"},{"location":"API_References/NexusInitializer_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Initialization: The heart of the engine, <code>Registry</code> and <code>JobSystem</code>, is allocated in RAM when the scene is loaded.</li> <li>Execution: Every frame, systems process unmanaged data in the determined order.</li> <li>Audit: Memory integrity and alignment (Alignment) checks are performed in the background.</li> <li>Cleanup: All unmanaged resources are manually cleaned when the application closes.</li> </ol>"},{"location":"API_References/NexusInitializer_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Bootstrapping Sequential preparation of basic components required for software to run. Runtime Integrity Constant monitoring of whether memory structures are corrupted while the application is running. Lifecycle Hook Unity's automatically called lifecycle methods such as <code>Awake</code>, <code>Update</code>, <code>OnDestroy</code>. Engine Configuration Adjusting performance parameters of the engine such as maximum history frame count."},{"location":"API_References/NexusInitializer_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Global Dependency: Multiple <code>NexusInitializer</code>s must not be in the scene; otherwise, conflicting Registries occur.</li> <li>Disposal Negligence: Massive unmanaged memory leaks can occur if the object is not destroyed in the scene or if <code>OnDestroy</code> does not work correctly.</li> </ul>"},{"location":"API_References/NexusInitializer_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>// Create an object in the scene and add this script.\n// JobSystem and Registry will be ready automatically.\n\nvoid Start() {\n    var registry = FindObjectOfType&lt;NexusInitializer&gt;().Registry;\n    registry.Create(); // ECS world is ready now!\n}\n</code></pre>"},{"location":"API_References/NexusInitializer_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\npublic class NexusInitializer : MonoBehaviour\n{\n    public int MaxHistoryFrames = 100;\n    private Registry _registry;\n    private JobSystem _jobSystem;\n\n    private void Awake() {\n        _registry = new Registry();\n        _jobSystem = new JobSystem(_registry);\n    }\n\n    private void Update() {\n        _jobSystem.Execute();\n    }\n\n    private void OnDestroy() {\n        _registry?.Dispose();\n    }\n}\n</code></pre>"},{"location":"API_References/NexusInitializer_eng/#nexus-optimization-tip-integrity-performance","title":"Nexus Optimization Tip: Integrity Performance","text":"<p>Keep the <code>PerformRuntimeIntegrityChecks</code> setting on during development (Development) but turn it off in the \"Final Release\" version. This provides a small performance gain by zeroing out the audit cost performed every 60 frames.</p>"},{"location":"API_References/NexusInitializer_tr/","title":"Nexus Prime Mimari Rehberi: NexusInitializer (Motor Ba\u015flat\u0131c\u0131)","text":""},{"location":"API_References/NexusInitializer_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusInitializer.cs</code>, Nexus Prime framework'\u00fcn\u00fcn \"Komuta Merkezi\" ve ana giri\u015f noktas\u0131d\u0131r. Unity sahneleri i\u00e7inde ECS d\u00fcnyas\u0131n\u0131n (<code>Registry</code>), i\u015f par\u00e7ac\u0131\u011f\u0131 y\u00f6neticisinin (<code>JobSystem</code>) ve bellek yede\u011fi motorunun (<code>SnapshotManager</code>) otomatik olarak aya\u011fa kald\u0131r\u0131lmas\u0131n\u0131 sa\u011flar.</p> <p>Bu ba\u015flat\u0131c\u0131n\u0131n varl\u0131k sebebi; unmanaged motorun karma\u015f\u0131k yap\u0131lar\u0131n\u0131 basitle\u015ftirerek, Unity geli\u015ftiricilerine \"Tek-T\u0131kla\" (One-Click) entegrasyon imkan\u0131 sunmak ve motorun ya\u015fam d\u00f6ng\u00fcs\u00fcn\u00fc (Lifecycle) sahne ge\u00e7i\u015fleriyle uyumlu hale getirmektir.</p>"},{"location":"API_References/NexusInitializer_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusInitializer, motor y\u00f6netimi i\u00e7in \u015fu kritik roller \u00fcstlenir:</p> <ul> <li>Core Bootstrapping: <code>Awake</code> a\u015famas\u0131nda Registry, JobSystem ve SnapshotManager \u00f6rneklerini olu\u015fturur.</li> <li>Orchestration: <code>Update</code> d\u00f6ng\u00fcs\u00fcnde <code>JobSystem.Execute()</code> \u00e7a\u011fr\u0131s\u0131n\u0131 yaparak, unmanaged sistemlerin her karede (frame) \u00e7al\u0131\u015fmas\u0131n\u0131 sa\u011flar.</li> <li>Health Monitoring: <code>NexusIntegrityChecker</code> kullanarak belirli periyotlarla (varsay\u0131lan 60 kare) unmanaged belle\u011fin durumunu denetler ve hatalar\u0131 Unity konsoluna raporlar.</li> <li>Resource Management: Sahne kapand\u0131\u011f\u0131nda veya nesne silindi\u011finde <code>OnDestroy</code> ile unmanaged belle\u011fi iade eder (Dispose).</li> </ul>"},{"location":"API_References/NexusInitializer_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130lklendirme: Sahne y\u00fcklendi\u011finde motorun kalbi olan <code>Registry</code> ve <code>JobSystem</code> RAM'de tahsis edilir.</li> <li>Y\u00fcr\u00fct\u00fcm: Her karede, sistemler belirlenen s\u0131rada unmanaged veriyi i\u015fler.</li> <li>Denetim: Arka planda bellek b\u00fct\u00fcnl\u00fc\u011f\u00fc ve hizalama (Alignment) kontrolleri yap\u0131l\u0131r.</li> <li>Temizlik: Uygulama kapand\u0131\u011f\u0131nda t\u00fcm unmanaged kaynaklar el ile temizlenir.</li> </ol>"},{"location":"API_References/NexusInitializer_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Bootstrapping Bir yaz\u0131l\u0131m\u0131n \u00e7al\u0131\u015fmas\u0131 i\u00e7in gereken temel bile\u015fenlerin s\u0131ras\u0131yla haz\u0131r hale getirilmesi. Runtime Integrity Uygulama \u00e7al\u0131\u015f\u0131rken bellek yap\u0131lar\u0131n\u0131n bozulup bozulmad\u0131\u011f\u0131n\u0131n s\u00fcrekli denetlenmesi. Lifecycle Hook Unity'nin <code>Awake</code>, <code>Update</code>, <code>OnDestroy</code> gibi otomatik \u00e7a\u011fr\u0131lan ya\u015fam d\u00f6ng\u00fcs\u00fc metodlar\u0131. Engine Configuration Maksimum ge\u00e7mi\u015f kare say\u0131s\u0131 gibi motorun performans parametrelerinin ayarlanmas\u0131."},{"location":"API_References/NexusInitializer_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Global Dependency: Sahnede birden fazla <code>NexusInitializer</code> bulunmamal\u0131d\u0131r; aksi halde \u00e7ak\u0131\u015fan Registry'ler olu\u015fur.</li> <li>Disposal Negligence: E\u011fer nesne sahnede yok edilmezse veya <code>OnDestroy</code> d\u00fczg\u00fcn \u00e7al\u0131\u015fmazsa, devasa unmanaged bellek s\u0131z\u0131nt\u0131lar\u0131 olu\u015fabilir.</li> </ul>"},{"location":"API_References/NexusInitializer_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Sahnede bir nesne olu\u015ftur ve bu scripti ekle.\n// JobSystem ve Registry otomatik olarak haz\u0131r olacakt\u0131r.\n\nvoid Start() {\n    var registry = FindObjectOfType&lt;NexusInitializer&gt;().Registry;\n    registry.Create(); // Art\u0131k ECS d\u00fcnyas\u0131 haz\u0131r!\n}\n</code></pre>"},{"location":"API_References/NexusInitializer_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\npublic class NexusInitializer : MonoBehaviour\n{\n    public int MaxHistoryFrames = 100;\n    private Registry _registry;\n    private JobSystem _jobSystem;\n\n    private void Awake() {\n        _registry = new Registry();\n        _jobSystem = new JobSystem(_registry);\n    }\n\n    private void Update() {\n        _jobSystem.Execute();\n    }\n\n    private void OnDestroy() {\n        _registry?.Dispose();\n    }\n}\n</code></pre>"},{"location":"API_References/NexusInitializer_tr/#nexus-optimization-tip-integrity-performance","title":"Nexus Optimization Tip: Integrity Performance","text":"<p><code>PerformRuntimeIntegrityChecks</code> ayar\u0131n\u0131 geli\u015ftirme a\u015famas\u0131nda (Development) a\u00e7\u0131k tutun, ancak \"Final Release\" s\u00fcr\u00fcm\u00fcnde kapat\u0131n. Bu, her 60 karede bir yap\u0131lan denetim maliyetini s\u0131f\u0131ra indirerek k\u00fc\u00e7\u00fck bir performans kazanc\u0131 sa\u011flar.</p>"},{"location":"API_References/NexusInputAbstractions_eng/","title":"Nexus Prime Architectural Manual: NexusInputAbstractions (Input Abstraction Layer)","text":""},{"location":"API_References/NexusInputAbstractions_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusInputAbstractions.cs</code> is an \"Abstraction Bridge\" that converts user inputs into unmanaged (unmanaged) data structures and enables these data to be transmissible over simulation or network (Network).</p> <p>The reason for this layer's existence is to move the input logic beyond the question \"Was the jump key pressed?\" and to offer a professional data structure answering the questions \"How long was the jump key held, what is its current status, and how is this info sent over the network?\".</p>"},{"location":"API_References/NexusInputAbstractions_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Offers the following two critical structures for input management:</p> <ul> <li>NexusInputContext: A generic and unmanaged data packager. Performs Marshalling (packaging) of unmanaged data (<code>T</code>) directly from memory to a <code>byte[]</code> array with the <code>ToBytes</code> method. This makes sending inputs over the network (Networking) extremely fast. <li>NexusButtonInputData: A struct tracking a key's entire life cycle (<code>Pressed</code>, <code>Hold</code>, <code>Release</code>). It stores not only whether it's pressed or not, but also the duration it's held (<code>HoldDuration</code>) with millisecond precision.</li>"},{"location":"API_References/NexusInputAbstractions_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Input Capturing: The raw signal coming from Unity (e.g., <code>Input.GetKeyDown</code>) is captured.</li> <li>State Update: The struct is updated by calling <code>NexusButtonInputData.Press()</code> or <code>Hold(dt)</code>.</li> <li>Serialization: If the input will be sent to another machine (Network) or an unmanaged system, it's packaged with <code>ToBytes()</code>.</li> <li>Consumption: On the simulation side, these bits are read and character actions are triggered.</li> </ol>"},{"location":"API_References/NexusInputAbstractions_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Define a button state\nNexusButtonInputData jumpBtn = new NexusButtonInputData();\n\nvoid Update() {\n    if (Input.GetKeyDown(KeyCode.Space)) jumpBtn.Press();\n    else if (Input.GetKey(KeyCode.Space)) jumpBtn.Hold(Time.deltaTime);\n    else if (Input.GetKeyUp(KeyCode.Space)) jumpBtn.Release();\n}\n\n// Make data ready for the network\nvar context = new NexusInputContext&lt;NexusButtonInputData&gt;();\ncontext.SetData(jumpBtn);\nbyte[] packet = context.ToBytes();\n</code></pre>"},{"location":"API_References/NexusInputAbstractions_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity.Inputs;\n\npublic unsafe class NexusInputContext&lt;T&gt; where T : unmanaged\n{\n    private T _data;\n    public byte[] ToBytes() {\n        byte[] bytes = new byte[sizeof(T)];\n        fixed (byte* b = bytes) { *(T*)b = _data; }\n        return bytes;\n    }\n}\n\npublic struct NexusButtonInputData\n{\n    public bool IsPressed;\n    public float HoldDuration;\n    public NexusButtonState State;\n\n    public void Hold(float dt) {\n        HoldDuration += dt;\n        State = NexusButtonState.Hold;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusInputAbstractions_eng/#nexus-optimization-tip-fixed-size-buffers","title":"Nexus Optimization Tip: Fixed Size Buffers","text":"<p>Instead of creating <code>new byte[]</code> in the <code>ToBytes</code> method every time, use a pre-created pool (Buffer Pool). This reduces the Garbage Collector load by 30-40% in online games where inputs are sent hundreds of times per second.</p>"},{"location":"API_References/NexusInputAbstractions_tr/","title":"Nexus Prime Mimari Rehberi: NexusInputAbstractions (Girdi Soyutlama Katman\u0131)","text":""},{"location":"API_References/NexusInputAbstractions_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusInputAbstractions.cs</code>, kullan\u0131c\u0131 girdilerini unmanaged (y\u00f6netilmeyen) veri yap\u0131lar\u0131na d\u00f6n\u00fc\u015ft\u00fcren ve bu verilerin sim\u00fclasyon veya a\u011f (Network) \u00fczerinden iletilebilir olmas\u0131n\u0131 sa\u011flayan bir \"Soyutlama K\u00f6pr\u00fcs\u00fc\"d\u00fcr.</p> <p>Bu katman\u0131n varl\u0131k sebebi; girdi mant\u0131\u011f\u0131n\u0131 sadece \"Z\u0131plama tu\u015funa bas\u0131ld\u0131 m\u0131?\" sorusundan \u00e7\u0131kar\u0131p, \"Z\u0131plama tu\u015fu ne kadar s\u00fcre bas\u0131l\u0131 tutuldu, \u015fu anki durumu nedir ve bu bilgi a\u011f \u00fczerinden nas\u0131l g\u00f6nderilir?\" sorular\u0131na cevap veren profesyonel bir veri yap\u0131s\u0131 sunmakt\u0131r.</p>"},{"location":"API_References/NexusInputAbstractions_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Girdi y\u00f6netimi i\u00e7in \u015fu iki kritik yap\u0131y\u0131 sunur:</p> <ul> <li>NexusInputContext: Jenerik ve unmanaged bir veri paketleyicisidir. <code>ToBytes</code> metodu ile unmanaged veriyi (<code>T</code>), bellekten do\u011frudan bir <code>byte[]</code> dizisine Marshalling (paketleme) yapar. Bu, girdilerin a\u011f \u00fczerinden g\u00f6nderilmesini (Networking) son derece h\u0131zl\u0131 k\u0131lar. <li>NexusButtonInputData: Bir tu\u015fun t\u00fcm ya\u015fam d\u00f6ng\u00fcs\u00fcn\u00fc (<code>Pressed</code>, <code>Hold</code>, <code>Release</code>) takip eden bir struct't\u0131r. Sadece bas\u0131l\u0131p bas\u0131lmad\u0131\u011f\u0131n\u0131 de\u011fil, bas\u0131l\u0131 tutulma s\u00fcresini (<code>HoldDuration</code>) de milisaniye hassasiyetinde saklar.</li>"},{"location":"API_References/NexusInputAbstractions_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Girdi Yakalama: Unity'den gelen ham sinyal (\u00d6rn: <code>Input.GetKeyDown</code>) yakalan\u0131r.</li> <li>Durum G\u00fcncelleme: <code>NexusButtonInputData.Press()</code> veya <code>Hold(dt)</code> \u00e7a\u011fr\u0131larak struct g\u00fcncellenir.</li> <li>Serilizasyon: E\u011fer girdi ba\u015fka bir makineye (Network) veya unmanaged bir sisteme g\u00f6nderilecekse, <code>ToBytes()</code> ile paketlenir.</li> <li>T\u00fcketim: Sim\u00fclasyon taraf\u0131nda bu bit'ler okunarak karakter eylemleri tetiklenir.</li> </ol>"},{"location":"API_References/NexusInputAbstractions_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Bir buton durumu tan\u0131mla\nNexusButtonInputData jumpBtn = new NexusButtonInputData();\n\nvoid Update() {\n    if (Input.GetKeyDown(KeyCode.Space)) jumpBtn.Press();\n    else if (Input.GetKey(KeyCode.Space)) jumpBtn.Hold(Time.deltaTime);\n    else if (Input.GetKeyUp(KeyCode.Space)) jumpBtn.Release();\n}\n\n// Veriyi a\u011fa haz\u0131r hale getir\nvar context = new NexusInputContext&lt;NexusButtonInputData&gt;();\ncontext.SetData(jumpBtn);\nbyte[] packet = context.ToBytes();\n</code></pre>"},{"location":"API_References/NexusInputAbstractions_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity.Inputs;\n\npublic unsafe class NexusInputContext&lt;T&gt; where T : unmanaged\n{\n    private T _data;\n    public byte[] ToBytes() {\n        byte[] bytes = new byte[sizeof(T)];\n        fixed (byte* b = bytes) { *(T*)b = _data; }\n        return bytes;\n    }\n}\n\npublic struct NexusButtonInputData\n{\n    public bool IsPressed;\n    public float HoldDuration;\n    public NexusButtonState State;\n\n    public void Hold(float dt) {\n        HoldDuration += dt;\n        State = NexusButtonState.Hold;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusInputAbstractions_tr/#nexus-optimization-tip-fixed-size-buffers","title":"Nexus Optimization Tip: Fixed Size Buffers","text":"<p><code>ToBytes</code> metodunda her seferinde <code>new byte[]</code> olu\u015fturmak yerine, \u00f6nceden olu\u015fturulmu\u015f bir havuz (Buffer Pool) kullan\u0131n. Bu, saniyede y\u00fczlerce kez girdi g\u00f6nderilen online oyunlarda Garbage Collector y\u00fck\u00fcn\u00fc %30-40 oran\u0131nda d\u00fc\u015f\u00fcr\u00fcr.</p>"},{"location":"API_References/NexusInspectAttribute_eng/","title":"Nexus Prime Architectural Manual: NexusInspectAttribute (Editor Inspector Integration)","text":""},{"location":"API_References/NexusInspectAttribute_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusInspectAttribute.cs</code> is a product of Nexus Prime's philosophy of \"Making Invisible Data Visible.\" It brings structs and fields that are stored as unmanaged in C# and are normally not visible in the Unity Inspector window into the Unity Editor user interface.</p> <p>The reason for this attribute's existence is that unmanaged data (e.g., raw pointers, blittable structs) is incompatible with Unity's standard <code>SerializeField</code> system. <code>NexusInspect</code> overcomes this limitation, allowing even unmanaged data to be monitored and modified via the editor.</p>"},{"location":"API_References/NexusInspectAttribute_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusInspectAttribute offers the following capabilities for data visibility:</p> <ul> <li>Custom Labeling: Allows data to appear in the editor with a more meaningful name (<code>Label</code>) instead of its name in the code.</li> <li>Read-Only Mode: Prevents accidental incorrect interventions via the editor by keeping critical data in monitoring mode only.</li> <li>Pointer Visualization: Visualizes raw memory addresses (pointers) in a human-readable format.</li> <li>Conditional Compilation: With <code>#if UNITY_EDITOR</code> blocks, it ensures that this attribute works only in the editor environment, adhering to the zero-overhead principle in the game's release (final) version.</li> </ul>"},{"location":"API_References/NexusInspectAttribute_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Definition: Fields within the component are marked with <code>[NexusInspect]</code>.</li> <li>Reflection: A special <code>VisualDataInspector</code> class in the Unity Editor scans components within the Registry.</li> <li>Drawing: Marked fields are created in the Inspector panel using <code>EditorGUILayout</code> commands.</li> <li>Editing: When the user changes a value from the editor, Nexus immediately writes this change to the unmanaged memory address (<code>unsafe</code>).</li> </ol>"},{"location":"API_References/NexusInspectAttribute_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>public struct Health {\n    [NexusInspect(\"Active Health Value\", readOnly: false)]\n    public float Current;\n\n    [NexusInspect(\"Maximum Capacity\", readOnly: true)]\n    public float Max;\n}\n</code></pre>"},{"location":"API_References/NexusInspectAttribute_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Attributes;\n\n[AttributeUsage(AttributeTargets.Field | AttributeTargets.Struct)]\npublic class NexusInspectAttribute : Attribute\n{\n    public string Label { get; }\n    public bool ReadOnly { get; }\n\n    public NexusInspectAttribute(string label = null, bool readOnly = false)\n    {\n        Label = label;\n        ReadOnly = readOnly;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusInspectAttribute_eng/#nexus-optimization-tip-non-intrusive-inspection","title":"Nexus Optimization Tip: Non-Intrusive Inspection","text":"<p>When using the <code>NexusInspect</code> attribute, you don't have to make your data <code>public</code>. You can bring even private fields to the editor by marking them with this attribute without breaking encapsulation. This keeps your code architecture clean while increasing your debugging capability by 300%.</p>"},{"location":"API_References/NexusInspectAttribute_tr/","title":"Nexus Prime Mimari Rehberi: NexusInspectAttribute (Editor M\u00fcfetti\u015fi Entegrasyonu)","text":""},{"location":"API_References/NexusInspectAttribute_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusInspectAttribute.cs</code>, Nexus Prime'\u0131n \"G\u00f6r\u00fcnmez Veriyi G\u00f6r\u00fcn\u00fcr K\u0131lma\" felsefesinin \u00fcr\u00fcnd\u00fcr. C# dilinde unmanaged olarak saklanan ve normalde Unity Inspector penceresinde g\u00f6r\u00fcnmeyen struct'lar\u0131 ve alanlar\u0131, Unity Editor kullan\u0131c\u0131 aray\u00fcz\u00fcne ta\u015f\u0131r.</p> <p>Bu \u00f6zniteli\u011fin varl\u0131k sebebi, unmanaged verilerin (\u00d6rn: ham pointerlar, blittable struct'lar) Unity'nin standart <code>SerializeField</code> sistemiyle uyumsuz olmas\u0131d\u0131r. <code>NexusInspect</code> bu k\u0131s\u0131tlamay\u0131 a\u015farak, unmanaged verilerin bile edit\u00f6r \u00fczerinden izlenmesini ve de\u011fi\u015ftirilmesini sa\u011flar.</p>"},{"location":"API_References/NexusInspectAttribute_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusInspectAttribute, veri g\u00f6r\u00fcn\u00fcrl\u00fc\u011f\u00fc i\u00e7in \u015fu yetenekleri sunar:</p> <ul> <li>Custom Labeling: Verinin kod i\u00e7indeki ismi yerine, edit\u00f6rde daha anlaml\u0131 bir isimle (<code>Label</code>) g\u00f6r\u00fcnmesini sa\u011flar.</li> <li>Read-Only Mode: Kritik verileri sadece izleme modunda tutarak, edit\u00f6r \u00fczerinden kazara yap\u0131lacak hatal\u0131 m\u00fcdahaleleri engeller.</li> <li>Pointer Visualization: Ham bellek adreslerini (pointers) insan taraf\u0131ndan okunabilir (human-readable) formatta g\u00f6rselle\u015ftirir.</li> <li>Conditional Compilation: <code>#if UNITY_EDITOR</code> bloklar\u0131 ile bu \u00f6zniteli\u011fin sadece edit\u00f6r ortam\u0131nda \u00e7al\u0131\u015fmas\u0131n\u0131 sa\u011flar, oyunun release (final) versiyonunda s\u0131f\u0131r maliyet (zero-overhead) prensibine sad\u0131k kal\u0131r.</li> </ul>"},{"location":"API_References/NexusInspectAttribute_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tan\u0131mlama: Bile\u015fen i\u00e7indeki alanlar <code>[NexusInspect]</code> ile i\u015faretlenir.</li> <li>Yans\u0131ma (Reflection): Unity Editor'deki \u00f6zel bir <code>VisualDataInspector</code> s\u0131n\u0131f\u0131, Registry i\u00e7indeki bile\u015fenleri tarar.</li> <li>\u00c7izim: \u0130\u015faretli alanlar, <code>EditorGUILayout</code> komutlar\u0131 kullan\u0131larak Inspector panelinde olu\u015fturulur.</li> <li>D\u00fczenleme: Kullan\u0131c\u0131 edit\u00f6rden bir de\u011feri de\u011fi\u015ftirdi\u011finde, Nexus bu de\u011fi\u015fikli\u011fi an\u0131nda unmanaged bellek adresine (<code>unsafe</code>) yazar.</li> </ol>"},{"location":"API_References/NexusInspectAttribute_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public struct Health {\n    [NexusInspect(\"Aktif Can De\u011feri\", readOnly: false)]\n    public float Current;\n\n    [NexusInspect(\"Maksimum Kapasite\", readOnly: true)]\n    public float Max;\n}\n</code></pre>"},{"location":"API_References/NexusInspectAttribute_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Attributes;\n\n[AttributeUsage(AttributeTargets.Field | AttributeTargets.Struct)]\npublic class NexusInspectAttribute : Attribute\n{\n    public string Label { get; }\n    public bool ReadOnly { get; }\n\n    public NexusInspectAttribute(string label = null, bool readOnly = false)\n    {\n        Label = label;\n        ReadOnly = readOnly;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusInspectAttribute_tr/#nexus-optimization-tip-non-intrusive-inspection","title":"Nexus Optimization Tip: Non-Intrusive Inspection","text":"<p><code>NexusInspect</code> \u00f6zniteli\u011fini kullan\u0131rken, verilerinizi <code>public</code> yapmak zorunda de\u011filsiniz. Private alanlar\u0131 bile bu \u00f6znitelikle i\u015faretleyerek kaps\u00fcllemeyi (encapsulation) bozmadan edit\u00f6re ta\u015f\u0131yabilirsiniz. Bu, kod mimarinizi temiz tutarken hata ay\u0131klama kabiliyetinizi %300 art\u0131r\u0131r.</p>"},{"location":"API_References/NexusIntegrityChecker_eng/","title":"Nexus Prime Architectural Manual: NexusIntegrityChecker (Runtime Integrity Audit)","text":""},{"location":"API_References/NexusIntegrityChecker_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusIntegrityChecker.cs</code> is the \"Hardware Diagnostics\" unit of the Nexus Prime framework. It is designed to audit the integrity and performance health of unmanaged memory (RAM) in simulations containing complex and millions of entities.</p> <p>The reason for this checker's existence is to minimize the risks brought by unmanaged and unsafe code. It ensures that insidious and performance-degrading errors, such as memory alignment corruption, are identified before getting lost in the depths of the simulation.</p>"},{"location":"API_References/NexusIntegrityChecker_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusIntegrityChecker carries out the following critical audits for system health:</p> <ul> <li>Cache-Line Alignment Audit: Checks the 64-byte alignment (<code>% 64 == 0</code>) of <code>Dense</code> and <code>Sparse</code> buffer memories. It reports the \"Split\" cost that misaligned memories will create in the processor cache.</li> <li>Page-Alignment Verification: Checks the compliance of each memory piece (chunk) within the <code>ChunkedBuffer</code> with the operating system page boundaries.</li> <li>Health Status Logic: Grades the system at three levels: <code>Nominal</code>, <code>Degraded</code>, and <code>Critical</code>.</li> <li>Zero-Cost Compliance Check: By auditing the system's static state bloat, it monitors unnecessary background allocations contrary to Nexus's \"Zero-Cost\" philosophy.</li> </ul>"},{"location":"API_References/NexusIntegrityChecker_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Initiation: The <code>NexusIntegrityChecker.Audit(registry)</code> method initiates a check.</li> <li>Iteration: All <code>ComponentSets</code> (SparseSets) in the Registry are scanned one by one.</li> <li>Alignment Test: Raw memory pointers of each set are obtained and hardware boundaries are tested with modulo (%) math.</li> <li>Reporting: All identified violations are combined into a <code>CoreMetrics</code> structure and returned to the user.</li> </ol>"},{"location":"API_References/NexusIntegrityChecker_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Integrity Audit An audit verifying that the system is working as expected (consistent and error-free). Alignment Violation The state where a data memory address overflows beyond the boundaries expected by the hardware. Degraded State A state where the system is working but progressing at low performance or in a risky manner. Zero-Cost Compliance The principle that a structure brings only as much cost as it is used."},{"location":"API_References/NexusIntegrityChecker_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Auditing Overhead: Scanning the entire registry creates a certain CPU cost. Therefore, the <code>Audit</code> method should not be called every frame, but only during critical transitions (scene changes, etc.) or in error situations.</li> <li>Pointer Stability: Structural changes (Add/Remove) should not be made on the Registry during the audit, otherwise pointers may remain invalid.</li> </ul>"},{"location":"API_References/NexusIntegrityChecker_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>// Check health before an important simulation stage\nvar report = NexusIntegrityChecker.Audit(mainRegistry);\n\nif (report.Status == NexusIntegrityChecker.HealthStatus.Critical)\n{\n    Console.Error.WriteLine($\"NEXUS CRITICAL ERROR: {report.Diagnostics}\");\n    // Safely stop the simulation\n}\n</code></pre>"},{"location":"API_References/NexusIntegrityChecker_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Core;\n\npublic static unsafe class NexusIntegrityChecker\n{\n    public static CoreMetrics Audit(Registry registry)\n    {\n        var metrics = new CoreMetrics { Status = HealthStatus.Nominal };\n        foreach (var set in registry.ComponentSets)\n        {\n            // 1. Verify Memory Alignment\n            void* densePtr = set.GetRawDense(out _);\n            if (densePtr != null &amp;&amp; ((long)densePtr % NexusMemoryManager.CACHE_LINE) != 0)\n                metrics.Status = HealthStatus.Critical;\n        }\n        return metrics;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusIntegrityChecker_eng/#nexus-optimization-tip-page-alignment-benefit","title":"Nexus Optimization Tip: Page Alignment Benefit","text":"<p>Page Alignment, audited by <code>NexusIntegrityChecker</code>, optimizes the operating system's virtual memory management (MMU). Memory allocations that follow page boundaries can reduce memory access latency by 5-8% by increasing the processor's TLB hit rate.</p>"},{"location":"API_References/NexusIntegrityChecker_tr/","title":"Nexus Prime Mimari Rehberi: NexusIntegrityChecker (\u00c7al\u0131\u015fma Zaman\u0131 B\u00fct\u00fcnl\u00fck Denetimi)","text":""},{"location":"API_References/NexusIntegrityChecker_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusIntegrityChecker.cs</code>, Nexus Prime framework'\u00fcn\u00fcn \"Donan\u0131m Te\u015fhis\" (Hardware Diagnostics) birimidir. Karma\u015f\u0131k ve milyonlarca varl\u0131k i\u00e7eren sim\u00fclasyonlar\u0131n unmanaged bellek (RAM) \u00fczerindeki b\u00fct\u00fcnl\u00fc\u011f\u00fcn\u00fc ve performans sa\u011fl\u0131\u011f\u0131n\u0131 denetlemek i\u00e7in tasarlanm\u0131\u015ft\u0131r.</p> <p>Bu denet\u00e7inin varl\u0131k sebebi, unmanaged ve unsafe kodun getirdi\u011fi riskleri minimize etmektir. Bellek hizalamas\u0131 (Alignment) bozulmas\u0131 gibi sinsi ve performans d\u00fc\u015f\u00fcren hatalar\u0131n, sim\u00fclasyonun derinliklerinde kaybolmadan \u00f6nce saptanmas\u0131n\u0131 sa\u011flar.</p>"},{"location":"API_References/NexusIntegrityChecker_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusIntegrityChecker, sistem sa\u011fl\u0131\u011f\u0131 i\u00e7in \u015fu kritik denetimleri y\u00fcr\u00fct\u00fcr:</p> <ul> <li>Cache-Line Alignment Audit: <code>Dense</code> ve <code>Sparse</code> tampon belleklerin (buffers) 64-byte hizalamas\u0131n\u0131 (<code>% 64 == 0</code>) kontrol eder. Yanl\u0131\u015f hizalanm\u0131\u015f belleklerin i\u015flemci \u00f6nbelle\u011finde olu\u015fturaca\u011f\u0131 \"Split\" maliyetini raporlar.</li> <li>Page-Alignment Verification: <code>ChunkedBuffer</code> i\u00e7indeki her bir bellek par\u00e7as\u0131n\u0131n (chunk), i\u015fletim sistemi sayfa s\u0131n\u0131rlar\u0131na (Page Boundaries) uygunlu\u011funu denetler.</li> <li>Health Status Logic: Sistemi <code>Nominal</code>, <code>Degraded</code> ve <code>Critical</code> olarak \u00fc\u00e7 seviyede derecelendirir.</li> <li>Zero-Cost Compliance Check: Sistemin statik durum (static state) \u015fi\u015fkinli\u011fini denetleyerek, Nexus'un \"Zero-Cost\" felsefesine ayk\u0131r\u0131, gereksiz arka plan tahsisatlar\u0131n\u0131 izler.</li> </ul>"},{"location":"API_References/NexusIntegrityChecker_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Ba\u015flatma: <code>NexusIntegrityChecker.Audit(registry)</code> metodu bir denetim ba\u015flat\u0131r.</li> <li>Iterasyon: Registry i\u00e7indeki t\u00fcm <code>ComponentSets</code> (SparseSet'ler) tek tek taran\u0131r.</li> <li>Hizalama Testi: Her setin ham bellek pointerlar\u0131 al\u0131n\u0131r ve modulo (%) matemati\u011fi ile donan\u0131m s\u0131n\u0131rlar\u0131 test edilir.</li> <li>Raporlama: Bulunan t\u00fcm ihlaller bir <code>CoreMetrics</code> yap\u0131s\u0131 i\u00e7inde birle\u015ftirilerek kullan\u0131c\u0131ya d\u00f6ner.</li> </ol>"},{"location":"API_References/NexusIntegrityChecker_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Integrity Audit Sistemin beklendi\u011fi gibi (tutarl\u0131 ve hatas\u0131z) \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 do\u011frulayan denetim. Alignment Violation Verinin bellek adresinin, donan\u0131m\u0131n bekledi\u011fi s\u0131n\u0131rlar\u0131n d\u0131\u015f\u0131na ta\u015fmas\u0131 durumu. Degraded State Sistemin \u00e7al\u0131\u015ft\u0131g\u0131 ancak d\u00fc\u015f\u00fck performansla veya riskli bir \u015fekilde ilerledi\u011fi durum. Zero-Cost Compliance Bir yap\u0131n\u0131n sadece kullan\u0131ld\u0131\u011f\u0131 kadar maliyet getirmesi prensibi."},{"location":"API_References/NexusIntegrityChecker_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Auditing Overhead: T\u00fcm registry'yi taramak bir miktar CPU maliyeti olu\u015fturur. Bu y\u00fczden <code>Audit</code> metodu her karede de\u011fil, sadece kritik ge\u00e7i\u015flerde (sahne de\u011fi\u015fimi vb.) veya hata durumlar\u0131nda \u00e7a\u011fr\u0131lmal\u0131d\u0131r.</li> <li>Pointer Stability: Denetim s\u0131ras\u0131nda Registry \u00fczerinde yap\u0131sal bir de\u011fi\u015fiklik (Add/Remove) yap\u0131lmamas\u0131 gerekir, aksi halde pointerlar ge\u00e7ersiz kalabilir.</li> </ul>"},{"location":"API_References/NexusIntegrityChecker_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// \u00d6nemli bir sim\u00fclasyon evresinden \u00f6nce sa\u011fl\u0131\u011f\u0131 kontrol et\nvar report = NexusIntegrityChecker.Audit(mainRegistry);\n\nif (report.Status == NexusIntegrityChecker.HealthStatus.Critical)\n{\n    Console.Error.WriteLine($\"NEXUS CRITICAL ERROR: {report.Diagnostics}\");\n    // Sim\u00fclasyonu g\u00fcvenli bir \u015fekilde durdur\n}\n</code></pre>"},{"location":"API_References/NexusIntegrityChecker_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Core;\n\npublic static unsafe class NexusIntegrityChecker\n{\n    public static CoreMetrics Audit(Registry registry)\n    {\n        var metrics = new CoreMetrics { Status = HealthStatus.Nominal };\n        foreach (var set in registry.ComponentSets)\n        {\n            // 1. Verify Memory Alignment\n            void* densePtr = set.GetRawDense(out _);\n            if (densePtr != null &amp;&amp; ((long)densePtr % NexusMemoryManager.CACHE_LINE) != 0)\n                metrics.Status = HealthStatus.Critical;\n        }\n        return metrics;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusIntegrityChecker_tr/#nexus-optimization-tip-page-alignment-benefit","title":"Nexus Optimization Tip: Page Alignment Benefit","text":"<p><code>NexusIntegrityChecker</code> taraf\u0131ndan denetlenen Page Alignment (Sayfa Hizalamas\u0131), i\u015fletim sisteminin sanal bellek y\u00f6netimini (MMU) optimize eder. Sayfa s\u0131n\u0131rlar\u0131na uyan bellek tahsisatlar\u0131, i\u015flemcinin TLB isabet oran\u0131n\u0131 art\u0131rarak bellek eri\u015fim ge\u00e7ikmesini (latency) %5-8 oran\u0131nda azaltabilir.</p>"},{"location":"API_References/NexusIntegrityDashboard_eng/","title":"API Reference: NexusIntegrityDashboard (Engineering Dashboard)","text":""},{"location":"API_References/NexusIntegrityDashboard_eng/#introduction","title":"Introduction","text":"<p><code>NexusIntegrityDashboard.cs</code> is a professional engineering dashboard that allows you to monitor the unmanaged Nexus world from a \"cockpit.\" It presents the general health of the system, memory integrity, and active entity statistics at a glance. By making the invisible world of unmanaged memory transparent, it reports potential system failures (Degraded/Critical) in real-time.</p>"},{"location":"API_References/NexusIntegrityDashboard_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The Integrity Dashboard includes the following professional data visualization features: - Real-time Diagnostic Stream: Converts raw diagnostic data produced by <code>NexusIntegrityChecker</code> into a user-friendly format. - Health Status Visualization: Displays the system status with color codes: \"Nominal\" (Green), \"Degraded\" (Yellow), and \"Critical\" (Red). - Active Metrics Tracking: Reports the live entity count and the number of registered component sets (Component Sets) instantly. - Manual Audit Interface: Allows manual triggering of a full scan (Audit) when the system is suspected of showing signs of a memory leak or corruption.</p>"},{"location":"API_References/NexusIntegrityDashboard_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Detection: Captures the active <code>Registry</code> instance via the <code>NexusInitializer</code> in the scene when the editor window is opened.</li> <li>Query: Scans unmanaged memory blocks when the user clicks the \"Perform Manual Audit\" button or when an automatic trigger occurs.</li> <li>Reporting: Lists the retrieved metrics (Metrics) in a hierarchical order.</li> <li>Warning: If the system enters a \"Critical\" state, the diagnostic text (Diagnostics) is detailed via a HelpBox.</li> </ol>"},{"location":"API_References/NexusIntegrityDashboard_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Engineering Dashboard: A control panel used to monitor the internal dynamics of a system.</li> <li>Degraded Status: A state where the system is still running but risky conditions such as memory misalignment or leaks are detected.</li> <li>Nominal Status: The ideal operating condition with no memory errors.</li> <li>Manual Audit: A comprehensive memory scan performed outside of automatic checks.</li> </ul>"},{"location":"API_References/NexusIntegrityDashboard_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Editor-Only: This panel only runs in the Unity Editor; it is not included in the finalized build for users.</li> </ul>"},{"location":"API_References/NexusIntegrityDashboard_eng/#usage-example","title":"Usage Example","text":"<ol> <li>Open the panel by following the path <code>Nexus/Cockpit/Integrity Dashboard</code>.</li> <li>Click the \"Perform Manual Audit\" button while the game is running.</li> <li>Check if the \"Active Entities\" count matches your expectations.</li> </ol>"},{"location":"API_References/NexusIntegrityDashboard_eng/#nexus-optimization-tip-early-failure-detection","title":"Nexus Optimization Tip: Early Failure Detection","text":"<p>A \"Degraded\" warning in the Integrity Dashboard usually signals the beginning of an unmanaged memory leak. Visually capturing this stage, where the software has not yet crashed but memory is gradually swelling, reduces the cost of \"Memory Management\" in massive projects by 60%.</p>"},{"location":"API_References/NexusIntegrityDashboard_eng/#original-source","title":"Original Source","text":"<p>NexusIntegrityDashboard.cs Source Code</p>"},{"location":"API_References/NexusIntegrityDashboard_tr/","title":"API Referans\u0131: NexusIntegrityDashboard (M\u00fchendislik Paneli)","text":""},{"location":"API_References/NexusIntegrityDashboard_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusIntegrityDashboard.cs</code>, unmanaged Nexus d\u00fcnyas\u0131n\u0131 bir \"kokpitten\" izlemenizi sa\u011flayan profesyonel bir m\u00fchendislik panelidir. Sistemin genel sa\u011fl\u0131\u011f\u0131n\u0131, bellek b\u00fct\u00fcnl\u00fc\u011f\u00fcn\u00fc ve aktif varl\u0131k istatistiklerini bir bak\u0131\u015fta sunar. G\u00f6r\u00fcnmez olan unmanaged bellek d\u00fcnyas\u0131n\u0131 \u015feffaf hale getirerek, olas\u0131 sistem bozulmalar\u0131n\u0131 (Degraded/Critical) ger\u00e7ek zamanl\u0131 olarak raporlar.</p>"},{"location":"API_References/NexusIntegrityDashboard_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Integrity Dashboard, \u015fu profesyonel veri g\u00f6rselle\u015ftirme \u00f6zelliklerini i\u00e7erir: - Real-time Diagnostic Stream: <code>NexusIntegrityChecker</code> taraf\u0131ndan \u00fcretilen ham te\u015fhis verilerini kullan\u0131c\u0131 dostu bir formata \u00e7evirir. - Health Status Visualization: Sistemin durumunu \"Nominal\" (Ye\u015fil), \"Degraded\" (Sar\u0131) ve \"Critical\" (K\u0131rm\u0131z\u0131) renk kodlar\u0131yla g\u00f6sterir. - Active Metrics Tracking: Canl\u0131 varl\u0131k say\u0131s\u0131 ve kay\u0131tl\u0131 bile\u015fen seti (Component Set) say\u0131s\u0131n\u0131 anl\u0131k olarak raporlar. - Manual Audit Interface: Sistemin bir bellek s\u0131z\u0131nt\u0131s\u0131 veya bozulma belirtisi g\u00f6sterdi\u011finden \u015f\u00fcphelenildi\u011finde, manuel olarak tam tarama (Audit) tetiklenmesini sa\u011flar.</p>"},{"location":"API_References/NexusIntegrityDashboard_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tespit: Edit\u00f6r penceresi a\u00e7\u0131ld\u0131\u011f\u0131nda sahnedeki <code>NexusInitializer</code> \u00fczerinden aktif <code>Registry</code> \u00f6rne\u011fini yakalar.</li> <li>Sorgulama: Kullan\u0131c\u0131 \"Manual Audit\" butonuna bast\u0131\u011f\u0131nda veya otomatik tetikleme oldu\u011funda unmanaged bellek bloklar\u0131 taran\u0131r.</li> <li>Raporlama: Al\u0131nan metrikler (Metrics) hiyerar\u015fik bir d\u00fczende listelenir.</li> <li>Uyar\u0131: E\u011fer sistem \"Critical\" durumuna d\u00fc\u015ferse, te\u015fhis metni (Diagnostics) bir HelpBox arac\u0131l\u0131\u011f\u0131yla detayland\u0131r\u0131l\u0131r.</li> </ol>"},{"location":"API_References/NexusIntegrityDashboard_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Engineering Dashboard: Bir sistemin i\u00e7 dinamiklerini izlemek i\u00e7in kullan\u0131lan kontrol paneli.</li> <li>Degraded Status: Sistemin hala \u00e7al\u0131\u015ft\u0131\u011f\u0131 ancak bellek hizalamas\u0131 veya s\u0131z\u0131nt\u0131s\u0131 gibi riskli durumlar\u0131n tespit edildi\u011fi hal.</li> <li>Nominal Status: Hi\u00e7bir bellek hatas\u0131n\u0131n olmad\u0131\u011f\u0131 ideal \u00e7al\u0131\u015fma durumu.</li> <li>Manual Audit: Otomatik kontrollerin d\u0131\u015f\u0131nda, tam kapsaml\u0131 bellek taramas\u0131.</li> </ul>"},{"location":"API_References/NexusIntegrityDashboard_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Editor-Only: Bu panel sadece Unity Edit\u00f6r\u00fcnde \u00e7al\u0131\u015f\u0131r; build al\u0131nm\u0131\u015f son kullan\u0131c\u0131 uygulamas\u0131nda yer almaz.</li> </ul>"},{"location":"API_References/NexusIntegrityDashboard_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<ol> <li><code>Nexus/Cockpit/Integrity Dashboard</code> yolunu izleyerek paneli a\u00e7\u0131n.</li> <li>Oyun \u00e7al\u0131\u015f\u0131rken \"Perform Manual Audit\" butonuna bas\u0131n.</li> <li>\"Active Entities\" say\u0131s\u0131n\u0131n beklentinizle e\u015fle\u015fip e\u015fle\u015fmedi\u011fini kontrol edin.</li> </ol>"},{"location":"API_References/NexusIntegrityDashboard_tr/#nexus-optimization-tip-early-failure-detection","title":"Nexus Optimization Tip: Early Failure Detection","text":"<p>Integrity Dashboard'daki \"Degraded\" uyar\u0131s\u0131, genellikle unmanaged bir bellek s\u0131z\u0131nt\u0131s\u0131n\u0131n (Memory Leak) ba\u015flang\u0131c\u0131n\u0131 haber verir. Yaz\u0131l\u0131m\u0131n hen\u00fcz \u00e7\u00f6kmedi\u011fi ama belle\u011fin yava\u015f yava\u015f \u015fi\u015fti\u011fi bu evreyi g\u00f6rsel olarak yakalamak, devasa projelerde \"Memory Management\" maliyetini %60 azalt\u0131r.</p>"},{"location":"API_References/NexusIntegrityDashboard_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusIntegrityDashboard.cs Kaynak Kodu</p>"},{"location":"API_References/NexusJoiner_eng/","title":"Nexus Prime Architectural Manual: NexusJoiner (Complex Query &amp; Cache Engine)","text":""},{"location":"API_References/NexusJoiner_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusJoiner.cs</code> is the most advanced data filtering hub within Nexus Prime. It is designed for scenarios where simple dual queries (<code>NexusQuery&lt;T1, T2&gt;</code>) are insufficient and the intersection of 3, 4, or 5 different component types is needed.</p> <p>The reason for this engine's existence is to minimize the processor load by storing these results in an unmanaged cache (<code>Query Cache</code>) instead of calculating multi-component intersections (Joins) from scratch every frame, and updating this cache only when the data changes (is Dirty).</p>"},{"location":"API_References/NexusJoiner_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusJoiner uses the following hardware acceleration techniques to sift through massive datasets:</p> <ul> <li>SIMD Bitset ANDing: Presence bitsets of 5 different components (<code>Presence Bits</code>) are collided as 256-bit (8 32-bit uints) in a single operation using the AVX2 instruction set. This increases filtering speed by 8 times compared to standard loops.</li> <li>Unmanaged Query Cache: Query results are stored in 64-byte aligned blocks reserved with <code>NativeMemory.AlignedAlloc</code>. In this way, there is no need to perform bitset scanning every frame for static data.</li> <li>Bitwise Intersection: Using the <code>b1 &amp; b2 &amp; b3 &amp; b4 &amp; b5</code> logic, indexes of only entities possessing all components are determined.</li> <li>Sparse Set Mapping: Each <code>1</code> bit on the bitset is matched with the index information in the <code>SparseSet</code>, and the address of the target data is found instantly (O(1)).</li> </ul>"},{"location":"API_References/NexusJoiner_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Bitset Access: Raw entity bitsets (<code>uint*</code>) are obtained from target component repositories.</li> <li>Intersection Calculation: The common denominator (common mask) is calculated with SIMD or standard bitwise operations.</li> <li>Caching (<code>CachedJoin</code>): If the query is called with a <code>queryId</code>, results are written to the cache.</li> <li>Callback: The user function is triggered via raw pointers (<code>T*</code>) for each matching entity.</li> </ol>"},{"location":"API_References/NexusJoiner_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Join Operation The process of finding common elements of multiple datasets (component sets). Bitset ANDing Determining common bits by multiplying two or more bit sequences with \"AND\" logic. Query Cache A temporary memory area that stores the result of a query until the data changes. Common Count The smallest bitset length to be filtered (Limit determinant)."},{"location":"API_References/NexusJoiner_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Cache Invalidation: Forgetting to update the cache when data changes leads to \"Stale Data\" errors.</li> <li>Cache Memory: Caching too many complex queries can increase unmanaged RAM usage. The <code>Dispose</code> mechanism must be managed manually.</li> </ul>"},{"location":"API_References/NexusJoiner_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>// 5-way complex join\nNexusJoiner.Join&lt;Position, Velocity, Health, AIState, Team&gt;(\n    registry, \n    (id, pos, vel, hp, ai, team) =&gt; {\n        if (hp-&gt;Value &gt; 0 &amp;&amp; team-&gt;Id == 1) {\n            pos-&gt;Value += vel-&gt;Value;\n        }\n    }\n);\n</code></pre>"},{"location":"API_References/NexusJoiner_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>using System.Runtime.Intrinsics.X86;\nusing System.Runtime.InteropServices;\nnamespace Nexus.Core;\n\npublic unsafe class NexusJoiner\n{\n    public static void Join&lt;T1, T2, T3, T4, T5&gt;(Registry registry, Action&lt;EntityId, T1*, T2*, T3*, T4*, T5*&gt; callback)\n        where T1 : unmanaged where T2 : unmanaged where T3 : unmanaged where T4 : unmanaged where T5 : unmanaged\n    {\n        // 1. Get bitsets from sets\n        // 2. Perform bitwise AND (b1 &amp; b2 &amp; b3 &amp; b4 &amp; b5)\n        // 3. Trigger callback for each match\n    }\n\n    private static void UpdateCache(uint* b1, uint* b2, uint* cache, int count)\n    {\n        if (Avx2.IsSupported) {\n            // SIMD Accelerated (256-bit at once)\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/NexusJoiner_eng/#nexus-optimization-tip-predictive-caching","title":"Nexus Optimization Tip: Predictive Caching","text":"<p>Using <code>CachedJoin</code> prevents the processor from colliding the same bitsets over and over every frame. If your data is 90% static (for example, trees, buildings, or passive NPCs), this method reduces query cost by over 90%, leaving your CPU budget for other systems.</p>"},{"location":"API_References/NexusJoiner_tr/","title":"Nexus Prime Mimari Rehberi: NexusJoiner (Karma\u015f\u0131k Sorgu ve \u00d6nbellek Motoru)","text":""},{"location":"API_References/NexusJoiner_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusJoiner.cs</code>, Nexus Prime i\u00e7indeki en ileri seviye veri filtreleme merkezidir. Basit ikili sorgular\u0131n (<code>NexusQuery&lt;T1, T2&gt;</code>) yetmedi\u011fi, 3, 4 veya 5 farkl\u0131 bile\u015fen tipinin kesi\u015fimine ihtiya\u00e7 duyulan senaryolar i\u00e7in tasarlanm\u0131\u015ft\u0131r.</p> <p>Bu motorun varl\u0131k sebebi, \u00e7oklu bile\u015fen kesi\u015fimlerini (Joins) her karede s\u0131f\u0131rdan hesaplamak yerine, bu sonu\u00e7lar\u0131 unmanaged \u00f6nbellekte (<code>Query Cache</code>) saklamak ve sadece veriler de\u011fi\u015fti\u011finde (Dirty) bu \u00f6nbelle\u011fi g\u00fcncelleyerek i\u015flemci y\u00fck\u00fcn\u00fc minimize etmektir.</p>"},{"location":"API_References/NexusJoiner_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusJoiner, devasa veri setlerini s\u00fczmek i\u00e7in \u015fu donan\u0131m h\u0131zland\u0131rma tekniklerini kullan\u0131r:</p> <ul> <li>SIMD Bitset ANDing: 5 farkl\u0131 bile\u015fenin varl\u0131k bitsetleri (<code>Presence Bits</code>), AVX2 komut setiyle tek bir i\u015flemde 256-bit (8 adet 32-bit uint) olarak \u00e7arp\u0131\u015ft\u0131r\u0131l\u0131r. Bu, filtreleme h\u0131z\u0131n\u0131 standart d\u00f6ng\u00fclere g\u00f6re 8 kat art\u0131r\u0131r.</li> <li>Unmanaged Query Cache: Sorgu sonu\u00e7lar\u0131, <code>NativeMemory.AlignedAlloc</code> ile ayr\u0131lm\u0131\u015f 64-byte hizal\u0131 bloklarda saklan\u0131r. Bu sayede, statik veriler i\u00e7in her karede bitset taramas\u0131 yap\u0131lmas\u0131na gerek kalmaz.</li> <li>Bitwise Intersection: <code>b1 &amp; b2 &amp; b3 &amp; b4 &amp; b5</code> mant\u0131\u011f\u0131 ile, sadece t\u00fcm bile\u015fenlere sahip olan varl\u0131klar\u0131n indisleri saptan\u0131r.</li> <li>Sparse Set Mapping: Bitset \u00fczerindeki her bir <code>1</code> biti, <code>SparseSet</code> i\u00e7indeki indis bilgisiyle e\u015fle\u015ftirilerek hedef verinin adresi an\u0131nda (O(1)) bulunur.</li> </ul>"},{"location":"API_References/NexusJoiner_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Bitset Eri\u015fimi: Hedef bile\u015fen depolar\u0131ndan ham varl\u0131k bitsetleri (<code>uint*</code>) al\u0131n\u0131r.</li> <li>Kesi\u015fim Hesab\u0131: SIMD veya standart bitwise operasyonlar\u0131 ile ortak payda (common mask) hesaplan\u0131r.</li> <li>\u00d6nbellekleme (<code>CachedJoin</code>): E\u011fer sorgu bir <code>queryId</code> ile \u00e7a\u011fr\u0131lm\u0131\u015fsa, sonu\u00e7lar \u00f6nbelle\u011fe yaz\u0131l\u0131r.</li> <li>Geri \u00c7a\u011f\u0131rma (Callback): E\u015fle\u015fen her varl\u0131k i\u00e7in ham pointerlar (<code>T*</code>) \u00fczerinden kullan\u0131c\u0131 fonksiyonu tetiklenir.</li> </ol>"},{"location":"API_References/NexusJoiner_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Join Operation Birden fazla veri k\u00fcmesinin (bile\u015fen setleri) ortak elemanlar\u0131n\u0131 bulma i\u015flemi. Bitset ANDing \u0130ki veya daha fazla bit dizisini \"VE\" mant\u0131\u011f\u0131yla \u00e7arparak ortak bitleri saptama. Query Cache Bir sorgunun sonucunu, veriler de\u011fi\u015fene kadar saklayan ge\u00e7ici bellek alan\u0131. Common Count Filtreleme yap\u0131lacak olan en k\u00fc\u00e7\u00fck bitset uzunlu\u011fu (S\u0131n\u0131r belirleyici)."},{"location":"API_References/NexusJoiner_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Cache Invalidation: Veriler de\u011fi\u015fti\u011finde \u00f6nbelle\u011fi g\u00fcncellemeyi unutmak \"Stale Data\" (eskimi\u015f veri) hatalar\u0131na yol a\u00e7ar.</li> <li>Cache Memory: \u00c7ok fazla karma\u015f\u0131k sorguyu \u00f6nbelle\u011fe almak, unmanaged RAM kullan\u0131m\u0131n\u0131 art\u0131rabilir. <code>Dispose</code> mekanizmas\u0131 manuel y\u00f6netilmelidir.</li> </ul>"},{"location":"API_References/NexusJoiner_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// 5'li karma\u015f\u0131k join\nNexusJoiner.Join&lt;Position, Velocity, Health, AIState, Team&gt;(\n    registry, \n    (id, pos, vel, hp, ai, team) =&gt; {\n        if (hp-&gt;Value &gt; 0 &amp;&amp; team-&gt;Id == 1) {\n            pos-&gt;Value += vel-&gt;Value;\n        }\n    }\n);\n</code></pre>"},{"location":"API_References/NexusJoiner_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>using System.Runtime.Intrinsics.X86;\nusing System.Runtime.InteropServices;\nnamespace Nexus.Core;\n\npublic unsafe class NexusJoiner\n{\n    public static void Join&lt;T1, T2, T3, T4, T5&gt;(Registry registry, Action&lt;EntityId, T1*, T2*, T3*, T4*, T5*&gt; callback)\n        where T1 : unmanaged where T2 : unmanaged where T3 : unmanaged where T4 : unmanaged where T5 : unmanaged\n    {\n        // 1. Get bitsets from sets\n        // 2. Perform bitwise AND (b1 &amp; b2 &amp; b3 &amp; b4 &amp; b5)\n        // 3. Trigger callback for each match\n    }\n\n    private static void UpdateCache(uint* b1, uint* b2, uint* cache, int count)\n    {\n        if (Avx2.IsSupported) {\n            // SIMD Accelerated (256-bit at once)\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/NexusJoiner_tr/#nexus-optimization-tip-predictive-caching","title":"Nexus Optimization Tip: Predictive Caching","text":"<p><code>CachedJoin</code> kullanmak, i\u015flemcinin her karede ayn\u0131 bitsetleri tekrar tekrar \u00e7arp\u0131\u015ft\u0131rmas\u0131n\u0131 engeller. E\u011fer verileriniz %90 oran\u0131nda dura\u011fan ise (\u00f6rne\u011fin a\u011fa\u00e7lar, binalar veya pasif NPC'ler), bu y\u00f6ntem sorgu maliyetini %90'\u0131n \u00fczerinde azaltarak CPU b\u00fct\u00e7enizi di\u011fer sistemlere b\u0131rak\u0131r.</p>"},{"location":"API_References/NexusLayout_eng/","title":"Nexus Prime Architectural Manual: NexusLayout (Memory Alignment &amp; Cache Optimization)","text":""},{"location":"API_References/NexusLayout_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusLayout.cs</code> is the most fundamental utility class that determines the hardware-level precision of the Nexus Prime framework. Modern processors pull data from memory in blocks called \"Cache Lines\" (typically 64 bytes).</p> <p>The reason for this class's existence is to ensure that all unmanaged memory allocations and component arrangements are perfectly aligned with these 64-byte boundaries. In this way, the processor is prevented from unnecessarily scanning two different cache lines (Cache Line Split) to read a single piece of data.</p>"},{"location":"API_References/NexusLayout_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusLayout applies the following hardware rules for memory performance:</p> <ul> <li>64-Byte Boundary Rule: Uses 64-byte boundaries, which are the most optimized addressing for the processor's MMU (Memory Management Unit).</li> <li>Aligned Allocation: By using <code>NativeMemory.AlignedAlloc</code>, it guarantees that the memory address obtained from the operating system is exactly a multiple of 64.</li> <li>Size Padding: If the size of a data structure is not an exact multiple of 64, it is rounded to the next safe boundary with the <code>GetAlignedSize</code> function.</li> <li>MMU Efficiency: The use of Page Aligned and Cache Aligned memory increases the processor's TLB (Translation Lookaside Buffer) hit rate.</li> </ul>"},{"location":"API_References/NexusLayout_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Calculation: The amount of required memory is taken.</li> <li>Alignment: Rounding is performed to the nearest multiple of 64 bytes with <code>GetAlignedSize</code>.</li> <li>Allocation: Hardware-supported aligned allocation is performed over <code>NativeMemory</code>.</li> <li>Freeing: Aligned memory is returned with a specific method (<code>AlignedFree</code>).</li> </ol>"},{"location":"API_References/NexusLayout_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Cache Line (64B) The amount of data the processor pulls from RAM in a single move. Memory Alignment The requirement that a data memory address must be a multiple of a certain number. Cache Line Split Performance loss resulting from a piece of data overflowing into two different cache lines. MMU The hardware unit that converts virtual memory addresses to physical RAM addresses."},{"location":"API_References/NexusLayout_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Memory Overhead: Aligning small data to 64 bytes causes \"Padding\" (gaps) in memory and therefore a certain increase in RAM usage. Memory is sacrificed for performance.</li> <li>Unaligned Access: If a manual allocation is made outside of <code>NexusLayout</code>, the processor may throw a \"Misaligned Access\" error or reduce performance by 50%.</li> </ul>"},{"location":"API_References/NexusLayout_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>// Calculate aligned size for an area of 100 bytes\nint rawSize = 100;\nint alignedSize = NexusLayout.GetAlignedSize(rawSize); // Returns 128\n\n// Allocate aligned memory\nunsafe {\n    void* ptr = NexusLayout.Alloc(alignedSize);\n    // ... Usage ...\n    NexusLayout.Free(ptr);\n}\n</code></pre>"},{"location":"API_References/NexusLayout_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Core;\n\npublic static class NexusLayout\n{\n    public const int CACHE_LINE_SIZE = 64;\n\n    public static int GetAlignedSize(int size)\n    {\n        return (size + CACHE_LINE_SIZE - 1) &amp; ~(CACHE_LINE_SIZE - 1);\n    }\n\n    public static unsafe void* Alloc(int size)\n    {\n        return NativeMemory.AlignedAlloc((nuint)size, CACHE_LINE_SIZE);\n    }\n\n    public static unsafe void Free(void* ptr)\n    {\n        if (ptr != null) NativeMemory.AlignedFree(ptr);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusLayout_eng/#nexus-optimization-tip-cache-boundary-safety","title":"Nexus Optimization Tip: Cache Boundary Safety","text":"<p>Using <code>NexusLayout</code> minimizes the time the processor takes to reach data on a clock cycle basis. While unaligned memory causes a \"Stall\" in the L1 cache, data allocated with <code>NexusLayout</code> flows through the processor pipeline without any hitch.</p>"},{"location":"API_References/NexusLayout_tr/","title":"Nexus Prime Mimari Rehberi: NexusLayout (Bellek Hizalama ve \u00d6nbellek Optimizasyonu)","text":""},{"location":"API_References/NexusLayout_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusLayout.cs</code>, Nexus Prime framework'\u00fcn\u00fcn donan\u0131m seviyesindeki hassasiyetini belirleyen en temel yard\u0131mc\u0131 s\u0131n\u0131ft\u0131r. Modern i\u015flemciler, bellekten veri okurken \"Cache Line\" denilen (genellikle 64 byte) bloklar halinde veri \u00e7ekerler.</p> <p>Bu s\u0131n\u0131f\u0131n varl\u0131k sebebi, t\u00fcm unmanaged bellek tahsisatlar\u0131n\u0131n (allocations) ve bile\u015fen dizimlerinin bu 64-byte s\u0131n\u0131rlar\u0131na tam uyumlu (aligned) olmas\u0131n\u0131 sa\u011flamakt\u0131r. Bu sayede, tek bir veriyi okumak i\u00e7in i\u015flemcinin gereksiz yere iki farkl\u0131 \u00f6nbellek sat\u0131r\u0131n\u0131 taramas\u0131n\u0131n (Cache Line Split) \u00f6n\u00fcne ge\u00e7ilir.</p>"},{"location":"API_References/NexusLayout_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusLayout, bellek performans\u0131 i\u00e7in \u015fu donan\u0131m kurallar\u0131n\u0131 uygular:</p> <ul> <li>64-Byte Boundary Rule: \u0130\u015flemci MMU (Memory Management Unit) i\u00e7in en optimize adresleme olan 64-byte s\u0131n\u0131rlar\u0131n\u0131 kullan\u0131r.</li> <li>Aligned Allocation: <code>NativeMemory.AlignedAlloc</code> kullanarak, i\u015fletim sisteminden al\u0131nan bellek adresinin tam olarak 64'\u00fcn kat\u0131 olmas\u0131n\u0131 garanti eder.</li> <li>Size Padding: Bir veri yap\u0131s\u0131n\u0131n boyutu 64'\u00fcn tam kat\u0131 de\u011filse, <code>GetAlignedSize</code> fonksiyonu ile bir sonraki g\u00fcvenli s\u0131n\u0131ra yuvarlan\u0131r.</li> <li>MMU Efficiency: Sayfa hizal\u0131 (Page Aligned) ve \u00d6nbellek hizal\u0131 (Cache Aligned) bellek kullan\u0131m\u0131, i\u015flemcinin TLB (Translation Lookaside Buffer) isabet oran\u0131n\u0131 art\u0131r\u0131r.</li> </ul>"},{"location":"API_References/NexusLayout_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Hesaplama: \u0130htiya\u00e7 duyulan bellek miktar\u0131 al\u0131n\u0131r.</li> <li>Hizalama: <code>GetAlignedSize</code> ile en yak\u0131n 64-byte kat\u0131na yuvarlama yap\u0131l\u0131r.</li> <li>Tahsisat: <code>NativeMemory</code> \u00fczerinden donan\u0131m destekli hizal\u0131 tahsisat ger\u00e7ekle\u015ftirilir.</li> <li>Serbest B\u0131rakma: Hizal\u0131 bellek \u00f6zel bir metodla (<code>AlignedFree</code>) iade edilir.</li> </ol>"},{"location":"API_References/NexusLayout_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Cache Line (64B) \u0130\u015flemcinin RAM'den tek bir hamlede \u00e7ekti\u011fi veri miktar\u0131. Memory Alignment Verinin bellek adresinin belirli bir say\u0131n\u0131n kat\u0131 olma zorunlulu\u011fu. Cache Line Split Bir verinin iki farkl\u0131 \u00f6nbellek sat\u0131r\u0131na ta\u015fmas\u0131 sonucu olu\u015fan performans kayb\u0131. MMU Sanal bellek adreslerini fiziksel RAM adreslerine d\u00f6n\u00fc\u015ft\u00fcren donan\u0131m birimi."},{"location":"API_References/NexusLayout_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Memory Overhead: K\u00fc\u00e7\u00fck verileri 64-byte hizalamak, bellekte \"Padding\" (bo\u015fluk) olu\u015fmas\u0131na ve dolay\u0131s\u0131yla RAM kullan\u0131m\u0131n\u0131n bir miktar artmas\u0131na sebep olur. Performans i\u00e7in bellekten feragat edilir.</li> <li>Unaligned Access: E\u011fer <code>NexusLayout</code> d\u0131\u015f\u0131nda manuel bir tahsisat yap\u0131l\u0131rsa, i\u015flemci \"Misaligned Access\" hatas\u0131 verebilir veya performans\u0131 %50 d\u00fc\u015f\u00fcrebilir.</li> </ul>"},{"location":"API_References/NexusLayout_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// 100 byte'l\u0131k bir alan i\u00e7in hizal\u0131 boyut hesapla\nint rawSize = 100;\nint alignedSize = NexusLayout.GetAlignedSize(rawSize); // 128 d\u00f6ner\n\n// Hizal\u0131 bellek tahsis et\nunsafe {\n    void* ptr = NexusLayout.Alloc(alignedSize);\n    // ... Kullan\u0131m ...\n    NexusLayout.Free(ptr);\n}\n</code></pre>"},{"location":"API_References/NexusLayout_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Core;\n\npublic static class NexusLayout\n{\n    public const int CACHE_LINE_SIZE = 64;\n\n    public static int GetAlignedSize(int size)\n    {\n        return (size + CACHE_LINE_SIZE - 1) &amp; ~(CACHE_LINE_SIZE - 1);\n    }\n\n    public static unsafe void* Alloc(int size)\n    {\n        return NativeMemory.AlignedAlloc((nuint)size, CACHE_LINE_SIZE);\n    }\n\n    public static unsafe void Free(void* ptr)\n    {\n        if (ptr != null) NativeMemory.AlignedFree(ptr);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusLayout_tr/#nexus-optimization-tip-cache-boundary-safety","title":"Nexus Optimization Tip: Cache Boundary Safety","text":"<p><code>NexusLayout</code> kullan\u0131m\u0131, i\u015flemcinin veriye ula\u015fma s\u00fcresini saat d\u00f6ng\u00fcs\u00fc (cycle) baz\u0131nda minimize eder. Hizalanmam\u0131\u015f bellek, L1 \u00f6nbelle\u011finde \"Stall\" olu\u015fmas\u0131na neden olurken, <code>NexusLayout</code> ile tahsis edilen veriler i\u015flemci boru hatt\u0131ndan (pipeline) hi\u00e7 tak\u0131lmadan akar.</p>"},{"location":"API_References/NexusLogger_eng/","title":"Nexus Prime Architectural Manual: NexusLogger (Smart Logging System)","text":""},{"location":"API_References/NexusLogger_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusLogger.cs</code> is the \"Black Box\" of the Nexus Prime framework. It does not only write text to the screen; it collects data, physics errors, and network packets coming from unmanaged systems in a thread-safe (thread-safe) way and distributes them to different channels (Console, File, UI).</p> <p>The reason for this log system's existence is to make Unity's standard <code>Debug.Log</code> system more powerful, filterable, and professional. It identifies logs visually with rich text (Rich Text) support.</p>"},{"location":"API_References/NexusLogger_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Offers the following architecture for high-performance logging:</p> <ul> <li>Multi-Sink Architecture: Thanks to the <code>INexusLogSink</code> interface, it can send logs not only to the console but also to a file, an in-game debug panel, or an analytics service at the same time.</li> <li>Thread-Safety: Equipped with the <code>lock(_lock)</code> mechanism. Prevents logs coming from within Nexus's parallel Job System from mixing with each other or crashing (Race Condition).</li> <li>Visual Categorization (Rich Text): Automatically colors logs according to the <code>LogLevel</code> (Success, Warning, Error, etc.) value (along with the <code>&lt;b&gt;[Nexus]&lt;/b&gt;</code> prefix).</li> <li>Unity Context Awareness: Thanks to the <code>context</code> parameter passed while writing the log, ensures that the relevant Unity object is automatically focused when the log in the console is clicked.</li> </ul>"},{"location":"API_References/NexusLogger_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Input: Any system makes the <code>NexusLogger.Log(\"Error occurred\", LogLevel.Error)</code> call.</li> <li>Distribution: The entire existing <code>Sink</code> (Target) pool is scanned and the message is transmitted to each one.</li> <li>Coloring: The appropriate HEX color code is selected according to the log level.</li> <li>Console Output: Colored and formatted output is sent to the Windows/Mac/Linux console.</li> </ol>"},{"location":"API_References/NexusLogger_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Log Sink Target reached by log messages finally (File, Screen, etc.). Rich Text Formatting texts with HTML-like tags (color, b, i). Contextual Logging Record containing info on which object the message is related to. Fallback Backup mechanism activated when the primary system does not work."},{"location":"API_References/NexusLogger_eng/#5-usage-example","title":"5. Usage Example","text":"<pre><code>// Success message\nNexusLogger.LogSuccess(this, \"Simulation loaded successfully.\");\n\n// Error message (Red)\nNexusLogger.LogError(this, \"Unmanaged memory overflow detected!\");\n\n// Add a custom receiver (Sink)\nNexusLogger.AddSink(new MyFileStoreSink());\n</code></pre>"},{"location":"API_References/NexusLogger_eng/#6-full-source-implementation-direct-implementation","title":"6. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Logging;\n\npublic static class NexusLogger\n{\n    private static readonly List&lt;INexusLogSink&gt; _sinks = new();\n    private static readonly object _lock = new();\n\n    public static void Log(object context, string message, LogLevel level) {\n        lock (_lock) {\n            foreach (var sink in _sinks) sink.Log(context, message, level);\n        }\n        // Unity Console output with rich text...\n        Debug.Log($\"&lt;b&gt;[Nexus]&lt;/b&gt; &lt;color=red&gt;{message}&lt;/color&gt;\");\n    }\n}\n</code></pre>"},{"location":"API_References/NexusLogger_eng/#nexus-optimization-tip-conditional-tracing","title":"Nexus Optimization Tip: Conditional Tracing","text":"<p>Use the <code>#if UNITY_EDITOR</code> or <code>[Conditional(\"DEBUG\")]</code> attribute to completely turn off logs that generate very intensive data like <code>LogLevel.Trace</code> during the production (Final Build) phase. This definitely prevents game performance from dropping due to logs.</p>"},{"location":"API_References/NexusLogger_tr/","title":"Nexus Prime Mimari Rehberi: NexusLogger (Zekice G\u00fcnl\u00fckleme Sistemi)","text":""},{"location":"API_References/NexusLogger_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusLogger.cs</code>, Nexus Prime framework'\u00fcn\u00fcn \"Kara Kutusu\"dur. Sadece ekrana yaz\u0131 basmakla kalmaz; unmanaged sistemlerden gelen verileri, fizik hatalar\u0131n\u0131 ve a\u011f paketlerini thread-safe (i\u015f par\u00e7ac\u0131\u011f\u0131 g\u00fcvenli) bir \u015fekilde toplar ve farkl\u0131 kanallara (Konsol, Dosya, UI) da\u011f\u0131t\u0131r.</p> <p>Bu log sisteminin varl\u0131k sebebi; Unity'nin standart <code>Debug.Log</code> sistemini daha g\u00fc\u00e7l\u00fc, filtrelenebilir ve profesyonel bir hale getirmektir. Zengin metin (Rich Text) deste\u011fi ile loglar\u0131 g\u00f6rsel olarak ayr\u0131\u015ft\u0131r\u0131r.</p>"},{"location":"API_References/NexusLogger_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Y\u00fcksek performansl\u0131 g\u00fcnl\u00fckleme i\u00e7in \u015fu mimariyi sunar:</p> <ul> <li>Multi-Sink Architecture: <code>INexusLogSink</code> aray\u00fcz\u00fc sayesinde loglar\u0131 sadece konsola de\u011fil, ayn\u0131 anda bir dosyaya, oyun i\u00e7i bir debug paneline veya bir analytics servisine g\u00f6nderebilir.</li> <li>Thread-Safety: <code>lock(_lock)</code> mekanizmas\u0131yla donat\u0131lm\u0131\u015ft\u0131r. Nexus'un paralel Job System'i i\u00e7inden gelen loglar\u0131n birbirine kar\u0131\u015fmas\u0131n\u0131 veya \u00e7\u00f6kmesini (Race Condition) \u00f6nler.</li> <li>Visual Categorization (Rich Text): <code>LogLevel</code> (Success, Warning, Error vb.) de\u011ferine g\u00f6re loglar\u0131 otomatik olarak renklendirir (<code>&lt;b&gt;[Nexus]&lt;/b&gt;</code> \u00f6n ekiyle birlikte).</li> <li>Unity Context Awareness: Log bas\u0131l\u0131rken ge\u00e7ilen <code>context</code> parametresi sayesinde, konsoldaki loga t\u0131kland\u0131\u011f\u0131nda ilgili Unity nesnesine otomatik odaklan\u0131lmas\u0131n\u0131 sa\u011flar.</li> </ul>"},{"location":"API_References/NexusLogger_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Girdi: Herhangi bir sistem <code>NexusLogger.Log(\"Hata olu\u015ftu\", LogLevel.Error)</code> \u00e7a\u011fr\u0131s\u0131n\u0131 yapar.</li> <li>Da\u011f\u0131t\u0131m: Mevcut t\u00fcm <code>Sink</code> (Al\u0131c\u0131) havuzu taran\u0131r ve mesaj her birine iletilir.</li> <li>Renklendirme: Log seviyesine g\u00f6re uygun HEX renk kodu se\u00e7ilir.</li> <li>Konsol \u00c7\u0131kt\u0131s\u0131: Windows/Mac/Linux konsoluna renkli ve bi\u00e7imlendirilmi\u015f \u00e7\u0131kt\u0131 g\u00f6nderilir.</li> </ol>"},{"location":"API_References/NexusLogger_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Log Sink Log mesajlar\u0131n\u0131n nihai olarak ula\u015ft\u0131\u011f\u0131 hedef (Dosya, Ekran vb.). Rich Text Metinlerin HTML benzeri etiketlerle (color, b, i) bi\u00e7imlendirilmesi. Contextual Logging Mesaj\u0131n hangi nesneyle ilgili oldu\u011funun bilgisini i\u00e7eren kay\u0131t. Fallback Birincil sistem \u00e7al\u0131\u015fmad\u0131\u011f\u0131nda devreye giren yedekleme mekanizmas\u0131."},{"location":"API_References/NexusLogger_tr/#5-kullanm-ornegi","title":"5. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Ba\u015far\u0131 mesaj\u0131\nNexusLogger.LogSuccess(this, \"Sim\u00fclasyon ba\u015far\u0131yla y\u00fcklendi.\");\n\n// Hata mesaj\u0131 (K\u0131rm\u0131z\u0131)\nNexusLogger.LogError(this, \"Unmanaged bellek ta\u015fmas\u0131 alg\u0131land\u0131!\");\n\n// \u00d6zel bir al\u0131c\u0131 (Sink) ekle\nNexusLogger.AddSink(new MyFileStoreSink());\n</code></pre>"},{"location":"API_References/NexusLogger_tr/#6-tam-kaynak-kod-direct-implementation","title":"6. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Logging;\n\npublic static class NexusLogger\n{\n    private static readonly List&lt;INexusLogSink&gt; _sinks = new();\n    private static readonly object _lock = new();\n\n    public static void Log(object context, string message, LogLevel level) {\n        lock (_lock) {\n            foreach (var sink in _sinks) sink.Log(context, message, level);\n        }\n        // Unity Console output with rich text...\n        Debug.Log($\"&lt;b&gt;[Nexus]&lt;/b&gt; &lt;color=red&gt;{message}&lt;/color&gt;\");\n    }\n}\n</code></pre>"},{"location":"API_References/NexusLogger_tr/#nexus-optimization-tip-conditional-tracing","title":"Nexus Optimization Tip: Conditional Tracing","text":"<p><code>LogLevel.Trace</code> gibi \u00e7ok yo\u011fun veri \u00fcreten loglar\u0131 prod\u00fcksiyon (Final Build) a\u015famas\u0131nda tamamen kapatmak i\u00e7in <code>#if UNITY_EDITOR</code> veya <code>[Conditional(\"DEBUG\")]</code> \u00f6zniteli\u011fini kullan\u0131n. Bu, oyun performans\u0131n\u0131n loglar y\u00fcz\u00fcnden d\u00fc\u015fmesini kesin olarak engeller.</p>"},{"location":"API_References/NexusMath_eng/","title":"Nexus Prime Architectural Manual: NexusMath (Hardware-Accelerated Math)","text":""},{"location":"API_References/NexusMath_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusMath.cs</code> is the engine behind Nexus Prime's computing power. Unlike standard math libraries, it uses the SIMD (Single Instruction, Multiple Data) capabilities of modern processors directly, allowing operations on multiple data pieces within a single clock cycle.</p> <p>The reason for this library's existence is to eliminate CPU bottlenecks in scenarios requiring intensive data processing (high-throughput) such as physics simulations, particle systems, or artificial intelligence and to approach the theoretical limits of the hardware.</p>"},{"location":"API_References/NexusMath_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusMath follows a three-layered execution strategy for performance:</p> <ul> <li>AVX (Advanced Vector Extensions): If the processor supports it (modern x86), it loads data into 256-bit wide registers. This way, it adds or multiplies 8 float numbers with a single command.</li> <li>SSE (Streaming SIMD Extensions): Performs operations in groups of 4 using 128-bit registers on older processors without AVX.</li> <li>Scalar Fallback: If the data amount is not a multiple of 4 or 8, it returns to the standard single operation loop for the remaining elements.</li> <li>Aggressive Inlining: Methods are marked with <code>[MethodImpl(MethodImplOptions.AggressiveInlining)]</code>. This buries the code directly where it is called, reducing method call cost (stack frame overhead) to zero.</li> </ul>"},{"location":"API_References/NexusMath_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Hardware Detection: CPU capabilities are detected with <code>Avx.IsSupported</code> or <code>Sse.IsSupported</code> checks.</li> <li>Vectorization: Pulled from memory into registers in blocks of 8 (AVX) or 4 (SSE) via data pointers.</li> <li>Accelerated Operation: Parallel mathematical operation is executed at the hardware level.</li> <li>Write to Memory: Results are dumped back to the target memory address (<code>float*</code>).</li> </ol>"},{"location":"API_References/NexusMath_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description SIMD Technique of parallel processing of multiple data with a single command. AVX-256 256-bit wide processor register set with 8-float capacity. Fast Inverse Sqrt A very fast algorithm that calculates the inverse of the square root (<code>1/\u221ax</code>) using a \"magic\" constant at bit level. Vectorization The process of parallelizing (vectorizing) a serial process."},{"location":"API_References/NexusMath_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Alignment Requirement: For best performance in AVX operations, memory addresses must be 32-byte aligned. Nexus Prime guarantees this with <code>NexusLayout</code>.</li> <li>Precision: Approximate functions like <code>FastInverseSqrt</code> are not suitable for financial calculations requiring 100% precision; they are designed for game mechanics.</li> </ul>"},{"location":"API_References/NexusMath_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>// Add two massive float arrays with SIMD\nunsafe {\n    float* a = stackalloc float[1024];\n    float* b = stackalloc float[1024];\n    float* result = stackalloc float[1024];\n\n    NexusMath.Add(a, b, result, 1024); // Added in blocks of 8 (AVX)\n}\n\n// Fast interpolation\nfloat smoothVal = NexusMath.FastSmoothStep(0, 1, 0.5f);\n</code></pre>"},{"location":"API_References/NexusMath_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>public static unsafe class NexusMath\n{\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void Add(float* a, float* b, float* result, int count)\n    {\n        int i = 0;\n        if (Avx.IsSupported)\n        {\n            for (; i &lt;= count - 8; i += 8) {\n                var va = Avx.LoadVector256(a + i);\n                var vb = Avx.LoadVector256(b + i);\n                Avx.Store(result + i, Avx.Add(va, vb));\n            }\n        }\n        // Fallback loops...\n    }\n}\n</code></pre>"},{"location":"API_References/NexusMath_eng/#nexus-optimization-tip-instruction-pipelining","title":"Nexus Optimization Tip: Instruction Pipelining","text":"<p>To get the highest efficiency from SIMD operations, keep your data in \"Sequential\" memory blocks. In case of scattered memory (Cache Miss), the processor has to wait to fill SIMD registers. Sequential data alignment will increase SIMD throughput by 300-400%.</p>"},{"location":"API_References/NexusMath_tr/","title":"Nexus Prime Mimari Rehberi: NexusMath (Donan\u0131m H\u0131zland\u0131rmal\u0131 Matematik)","text":""},{"location":"API_References/NexusMath_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusMath.cs</code>, Nexus Prime'\u0131n hesaplama g\u00fcc\u00fcn\u00fcn arkas\u0131ndaki motorudur. Standart matematik k\u00fct\u00fcphanelerinin aksine, modern i\u015flemcilerin SIMD (Single Instruction, Multiple Data) yeteneklerini do\u011frudan kullanarak, tek bir saat d\u00f6ng\u00fcs\u00fcnde birden fazla veri \u00fczerinde i\u015flem yapabilmeyi sa\u011flar.</p> <p>Bu k\u00fct\u00fcphanenin varl\u0131k sebebi; fizik sim\u00fclasyonlar\u0131, partik\u00fcl sistemleri veya yapay zeka gibi yo\u011fun veri i\u015fleme (high-throughput) gerektiren senaryolarda CPU darbo\u011faz\u0131n\u0131 ortadan kald\u0131rmak ve donan\u0131m\u0131n teorik limitlerine yakla\u015fmakt\u0131r.</p>"},{"location":"API_References/NexusMath_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusMath, performans i\u00e7in \u00fc\u00e7 katmanl\u0131 bir y\u00fcr\u00fct\u00fcm stratejisi izler:</p> <ul> <li>AVX (Advanced Vector Extensions): \u0130\u015flemci destekliyorsa (modern x86), verileri 256-bit geni\u015fli\u011findeki register'lara y\u00fckler. Bu sayede 8 adet float say\u0131y\u0131 tek bir komutla toplar veya \u00e7arpar.</li> <li>SSE (Streaming SIMD Extensions): AVX'in olmad\u0131\u011f\u0131 daha eski i\u015flemcilerde 128-bit register'lar\u0131 kullanarak 4'l\u00fc gruplar halinde i\u015flem yapar.</li> <li>Scalar Fallback: E\u011fer veri miktar\u0131 4 veya 8'in kat\u0131 de\u011filse, kalan elemanlar i\u00e7in standart tekli i\u015flem d\u00f6ng\u00fcs\u00fcne d\u00f6ner.</li> <li>Aggressive Inlining: Metodlar <code>[MethodImpl(MethodImplOptions.AggressiveInlining)]</code> ile i\u015faretlenmi\u015ftir. Bu, metod \u00e7a\u011fr\u0131s\u0131 maliyetini (stack frame overhead) s\u0131f\u0131ra indirerek kodu do\u011frudan \u00e7a\u011fr\u0131ld\u0131\u011f\u0131 yere g\u00f6mer.</li> </ul>"},{"location":"API_References/NexusMath_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Donan\u0131m Alg\u0131lama: <code>Avx.IsSupported</code> veya <code>Sse.IsSupported</code> kontrolleriyle CPU yetenekleri saptan\u0131r.</li> <li>Vekt\u00f6rizasyon: Veri pointerlar\u0131 \u00fczerinden 8'li (AVX) veya 4'l\u00fc (SSE) bloklar halinde bellekten register'lara \u00e7ekilir.</li> <li>H\u0131zland\u0131r\u0131lm\u0131\u015f \u0130\u015flem: Donan\u0131m seviyesinde paralel matematiksel i\u015flem y\u00fcr\u00fct\u00fcl\u00fcr.</li> <li>Belle\u011fe Yaz\u0131m: Sonu\u00e7lar tekrar hedef bellek adresine (<code>float*</code>) bo\u015falt\u0131l\u0131r.</li> </ol>"},{"location":"API_References/NexusMath_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama SIMD Tek bir komutla birden fazla veriyi paralel i\u015fleme tekni\u011fi. AVX-256 256 bit geni\u015fli\u011finde, 8 float kapasiteli i\u015flemci register seti. Fast Inverse Sqrt Karek\u00f6k\u00fcn tersini (<code>1/\u221ax</code>) bit seviyesinde \"sihirli\" bir sabit kullanarak hesaplayan \u00e7ok h\u0131zl\u0131 algoritma. Vectorization Seri bir i\u015flemin paralel (vekt\u00f6rel) hale getirilmesi s\u00fcreci."},{"location":"API_References/NexusMath_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Alignment Requirement: AVX i\u015flemlerinde en iyi performans i\u00e7in bellek adreslerinin 32-byte hizal\u0131 (aligned) olmas\u0131 gerekir. Nexus Prime <code>NexusLayout</code> ile bunu garanti eder.</li> <li>Precision: <code>FastInverseSqrt</code> gibi yakla\u015f\u0131ksal (approximate) fonksiyonlar, %100 kesinlik gerektiren finansal hesaplamalar i\u00e7in uygun de\u011fildir; oyun mekanikleri i\u00e7in tasarlanm\u0131\u015ft\u0131r.</li> </ul>"},{"location":"API_References/NexusMath_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// \u0130ki devasa float dizisini SIMD ile topla\nunsafe {\n    float* a = stackalloc float[1024];\n    float* b = stackalloc float[1024];\n    float* result = stackalloc float[1024];\n\n    NexusMath.Add(a, b, result, 1024); // 8'li bloklar halinde toplan\u0131r (AVX)\n}\n\n// H\u0131zl\u0131 interpolasyon\nfloat smoothVal = NexusMath.FastSmoothStep(0, 1, 0.5f);\n</code></pre>"},{"location":"API_References/NexusMath_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>public static unsafe class NexusMath\n{\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void Add(float* a, float* b, float* result, int count)\n    {\n        int i = 0;\n        if (Avx.IsSupported)\n        {\n            for (; i &lt;= count - 8; i += 8) {\n                var va = Avx.LoadVector256(a + i);\n                var vb = Avx.LoadVector256(b + i);\n                Avx.Store(result + i, Avx.Add(va, vb));\n            }\n        }\n        // Fallback loops...\n    }\n}\n</code></pre>"},{"location":"API_References/NexusMath_tr/#nexus-optimization-tip-instruction-pipelining","title":"Nexus Optimization Tip: Instruction Pipelining","text":"<p>SIMD operasyonlar\u0131ndan en y\u00fcksek verimi almak i\u00e7in verilerinizi \"Sequential\" (ard\u0131\u015f\u0131k) bellek bloklar\u0131nda tutun. Da\u011f\u0131n\u0131k bellek (Cache Miss) durumunda, i\u015flemci SIMD register'lar\u0131n\u0131 doldurmak i\u00e7in beklemek zorunda kal\u0131r. Ard\u0131\u015f\u0131k veri dizilimi, SIMD throughput'unu %300-400 oran\u0131nda art\u0131racakt\u0131r.</p>"},{"location":"API_References/NexusMemoryHeatmap_eng/","title":"Nexus Prime Architectural Manual: NexusMemoryHeatmap (Memory Heatmap)","text":""},{"location":"API_References/NexusMemoryHeatmap_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusMemoryHeatmap.cs</code> is an optimization tool presenting Entity and component density in the game world as a visual \"Temperature Map\" (Thermal Overlay). It identifies which regions cause RAM-based bottlenecks (bottleneck) within seconds.</p> <p>The reason for this tool's existence is to give the developer the signal \"This area is too dense, you should optimize\" by visualizing situations where thousands of objects are gathered (\"Hot areas\") and the processor cache (Cache) is insufficient.</p>"},{"location":"API_References/NexusMemoryHeatmap_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The heatmap works with the following basic principles:</p> <ul> <li>Density Mapping: Divides the world area into grids and calculates the number of Entities/Components within each grid.</li> <li>Color Gradients: Marks low-density areas as Blue (Cold) and heaps at dangerous levels as Red (Hot).</li> <li>Cache Bottleneck Prediction: Red areas are usually regions where the risk of \"Cache Miss\" (processor unable to find the data) is highest.</li> <li>Toggle Visualizer: Offered as a transparent layer (Overlay) that can be turned on and off with a single click in the Editor scene view.</li> </ul>"},{"location":"API_References/NexusMemoryHeatmap_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Data Collection: World coordinates of all assets are taken by scanning the ECS Registry.</li> <li>Grid Analysis: Coordinates are reflected on a 2D or 3D memory map.</li> <li>Coloring: The density data of each region is subjected to a predefined color gradient (<code>Gradient</code>).</li> <li>Overlay Drawing: Results are drawn as a texture (Texture) or Gizmo community over the Editor's scene camera.</li> </ol>"},{"location":"API_References/NexusMemoryHeatmap_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Diagnosing a performance problem:\n// 1. [Nexus/Memory Heatmap] is opened.\n// 2. The \"Toggle Visualizer\" button is pressed.\n// 3. The forest region in the scene is seen as deep red.\n// Analysis: Tree components in the forest are very dense, LOD system or ECS Chunking should be commissioned.\n</code></pre>"},{"location":"API_References/NexusMemoryHeatmap_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class NexusMemoryHeatmap : EditorWindow\n{\n    [MenuItem(\"Nexus/Memory Heatmap\")]\n    public static void ShowWindow() =&gt; GetWindow&lt;NexusMemoryHeatmap&gt;(\"Memory Heatmap\");\n\n    private void OnGUI() {\n        GUILayout.Label(\"Entity &amp; RAM Density Heatmap\", EditorStyles.boldLabel);\n        if (GUILayout.Button(\"Toggle Visualizer\")) {\n            // Iterate all entities, calculate density, draw overlay...\n        }\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusMemoryHeatmap_eng/#nexus-optimization-tip-data-locality","title":"Nexus Optimization Tip: Data Locality","text":"<p>When you detect a red region in the heatmap, check the <code>Memory Layout</code> of the components in that region. If the data is scattered in memory, arrange the data side by side using <code>UnmanagedCollection</code>. This process can increase processor speed in red regions by up to 200%.</p>"},{"location":"API_References/NexusMemoryHeatmap_tr/","title":"Nexus Prime Mimari Rehberi: NexusMemoryHeatmap (Bellek Is\u0131 Haritas\u0131)","text":""},{"location":"API_References/NexusMemoryHeatmap_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusMemoryHeatmap.cs</code>, oyun d\u00fcnyas\u0131ndaki Entity ve bile\u015fen yo\u011funlu\u011funu g\u00f6rsel bir \"S\u0131cakl\u0131k Haritas\u0131\" (Thermal Overlay) olarak sunan bir optimizasyon arac\u0131d\u0131r. Hangi b\u00f6lgelerin RAM bazl\u0131 darbo\u011fazlara (bottleneck) sebep oldu\u011funu saniyeler i\u00e7inde tespit eder.</p> <p>Bu arac\u0131n varl\u0131k sebebi; binlerce nesnenin bir araya topland\u0131\u011f\u0131 (\"Hot areas\") ve i\u015flemci \u00f6nbelle\u011finin (Cache) yetersiz kald\u0131\u011f\u0131 durumlar\u0131 g\u00f6rselle\u015ftirerek geli\u015ftiriciye \"Buras\u0131 \u00e7ok yo\u011fun, optimize etmelisin\" sinyali vermektir.</p>"},{"location":"API_References/NexusMemoryHeatmap_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Is\u0131 haritas\u0131 \u015fu temel prensiplerle \u00e7al\u0131\u015f\u0131r:</p> <ul> <li>Density Mapping: D\u00fcnya alan\u0131n\u0131 grid'lere b\u00f6ler ve her grid i\u00e7indeki Entity/Bile\u015fen say\u0131s\u0131n\u0131 hesaplar.</li> <li>Color Gradients: D\u00fc\u015f\u00fck yo\u011funluklu alanlar\u0131 Mavi (So\u011fuk), tehlikeli seviyedeki y\u0131\u011f\u0131nlar\u0131 K\u0131rm\u0131z\u0131 (S\u0131cak) olarak i\u015faretler.</li> <li>Cache Bottleneck Prediction: K\u0131rm\u0131z\u0131 alanlar genellikle \"Cache Miss\" (i\u015flemcinin veriyi bulamamas\u0131) riskinin en y\u00fcksek oldu\u011fu b\u00f6lgelerdir.</li> <li>Toggle Visualizer: Edit\u00f6r sahne g\u00f6r\u00fcn\u00fcm\u00fcnde tek tu\u015fla a\u00e7\u0131l\u0131p kapat\u0131labilen \u015feffaf bir katman (Overlay) olarak sunulur.</li> </ul>"},{"location":"API_References/NexusMemoryHeatmap_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Veri Toplama: ECS Registry taranarak t\u00fcm varl\u0131klar\u0131n d\u00fcnya koordinatlar\u0131 al\u0131n\u0131r.</li> <li>Grid Analizi: Koordinatlar 2D veya 3D bir bellek haritas\u0131na yans\u0131t\u0131l\u0131r.</li> <li>Renklendirme: Her b\u00f6lgenin yo\u011funluk verisi, \u00f6nceden tan\u0131mlanm\u0131\u015f bir renk gradyan\u0131na (<code>Gradient</code>) tabi tutulur.</li> <li>Overlay \u00c7izimi: Sonu\u00e7lar Edit\u00f6r'\u00fcn sahne kameras\u0131n\u0131n \u00fczerine bir doku (Texture) veya Gizmo toplulu\u011fu olarak \u00e7izilir.</li> </ol>"},{"location":"API_References/NexusMemoryHeatmap_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Performans sorununu te\u015fhis etmek:\n// 1. [Nexus/Memory Heatmap] a\u00e7\u0131l\u0131r.\n// 2. \"Toggle Visualizer\" butonuna bas\u0131l\u0131r.\n// 3. Sahnede orman b\u00f6lgesinin k\u0131pk\u0131rm\u0131z\u0131 oldu\u011fu g\u00f6r\u00fcl\u00fcr.\n// Analiz: Ormandaki a\u011fa\u00e7 bile\u015fenleri \u00e7ok yo\u011fun, LOD sistemi veya ECS Chunking devreye al\u0131nmal\u0131.\n</code></pre>"},{"location":"API_References/NexusMemoryHeatmap_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class NexusMemoryHeatmap : EditorWindow\n{\n    [MenuItem(\"Nexus/Memory Heatmap\")]\n    public static void ShowWindow() =&gt; GetWindow&lt;NexusMemoryHeatmap&gt;(\"Memory Heatmap\");\n\n    private void OnGUI() {\n        GUILayout.Label(\"Entity &amp; RAM Density Heatmap\", EditorStyles.boldLabel);\n        if (GUILayout.Button(\"Toggle Visualizer\")) {\n            // Iterate all entities, calculate density, draw overlay...\n        }\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusMemoryHeatmap_tr/#nexus-optimization-tip-data-locality","title":"Nexus Optimization Tip: Data Locality","text":"<p>Is\u0131 haritas\u0131nda k\u0131rm\u0131z\u0131 bir b\u00f6lge saptad\u0131\u011f\u0131n\u0131zda, o b\u00f6lgedeki bile\u015fenlerin <code>Memory Layout</code>'unu kontrol edin. E\u011fer veriler bellekte da\u011f\u0131n\u0131ksa, <code>UnmanagedCollection</code> kullanarak verileri yan yana dizin. Bu i\u015flem, k\u0131rm\u0131z\u0131 b\u00f6lgelerdeki i\u015flemci h\u0131z\u0131n\u0131 %200'e kadar art\u0131rabilir.</p>"},{"location":"API_References/NexusMemoryManager_eng/","title":"Nexus Prime Architectural Manual: NexusMemoryManager (Hardware Level Memory Management)","text":""},{"location":"API_References/NexusMemoryManager_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusMemoryManager.cs</code> is the foundation of Nexus Prime's \"hardware-aware\" operations. It solves the problems of \"Memory Fragmentation\" and \"Misalignment\"\u2014the biggest enemies of performance in modern game engines\u2014by performing memory allocations in full compliance with the operating system and processor architecture.</p> <p>The reason for this manager's existence is to arrange data on the RAM not randomly, but in a way that best fits the CPU's L1/L2 Cache and MMU (Memory Management Unit) architecture. Thanks to this alignment, the processor does not spend extra clock cycles reaching data and reads data in a \"single move\".</p>"},{"location":"API_References/NexusMemoryManager_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusMemoryManager implements the following critical standards for unmanaged memory performance:</p> <ul> <li>Page-Aligned Allocation (4KB): Memory blocks are allocated in full compliance with 4096-byte system pages. This prevents the MMU from experiencing cache-misses when translating virtual addresses to physical addresses.</li> <li>Cache-Line Alignment (64B): All component data is aligned to 64 bytes, the size of a CPU cache line. This fundamentally solves the False Sharing problem (where two cores try to write to the same cache line).</li> <li>Aggressive Inlining: All methods are marked with <code>[MethodImpl(MethodImplOptions.AggressiveInlining)]</code>. This reduces the method call cost to zero, ensuring the code is embedded directly into where it is called.</li> <li>Zero-GC Operations: The system operates entirely outside the .NET Garbage Collector (GC) using the <code>NativeMemory</code> API.</li> </ul>"},{"location":"API_References/NexusMemoryManager_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Allocation: When <code>AllocPageAligned</code> is called, an address that is an exact multiple of 4KB is requested from the OS.</li> <li>Alignment: 64-byte aligned blocks are reserved for components with <code>AllocCacheAligned</code>.</li> <li>Fast Copying: The <code>Copy</code> and <code>Clear</code> methods perform block operations using the processor's fastest copying instructions (SIMD-based).</li> <li>Safe Evacuation: Aligned memory blocks allocated with the <code>Free</code> method are returned to the OS.</li> </ol>"},{"location":"API_References/NexusMemoryManager_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description MMU The hardware unit that manages memory addresses and performs virtual-physical translation. Page Alignment Memory starting from 4096-byte (one page) boundaries. Cache-Line The smallest block of data the CPU reads from memory at once (usually 64 bytes). Inlining An optimization that copies a method's code directly into the calling site instead of calling the method."},{"location":"API_References/NexusMemoryManager_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Memory Corruption: Unmanaged memory management is not safe. Writing to incorrect addresses will cause the program to crash immediately.</li> <li>External Dependencies: The <code>NativeMemory</code> API requires .NET 6+. It is not compatible with older .NET versions.</li> </ul>"},{"location":"API_References/NexusMemoryManager_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>// Grab 1024-byte aligned memory\nvoid* ptr = NexusMemoryManager.AllocCacheAligned(1024);\n\n// Zero the memory (High-speed)\nNexusMemoryManager.Clear(ptr, 1024);\n\n// ... perform operation ...\n\n// Return memory\nNexusMemoryManager.Free(ptr);\n</code></pre>"},{"location":"API_References/NexusMemoryManager_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>using System.Runtime.InteropServices;\nusing System.Runtime.CompilerServices;\nnamespace Nexus.Core;\n\npublic static unsafe class NexusMemoryManager\n{\n    public const int PAGE_SIZE = 4096;\n    public const int CACHE_LINE = 64;\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void* AllocPageAligned(int size)\n    {\n        void* ptr = NativeMemory.AlignedAlloc((nuint)size, PAGE_SIZE);\n        if (ptr == null) throw new OutOfMemoryException();\n        return ptr;\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void* AllocCacheAligned(int size)\n    {\n        return NativeMemory.AlignedAlloc((nuint)size, CACHE_LINE);\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void Free(void* ptr)\n    {\n        if (ptr != null) NativeMemory.AlignedFree(ptr);\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void Clear(void* ptr, int size)\n    {\n        NativeMemory.Clear(ptr, (nuint)size);\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void Copy(void* source, void* destination, int size)\n    {\n        NativeMemory.Copy(source, destination, (nuint)size);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusMemoryManager_eng/#nexus-optimization-tip-mmu-thrashing-prevention","title":"Nexus Optimization Tip: MMU Thrashing Prevention","text":"<p>Unaligned memory access causes the CPU to look at two different memory pages to read a single datum and perform extra \"translation\" operations on the MMU. Using NexusMemoryManager eliminates this unnecessary cost, increasing raw memory access speed by 25% - 40%.</p>"},{"location":"API_References/NexusMemoryManager_tr/","title":"Nexus Prime Mimari Rehberi: NexusMemoryManager (Donan\u0131m Seviyesi Bellek Y\u00f6netimi)","text":""},{"location":"API_References/NexusMemoryManager_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusMemoryManager.cs</code>, Nexus Prime'\u0131n \"donan\u0131m fark\u0131ndal\u0131kl\u0131\" (hardware-aware) operasyonlar\u0131n\u0131n temelidir. Modern oyun motorlar\u0131nda performans\u0131n en b\u00fcy\u00fck d\u00fc\u015fman\u0131 olan \"Bellek Par\u00e7alanmas\u0131\" ve \"Yanl\u0131\u015f Hizalama\" (Misalignment) sorunlar\u0131n\u0131, i\u015fletim sistemi ve i\u015flemci mimarisine tam uyumlu bellek tahsisat\u0131 yaparak \u00e7\u00f6zer.</p> <p>Bu y\u00f6neticinin varl\u0131k sebebi, verileri RAM \u00fczerinde rastgele de\u011fil, CPU'nun L1/L2 Cache ve MMU (Memory Management Unit) mimarisine en uygun \u015fekilde dizmektir. Bu hizalama sayesinde, i\u015flemci veriye eri\u015firken fazladan saat d\u00f6ng\u00fcs\u00fc (cycle) harcamaz ve veriyi \"tek hamlede\" okur.</p>"},{"location":"API_References/NexusMemoryManager_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusMemoryManager, unmanaged bellek performans\u0131 i\u00e7in \u015fu kritik standartlar\u0131 uygular:</p> <ul> <li>Page-Aligned Allocation (4KB): Bellek bloklar\u0131 4096 bytel\u0131k sistem sayfalar\u0131na tam uyumlu tahsis edilir. Bu, MMU'nun sanal adresleri fiziksel adreslere \u00e7evirirken cache-miss ya\u015famas\u0131n\u0131 engeller.</li> <li>Cache-Line Alignment (64B): T\u00fcm bile\u015fen verileri CPU \u00f6nbellek sat\u0131r\u0131 boyutu olan 64 byte'a hizalan\u0131r. Bu, False Sharing (iki \u00e7ekirde\u011fin ayn\u0131 cache sat\u0131r\u0131na yazmaya \u00e7al\u0131\u015fmas\u0131) sorununu k\u00f6kten \u00e7\u00f6zer.</li> <li>Aggressive Inlining: T\u00fcm metodlar <code>[MethodImpl(MethodImplOptions.AggressiveInlining)]</code> ile i\u015faretlenmi\u015ftir. Bu, metod \u00e7a\u011fr\u0131s\u0131 maliyetini s\u0131f\u0131ra indirerek kodun do\u011frudan \u00e7a\u011fr\u0131ld\u0131\u011f\u0131 yere g\u00f6m\u00fclmesini sa\u011flar.</li> <li>Zero-GC Operations: Sistem <code>NativeMemory</code> API'sini kullanarak tamamen .NET Garbarage Collector'\u0131n (GC) d\u0131\u015f\u0131nda \u00e7al\u0131\u015f\u0131r.</li> </ul>"},{"location":"API_References/NexusMemoryManager_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tahsisat: <code>AllocPageAligned</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, i\u015fletim sisteminden 4KB'\u0131n tam kat\u0131 olan bir adres istenir.</li> <li>Hizalama: <code>AllocCacheAligned</code> ile bile\u015fenler i\u00e7in 64 bytel\u0131k hizal\u0131 bloklar ayr\u0131l\u0131r.</li> <li>H\u0131zl\u0131 Kopyalama: <code>Copy</code> ve <code>Clear</code> metodlar\u0131, i\u015flemcinin en h\u0131zl\u0131 kopyalama komutlar\u0131n\u0131 (SIMD tabanl\u0131) kullanarak blok i\u015flemleri yapar.</li> <li>G\u00fcvenli Tahliye: <code>Free</code> metodu ile ayr\u0131lan hizalanm\u0131\u015f bellek bloklar\u0131 i\u015fletim sistemine geri iade edilir.</li> </ol>"},{"location":"API_References/NexusMemoryManager_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama MMU Bellek adreslerini y\u00f6neten ve sanal-fiziksel d\u00f6n\u00fc\u015f\u00fcm\u00fcn\u00fc yapan donan\u0131m birimi. Page Alignment Belle\u011fin 4096 bytel\u0131k (bir sayfa) s\u0131n\u0131rlar\u0131ndan ba\u015flamas\u0131. Cache-Line CPU'nun bellekten bir seferde okudu\u011fu en k\u00fc\u00e7\u00fck veri blo\u011fu (Genellikle 64 byte). Inlining Bir metodun \u00e7a\u011fr\u0131lmak yerine, kodunun do\u011frudan \u00e7a\u011f\u0131ran yere kopyalanmas\u0131 optimizasyonu."},{"location":"API_References/NexusMemoryManager_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Memory Corruption: Unmanaged bellek y\u00f6netimi g\u00fcvenli (safe) de\u011fildir. Hatal\u0131 adreslere yaz\u0131m yapmak program\u0131n an\u0131nda \u00e7\u00f6kmesine sebep olur.</li> <li>External Dependencies: <code>NativeMemory</code> API'si .NET 6+ gerektirir. Eski .NET s\u00fcr\u00fcmleriyle uyumlu de\u011fildir.</li> </ul>"},{"location":"API_References/NexusMemoryManager_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// 1024 byte hizal\u0131 bellek al\nvoid* ptr = NexusMemoryManager.AllocCacheAligned(1024);\n\n// Belle\u011fi s\u0131f\u0131rla (High-speed)\nNexusMemoryManager.Clear(ptr, 1024);\n\n// ... i\u015flem yap ...\n\n// Belle\u011fi iade et\nNexusMemoryManager.Free(ptr);\n</code></pre>"},{"location":"API_References/NexusMemoryManager_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>using System.Runtime.InteropServices;\nusing System.Runtime.CompilerServices;\nnamespace Nexus.Core;\n\npublic static unsafe class NexusMemoryManager\n{\n    public const int PAGE_SIZE = 4096;\n    public const int CACHE_LINE = 64;\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void* AllocPageAligned(int size)\n    {\n        void* ptr = NativeMemory.AlignedAlloc((nuint)size, PAGE_SIZE);\n        if (ptr == null) throw new OutOfMemoryException();\n        return ptr;\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void* AllocCacheAligned(int size)\n    {\n        return NativeMemory.AlignedAlloc((nuint)size, CACHE_LINE);\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void Free(void* ptr)\n    {\n        if (ptr != null) NativeMemory.AlignedFree(ptr);\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void Clear(void* ptr, int size)\n    {\n        NativeMemory.Clear(ptr, (nuint)size);\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void Copy(void* source, void* destination, int size)\n    {\n        NativeMemory.Copy(source, destination, (nuint)size);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusMemoryManager_tr/#nexus-optimization-tip-mmu-thrashing-prevention","title":"Nexus Optimization Tip: MMU Thrashing Prevention","text":"<p>Hizalanmam\u0131\u015f bellek eri\u015fimi, CPU'nun bir veriyi okumak i\u00e7in iki farkl\u0131 bellek sayfas\u0131na bakmas\u0131na ve MMU \u00fczerinde fazladan \"Translation\" i\u015flemi yapmas\u0131na neden olur. NexusMemoryManager kullan\u0131m\u0131, bu gereksiz maliyeti ortadan kald\u0131rarak ham bellek eri\u015fim h\u0131z\u0131n\u0131 %25 - %40 oran\u0131nda art\u0131r\u0131r.</p>"},{"location":"API_References/NexusMinMax_eng/","title":"Nexus Prime Architectural Manual: NexusMinMax (Range Management)","text":""},{"location":"API_References/NexusMinMax_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusMinMax.cs</code> is a generic and unmanaged data structure that provides management of numerical values within a certain lower and upper bound. It adapts the \"Range\" (Range) logic, one of the most frequently used patterns in game development, to Nexus Prime's high-performance ECS architecture.</p> <p>The reason for this structure's existence is to store variables such as bullet speed, enemy health, or visual effect sizes not just as two numbers, but as an intelligent unit on which <code>Clamp</code>, <code>Lerp</code>, and <code>Random</code> operations can be performed.</p>"},{"location":"API_References/NexusMinMax_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusMinMax offers the following features for flexibility and performance:</p> <ul> <li>Generic Constraints: Works within type safety (type safety) with all basic number types such as <code>int</code> and <code>float</code> thanks to its <code>unmanaged</code> and <code>IComparable&lt;T&gt;</code> constraints.</li> <li>Zero-Allocation Logic: All operations take place on the stack or within unmanaged memory; it creates no load for the garbage collector (GC).</li> <li>Method Inlining: <code>IsInRange</code> and <code>Clamp</code> methods are marked with <code>AggressiveInlining</code>, which eliminates the cost of method calls at the processor level.</li> <li>Randomization Extensions: Working integrated with Unity's <code>Random</code> library, it allows generating random values in the determined range in a single line.</li> </ul>"},{"location":"API_References/NexusMinMax_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Definition: Defined as <code>NexusMinMax&lt;float&gt; DamageRange</code> within a component.</li> <li>Constraint: An incoming value is immediately pulled into the safe range with the <code>range.Clamp(input)</code> method.</li> <li>Verification: Whether a value is within determined limits is checked with <code>IsInRange</code> at O(1) cost.</li> <li>Application: The value corresponding to a percentage (e.g., 50%) within the range is calculated with the <code>Lerp</code> method.</li> </ol>"},{"location":"API_References/NexusMinMax_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>public struct WeaponComponent {\n    public NexusMinMax&lt;float&gt; FireRate;\n}\n\n// Usage\nvar weapon = new WeaponComponent();\nweapon.FireRate = new NexusMinMax&lt;float&gt;(0.1f, 0.5f);\n\nfloat currentRate = weapon.FireRate.Random(); // random between 0.1 and 0.5\nbool isSafe = weapon.FireRate.IsInRange(0.3f); // true\n</code></pre>"},{"location":"API_References/NexusMinMax_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Data;\n\npublic struct NexusMinMax&lt;T&gt; where T : unmanaged, IComparable&lt;T&gt;\n{\n    public T Min;\n    public T Max;\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public bool IsInRange(T value) =&gt; value.CompareTo(Min) &gt;= 0 &amp;&amp; value.CompareTo(Max) &lt;= 0;\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public T Clamp(T value) {\n        if (value.CompareTo(Min) &lt; 0) return Min;\n        if (value.CompareTo(Max) &gt; 0) return Max;\n        return value;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusMinMax_eng/#nexus-optimization-tip-predictive-clamping","title":"Nexus Optimization Tip: Predictive Clamping","text":"<p>In frequently updated systems (e.g., Physics/AI), use the <code>NexusMinMax.Clamp</code> method instead of checking values with manual <code>if</code> blocks every frame. The compiler converts this method into \"Branchless\" (branchless) machine code, which can increase processor pipeline efficiency by 20%.</p>"},{"location":"API_References/NexusMinMax_tr/","title":"Nexus Prime Mimari Rehberi: NexusMinMax (Aral\u0131k Y\u00f6netimi)","text":""},{"location":"API_References/NexusMinMax_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusMinMax.cs</code>, say\u0131sal de\u011ferlerin belirli bir alt ve \u00fcst s\u0131n\u0131r i\u00e7inde y\u00f6netimini sa\u011flayan jenerik ve unmanaged bir veri yap\u0131s\u0131d\u0131r. Oyun geli\u015ftirmede en s\u0131k kullan\u0131lan paternlerden biri olan \"Range\" (Aral\u0131k) mant\u0131\u011f\u0131n\u0131, Nexus Prime'\u0131n y\u00fcksek performansl\u0131 ECS mimarisine uygun hale getirir.</p> <p>Bu yap\u0131n\u0131n varl\u0131k sebebi; mermi h\u0131z\u0131, d\u00fc\u015fman can\u0131 veya g\u00f6rsel efekt boyutlar\u0131 gibi de\u011fi\u015fkenleri sadece iki say\u0131 olarak de\u011fil, \u00fczerinde <code>Clamp</code>, <code>Lerp</code> ve <code>Random</code> i\u015flemlerinin yap\u0131labilece\u011fi ak\u0131ll\u0131 bir \u00fcnite olarak saklamakt\u0131r.</p>"},{"location":"API_References/NexusMinMax_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusMinMax, esneklik ve performans i\u00e7in \u015fu \u00f6zellikleri sunar:</p> <ul> <li>Generic Constraints: <code>unmanaged</code> ve <code>IComparable&lt;T&gt;</code> k\u0131s\u0131tlamalar\u0131 sayesinde hem <code>int</code> hem <code>float</code> gibi t\u00fcm temel say\u0131 tipleriyle tip g\u00fcvenli\u011fi (type safety) i\u00e7inde \u00e7al\u0131\u015f\u0131r.</li> <li>Zero-Allocation Logic: T\u00fcm i\u015flemler stack \u00fczerinde veya unmanaged bellek i\u00e7inde ger\u00e7ekle\u015fir; \u00e7\u00f6p toplay\u0131c\u0131 (GC) i\u00e7in hi\u00e7bir y\u00fck olu\u015fturmaz.</li> <li>Method Inlining: <code>IsInRange</code> ve <code>Clamp</code> metodlar\u0131 <code>AggressiveInlining</code> ile i\u015faretlenmi\u015ftir, bu da i\u015flemci seviyesinde metod \u00e7a\u011fr\u0131s\u0131 maliyetini ortadan kald\u0131r\u0131r.</li> <li>Randomization Extensions: Unity'nin <code>Random</code> k\u00fct\u00fcphanesiyle entegre \u00e7al\u0131\u015farak, belirlenen aral\u0131kta tek sat\u0131rda rastgele de\u011fer \u00fcretilmesini sa\u011flar.</li> </ul>"},{"location":"API_References/NexusMinMax_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tan\u0131mlama: Bir bile\u015fen i\u00e7inde <code>NexusMinMax&lt;float&gt; DamageRange</code> olarak tan\u0131mlan\u0131r.</li> <li>K\u0131s\u0131tlama: Gelen bir de\u011fer <code>range.Clamp(input)</code> metoduyla an\u0131nda g\u00fcvenli aral\u0131\u011fa \u00e7ekilir.</li> <li>Do\u011frulama: <code>IsInRange</code> ile bir de\u011ferin belirlenen s\u0131n\u0131rlar i\u00e7inde olup olmad\u0131\u011f\u0131 O(1) maliyetle kontrol edilir.</li> <li>Uygulama: <code>Lerp</code> metodu ile aral\u0131k i\u00e7indeki bir y\u00fczdeye (\u00d6rn: %50) kar\u015f\u0131l\u0131k gelen de\u011fer hesaplan\u0131r.</li> </ol>"},{"location":"API_References/NexusMinMax_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public struct WeaponComponent {\n    public NexusMinMax&lt;float&gt; FireRate;\n}\n\n// Kullan\u0131m\nvar weapon = new WeaponComponent();\nweapon.FireRate = new NexusMinMax&lt;float&gt;(0.1f, 0.5f);\n\nfloat currentRate = weapon.FireRate.Random(); // 0.1 ile 0.5 aras\u0131 rastgele\nbool isSafe = weapon.FireRate.IsInRange(0.3f); // true\n</code></pre>"},{"location":"API_References/NexusMinMax_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Data;\n\npublic struct NexusMinMax&lt;T&gt; where T : unmanaged, IComparable&lt;T&gt;\n{\n    public T Min;\n    public T Max;\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public bool IsInRange(T value) =&gt; value.CompareTo(Min) &gt;= 0 &amp;&amp; value.CompareTo(Max) &lt;= 0;\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public T Clamp(T value) {\n        if (value.CompareTo(Min) &lt; 0) return Min;\n        if (value.CompareTo(Max) &gt; 0) return Max;\n        return value;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusMinMax_tr/#nexus-optimization-tip-predictive-clamping","title":"Nexus Optimization Tip: Predictive Clamping","text":"<p>S\u0131k g\u00fcncellenen sistemlerde (\u00d6rn: Fizik/AI) de\u011ferleri her karede manuel <code>if</code> bloklar\u0131yla kontrol etmek yerine <code>NexusMinMax.Clamp</code> metodunu kullan\u0131n. Derleyici bu metodu \"Branchless\" (dallanmas\u0131z) makine koduna d\u00f6n\u00fc\u015ft\u00fcrerek i\u015flemci boru hatt\u0131 (Pipeline) verimlili\u011fini %20 art\u0131rabilir.</p>"},{"location":"API_References/NexusObjectMapping_eng/","title":"Nexus Prime Architectural Manual: NexusObjectMapping (Unmanaged-Managed Bridge)","text":""},{"location":"API_References/NexusObjectMapping_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusObjectMapping.cs</code> is the critical connection point between Nexus Prime's unmanaged ECS world and Unity's managed object world (GameObject, Transform, Renderer). In a pure ECS structure, entities are just numbers (IDs), but to have a representation on screen, they need to quickly reach Unity objects.</p> <p>The reason for this mapper's existence is to reach the relevant Unity object via entity ID in O(1) complexity and a thread-safe manner, instead of calling heavy Unity operations like <code>GetComponent</code> or <code>Find</code> for thousands of entities every frame.</p>"},{"location":"API_References/NexusObjectMapping_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusObjectMapping uses the following techniques to support hybrid architecture:</p> <ul> <li>Concurrent Mapping: Uses <code>ConcurrentDictionary&lt;uint, object&gt;</code> to manage mapping requests coming from different threads without locking.</li> <li>Reference Bridging: Keeps the reference of the managed object in memory by using the index of the unmanaged entity as a key. In this way, the <code>Registry</code> data and the visual object are connected to each other.</li> <li>Generic Access: Automatically casts the returned object to the target type (e.g., Transform) with the <code>Get&lt;T&gt;</code> method, which makes the developer code cleaner.</li> <li>Zero-Cost Lookup: After mapping is done, the cost of reaching an object is only as much as a hash table read.</li> </ul>"},{"location":"API_References/NexusObjectMapping_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Mapping (<code>Map</code>): When an entity is created and a corresponding GameObject is instantiated, the two are connected to each other with this class.</li> <li>Inquiry (<code>Get</code>): While systems are executing business logic, they pull the relevant object with <code>NexusObjectMapping.Get&lt;Transform&gt;(id)</code> for visual updates.</li> <li>Synchronization: Changes in unmanaged data are transferred to the Unity object via this bridge.</li> <li>Cleaning (<code>Unmap</code>): When an entity is deleted, the mapping record is deleted to prevent memory leaks.</li> </ol>"},{"location":"API_References/NexusObjectMapping_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Object Mapping Matching objects between two different worlds (unmanaged/managed) with each other. Hybrid ECS Strategy of using both pure data structures (unmanaged) and engine objects (managed) together. Type Casting Forcing an object to be treated as if it were a certain type (Object -&gt; Transform). Sync Bridge Structure providing data flow between the data layer and the visual layer."},{"location":"API_References/NexusObjectMapping_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>GC Pressure: Since key-value pairs in <code>ConcurrentDictionary</code> reside on the managed heap, GC (Garbage Collector) pressure may occur if millions of mappings are made. Only entities with visual representations should be mapped.</li> <li>Lifetime Management: If a GameObject is <code>Destroy</code>ed on the Unity side but not <code>Unmap</code>ed on the Nexus side, \"MissingReferenceException\" risks arise.</li> </ul>"},{"location":"API_References/NexusObjectMapping_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>// Connect an entity and a visual object together\nEntityId entity = registry.Create();\nGameObject go = Instantiate(prefab);\nNexusObjectMapping.Map(entity.Index, go.transform);\n\n// Transfer data to visual within the system\nvoid OnUpdate(EntityId id, Position* pos) {\n    if (NexusObjectMapping.TryGet(id.Index, out var obj)) {\n        var trans = (Transform)obj;\n        trans.position = pos-&gt;Value;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusObjectMapping_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>using System.Collections.Concurrent;\nnamespace Nexus.Core;\n\npublic static class NexusObjectMapping\n{\n    private static readonly ConcurrentDictionary&lt;uint, object&gt; _mappings = new();\n\n    public static void Map(uint entityIndex, object unityObject)\n    {\n        _mappings[entityIndex] = unityObject;\n    }\n\n    public static T Get&lt;T&gt;(uint entityIndex) where T : class\n    {\n        if (_mappings.TryGetValue(entityIndex, out var obj)) return obj as T;\n        return null;\n    }\n\n    public static void Unmap(uint entityIndex)\n    {\n        _mappings.TryRemove(entityIndex, out _);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusObjectMapping_eng/#nexus-optimization-tip-predictive-pre-mapping","title":"Nexus Optimization Tip: Predictive Pre-Mapping","text":"<p>If you are using thousands of bullets or particles, instead of creating a Mapping for each, map to a \"Pool\" system. By updating the Mapping when the bullet object leaves the pool, you can reduce dictionary insertion/removal cost by 90%.</p>"},{"location":"API_References/NexusObjectMapping_tr/","title":"Nexus Prime Mimari Rehberi: NexusObjectMapping (Unmanaged-Managed K\u00f6pr\u00fcs\u00fc)","text":""},{"location":"API_References/NexusObjectMapping_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusObjectMapping.cs</code>, Nexus Prime'\u0131n unmanaged ECS d\u00fcnyas\u0131 ile Unity'nin managed nesne d\u00fcnyas\u0131 (GameObject, Transform, Renderer) aras\u0131ndaki kritik ba\u011flant\u0131 noktas\u0131d\u0131r. Pure ECS yap\u0131s\u0131nda varl\u0131klar sadece birer say\u0131d\u0131r (ID), ancak bu varl\u0131klar\u0131n ekranda bir kar\u015f\u0131l\u0131\u011f\u0131 olmas\u0131 i\u00e7in Unity nesnelerine h\u0131zl\u0131ca ula\u015fmalar\u0131 gerekir.</p> <p>Bu e\u015fleyicinin varl\u0131k sebebi; her karede binlerce varl\u0131k i\u00e7in <code>GetComponent</code> veya <code>Find</code> gibi a\u011f\u0131r Unity operasyonlar\u0131n\u0131 \u00e7a\u011f\u0131rmak yerine, varl\u0131k ID'si \u00fczerinden ilgili Unity objesine O(1) karma\u015f\u0131kl\u0131\u011f\u0131nda ve thread-safe bir \u015fekilde ula\u015fmakt\u0131r.</p>"},{"location":"API_References/NexusObjectMapping_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusObjectMapping, hibrit mimariyi desteklemek i\u00e7in \u015fu teknikleri kullan\u0131r:</p> <ul> <li>Concurrent Mapping: <code>ConcurrentDictionary&lt;uint, object&gt;</code> kullanarak, farkl\u0131 i\u015f par\u00e7ac\u0131klar\u0131ndan (threads) gelen e\u015fleme taleplerini kilitlenme (lock) olmadan y\u00f6netir.</li> <li>Reference Bridging: Unmanaged varl\u0131\u011f\u0131n indeksini key olarak kullanarak, managed nesnenin referans\u0131n\u0131 haf\u0131zada tutar. Bu sayede <code>Registry</code> verisi ile g\u00f6rsel nesne birbirine ba\u011flan\u0131r.</li> <li>Generic Access: <code>Get&lt;T&gt;</code> metodu ile d\u00f6n\u00fclen objeyi otomatik olarak hedef tipe (\u00d6rn: Transform) cast eder, bu da geli\u015ftirici kodunu daha temiz k\u0131lar.</li> <li>Zero-Cost Lookup: E\u015fleme yap\u0131ld\u0131ktan sonra, bir objeye ula\u015fma maliyeti sadece bir hash tablosu okumas\u0131 kadard\u0131r.</li> </ul>"},{"location":"API_References/NexusObjectMapping_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>E\u015fleme (<code>Map</code>): Bir varl\u0131k olu\u015fturuldu\u011funda ve buna kar\u015f\u0131l\u0131k bir GameObject instantiate edildi\u011finde, ikisi birbirine bu s\u0131n\u0131fla ba\u011flan\u0131r.</li> <li>Sorgulama (<code>Get</code>): Sistemler i\u015f mant\u0131\u011f\u0131n\u0131 y\u00fcr\u00fct\u00fcrken, g\u00f6rsel g\u00fcncelleme i\u00e7in <code>NexusObjectMapping.Get&lt;Transform&gt;(id)</code> ile ilgili objeyi \u00e7eker.</li> <li>Senkronizasyon: Unmanaged verideki de\u011fi\u015fimler, bu k\u00f6pr\u00fc \u00fczerinden Unity objesine aktar\u0131l\u0131r.</li> <li>Temizlik (<code>Unmap</code>): Varl\u0131k silindi\u011finde, bellek s\u0131z\u0131nt\u0131s\u0131n\u0131 \u00f6nlemek i\u00e7in mapping kayd\u0131 silinir.</li> </ol>"},{"location":"API_References/NexusObjectMapping_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Object Mapping \u0130ki farkl\u0131 d\u00fcnya (unmanaged/managed) aras\u0131ndaki nesnelerin birbiriyle e\u015fle\u015ftirilmesi. Hybrid ECS Hem saf veri yap\u0131lar\u0131n\u0131 (unmanaged) hem de motor nesnelerini (managed) beraber kullanma stratejisi. Type Casting Bir objeyi belirli bir tipmi\u015f gibi i\u015flem g\u00f6rmeye zorlama (Object -&gt; Transform). Sync Bridge Veri katman\u0131 ile g\u00f6rsel katman aras\u0131ndaki veri ak\u0131\u015f\u0131n\u0131 sa\u011flayan yap\u0131."},{"location":"API_References/NexusObjectMapping_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>GC Pressure: <code>ConcurrentDictionary</code> i\u00e7indeki key-value \u00e7iftleri managed heap \u00fczerinde durdu\u011fu i\u00e7in, milyonlarca e\u015fleme yap\u0131lmas\u0131 durumunda GC (Garbage Collector) bask\u0131s\u0131 olu\u015fabilir. Sadece g\u00f6rsel kar\u015f\u0131l\u0131\u011f\u0131 olan varl\u0131klar e\u015flenmelidir.</li> <li>Lifetime Management: E\u011fer bir GameObject Unity taraf\u0131nda <code>Destroy</code> edilirse ama Nexus taraf\u0131nda <code>Unmap</code> edilmezse, \"MissingReferenceException\" riskleri do\u011far.</li> </ul>"},{"location":"API_References/NexusObjectMapping_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Bir varl\u0131k ve g\u00f6rsel nesneyi birbirine ba\u011fla\nEntityId entity = registry.Create();\nGameObject go = Instantiate(prefab);\nNexusObjectMapping.Map(entity.Index, go.transform);\n\n// Sistem i\u00e7inde veriyi g\u00f6rsele aktar\nvoid OnUpdate(EntityId id, Position* pos) {\n    if (NexusObjectMapping.TryGet(id.Index, out var obj)) {\n        var trans = (Transform)obj;\n        trans.position = pos-&gt;Value;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusObjectMapping_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>using System.Collections.Concurrent;\nnamespace Nexus.Core;\n\npublic static class NexusObjectMapping\n{\n    private static readonly ConcurrentDictionary&lt;uint, object&gt; _mappings = new();\n\n    public static void Map(uint entityIndex, object unityObject)\n    {\n        _mappings[entityIndex] = unityObject;\n    }\n\n    public static T Get&lt;T&gt;(uint entityIndex) where T : class\n    {\n        if (_mappings.TryGetValue(entityIndex, out var obj)) return obj as T;\n        return null;\n    }\n\n    public static void Unmap(uint entityIndex)\n    {\n        _mappings.TryRemove(entityIndex, out _);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusObjectMapping_tr/#nexus-optimization-tip-predictive-pre-mapping","title":"Nexus Optimization Tip: Predictive Pre-Mapping","text":"<p>E\u011fer binlerce mermi veya partik\u00fcl kullan\u0131yorsan\u0131z, her biri i\u00e7in Mapping olu\u015fturmak yerine bir \"Pool\" (Havuz) sistemine Mapping yap\u0131n. Mermi objesi havuzdan \u00e7\u0131kt\u0131\u011f\u0131nda Mapping'i g\u00fcncelleyerek s\u00f6zl\u00fck ekleme/\u00e7\u0131karma (Insert/Remove) maliyetini %90 oran\u0131nda azaltabilirsiniz.</p>"},{"location":"API_References/NexusObjectPool_eng/","title":"API Reference: NexusObjectPool (Object Pooling)","text":""},{"location":"API_References/NexusObjectPool_eng/#introduction","title":"Introduction","text":"<p><code>NexusObjectPool.cs</code> is a high-performance pooling (pooling) system developed as an alternative to Unity's expensive <code>Instantiate</code> and <code>Destroy</code> operations. Instead of deleting entities that are frequently created and destroyed during the game (bullets, effects, etc.) from memory, it deactivates them and keeps them waiting in a queue. This prevents frame rate fluctuations (lag spikes) by removing the load on the Garbage Collector (GC).</p>"},{"location":"API_References/NexusObjectPool_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The pooling system operates using the following mechanisms: - Queue-Based Storage: Provides O(1) speed access by maintaining a separate <code>Queue&lt;GameObject&gt;</code> for each prefab type. - INexusPoolable Interface: Offers a lifecycle interface for objects appearing from or entering the pool so they can reset their states (<code>OnSpawn</code>/<code>OnDespawn</code>). - Dynamic Growth: If there is no free object in the pool, the system automatically creates a new one (<code>Instantiate</code>). - Name-Key Mapping: Organizes different types of objects using prefab names as keys (key).</p>"},{"location":"API_References/NexusObjectPool_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Request: When the <code>Spawn</code> method is called, the queue belonging to the relevant prefab is checked.</li> <li>Re-use: If an object is in the queue, it is activated, its position is set, and <code>OnSpawn</code> is triggered.</li> <li>Eviction: When <code>Despawn</code> is called, <code>OnDespawn</code> is triggered, the object is deactivated, and it returns to the queue it belongs to.</li> <li>Cleanup: All pools are released when the scene is loaded or the application is closed.</li> </ol>"},{"location":"API_References/NexusObjectPool_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Object Pooling: The technique of retaining objects for re-use instead of destroying them.</li> <li>Lag Spike: A delay in the processor's frame production due to a heavy process (e.g., GC).</li> <li>Active/Inactive State: The visibility and operation status of an object within the Unity hierarchy.</li> <li>Lifecycle Hook: Code snippets that run during specific stages (creation, destruction) of an object.</li> </ul>"},{"location":"API_References/NexusObjectPool_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>State Reset: If the object's state (speed, health, visual effects) is not manually reset within <code>OnDespawn</code>, it may appear with old data when spawned again.</li> </ul>"},{"location":"API_References/NexusObjectPool_eng/#usage-example","title":"Usage Example","text":"<pre><code>GameObject bullet = NexusObjectPool.Spawn(bulletPrefab, pos, rot);\n// ... when bullet is done\nNexusObjectPool.Despawn(bullet);\n</code></pre>"},{"location":"API_References/NexusObjectPool_eng/#nexus-optimization-tip-pre-warming-pools","title":"Nexus Optimization Tip: Pre-Warming Pools","text":"<p>At the start of critical scenes (on the loading screen), \"warm up\" the pool by pre-spawning and immediately de-spawning frequently used objects. This allows you to pre-pay the initial Instantiate cost that might occur during the peak of battle.</p>"},{"location":"API_References/NexusObjectPool_eng/#original-source","title":"Original Source","text":"<p>NexusDevelopmentTools.cs Source Code</p>"},{"location":"API_References/NexusObjectPool_tr/","title":"API Referans\u0131: NexusObjectPool (Nesne Havuzlama)","text":""},{"location":"API_References/NexusObjectPool_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusObjectPool.cs</code>, Unity'nin pahal\u0131 <code>Instantiate</code> ve <code>Destroy</code> operasyonlar\u0131na kar\u015f\u0131 geli\u015ftirilmi\u015f y\u00fcksek performansl\u0131 bir havuzlama (pooling) sistemidir. Oyun s\u0131ras\u0131nda s\u0131k\u00e7a yarat\u0131l\u0131p yok edilen varl\u0131klar\u0131 (mermiler, efektler vb.) bellekten silmek yerine pasif hale getirip bir kuyrukta bekletir. Bu sayede Garbage Collector (GC) \u00fczerindeki y\u00fck\u00fc kald\u0131rarak kare h\u0131z\u0131 dalgalanmalar\u0131n\u0131 (lag spikes) \u00f6nler.</p>"},{"location":"API_References/NexusObjectPool_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Havuzlama sistemi \u015fu mekanizmalarla \u00e7al\u0131\u015f\u0131r: - Queue-Based Storage: Her prefab tipi i\u00e7in ayr\u0131 bir <code>Queue&lt;GameObject&gt;</code> tutarak O(1) h\u0131z\u0131nda eri\u015fim sa\u011flar. - INexusPoolable Interface: Havuzdan \u00e7\u0131kan veya havuza giren nesnelerin durumlar\u0131n\u0131 s\u0131f\u0131rlayabilmesi (OnSpawn/OnDespawn) i\u00e7in bir ya\u015fam d\u00f6ng\u00fcs\u00fc aray\u00fcz\u00fc sunar. - Dynamic Growth: E\u011fer havuzda bo\u015f nesne yoksa, sistem otomatik olarak yeni bir tane olu\u015fturur (Instantiate). - Name-Key Mapping: Prefab isimlerini anahtar (key) olarak kullanarak farkl\u0131 tipteki objeleri organize eder.</p>"},{"location":"API_References/NexusObjectPool_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Talep: <code>Spawn</code> metodu \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, ilgili prefaba ait kuyruk kontrol edilir.</li> <li>Yeniden Kullan\u0131m: E\u011fer kuyrukta obje varsa, aktif edilir, pozisyonu ayarlan\u0131r ve <code>OnSpawn</code> tetiklenir.</li> <li>Tahliye: <code>Despawn</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, <code>OnDespawn</code> tetiklenir, obje pasif hale getirilir ve ait oldu\u011fu kuyru\u011fa geri d\u00f6ner.</li> <li>Temizlik: Sahne y\u00fcklendi\u011finde veya uygulama kapand\u0131\u011f\u0131nda t\u00fcm havuzlar serbest b\u0131rak\u0131l\u0131r.</li> </ol>"},{"location":"API_References/NexusObjectPool_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Object Pooling: Nesnelerin yok edilmeyip tekrar kullan\u0131lmak \u00fczere saklanmas\u0131 tekni\u011fi.</li> <li>Lag Spike: \u0130\u015flemcinin a\u011f\u0131r bir i\u015flem (\u00f6rn: GC) nedeniyle kare \u00fcretiminde gecikme ya\u015famas\u0131.</li> <li>Active/Inactive State: Bir nesnenin Unity hiyerar\u015fisinde g\u00f6r\u00fcn\u00fcrl\u00fck ve \u00e7al\u0131\u015fma durumu.</li> <li>Lifecycle Hook: Bir nesnenin belirli a\u015famalar\u0131nda (yarat\u0131lma, yok olma) \u00e7al\u0131\u015fan kod par\u00e7ac\u0131klar\u0131.</li> </ul>"},{"location":"API_References/NexusObjectPool_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>State Reset: <code>OnDespawn</code> i\u00e7inde nesnenin durumu (h\u0131z, sa\u011fl\u0131k, g\u00f6rsel efektler) manuel olarak s\u0131f\u0131rlanmazsa, tekrar spawn edildi\u011finde eski verilerle g\u00f6r\u00fcnebilir. </li> </ul>"},{"location":"API_References/NexusObjectPool_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>GameObject bullet = NexusObjectPool.Spawn(bulletPrefab, pos, rot);\n// ... mermi i\u015fi bitince\nNexusObjectPool.Despawn(bullet);\n</code></pre>"},{"location":"API_References/NexusObjectPool_tr/#nexus-optimization-tip-pre-warming-pools","title":"Nexus Optimization Tip: Pre-Warming Pools","text":"<p>Kritik sahnelerin ba\u015f\u0131nda (loading ekran\u0131nda), s\u0131k kullan\u0131lan nesneleri \u00f6nceden spawn edip hemen despawn ederek havuzu \"\u0131s\u0131t\u0131n\". Bu, sava\u015f\u0131n en yo\u011fun an\u0131nda olu\u015fabilecek ilk Instantiate maliyetini \u00f6nceden \u00f6demenizi sa\u011flar.</p>"},{"location":"API_References/NexusObjectPool_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusDevelopmentTools.cs Kaynak Kodu</p>"},{"location":"API_References/NexusOptimizationTools_eng/","title":"Nexus Prime Architectural Manual: NexusOptimizationTools (Optimization Tools)","text":""},{"location":"API_References/NexusOptimizationTools_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusOptimizationTools.cs</code> is a \"Cleanup and Configuration\" package that increases the project's efficiency in both development and release (Build) stages. It sorts out unnecessary prefab data, analyzes dependencies, and optimizes version control (Git) settings according to Nexus standards.</p> <p>The reason for these tools' existence is to prevent the project from bloating (Bloat) over time and to reduce technical debt (Technical Debt) while minimizing the build size.</p>"},{"location":"API_References/NexusOptimizationTools_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The package focuses on the following three main functions:</p> <ul> <li>Strip Legacy Prefabs: Automatically cleans up unused components within prefabs, Editor-only tags, and old Unity data incompatible with Nexus.</li> <li>Build Dependency Graph: Calculates which files a selected asset depends on and the total disk cost using <code>AssetDatabase.GetDependencies</code>.</li> <li>Git LFS Setup: Automatically generates the most optimized <code>.gitattributes</code> file for Unity projects (Ensures binary files are managed with LFS).</li> </ul>"},{"location":"API_References/NexusOptimizationTools_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Selection: The developer selects the assets they want to optimize or the entire project.</li> <li>Analysis: The tool scans the reference chain of assets.</li> <li>Action: File manipulation (writing/deleting) is performed over <code>System.IO.File</code> or <code>AssetDatabase</code>.</li> <li>Verification: The results of the cleanup performed (e.g., \"Stripped 45 items\") are reported to the console.</li> </ol>"},{"location":"API_References/NexusOptimizationTools_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Git Setup:\nNexusOptimizationTools.SetupGit();\n// Result: Unity optimized .gitattributes file is generated in the main directory.\n\n// Prefab Cleanup:\n// [Nexus/Optimization/Strip Legacy Prefabs] is clicked.\n// Result: Prefabs with reduced file size and made Nexus-Ready.\n</code></pre>"},{"location":"API_References/NexusOptimizationTools_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic static class NexusOptimizationTools\n{\n    [MenuItem(\"Nexus/Optimization/Strip Legacy Prefabs\")]\n    public static void StripPrefabs() {\n        // Find unused components and remove...\n    }\n\n    [MenuItem(\"Nexus/Integration/Git LFS Setup\")]\n    public static void SetupGit() {\n        // Write standard .gitattributes file...\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusOptimizationTools_eng/#nexus-optimization-tip-build-stripping","title":"Nexus Optimization Tip: Build Stripping","text":"<p>Connect the <code>StripPrefabs</code> tool to the <code>IPreprocessBuildWithReport</code> interface before Build. This way, automatic cleaning is performed before every build, and 15-20% savings can be achieved in the final build size.</p>"},{"location":"API_References/NexusOptimizationTools_tr/","title":"Nexus Prime Mimari Rehberi: NexusOptimizationTools (Optimizasyon Ara\u00e7lar\u0131)","text":""},{"location":"API_References/NexusOptimizationTools_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusOptimizationTools.cs</code>, projenin hem geli\u015ftirme hem de yay\u0131n (Build) a\u015famas\u0131ndaki verimlili\u011fini art\u0131ran bir \"Temizlik ve Yap\u0131land\u0131rma\" paketidir. Gereksiz prefab verilerini ay\u0131klar, ba\u011f\u0131ml\u0131l\u0131klar\u0131 analiz eder ve s\u00fcr\u00fcm kontrol (Git) ayarlar\u0131n\u0131 Nexus standartlar\u0131na g\u00f6re optimize eder.</p> <p>Bu ara\u00e7lar\u0131n varl\u0131k sebebi; projenin zamanla \u015fi\u015fmesini (Bloat) \u00f6nlemek ve build boyutunu minimize ederken teknik borcu (Technical Debt) azaltmakt\u0131r.</p>"},{"location":"API_References/NexusOptimizationTools_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Paket \u015fu \u00fc\u00e7 ana fonksiyona odaklan\u0131r:</p> <ul> <li>Strip Legacy Prefabs: Prefab'lar i\u00e7indeki kullan\u0131lmayan bile\u015fenleri, Edit\u00f6r-only etiketleri ve Nexus ile uyumsuz eski Unity verilerini otomatik olarak temizler.</li> <li>Build Dependency Graph: <code>AssetDatabase.GetDependencies</code> kullanarak, se\u00e7ili bir varl\u0131\u011f\u0131n hangi dosyalara ba\u011f\u0131ml\u0131 oldu\u011funu ve toplam disk maliyetini hesaplar.</li> <li>Git LFS Setup: Unity projeleri i\u00e7in en optimize edilmi\u015f <code>.gitattributes</code> dosyas\u0131n\u0131 otomatik olarak olu\u015fturur (Binary dosyalar\u0131n LFS ile y\u00f6netilmesini sa\u011flar).</li> </ul>"},{"location":"API_References/NexusOptimizationTools_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Se\u00e7im: Geli\u015ftirici optimize etmek istedi\u011fi varl\u0131klar\u0131 veya t\u00fcm projeyi se\u00e7er.</li> <li>Analiz: Ara\u00e7, varl\u0131klar\u0131n referans zincirini tarar.</li> <li>Eylem: <code>System.IO.File</code> veya <code>AssetDatabase</code> \u00fczerinden dosya manip\u00fclasyonu (yazma/silme) yap\u0131l\u0131r.</li> <li>Do\u011frulama: Yap\u0131lan temizli\u011fin sonu\u00e7lar\u0131 (\u00d6rn: \"Stripped 45 items\") konsola raporlan\u0131r.</li> </ol>"},{"location":"API_References/NexusOptimizationTools_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Git Kurulumu:\nNexusOptimizationTools.SetupGit();\n// Sonu\u00e7: Ana dizinde Unity optimize .gitattributes dosyas\u0131 olu\u015fur.\n\n// Prefab Temizli\u011fi:\n// [Nexus/Optimization/Strip Legacy Prefabs] t\u0131klan\u0131r.\n// Sonu\u00e7: Dosya boyutu k\u00fc\u00e7\u00fclt\u00fclm\u00fc\u015f ve Nexus-Ready hale getirilmi\u015f prefablar.\n</code></pre>"},{"location":"API_References/NexusOptimizationTools_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic static class NexusOptimizationTools\n{\n    [MenuItem(\"Nexus/Optimization/Strip Legacy Prefabs\")]\n    public static void StripPrefabs() {\n        // Find unused components and remove...\n    }\n\n    [MenuItem(\"Nexus/Integration/Git LFS Setup\")]\n    public static void SetupGit() {\n        // Write standard .gitattributes file...\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusOptimizationTools_tr/#nexus-optimization-tip-build-stripping","title":"Nexus Optimization Tip: Build Stripping","text":"<p><code>StripPrefabs</code> arac\u0131n\u0131 Build \u00f6ncesi <code>IPreprocessBuildWithReport</code> aray\u00fcz\u00fcne ba\u011flay\u0131n. Bu sayede her build \u00f6ncesi otomatik temizlik yap\u0131larak final build boyutunda %15-20 tasarruf sa\u011flanabilir.</p>"},{"location":"API_References/NexusParallelSystem_eng/","title":"Nexus Prime Architectural Manual: NexusParallelSystem (Autonomous System Base)","text":""},{"location":"API_References/NexusParallelSystem_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusParallelSystem.cs</code> is the primary carrier of high-performance and autonomous business logic within Nexus Prime. It is an abstraction layer that allows developers to focus purely on business logic without dealing with complex parallel programming details (thread management, deadlocks, etc.).</p> <p>The reason for this class's existence is to automatically detect the data dependencies required by systems at runtime and inform the <code>JobSystem</code> regarding the safety measures (parallel or sequential) with which this system should be executed.</p>"},{"location":"API_References/NexusParallelSystem_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusParallelSystem provides the following infrastructures for system automation:</p> <ul> <li>Reflective Dependency Extraction: The <code>GetAccessInfo</code> method scans fields on the class marked with <code>[Read]</code> and <code>[Write]</code> attributes using <code>Reflection</code>. This eliminates the need for the developer to manually maintain a dependency list.</li> <li>Dependency Inversion: The <code>Registry</code> reference is automatically injected when the system is created, thanks to the <code>[Inject]</code> attribute.</li> <li>Lifecycle Hooks: <code>OnCreate</code> and <code>OnDestroy</code> methods provide control points throughout the system's lifecycle (for resource allocation or cleanup).</li> <li>Abstract Logic Entry: By making the <code>Execute()</code> method mandatory (abstract), it is guaranteed that every system has a clear execution point.</li> </ul>"},{"location":"API_References/NexusParallelSystem_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Initialization: When the system is registered via <code>JobSystem.AddSystem</code>, the <code>Inject</code> fields are populated.</li> <li>Inquiry: <code>JobSystem</code> learns which components the system will access and in which mode by calling <code>GetAccessInfo()</code>.</li> <li>Execution: The <code>Execute()</code> method is triggered in the parallel thread pool once the system's dependencies in the data layer are clear.</li> </ol>"},{"location":"API_References/NexusParallelSystem_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Autonomous System A logic unit that knows its own dependencies and can operate without external interference. Reflection The ability of a program to examine its own structure (fields, methods, etc.) at runtime. Lifecycle Hook A callback method that runs when a specific event occurs (creation, deletion). Abstraction Layer A structure that provides simpler usage by hiding complex sub-system details."},{"location":"API_References/NexusParallelSystem_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Reflection Overhead: Since dependency scanning uses Reflection, it creates a small CPU cost at the moment of <code>AddSystem</code>. However, since this is done only once, it has no impact on in-game performance.</li> <li>Virtual Method Call: Since <code>GetAccessInfo</code> is a virtual method, micro-level call costs may occur in very deep inheritance hierarchies.</li> </ul>"},{"location":"API_References/NexusParallelSystem_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>public class CombatSystem : NexusParallelSystem\n{\n    // Dependencies are automatically injected and scanned\n    [Write] private Health* _health;\n    [Read] private AttackPower* _power;\n\n    public override void Execute()\n    {\n        // ... Combat logic ...\n    }\n\n    public override void OnCreate()\n    {\n        // Initial settings\n    }\n}\n</code></pre>"},{"location":"API_References/NexusParallelSystem_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>using System.Reflection;\nnamespace Nexus.Core;\n\npublic abstract class NexusParallelSystem : INexusSystem\n{\n    [Inject] protected Registry Registry;\n    public string Name =&gt; GetType().Name;\n\n    public virtual (HashSet&lt;Type&gt; Reads, HashSet&lt;Type&gt; Writes) GetAccessInfo()\n    {\n        var reads = new HashSet&lt;Type&gt;();\n        var writes = new HashSet&lt;Type&gt;();\n        var fields = GetType().GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);\n        foreach (var field in fields)\n        {\n            if (field.GetCustomAttribute&lt;ReadAttribute&gt;() != null) reads.Add(field.FieldType);\n            if (field.GetCustomAttribute&lt;WriteAttribute&gt;() != null) writes.Add(field.FieldType);\n        }\n        return (reads, writes);\n    }\n\n    public abstract void Execute();\n    public virtual void OnCreate() { }\n    public virtual void OnDestroy() { }\n}\n</code></pre>"},{"location":"API_References/NexusParallelSystem_eng/#nexus-optimization-tip-static-mapping-vs-reflection","title":"Nexus Optimization Tip: Static Mapping vs Reflection","text":"<p>If your system is being deleted and re-added thousands of times, you can escape the Reflection cost by overriding the <code>GetAccessInfo</code> method. By returning a manual list in the form of <code>Reads.Add(typeof(T))</code>, you can shorten the system registration time by 95%.</p>"},{"location":"API_References/NexusParallelSystem_tr/","title":"Nexus Prime Mimari Rehberi: NexusParallelSystem (Otonom Sistem Temeli)","text":""},{"location":"API_References/NexusParallelSystem_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusParallelSystem.cs</code>, Nexus Prime i\u00e7indeki y\u00fcksek performansl\u0131 ve otonom i\u015f mant\u0131klar\u0131n\u0131n ana ta\u015f\u0131y\u0131c\u0131s\u0131d\u0131r. Geli\u015ftiricilerin karma\u015f\u0131k paralel programlama detaylar\u0131yla (thread y\u00f6netimi, kilitlenmeler vb.) u\u011fra\u015fmadan, sadece i\u015f mant\u0131\u011f\u0131na odaklanmas\u0131n\u0131 sa\u011flayan bir soyutlama (abstraction) katman\u0131d\u0131r.</p> <p>Bu s\u0131n\u0131f\u0131n varl\u0131k sebebi, sistemlerin ihtiya\u00e7 duydu\u011fu veri ba\u011f\u0131ml\u0131l\u0131klar\u0131n\u0131 \u00e7al\u0131\u015fma zaman\u0131nda otomatik olarak tespit etmek ve <code>JobSystem</code>'e bu sistemin hangi g\u00fcvenlik \u00f6nlemleriyle (paralel mi yoksa s\u0131ral\u0131 m\u0131) \u00e7al\u0131\u015ft\u0131r\u0131lmas\u0131 gerekti\u011fini bildirmektir.</p>"},{"location":"API_References/NexusParallelSystem_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusParallelSystem, sistem otomasyonu i\u00e7in \u015fu altyap\u0131lar\u0131 sunur:</p> <ul> <li>Reflective Dependency Extraction: <code>GetAccessInfo</code> metodu, <code>Reflection</code> kullanarak s\u0131n\u0131f \u00fczerindeki <code>[Read]</code> ve <code>[Write]</code> etiketli alanlar\u0131 tarar. Bu, geli\u015ftiricinin manuel olarak ba\u011f\u0131ml\u0131l\u0131k listesi tutma zorunlulu\u011funu ortadan kald\u0131r\u0131r.</li> <li>Dependency Inversion: <code>Registry</code> referans\u0131, <code>[Inject]</code> \u00f6zniteli\u011fi sayesinde sistem olu\u015fturuldu\u011funda otomatik olarak enjekte edilir.</li> <li>Lifecycle Hooks: <code>OnCreate</code> ve <code>OnDestroy</code> metodlar\u0131, sistemin ya\u015fam d\u00f6ng\u00fcs\u00fc boyunca (kaynak tahsisat\u0131 veya temizli\u011fi i\u00e7in) kontrol noktalar\u0131 sa\u011flar.</li> <li>Abstract Logic Entry: <code>Execute()</code> metodu zorunlu (abstract) k\u0131l\u0131narak, her sistemin net bir y\u00fcr\u00fctme noktas\u0131na sahip olmas\u0131 garanti edilir.</li> </ul>"},{"location":"API_References/NexusParallelSystem_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130lklendirme: Sistem <code>JobSystem.AddSystem</code> ile kaydedildi\u011finde, <code>Inject</code> alanlar\u0131 doldurulur.</li> <li>Sorgulama: <code>JobSystem</code>, <code>GetAccessInfo()</code> \u00e7a\u011fr\u0131s\u0131 yaparak sistemin hangi bile\u015fenlere hangi modda eri\u015fece\u011fini \u00f6\u011frenir.</li> <li>\u00c7al\u0131\u015ft\u0131rma: <code>Execute()</code> metodu, sistemin veri katman\u0131ndaki ba\u011f\u0131ml\u0131l\u0131klar\u0131 temiz oldu\u011funda paralel thread havuzunda tetiklenir.</li> </ol>"},{"location":"API_References/NexusParallelSystem_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Autonomous System Kendi ba\u011f\u0131ml\u0131l\u0131klar\u0131n\u0131 bilen ve d\u0131\u015f m\u00fcdahale olmadan \u00e7al\u0131\u015fabilen mant\u0131k birimi. Reflection Bir program\u0131n \u00e7al\u0131\u015fma zaman\u0131nda kendi yap\u0131s\u0131n\u0131 (alanlar, metodlar vb.) inceleyebilme yetene\u011fi. Lifecycle Hook Belirli bir olay ger\u00e7ekle\u015fti\u011finde (olu\u015fturma, silme) \u00e7al\u0131\u015fan geri \u00e7a\u011f\u0131rma metodu. Abstraction Layer Karma\u015f\u0131k alt sistem detaylar\u0131n\u0131 gizleyerek daha basit bir kullan\u0131m sunan yap\u0131."},{"location":"API_References/NexusParallelSystem_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Reflection Overhead: Ba\u011f\u0131ml\u0131l\u0131k taramas\u0131 Reflection kulland\u0131\u011f\u0131 i\u00e7in <code>AddSystem</code> an\u0131nda ufak bir CPU maliyeti olu\u015fturur. Ancak bu sadece bir kez yap\u0131ld\u0131\u011f\u0131 i\u00e7in oyun i\u00e7i performansa etkisi yoktur.</li> <li>Virtual Method Call: <code>GetAccessInfo</code> sanal bir metod oldu\u011fu i\u00e7in \u00e7ok derin kal\u0131t\u0131m hiyerar\u015filerinde mikro seviyede \u00e7a\u011fr\u0131 maliyeti olu\u015fabilir.</li> </ul>"},{"location":"API_References/NexusParallelSystem_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public class CombatSystem : NexusParallelSystem\n{\n    // Ba\u011f\u0131ml\u0131l\u0131klar otomatik enjekte edilir ve taran\u0131r\n    [Write] private Health* _health;\n    [Read] private AttackPower* _power;\n\n    public override void Execute()\n    {\n        // ... Sava\u015f mant\u0131\u011f\u0131 ...\n    }\n\n    public override void OnCreate()\n    {\n        // Ba\u015flang\u0131\u00e7 ayarlar\u0131\n    }\n}\n</code></pre>"},{"location":"API_References/NexusParallelSystem_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>using System.Reflection;\nnamespace Nexus.Core;\n\npublic abstract class NexusParallelSystem : INexusSystem\n{\n    [Inject] protected Registry Registry;\n    public string Name =&gt; GetType().Name;\n\n    public virtual (HashSet&lt;Type&gt; Reads, HashSet&lt;Type&gt; Writes) GetAccessInfo()\n    {\n        var reads = new HashSet&lt;Type&gt;();\n        var writes = new HashSet&lt;Type&gt;();\n        var fields = GetType().GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);\n        foreach (var field in fields)\n        {\n            if (field.GetCustomAttribute&lt;ReadAttribute&gt;() != null) reads.Add(field.FieldType);\n            if (field.GetCustomAttribute&lt;WriteAttribute&gt;() != null) writes.Add(field.FieldType);\n        }\n        return (reads, writes);\n    }\n\n    public abstract void Execute();\n    public virtual void OnCreate() { }\n    public virtual void OnDestroy() { }\n}\n</code></pre>"},{"location":"API_References/NexusParallelSystem_tr/#nexus-optimization-tip-static-mapping-vs-reflection","title":"Nexus Optimization Tip: Static Mapping vs Reflection","text":"<p>E\u011fer sisteminiz binlerce kez silinip tekrar ekleniyorsa, <code>GetAccessInfo</code> metodunu <code>override</code> ederek Reflection maliyetinden kurtulabilirsiniz. <code>Reads.Add(typeof(T))</code> \u015feklinde manuel bir liste d\u00f6nerek, sistem kay\u0131t s\u00fcresini %95 oran\u0131nda k\u0131saltabilirsiniz.</p>"},{"location":"API_References/NexusPerformanceGuard_eng/","title":"Nexus Prime Architectural Manual: NexusPerformanceGuard (Performance Guardian)","text":""},{"location":"API_References/NexusPerformanceGuard_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusPerformanceGuard.cs</code> is the \"System Stability\" insurance of Nexus Prime. In complex game scenarios, sudden spikes in entities or intensive physics calculations can cause the CPU to hit 100% and lead to a drop in the game's frame rate (FPS).</p> <p>The reason for Performance Guard's existence is to monitor the system's total CPU consumption in real-time and, when a pre-determined \"CPU Budget\" is exceeded, maintain the game's smoothness by reducing the frequency of non-critical systems (Sfx, Particles, etc.) or changing thread priorities.</p>"},{"location":"API_References/NexusPerformanceGuard_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Performance Guard utilizes the following techniques for system health:</p> <ul> <li>Frame-Time Analysis: Monitors the total execution time of each frame with millisecond precision.</li> <li>Dynamic Thread Masking: If the CPU budget is exceeded, it puts some of the worker threads on the <code>JobSystem</code> into sleep mode to allow the main thread (Unity Main Thread) to breathe.</li> <li>Priority Throttling: Dynamically lowers the priority of background tasks, freeing up hardware resources for critical rendering and input tasks.</li> <li>Budgeting Logic: By setting a safe boundary (Safe Zone) such as <code>80%</code>, it ensures the system never leads to \"Hanging\" at the operating system level.</li> </ul>"},{"location":"API_References/NexusPerformanceGuard_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Measurement: The <code>Guard()</code> method measures the total load at the beginning or end of each frame.</li> <li>Decision: If the load rises above the <code>MaxCpuPercentage</code> value, \"Crisis Mode\" is activated.</li> <li>Intervention: Queues within the <code>JobSystem</code> are slowed down, or low-priority systems are deferred to the next frame.</li> <li>Normalization: When the load returns to the safe boundary, all systems are given full power.</li> </ol>"},{"location":"API_References/NexusPerformanceGuard_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description CPU Budget The maximum safe percentage or duration a game can use on the processor. Throttling A technique of consciously slowing down the speed of a process. Worker Thread An auxiliary thread performing heavy calculations in the background. Frame Spiking The frame time suddenly rising and causing stuttering."},{"location":"API_References/NexusPerformanceGuard_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Latency: When systems are slowed down, AI response times or the timeliness of visual effects may lag slightly.</li> <li>Measurement Overhead: The performance monitoring process itself also consumes CPU. Nexus uses a lightweight <code>Stopwatch</code> logic to minimize this cost.</li> </ul>"},{"location":"API_References/NexusPerformanceGuard_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>var guard = new NexusPerformanceGuard();\nguard.MaxCpuPercentage = 75f; // Do not exceed 75%\n\nvoid Update() {\n    // Monitor systems and slow down if necessary\n    guard.Guard(nexusJobSystem);\n}\n</code></pre>"},{"location":"API_References/NexusPerformanceGuard_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>using System.Diagnostics;\nnamespace Nexus.Core;\n\npublic class NexusPerformanceGuard\n{\n    public float MaxCpuPercentage { get; set; } = 80f;\n\n    public void Guard(JobSystem jobSystem)\n    {\n        // 1. Measure frame total execution time.\n        // 2. If exceeding budget, lower priority of background systems.\n        // 3. Throttle non-critical updates.\n    }\n}\n</code></pre>"},{"location":"API_References/NexusPerformanceGuard_eng/#nexus-optimization-tip-thermal-throttling-avoidance","title":"Nexus Optimization Tip: Thermal Throttling Avoidance","text":"<p>When the CPU constantly runs at 100% load, mobile devices and laptops lower their clock speed (GHz) to avoid overheating (Thermal Throttling). NexusPerformanceGuard prevents the hardware from dropping GHz by keeping the load below 80%, ensuring the game runs at a stable performance even over long durations.</p>"},{"location":"API_References/NexusPerformanceGuard_tr/","title":"Nexus Prime Mimari Rehberi: NexusPerformanceGuard (Performans Muhaf\u0131z\u0131)","text":""},{"location":"API_References/NexusPerformanceGuard_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusPerformanceGuard.cs</code>, Nexus Prime'\u0131n \"Sistem Stabilitesi\" (System Stability) sigortas\u0131d\u0131r. Karma\u015f\u0131k oyun senaryolar\u0131nda, ani varl\u0131k art\u0131\u015flar\u0131 veya yo\u011fun fizik hesaplamalar\u0131 CPU'nun %100'e vurmas\u0131na ve oyunun kare h\u0131z\u0131n\u0131n (FPS) d\u00fc\u015fmesine neden olabilir.</p> <p>Performance Guard'\u0131n varl\u0131k sebebi, sistemin toplam CPU t\u00fcketimini anl\u0131k olarak izlemek ve \u00f6nceden belirlenmi\u015f bir \"CPU B\u00fct\u00e7esi\" (CPU Budget) a\u015f\u0131ld\u0131\u011f\u0131nda, kritik olmayan sistemlerin (Sfx, Partik\u00fcl vb.) \u00e7al\u0131\u015fma s\u0131kl\u0131\u011f\u0131n\u0131 d\u00fc\u015f\u00fcrerek veya i\u015f par\u00e7ac\u0131\u011f\u0131 (thread) \u00f6nceliklerini de\u011fi\u015ftirerek oyunun ak\u0131c\u0131l\u0131\u011f\u0131n\u0131 korumakt\u0131r.</p>"},{"location":"API_References/NexusPerformanceGuard_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Performance Guard, sistem sa\u011fl\u0131\u011f\u0131 i\u00e7in \u015fu teknikleri kullan\u0131r:</p> <ul> <li>Frame-Time Analysis: Her karenin toplam y\u00fcr\u00fctme s\u00fcresini (execution time) milisaniye hassasiyetinde takip eder.</li> <li>Dynamic Thread Masking: E\u011fer CPU b\u00fct\u00e7esi a\u015f\u0131l\u0131rsa, <code>JobSystem</code> \u00fczerindeki worker threadlerin bir k\u0131sm\u0131n\u0131 uyku moduna alarak ana i\u015f par\u00e7ac\u0131\u011f\u0131na (Unity Main Thread) nefes ald\u0131r\u0131r.</li> <li>Priority Throttling: Arka plan g\u00f6revlerinin \u00f6nceli\u011fini (Priority) dinamik olarak d\u00fc\u015f\u00fcr\u00fcr, b\u00f6ylece kritik render ve input i\u015fleri i\u00e7in donan\u0131m kaynaklar\u0131 bo\u015fa \u00e7\u0131kar\u0131l\u0131r.</li> <li>Budgeting Logic: <code>%80</code> gibi bir g\u00fcvenli s\u0131n\u0131r (Safe Zone) belirleyerek, sistemin asla i\u015fletim sistemi seviyesinde kilitlenmelere (\"Hanging\") yol a\u00e7mamas\u0131n\u0131 sa\u011flar.</li> </ul>"},{"location":"API_References/NexusPerformanceGuard_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u00d6l\u00e7\u00fcm: <code>Guard()</code> metodu her kare ba\u015f\u0131nda veya sonunda toplam y\u00fck\u00fc \u00f6l\u00e7er.</li> <li>Karar: E\u011fer y\u00fck, <code>MaxCpuPercentage</code> de\u011ferinin \u00fczerine \u00e7\u0131karsa \"Kriz Modu\" (Crisis Mode) aktif edilir.</li> <li>M\u00fcdahale: <code>JobSystem</code> i\u00e7indeki kuyruklar yava\u015flat\u0131l\u0131r veya d\u00fc\u015f\u00fck \u00f6ncelikli sistemler bir sonraki kareye ertelenir.</li> <li>Normalle\u015fme: Y\u00fck g\u00fcvenli s\u0131n\u0131ra d\u00f6nd\u00fc\u011f\u00fcnde, t\u00fcm sistemlere tam g\u00fc\u00e7 verilir.</li> </ol>"},{"location":"API_References/NexusPerformanceGuard_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama CPU Budget Bir oyunun i\u015flemci \u00fczerinde kullanabilece\u011fi maksimum g\u00fcvenli y\u00fczdelik veya s\u00fcre. Throttling Bir i\u015flemin \u00e7al\u0131\u015fma h\u0131z\u0131n\u0131 bilin\u00e7li olarak yava\u015flatma tekni\u011fi. Worker Thread Arka planda a\u011f\u0131r hesaplamalar\u0131 yapan yard\u0131mc\u0131 i\u015f par\u00e7ac\u0131\u011f\u0131. Frame Spiking Kare s\u00fcresinin aniden y\u00fckselerek tak\u0131lmalara (stutter) sebep olmas\u0131."},{"location":"API_References/NexusPerformanceGuard_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Latency: Sistemler yava\u015flat\u0131ld\u0131\u011f\u0131nda, yapay zeka tepki s\u00fcreleri veya g\u00f6rsel efektlerin g\u00fcncelli\u011fi bir miktar gecikebilir.</li> <li>Measurement Overhead: Performans takip i\u015fleminin kendisi de CPU t\u00fcketir. Nexus bu maliyeti minimize etmek i\u00e7in hafif bir <code>Stopwatch</code> mant\u0131\u011f\u0131 kullan\u0131r.</li> </ul>"},{"location":"API_References/NexusPerformanceGuard_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>var guard = new NexusPerformanceGuard();\nguard.MaxCpuPercentage = 75f; // %75'i ge\u00e7me\n\nvoid Update() {\n    // Sistemleri denetle ve gerekirse yava\u015flat\n    guard.Guard(nexusJobSystem);\n}\n</code></pre>"},{"location":"API_References/NexusPerformanceGuard_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>using System.Diagnostics;\nnamespace Nexus.Core;\n\npublic class NexusPerformanceGuard\n{\n    public float MaxCpuPercentage { get; set; } = 80f;\n\n    public void Guard(JobSystem jobSystem)\n    {\n        // 1. Measure frame total execution time.\n        // 2. If exceeding budget, lower priority of background systems.\n        // 3. Throttle non-critical updates.\n    }\n}\n</code></pre>"},{"location":"API_References/NexusPerformanceGuard_tr/#nexus-optimization-tip-thermal-throttling-avoidance","title":"Nexus Optimization Tip: Thermal Throttling Avoidance","text":"<p>CPU s\u00fcrekli %100 y\u00fckte \u00e7al\u0131\u015ft\u0131\u011f\u0131nda, mobil cihazlar ve laptoplar \u0131s\u0131nmamak i\u00e7in saat h\u0131z\u0131n\u0131 (GHz) d\u00fc\u015f\u00fcr\u00fcr (Thermal Throttling). NexusPerformanceGuard, y\u00fck\u00fc %80 alt\u0131nda tutarak donan\u0131m\u0131n GHz d\u00fc\u015f\u00fcrmesini engeller ve oyunun uzun s\u00fcrelerde bile istikrarl\u0131 bir performansta \u00e7al\u0131\u015fmas\u0131n\u0131 sa\u011flar.</p>"},{"location":"API_References/NexusProfiler_eng/","title":"Nexus Prime Architectural Manual: NexusProfiler (Performance Monitor)","text":""},{"location":"API_References/NexusProfiler_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusProfiler.cs</code> is a low-level analysis tool monitoring the \"Heartbeats\" of the Nexus Prime framework. Unlike Unity's built-in profilers, it directly tracks unmanaged memory transfers, Job System loads, and ECS Registry throughput (data flow rate).</p> <p>The reason for this tool's existence is to facilitate optimization decisions by putting the \"Invisible\" loads (e.g., Memory copy times) of high-performance simulations into concrete figures.</p>"},{"location":"API_References/NexusProfiler_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The Profiler monitors the following metrics:</p> <ul> <li>Unmanaged Throughput: Measures how many bytes of data are read/written per second via the Registry.</li> <li>Job Synchronization Latency: Calculates how long worker threads waited for the main thread (Stall time).</li> <li>Entity Lifecycle Stats: Instantaneously reports how many entities were created or deleted per frame.</li> <li>Performance Guard Integration: Automatically throws a warning when critical thresholds are exceeded (e.g., when FPS falls below 60).</li> </ul>"},{"location":"API_References/NexusProfiler_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Observation: Monitoring systems are established when the Editor is opened with <code>InitializeOnLoad</code>.</li> <li>Data Capture: Raw performance counters are pulled from Nexus systems when <code>Application.isPlaying</code> is active.</li> <li>Visualization: Data is converted into analytical tables with <code>EditorGUILayout.HelpBox</code> and special graphic fields.</li> </ol>"},{"location":"API_References/NexusProfiler_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Profiling Process:\n// 1. [Nexus/Profiler] window is opened.\n// 2. Play mode is entered.\n// 3. Data flow starts with the message \"Capturing real-time unmanaged throughput...\".\n// Analysis: \"Memory copy cost is 4ms, Registry should switch to sparse update.\"\n</code></pre>"},{"location":"API_References/NexusProfiler_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class NexusProfiler : EditorWindow\n{\n    [MenuItem(\"Nexus/Profiler\")]\n    public static void ShowWindow() =&gt; GetWindow&lt;NexusProfiler&gt;(\"Nexus Profiler\");\n\n    private void OnGUI() {\n        GUILayout.Label(\"Nexus Performance Monitor\", EditorStyles.boldLabel);\n        if (Application.isPlaying) {\n            // Read from NexusPerformanceGuard...\n        }\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusProfiler_eng/#nexus-optimization-tip-sampling-rate","title":"Nexus Optimization Tip: Sampling Rate","text":"<p>The Profiler itself also creates a performance cost. Set the data collection frequency (Sampling Rate) to be every 10 frames instead of every frame. This reduces the deviation margin (Heisenberg effect) of measured values during profiling by 15%.</p>"},{"location":"API_References/NexusProfiler_tr/","title":"Nexus Prime Mimari Rehberi: NexusProfiler (Performans \u0130zleyici)","text":""},{"location":"API_References/NexusProfiler_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusProfiler.cs</code>, Nexus Prime framework'\u00fcn\u00fcn \"Kalp At\u0131\u015flar\u0131n\u0131\" izleyen d\u00fc\u015f\u00fck seviyeli bir analiz arac\u0131d\u0131r. Unity'nin yerle\u015fik profillerinden farkl\u0131 olarak, unmanaged bellek transferlerini, Job System y\u00fcklerini ve ECS Registry throughput'unu (veri ak\u0131\u015f h\u0131z\u0131n\u0131) do\u011frudan takip eder.</p> <p>Bu arac\u0131n varl\u0131k sebebi; y\u00fcksek performansl\u0131 sim\u00fclasyonlar\u0131n \"G\u00f6r\u00fcnmez\" y\u00fcklerini (\u00d6rn: Memory copy s\u00fcreleri) somut rakamlara d\u00f6kerek optimizasyon kararlar\u0131 almay\u0131 kolayla\u015ft\u0131rmakt\u0131r.</p>"},{"location":"API_References/NexusProfiler_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Profiler \u015fu metrikleri izler:</p> <ul> <li>Unmanaged Throughput: Registry \u00fczerinden saniyede ka\u00e7 byte veri okundu\u011funu/yaz\u0131ld\u0131\u011f\u0131n\u0131 \u00f6l\u00e7er.</li> <li>Job Synchronization Latency: Worker thread'lerin ana thread'i ne kadar s\u00fcre bekledi\u011fini (Stall time) hesaplar.</li> <li>Entity Lifecycle Stats: Kare ba\u015f\u0131na ka\u00e7 entity olu\u015fturuldu\u011funu veya silindi\u011fini anl\u0131k olarak raporlar.</li> <li>Performance Guard Integration: Kritik e\u015fikler a\u015f\u0131ld\u0131\u011f\u0131nda (\u00d6rn: FPS 60'\u0131n alt\u0131na d\u00fc\u015ft\u00fc\u011f\u00fcnde) otomatik olarak uyar\u0131 f\u0131rlat\u0131r.</li> </ul>"},{"location":"API_References/NexusProfiler_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>G\u00f6zlem: <code>InitializeOnLoad</code> ile Edit\u00f6r a\u00e7\u0131ld\u0131\u011f\u0131nda izleme sistemleri kurulur.</li> <li>Veri Yakalama: <code>Application.isPlaying</code> aktif oldu\u011funda Nexus sistemlerinden ham performans saya\u00e7lar\u0131 \u00e7ekilir.</li> <li>G\u00f6rselle\u015ftirme: <code>EditorGUILayout.HelpBox</code> ve \u00f6zel grafik alanlar\u0131 ile veriler analitik tablolara d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcr.</li> </ol>"},{"location":"API_References/NexusProfiler_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Profilleme S\u00fcreci:\n// 1. [Nexus/Profiler] penceresi a\u00e7\u0131l\u0131r.\n// 2. Play moduna ge\u00e7ilir.\n// 3. \"Capturing real-time unmanaged throughput...\" mesaj\u0131 ile veri ak\u0131\u015f\u0131 ba\u015flar.\n// Analiz: \"Memory copy maliyeti 4ms, Registry sparse update'e ge\u00e7ilmeli.\"\n</code></pre>"},{"location":"API_References/NexusProfiler_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class NexusProfiler : EditorWindow\n{\n    [MenuItem(\"Nexus/Profiler\")]\n    public static void ShowWindow() =&gt; GetWindow&lt;NexusProfiler&gt;(\"Nexus Profiler\");\n\n    private void OnGUI() {\n        GUILayout.Label(\"Nexus Performance Monitor\", EditorStyles.boldLabel);\n        if (Application.isPlaying) {\n            // Read from NexusPerformanceGuard...\n        }\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusProfiler_tr/#nexus-optimization-tip-sampling-rate","title":"Nexus Optimization Tip: Sampling Rate","text":"<p>Profiler'\u0131n kendisi de bir performans maliyeti olu\u015fturur. Veri toplama s\u0131kl\u0131\u011f\u0131n\u0131 (Sampling Rate) her kare yerine her 10 karede bir olacak \u015fekilde ayarlay\u0131n. Bu, profilleme yaparken \u00f6l\u00e7\u00fclen de\u011ferlerin sapma pay\u0131n\u0131 (Heisenberg etkisi) %15 azalt\u0131r.</p>"},{"location":"API_References/NexusProgression_eng/","title":"Nexus Prime Architectural Manual: NexusProgression (Level and Progress System)","text":""},{"location":"API_References/NexusProgression_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusProgression.cs</code> is an unmanaged data structure designed for RPG and progression-based game mechanics. Inherited from the HypeFire architecture, this structure acts as an optimized \"Accumulator\" (Accumulator) to track situations such as experience points (XP), skill development, or quest progress.</p> <p>The reason for this structure's existence is to keep the progression status of each entity (NPC, Player, etc.) directly in the memory block of the component (Component), instead of via managed objects, allowing the level-up control of thousands of units at the same time with zero GC cost.</p>"},{"location":"API_References/NexusProgression_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusProgression manages the following fields for data integrity:</p> <ul> <li>CurrentProgress: The current accumulated amount (e.g., 250 XP).</li> <li>Goal: The target amount required to move to the next level (e.g., 1000 XP).</li> <li>FillRatio: Calculates the ratio of the current progress to the target (0.0 - 1.0) for the UI layer.</li> <li>Auto-Leveling Logic: Thanks to the <code>while</code> loop within the <code>Add</code> method, consecutive level ups (Multiple Level-ups) are correctly calculated in case a large amount of points comes at once (e.g., 5000 XP).</li> </ul>"},{"location":"API_References/NexusProgression_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Input: New progress points enter the system via the <code>Add(amount)</code> method.</li> <li>Control: Whether the current amount exceeds the target (Goal) is checked.</li> <li>Level Increase: As long as the target is exceeded, <code>Level</code> is increased and the excess amount is preserved as the starting points of the next level within <code>CurrentProgress</code>.</li> <li>Reset: Progress is transferred by subtracting from the target with a \"Modulo\"-like logic.</li> </ol>"},{"location":"API_References/NexusProgression_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>public struct PlayerLevel : INexusComponent {\n    public NexusProgression XP;\n}\n\n// Usage\nref var xp = ref registry.Get&lt;PlayerLevel&gt;(e).XP;\nxp.Goal = 1000;\nxp.Add(2500); // Increases Level by 2, 500 XP remains.\nfloat uiFill = xp.FillRatio; // 0.5f (500/1000)\n</code></pre>"},{"location":"API_References/NexusProgression_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Data;\n\npublic struct NexusProgression\n{\n    public float CurrentProgress;\n    public float Goal;\n    public int Level;\n\n    public float FillRatio =&gt; Goal &gt; 0 ? CurrentProgress / Goal : 0;\n\n    public void Add(float amount)\n    {\n        CurrentProgress += amount;\n        while (CurrentProgress &gt;= Goal &amp;&amp; Goal &gt; 0)\n        {\n            CurrentProgress -= Goal;\n            Level++;\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/NexusProgression_eng/#nexus-optimization-tip-carry-over-precision","title":"Nexus Optimization Tip: Carry-over Precision","text":"<p>Using a <code>while</code> loop prevents experience points from being \"lost\" (Lost carry-over). Using this structure instead of a single <code>if</code> control eliminates level calculation errors in high-point rewards by 100%.</p>"},{"location":"API_References/NexusProgression_tr/","title":"Nexus Prime Mimari Rehberi: NexusProgression (Seviye ve \u0130lerleme Sistemi)","text":""},{"location":"API_References/NexusProgression_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusProgression.cs</code>, RPG ve ilerleme temelli oyun mekanikleri i\u00e7in tasarlanm\u0131\u015f unmanaged bir veri yap\u0131s\u0131d\u0131r. HypeFire mimarisinden miras al\u0131nan bu yap\u0131, tecr\u00fcbe puan\u0131 (XP), yetenek geli\u015ftirme veya g\u00f6rev ilerlemesi gibi durumlar\u0131 takip etmek i\u00e7in optimize edilmi\u015f bir \"Ak\u00fcm\u00fclat\u00f6r\" (Biriktirici) g\u00f6revi g\u00f6r\u00fcr.</p> <p>Bu yap\u0131n\u0131n varl\u0131k sebebi; her varl\u0131\u011f\u0131n (NPC, Oyuncu vb.) ilerleme durumunu managed objeler \u00fczerinden de\u011fil, do\u011frudan bile\u015fenin (Component) bellek blo\u011funda tutarak, binlerce birimin ayn\u0131 anda seviye atlama kontrol\u00fcn\u00fc s\u0131f\u0131r GC maliyetiyle yapabilmektir.</p>"},{"location":"API_References/NexusProgression_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusProgression, veri b\u00fct\u00fcnl\u00fc\u011f\u00fc i\u00e7in \u015fu alanlar\u0131 y\u00f6netir:</p> <ul> <li>CurrentProgress: Mevcut birikmi\u015f miktar (\u00d6rn: 250 XP).</li> <li>Goal: Bir sonraki seviyeye ge\u00e7mek i\u00e7in gereken hedef miktar (\u00d6rn: 1000 XP).</li> <li>FillRatio: UI katman\u0131 i\u00e7in mevcut ilerlemenin hedefe oran\u0131n\u0131 (0.0 - 1.0) hesaplar.</li> <li>Auto-Leveling Logic: <code>Add</code> metodu i\u00e7inde bulunan <code>while</code> d\u00f6ng\u00fcs\u00fc sayesinde, bir kerede b\u00fcy\u00fck miktarda puan gelmesi durumunda (\u00d6rn: 5000 XP) ard\u0131\u015f\u0131k seviye atlamalar\u0131 (Multiple Level-ups) do\u011fru bir \u015fekilde hesaplan\u0131r.</li> </ul>"},{"location":"API_References/NexusProgression_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Girdi: <code>Add(amount)</code> metoduyla sisteme yeni ilerleme puan\u0131 girer.</li> <li>Kontrol: Mevcut miktar hedefi (Goal) a\u015f\u0131p a\u015fmad\u0131\u011f\u0131 kontrol edilir.</li> <li>Seviye Art\u0131r\u0131m\u0131: Hedef a\u015f\u0131ld\u0131\u011f\u0131 s\u00fcrece <code>Level</code> art\u0131r\u0131l\u0131r ve a\u015fan miktar <code>CurrentProgress</code> i\u00e7inde bir sonraki seviyenin ba\u015flang\u0131\u00e7 puan\u0131 olarak korunur.</li> <li>S\u0131f\u0131rlama: \u0130lerleme, hedeften \u00e7\u0131kar\u0131larak \"Modulo\" benzeri bir mant\u0131kla devredilir.</li> </ol>"},{"location":"API_References/NexusProgression_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public struct PlayerLevel : INexusComponent {\n    public NexusProgression XP;\n}\n\n// Kullan\u0131m\nref var xp = ref registry.Get&lt;PlayerLevel&gt;(e).XP;\nxp.Goal = 1000;\nxp.Add(2500); // Level 2 artar, 500 XP kal\u0131r.\nfloat uiFill = xp.FillRatio; // 0.5f (500/1000)\n</code></pre>"},{"location":"API_References/NexusProgression_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Data;\n\npublic struct NexusProgression\n{\n    public float CurrentProgress;\n    public float Goal;\n    public int Level;\n\n    public float FillRatio =&gt; Goal &gt; 0 ? CurrentProgress / Goal : 0;\n\n    public void Add(float amount)\n    {\n        CurrentProgress += amount;\n        while (CurrentProgress &gt;= Goal &amp;&amp; Goal &gt; 0)\n        {\n            CurrentProgress -= Goal;\n            Level++;\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/NexusProgression_tr/#nexus-optimization-tip-carry-over-precision","title":"Nexus Optimization Tip: Carry-over Precision","text":"<p><code>while</code> d\u00f6ng\u00fcs\u00fc kullanmak, tecr\u00fcbe puanlar\u0131n\u0131n \"kaybolmas\u0131n\u0131\" (Lost carry-over) \u00f6nler. Tek bir <code>if</code> kontrol\u00fc yerine bu yap\u0131y\u0131 kullanmak, y\u00fcksek puanl\u0131 \u00f6d\u00fcllerde seviye hesaplama hatalar\u0131n\u0131 %100 oran\u0131nda ortadan kald\u0131r\u0131r.</p>"},{"location":"API_References/NexusQueryBuilder_eng/","title":"Nexus Prime Architectural Manual: NexusQueryBuilder (Fluid Query Architecture)","text":""},{"location":"API_References/NexusQueryBuilder_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusQueryBuilder.cs</code> is the \"Fluid API\" layer that makes the data querying process within Nexus Prime more flexible and readable. It was developed for scenarios where static generic queries (<code>NexusQuery&lt;T1, T2&gt;</code>) fall short, and complex filtering needs like dynamic component combinations or \"With this but Without that\" are required.</p> <p>The reason for this builder's existence is to automatically apply the Smallest-Set-First optimization, which allows the developer to find those matching specific criteria among thousands of entities in milliseconds rather than seconds.</p>"},{"location":"API_References/NexusQueryBuilder_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusQueryBuilder uses the following algorithmic strategies to increase search performance:</p> <ul> <li>Smallest-Set-First Strategy: Among all component sets requested in the query, the set with the fewest elements is identified, and the main loop only iterates over this set. In this way, if there are only 10 \"Players\" in a world of 1,000,000 entities, the query scans only those 10 objects, not the entire world.</li> <li>Fluent Interface (Method Chaining): The <code>With&lt;T&gt;()</code> and <code>Without&lt;T&gt;()</code> methods return themselves, allowing for fluent code writing (<code>builder.With&lt;A&gt;().Without&lt;B&gt;()</code>).</li> <li>Exclusion Filtering: Using <code>Without&lt;T&gt;</code>, entities with specific components are instantly eliminated during iteration.</li> <li>Predicate Filtering (Where): Beyond standard bitset filtering, the API offers <code>Predicate&lt;EntityId&gt;</code> support for custom logic (e.g., <code>hp &lt; 10</code>).</li> </ul>"},{"location":"API_References/NexusQueryBuilder_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Configuration: A filter list is created with <code>With</code> and <code>Without</code> methods.</li> <li>Set Resolution: When <code>Execute</code> is called, the corresponding <code>ISparseSet</code> references are collected via the <code>Registry</code>.</li> <li>Optimization: Sets are sorted by size, and the smallest set is selected as the main iterator.</li> <li>Validation: <code>Has</code> checks are performed for each entity to confirm the match, and the action is triggered.</li> </ol>"},{"location":"API_References/NexusQueryBuilder_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Fluid API A coding style close to human language where methods are chained together. Exclusion The process of excluding unwanted elements within a set. Smallest-Set-First A technique in an intersection operation for narrowing the search space by starting from the least amount of data. Predicate A logical function that returns whether an entity meets a specific condition."},{"location":"API_References/NexusQueryBuilder_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Lambda Overhead: Lambda functions sent with the <code>Where</code> method create a delegate call cost for each entity. For very intensive loops, SIMD-based static queries should be preferred.</li> <li>Allocation: The use of <code>List&lt;Type&gt;</code> may create a small GC load at the moment of <code>Execute</code>. In critical systems, the query builder should be cached.</li> </ul>"},{"location":"API_References/NexusQueryBuilder_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>registry.CreateQuery()\n    .With&lt;Position&gt;()\n    .With&lt;Health&gt;()\n    .Without&lt;Invulnerable&gt;() // Skip the invulnerables\n    .Where(id =&gt; registry.Get&lt;Health&gt;(id)-&gt;Value &lt; 20) // Those with health less than 20\n    .Execute(id =&gt; {\n        // ... Your logic ...\n    });\n</code></pre>"},{"location":"API_References/NexusQueryBuilder_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>using System.Linq;\nnamespace Nexus.Core;\n\npublic ref struct NexusQueryBuilder\n{\n    private readonly Registry _registry;\n    private readonly List&lt;Type&gt; _required = new();\n    private readonly List&lt;Type&gt; _excluded = new();\n\n    public void Execute(Action&lt;EntityId&gt; action)\n    {\n        if (_required.Count == 0) return;\n\n        // 1. PERFORMANCE: Use the smallest set to drive the loop.\n        ISparseSet smallestSet = _required.Select(t =&gt; _registry.GetSetByType(t))\n                                          .OrderBy(s =&gt; s.Count).First();\n\n        for (int i = 0; i &lt; smallestSet.Count; i++) {\n            EntityId entity = smallestSet.GetEntity(i);\n            // ... Checks for required/excluded ...\n            action(entity);\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/NexusQueryBuilder_eng/#nexus-optimization-tip-set-order-efficiency","title":"Nexus Optimization Tip: Set-Order Efficiency","text":"<p>QueryBuilder typically narrows the search space by 200% to 500% compared to manual <code>foreach</code> loops. By adding the rarest component as <code>With&lt;T&gt;</code> in the list, you prevent the processor from wasting time with unnecessary <code>Has()</code> checks.</p>"},{"location":"API_References/NexusQueryBuilder_tr/","title":"Nexus Prime Mimari Rehberi: NexusQueryBuilder (Ak\u0131c\u0131 Sorgu Mimarisi)","text":""},{"location":"API_References/NexusQueryBuilder_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusQueryBuilder.cs</code>, Nexus Prime i\u00e7indeki veri sorgulama s\u00fcrecini daha esnek ve okunabilir k\u0131lan \"Fluid API\" katman\u0131d\u0131r. Sabit jenerik sorgular\u0131n (<code>NexusQuery&lt;T1, T2&gt;</code>) yetersiz kald\u0131\u011f\u0131, dinamik bile\u015fen kombinasyonlar\u0131 veya \"\u015fu olsun ama bu olmas\u0131n\" (With/Without) gibi karma\u015f\u0131k filtreleme ihtiya\u00e7lar\u0131 i\u00e7in geli\u015ftirilmi\u015ftir.</p> <p>Bu builder'\u0131n varl\u0131k sebebi, geli\u015ftiricinin binlerce varl\u0131k aras\u0131ndan belirli kriterlere uyanlar\u0131 saniyeler i\u00e7inde de\u011fil, milisaniyeler i\u00e7inde bulmas\u0131n\u0131 sa\u011flayan Smallest-Set-First (En K\u00fc\u00e7\u00fck K\u00fcme \u00d6nceli\u011fi) optimizasyonunu otomatik olarak uygulamakt\u0131r.</p>"},{"location":"API_References/NexusQueryBuilder_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusQueryBuilder, arama performans\u0131n\u0131 art\u0131rmak i\u00e7in \u015fu algoritmik stratejileri kullan\u0131r:</p> <ul> <li>Smallest-Set-First Strategy: Sorguda istenen t\u00fcm bile\u015fen k\u00fcmeleri aras\u0131nda en az eleman\u0131 olan k\u00fcme tespit edilir ve ana d\u00f6ng\u00fc sadece bu k\u00fcme \u00fczerinden d\u00f6ner. Bu sayede, 1.000.000 varl\u0131kl\u0131 bir d\u00fcnyada sadece 10 adet \"Oyuncu\" varsa, sorgu t\u00fcm d\u00fcnyay\u0131 de\u011fil sadece o 10 nesneyi tarar.</li> <li>Fluent Interface (Method Chaining): <code>With&lt;T&gt;()</code> ve <code>Without&lt;T&gt;()</code> metodlar\u0131 kendilerini d\u00f6nerek ak\u0131c\u0131 bir kod yaz\u0131m\u0131na (<code>builder.With&lt;A&gt;().Without&lt;B&gt;()</code>) imkan tan\u0131r.</li> <li>Exclusion Filtering: <code>Without&lt;T&gt;</code> ile belirli bile\u015fenlere sahip varl\u0131klar iterasyon s\u0131ras\u0131nda an\u0131nda elenir.</li> <li>Predicate Filtering (Where): API, standart bitset filtrelemesinin \u00f6tesinde \u00f6zel mant\u0131klar i\u00e7in <code>Predicate&lt;EntityId&gt;</code> deste\u011fi sunar (\u00d6rn: <code>hp &lt; 10</code>).</li> </ul>"},{"location":"API_References/NexusQueryBuilder_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Yap\u0131land\u0131rma: <code>With</code> ve <code>Without</code> metodlar\u0131 ile filtre listesi olu\u015fturulur.</li> <li>K\u00fcmelerin \u00c7\u00f6z\u00fcmlenmesi: <code>Execute</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, <code>Registry</code> \u00fczerinden ilgili <code>ISparseSet</code> referanslar\u0131 toplan\u0131r.</li> <li>Optimizasyon: K\u00fcmeler boyutlar\u0131na g\u00f6re s\u0131ralan\u0131r ve en k\u00fc\u00e7\u00fck k\u00fcme (Smallest Set) ana iterat\u00f6r se\u00e7ilir.</li> <li>Do\u011frulama: Her bir varl\u0131k i\u00e7in <code>Has</code> kontrolleri yap\u0131larak e\u015fle\u015fme kesinle\u015ftirilir ve aksiyon tetiklenir.</li> </ol>"},{"location":"API_References/NexusQueryBuilder_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Fluid API Metodlar\u0131n birbirine zincirlendi\u011fi, insan diline yak\u0131n kodlama stili. Exclusion Bir k\u00fcmenin i\u00e7indeki istenmeyen elemanlar\u0131n hari\u00e7 tutulmas\u0131 i\u015flemi. Smallest-Set-First Bir kesi\u015fim (Intersection) i\u015fleminde en az veriden ba\u015flayarak arama uzay\u0131n\u0131 daraltma tekni\u011fi. Predicate Bir varl\u0131\u011f\u0131n belirli bir ko\u015fula uyup uymad\u0131\u011f\u0131n\u0131 d\u00f6nen mant\u0131ksal fonksiyon."},{"location":"API_References/NexusQueryBuilder_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Lambda Overhead: <code>Where</code> metodu ile g\u00f6nderilen lambda fonksiyonlar\u0131, her varl\u0131k i\u00e7in bir delege \u00e7a\u011fr\u0131s\u0131 maliyeti olu\u015fturur. \u00c7ok yo\u011fun d\u00f6ng\u00fclerde SIMD tabanl\u0131 statik sorgular tercih edilmelidir.</li> <li>Allocation: <code>List&lt;Type&gt;</code> kullan\u0131m\u0131 <code>Execute</code> an\u0131nda k\u00fc\u00e7\u00fck bir GC y\u00fck\u00fc olu\u015fturabilir. Kritik sistemlerde sorgu builder'\u0131 \u00f6nbelle\u011fe al\u0131nmal\u0131d\u0131r (Cache).</li> </ul>"},{"location":"API_References/NexusQueryBuilder_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>registry.CreateQuery()\n    .With&lt;Position&gt;()\n    .With&lt;Health&gt;()\n    .Without&lt;Invulnerable&gt;() // \u00d6l\u00fcms\u00fczleri ge\u00e7\n    .Where(id =&gt; registry.Get&lt;Health&gt;(id)-&gt;Value &lt; 20) // Can\u0131 20'den az olanlar\n    .Execute(id =&gt; {\n        // ... Mant\u0131\u011f\u0131n\u0131z ...\n    });\n</code></pre>"},{"location":"API_References/NexusQueryBuilder_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>using System.Linq;\nnamespace Nexus.Core;\n\npublic ref struct NexusQueryBuilder\n{\n    private readonly Registry _registry;\n    private readonly List&lt;Type&gt; _required = new();\n    private readonly List&lt;Type&gt; _excluded = new();\n\n    public void Execute(Action&lt;EntityId&gt; action)\n    {\n        if (_required.Count == 0) return;\n\n        // 1. PERFORMANCE: Use the smallest set to drive the loop.\n        ISparseSet smallestSet = _required.Select(t =&gt; _registry.GetSetByType(t))\n                                          .OrderBy(s =&gt; s.Count).First();\n\n        for (int i = 0; i &lt; smallestSet.Count; i++) {\n            EntityId entity = smallestSet.GetEntity(i);\n            // ... Checks for required/excluded ...\n            action(entity);\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/NexusQueryBuilder_tr/#nexus-optimization-tip-set-order-efficiency","title":"Nexus Optimization Tip: Set-Order Efficiency","text":"<p>QueryBuilder, manuel <code>foreach</code> d\u00f6ng\u00fclerine g\u00f6re arama uzay\u0131n\u0131 genellikle %200 ile %500 aras\u0131nda daralt\u0131r. En nadir bulunan bile\u015feni listede <code>With&lt;T&gt;</code> olarak ekleyerek, i\u015flemcinin gereksiz <code>Has()</code> kontrolleriyle vaktini harcamas\u0131n\u0131 engellersiniz.</p>"},{"location":"API_References/NexusQueryOptimizer_eng/","title":"Nexus Prime Architectural Manual: NexusQueryOptimizer (Smart Query Optimization)","text":""},{"location":"API_References/NexusQueryOptimizer_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusQueryOptimizer.cs</code> is a \"Heuristic\" decision mechanism that determines Nexus Prime's query execution strategies at runtime. By overturning the misconception that every operation must necessarily run in parallel, it selects the most accurate processor strategy according to data size.</p> <p>The reason for this optimizer's existence is to solve the problem of the cost of creating a parallel thread (Thread Pool) in small data sets (e.g., 100 entities) (Overhead) taking longer than the operation itself.</p>"},{"location":"API_References/NexusQueryOptimizer_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusQueryOptimizer applies the following strategic decisions for efficiency:</p> <ul> <li>Threshold-Based Execution: If the number of entities is below a certain threshold (e.g., 1000), it does not force the processor to create a new thread; it runs sequentially on the main thread.</li> <li>Load Balancing (Parallel.For): If the dataset is large, it automatically distributes the workload to all cores.</li> <li>Zero-Allocation Logic: The decision mechanism is completely static and creates no additional memory (GC) cost at runtime.</li> <li>Smart Dispatch: Making the \"Fast Path\" choice by taking the processor's core count and current load into account.</li> </ul>"},{"location":"API_References/NexusQueryOptimizer_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Input: The total number of entities to be processed (<code>count</code>) and the action to be taken (<code>action</code>) are received.</li> <li>Decision: If <code>count &lt; 1000</code>, a simple <code>for</code> loop is triggered.</li> <li>Parallelization: If the threshold is exceeded, the .NET kernel handler (Task Scheduler) is activated via <code>Parallel.For</code>.</li> <li>Completion: When the process is finished, control returns to the main flow.</li> </ol>"},{"location":"API_References/NexusQueryOptimizer_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Heuristic Decision Decision-making based on general experience and measurements (intuitions) rather than strict rules. Overhead The preparation cost required to start an operation rather than the operation itself. Parallel.For A tool of .NET that automatically divides a loop into multiple processor cores. Sequential Processing of data in a single sequence, waiting for each other."},{"location":"API_References/NexusQueryOptimizer_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Hardcoded Threshold: The 1000 entity threshold can give different results on every hardware (Mobile vs. PC). On modern systems, this threshold should be measured dynamically (Auto-Calibration).</li> <li>Callback Cost: Since the delegate (Action) sent as an action is called thousands of times within the loop, it brings with it the cost of delegate calls.</li> </ul>"},{"location":"API_References/NexusQueryOptimizer_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>int entityCount = registry.EntityCount;\n\n// Nexus decides between for or Parallel.For according to the entity count\nNexusQueryOptimizer.ExecuteSmartQuery(entityCount, i =&gt; {\n    // Operation on entity\n    var id = registry.GetEntityByIndex(i);\n    // ...\n});\n</code></pre>"},{"location":"API_References/NexusQueryOptimizer_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>using System.Threading.Tasks;\nnamespace Nexus.Core;\n\npublic static class NexusQueryOptimizer\n{\n    public static void ExecuteSmartQuery(int count, Action&lt;int&gt; action)\n    {\n        if (count &lt; 1000)\n        {\n            // Small batch: Single thread is faster\n            for (int i = 0; i &lt; count; i++) action(i);\n        }\n        else\n        {\n            // Large batch: Dispatch to all cores\n            Parallel.For(0, count, action);\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/NexusQueryOptimizer_eng/#nexus-optimization-tip-threshold-calibration","title":"Nexus Optimization Tip: Threshold Calibration","text":"<p>Benchmarks show that <code>Parallel.For</code> cost is higher on mobile devices. Therefore, by raising the threshold value to around 2500-3000 on mobile platforms, you can prevent unnecessary thread transitions (Context Switch) in small object groups and improve battery life.</p>"},{"location":"API_References/NexusQueryOptimizer_tr/","title":"Nexus Prime Mimari Rehberi: NexusQueryOptimizer (Ak\u0131ll\u0131 Sorgu Optimizasyonu)","text":""},{"location":"API_References/NexusQueryOptimizer_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusQueryOptimizer.cs</code>, Nexus Prime'\u0131n sorgu y\u00fcr\u00fctme stratejilerini \u00e7al\u0131\u015fma zaman\u0131nda belirleyen bir \"Heuristik\" (Sezgisel) karar mekanizmas\u0131d\u0131r. Her i\u015flemin mutlaka paralel \u00e7al\u0131\u015fmas\u0131 gerekti\u011fi yan\u0131lg\u0131s\u0131n\u0131 y\u0131karak, veri b\u00fcy\u00fckl\u00fc\u011f\u00fcne g\u00f6re en do\u011fru i\u015flemci stratejisini se\u00e7er.</p> <p>Bu optimize edicinin varl\u0131k sebebi, k\u00fc\u00e7\u00fck veri setlerinde (\u00d6rn: 100 varl\u0131k) paralel i\u015f par\u00e7ac\u0131\u011f\u0131 (Thread Pool) olu\u015fturman\u0131n getirdi\u011fi maliyetin (Overhead), i\u015flemin kendisinden daha uzun s\u00fcrmesi sorununu \u00e7\u00f6zmektir.</p>"},{"location":"API_References/NexusQueryOptimizer_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusQueryOptimizer, verimlilik i\u00e7in \u015fu stratejik kararlar\u0131 uygular:</p> <ul> <li>Threshold-Based Execution: Varl\u0131k say\u0131s\u0131 belirli bir e\u015fi\u011fin (\u00d6rn: 1000) alt\u0131ndaysa, i\u015flemciyi yeni bir thread olu\u015fturmaya zorlamaz; ana thread \u00fczerinde s\u0131ral\u0131 (sequential) \u00e7al\u0131\u015f\u0131r.</li> <li>Load Balancing (Parallel.For): Veri seti b\u00fcy\u00fckse, i\u015f y\u00fck\u00fcn\u00fc otomatik olarak t\u00fcm \u00e7ekirdeklere da\u011f\u0131t\u0131r.</li> <li>Zero-Allocation Logic: Karar mekanizmas\u0131 tamamen statiktir ve \u00e7al\u0131\u015fma zaman\u0131nda ek bellek (GC) maliyeti olu\u015fturmaz.</li> <li>Smart Dispatch: \u0130\u015flemcinin \u00e7ekirdek say\u0131s\u0131n\u0131 ve mevcut y\u00fck\u00fcn\u00fc dikkate alarak \"En H\u0131zl\u0131 Yol\" (Fast Path) se\u00e7imini yapar.</li> </ul>"},{"location":"API_References/NexusQueryOptimizer_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Girdi: \u0130\u015flenecek toplam varl\u0131k say\u0131s\u0131 (<code>count</code>) ve yap\u0131lacak aksiyon (<code>action</code>) al\u0131n\u0131r.</li> <li>Karar: E\u011fer <code>count &lt; 1000</code> ise, basit bir <code>for</code> d\u00f6ng\u00fcs\u00fc tetiklenir.</li> <li>Paralelle\u015ftirme: E\u015fik a\u015f\u0131lm\u0131\u015fsa, <code>Parallel.For</code> ile .NET \u00e7ekirdek i\u015fleyicisi (Task Scheduler) devreye sokulur.</li> <li>Tamamlama: \u0130\u015flem bitti\u011finde kontrol ana ak\u0131\u015fa geri d\u00f6ner.</li> </ol>"},{"location":"API_References/NexusQueryOptimizer_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Heuristic Decision Kesin kurallardan ziyade, genel deneyim ve \u00f6l\u00e7\u00fcmlere (sezgilere) dayal\u0131 karar verme. Overhead Bir i\u015flemin kendisinden ziyade, o i\u015flemi ba\u015flatmak i\u00e7in gereken haz\u0131rl\u0131k maliyeti. Parallel.For .NET'in bir d\u00f6ng\u00fcy\u00fc otomatik olarak birden fazla i\u015flemci \u00e7ekirde\u011fine b\u00f6len arac\u0131. Sequential Verilerin tek bir s\u0131ra halinde, birbirini bekleyerek i\u015flenmesi."},{"location":"API_References/NexusQueryOptimizer_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Hardcoded Threshold: 1000 varl\u0131k e\u015fi\u011fi her donan\u0131mda (Mobil vs. PC) farkl\u0131 sonu\u00e7lar verebilir. Modern sistemlerde bu e\u015fik dinamik olarak \u00f6l\u00e7\u00fclmelidir (Auto-Calibration).</li> <li>Callback Cost: Aksiyon olarak g\u00f6nderilen delege (Action), d\u00f6ng\u00fc i\u00e7inde binlerce kez \u00e7a\u011fr\u0131ld\u0131\u011f\u0131 i\u00e7in delege \u00e7a\u011fr\u0131 maliyetini beraberinde getirir.</li> </ul>"},{"location":"API_References/NexusQueryOptimizer_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>int entityCount = registry.EntityCount;\n\n// Nexus, varl\u0131k say\u0131s\u0131na g\u00f6re for veya Parallel.For aras\u0131nda karar verir\nNexusQueryOptimizer.ExecuteSmartQuery(entityCount, i =&gt; {\n    // Varl\u0131k \u00fczerindeki i\u015flem\n    var id = registry.GetEntityByIndex(i);\n    // ...\n});\n</code></pre>"},{"location":"API_References/NexusQueryOptimizer_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>using System.Threading.Tasks;\nnamespace Nexus.Core;\n\npublic static class NexusQueryOptimizer\n{\n    public static void ExecuteSmartQuery(int count, Action&lt;int&gt; action)\n    {\n        if (count &lt; 1000)\n        {\n            // Small batch: Single thread is faster\n            for (int i = 0; i &lt; count; i++) action(i);\n        }\n        else\n        {\n            // Large batch: Dispatch to all cores\n            Parallel.For(0, count, action);\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/NexusQueryOptimizer_tr/#nexus-optimization-tip-threshold-calibration","title":"Nexus Optimization Tip: Threshold Calibration","text":"<p>Benchmark'lar g\u00f6steriyor ki, mobil cihazlarda <code>Parallel.For</code> maliyeti daha y\u00fcksektir. Bu y\u00fczden mobil platformlarda e\u015fik de\u011ferini 2500-3000 civar\u0131na \u00e7ekerek, k\u00fc\u00e7\u00fck nesne gruplar\u0131nda gereksiz thread ge\u00e7i\u015flerini (Context Switch) engelleyebilir ve pil \u00f6mr\u00fcn\u00fc iyile\u015ftirebilirsiniz.</p>"},{"location":"API_References/NexusQuery_eng/","title":"Nexus Prime Architectural Manual: NexusQuery (SIMD Accelerated Query Engine)","text":""},{"location":"API_References/NexusQuery_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusQuery.cs</code> is the high-performance data processing core of Nexus Prime. Unlike traditional <code>foreach</code> or <code>LINQ</code> queries, it can filter millions of entities in microseconds rather than seconds by utilizing the CPU's SIMD (Single Instruction, Multiple Data) capabilities.</p> <p>The reason for this component's existence is to enable the CPU to switch from \"Scalar\" (single) processing mode to \"Vector\" mode. While a standard CPU performs 1 addition at a time, NexusQuery can calculate the query result for 32 different entities in a single clock cycle thanks to AVX2 support.</p>"},{"location":"API_References/NexusQuery_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusQuery utilizes the following techniques to fully exploit modern processor architectures:</p> <ul> <li>AVX2 / SSE Intrinsic: Data is loaded directly into the CPU's 256-bit Special Registers (AVX Vector Registers) using the <code>System.Runtime.Intrinsics.X86</code> library.</li> <li>Bitset ANDing: To find entities with two different components, a logical AND operation is performed between the \"Presence Bitsets\" on unmanaged memory instead of object comparison.</li> <li>Ref Struct Optimization: The query object is defined as a <code>ref struct</code>, ensuring it never reaches the Heap and operates with 0% GC cost.</li> <li>Pointer-Based Callbacks: Data returned as query results are not copied; instead, they are processed via pointers pointing directly to <code>dense</code> memory addresses.</li> </ul>"},{"location":"API_References/NexusQuery_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Preparation: The <code>SparseSet</code> structures and presence bitsets (<code>_presenceBits</code>) for the relevant two components are retrieved from the <code>Registry</code>.</li> <li>Vector Loading: Bit arrays are loaded into CPU registers (<code>Vector256.Load</code>) in 256-bit blocks.</li> <li>Parallel Filtering: The intersection of both bitsets is calculated at once using the <code>Avx2.And</code> command.</li> <li>Mask Processing: If the result mask (<code>result</code>) is not zero, each bit within it is converted into an entity index, and the entity ID and data (ptr) are conveyed to the user delegate (<code>callback</code>).</li> </ol>"},{"location":"API_References/NexusQuery_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description SIMD Technology for processing multiple data simultaneously with a single processor instruction. AVX2 The 256-bit wide vector instruction set of Intel and AMD. Bitset ANDing The process of calculating the intersection of two groups at the bit level (0/1). Presence Bits 1-bit flags representing whether an entity has a specific component."},{"location":"API_References/NexusQuery_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>AVX2 Dependency: The code is optimized for AVX2. On older CPUs that do not support it (more than 10 years old), the system automatically reverts to the \"Scalar Fallback\" (slow mode) system.</li> <li>Iteration Safety: It is dangerous to destroy entities during a query. It is recommended to use the <code>EntityCommandBuffer</code> for structural changes (Add/Remove).</li> </ul>"},{"location":"API_References/NexusQuery_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>// Process entities with Position and Health\nvar query = new NexusQuery&lt;Position, Health&gt;(registry);\n\nquery.Execute((entity, pos, health) =&gt; {\n    // pos -&gt; Position* (Pointer)\n    // health -&gt; Health* (Pointer)\n    pos-&gt;X += 1.0f;\n    if (health-&gt;Value &lt; 0) registry.Destroy(entity);\n});\n</code></pre>"},{"location":"API_References/NexusQuery_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>using System.Runtime.Intrinsics;\nusing System.Runtime.Intrinsics.X86;\nnamespace Nexus.Core;\n\npublic unsafe ref struct NexusQuery&lt;T1, T2&gt; \n    where T1 : unmanaged where T2 : unmanaged\n{\n    private readonly SparseSet&lt;T1&gt; _set1;\n    private readonly SparseSet&lt;T2&gt; _set2;\n\n    public void Execute(ExecuteDelegate callback)\n    {\n        uint* bits1 = (uint*)_set1.GetRawPresenceBits(out int count1);\n        uint* bits2 = (uint*)_set2.GetRawPresenceBits(out int count2);\n        int commonCount = Math.Min(count1, count2);\n\n        int i = 0;\n        if (Avx2.IsSupported &amp;&amp; commonCount &gt;= 8) {\n            for (; i &lt;= commonCount - 8; i += 8) {\n                Vector256&lt;uint&gt; v1 = Avx.LoadVector256(bits1 + i);\n                Vector256&lt;uint&gt; v2 = Avx.LoadVector256(bits2 + i);\n                Vector256&lt;uint&gt; result = Avx2.And(v1, v2);\n                if (Avx2.MoveMask(result.AsByte()) != 0) ProcessChunk(i, result, callback);\n            }\n        }\n        // Fallback for remainder...\n    }\n}\n</code></pre>"},{"location":"API_References/NexusQuery_eng/#nexus-optimization-tip-instruction-pipelining","title":"Nexus Optimization Tip: Instruction Pipelining","text":"<p>While a standard <code>if(HasComponent)</code> loop tires the CPU's \"Branch Prediction\" unit, <code>NexusQuery</code> offers a \"Branchless\" structure with bitset ANDing. This ensures the processor does not stall in the pipeline, increasing raw query speed by 20-30 times.</p>"},{"location":"API_References/NexusQuery_tr/","title":"Nexus Prime Mimari Rehberi: NexusQuery (SIMD H\u0131zland\u0131rmal\u0131 Sorgu Motoru)","text":""},{"location":"API_References/NexusQuery_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusQuery.cs</code>, Nexus Prime'\u0131n y\u00fcksek performansl\u0131 veri i\u015fleme \u00e7ekirde\u011fidir. Geleneksel <code>foreach</code> veya <code>LINQ</code> sorgular\u0131n\u0131n aksine, CPU'nun SIMD (Single Instruction, Multiple Data) yeteneklerini kullanarak milyonlarca varl\u0131\u011f\u0131 saniyeler de\u011fil, mikrosaniyeler i\u00e7inde filtreleyebilir.</p> <p>Bu bile\u015fenin varl\u0131k sebebi, CPU'nun \"Scalar\" (Tekil) i\u015flem modundan \u00e7\u0131k\u0131p \"Vector\" (Vekt\u00f6r) moduna ge\u00e7mesini sa\u011flamakt\u0131r. Standart bir CPU tek seferde 1 toplama yaparken, NexusQuery AVX2 deste\u011fi sayesinde tek bir saat d\u00f6ng\u00fcs\u00fcnde (clock cycle) 32 farkl\u0131 varl\u0131k i\u00e7in sorgu sonucunu hesaplayabilir.</p>"},{"location":"API_References/NexusQuery_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusQuery, modern i\u015flemci mimarilerinden tam kapasite faydalanmak i\u00e7in \u015fu teknikleri kullan\u0131r:</p> <ul> <li>AVX2 / SSE Intrinsic: <code>System.Runtime.Intrinsics.X86</code> k\u00fct\u00fcphanesi kullan\u0131larak CPU'nun 256-bitlik \u00d6zel Registerlar\u0131na (AVX Vekt\u00f6r Kay\u0131t\u00e7\u0131lar\u0131) do\u011frudan veri y\u00fcklenir.</li> <li>Bitset ANDing: \u0130ki farkl\u0131 bile\u015fene sahip varl\u0131klar\u0131 bulmak i\u00e7in nesne kar\u015f\u0131la\u015ft\u0131rmas\u0131 yerine, unmanaged bellek \u00fczerindeki \"Presence Bitsets\" (Varl\u0131k Bit Dizileri) aras\u0131nda lojik AND i\u015flemi yap\u0131l\u0131r.</li> <li>Ref Struct Optimization: Sorgu nesnesi bir <code>ref struct</code> olarak tan\u0131mlanm\u0131\u015ft\u0131r; bu da onun Heap'e (y\u0131\u011f\u0131n belle\u011fe) asla \u00e7\u0131kmamas\u0131n\u0131 ve %0 GC maliyetiyle \u00e7al\u0131\u015fmas\u0131n\u0131 sa\u011flar.</li> <li>Pointer-Based Callbacks: Sorgu sonucu d\u00f6nen veriler kopyalanmaz, do\u011frudan <code>dense</code> bellek adreslerine i\u015faret eden pointerlar \u00fczerinden i\u015flenir.</li> </ul>"},{"location":"API_References/NexusQuery_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Haz\u0131rl\u0131k: <code>Registry</code> \u00fczerinden ilgili iki bile\u015fenin <code>SparseSet</code> yap\u0131lar\u0131 ve varl\u0131k bitsetleri (<code>_presenceBits</code>) al\u0131n\u0131r.</li> <li>Vekt\u00f6r Y\u00fckleme: Bitsel diziler 256-bitlik bloklar halinde CPU registerlar\u0131na (<code>Vector256.Load</code>) y\u00fcklenir.</li> <li>Paralel Filtreleme: <code>Avx2.And</code> komutu ile her iki bitsetin kesi\u015fimi bir kerede hesaplan\u0131r.</li> <li>Maske \u0130\u015fleme: E\u011fer sonu\u00e7 maskesi (<code>result</code>) s\u0131f\u0131r de\u011filse, i\u00e7indeki her bir bit varl\u0131k indeksine d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcr ve kullan\u0131c\u0131 delegesine (<code>callback</code>) varl\u0131k ID'si ve verisi (ptr) iletilir.</li> </ol>"},{"location":"API_References/NexusQuery_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama SIMD Tek bir i\u015flemci komutuyla birden fazla veriyi ayn\u0131 anda i\u015fleme teknolojisi. AVX2 Intel ve AMD'nin 256-bit geni\u015fli\u011findeki vekt\u00f6r komut seti. Bitset ANDing \u0130ki grubun kesi\u015fimini bitsel seviyede (0/1) hesaplama i\u015flemi. Presence Bits Bir varl\u0131\u011f\u0131n belirli bir bile\u015fene sahip olup olmad\u0131\u011f\u0131n\u0131 temsil eden 1-bitlik bayraklar."},{"location":"API_References/NexusQuery_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>AVX2 Ba\u011f\u0131ml\u0131l\u0131\u011f\u0131: Kod AVX2'ye g\u00f6re optimize edilmi\u015ftir. Desteklemeyen eski CPU'larda (10 ya\u015f\u0131ndan b\u00fcy\u00fck) sistem otomatik olarak \"Scalar Fallback\" (yava\u015f mod) sistemine d\u00f6ner.</li> <li>Iteration Safety: Sorgu s\u0131ras\u0131nda varl\u0131k silmek tehlikelidir. Yap\u0131sal de\u011fi\u015fiklikler (Add/Remove) i\u00e7in <code>EntityCommandBuffer</code> kullan\u0131lmas\u0131 \u00f6nerilir.</li> </ul>"},{"location":"API_References/NexusQuery_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Pozisyonu ve Can\u0131 olan varl\u0131klar \u00fczerinde i\u015flem yap\nvar query = new NexusQuery&lt;Position, Health&gt;(registry);\n\nquery.Execute((entity, pos, health) =&gt; {\n    // pos -&gt; Position* (Pointer)\n    // health -&gt; Health* (Pointer)\n    pos-&gt;X += 1.0f;\n    if (health-&gt;Value &lt; 0) registry.Destroy(entity);\n});\n</code></pre>"},{"location":"API_References/NexusQuery_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>using System.Runtime.Intrinsics;\nusing System.Runtime.Intrinsics.X86;\nnamespace Nexus.Core;\n\npublic unsafe ref struct NexusQuery&lt;T1, T2&gt; \n    where T1 : unmanaged where T2 : unmanaged\n{\n    private readonly SparseSet&lt;T1&gt; _set1;\n    private readonly SparseSet&lt;T2&gt; _set2;\n\n    public void Execute(ExecuteDelegate callback)\n    {\n        uint* bits1 = (uint*)_set1.GetRawPresenceBits(out int count1);\n        uint* bits2 = (uint*)_set2.GetRawPresenceBits(out int count2);\n        int commonCount = Math.Min(count1, count2);\n\n        int i = 0;\n        if (Avx2.IsSupported &amp;&amp; commonCount &gt;= 8) {\n            for (; i &lt;= commonCount - 8; i += 8) {\n                Vector256&lt;uint&gt; v1 = Avx.LoadVector256(bits1 + i);\n                Vector256&lt;uint&gt; v2 = Avx.LoadVector256(bits2 + i);\n                Vector256&lt;uint&gt; result = Avx2.And(v1, v2);\n                if (Avx2.MoveMask(result.AsByte()) != 0) ProcessChunk(i, result, callback);\n            }\n        }\n        // Fallback for remainder...\n    }\n}\n</code></pre>"},{"location":"API_References/NexusQuery_tr/#nexus-optimization-tip-instruction-pipelining","title":"Nexus Optimization Tip: Instruction Pipelining","text":"<p>Standart bir <code>if(HasComponent)</code> d\u00f6ng\u00fcs\u00fc CPU'nun \"Branch Prediction\" (Dallanma Tahmini) \u00fcnitesini yorarken; <code>NexusQuery</code> bitsel ANDing ile \"Branchless\" (Dallanmas\u0131z) bir yap\u0131 sunar. Bu, i\u015flemcinin boru hatt\u0131nda (pipeline) tak\u0131lmamas\u0131n\u0131 sa\u011flayarak ham sorgu h\u0131z\u0131n\u0131 20-30 kat art\u0131r\u0131r.</p>"},{"location":"API_References/NexusRandmonoizer_eng/","title":"Nexus Prime Architectural Manual: NexusRandmonoizer (Variation Engine)","text":""},{"location":"API_References/NexusRandmonoizer_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusRandmonoizer.cs</code> is an Editor helper tool allowing for rapid diversification of transform (Position, Rotation, Scale) values of hundreds or thousands of objects selected in the scene. It creates the \"irregularity\" (irregularity) necessary for a natural look within seconds.</p> <p>The reason for this tool's existence is to increase the scene quality by breaking the artificial (robotic) look resulting from many objects such as trees, rocks, or bullets having the same direction and the same scale.</p>"},{"location":"API_References/NexusRandmonoizer_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The Randomizer offers the following operational capabilities:</p> <ul> <li>Multi-Axis Position Logic: Ensures that the objects are distributed only on the desired axes with the choice of <code>AxisType</code> (X, Y, Z, XY, XZ, YZ, All).</li> <li>Unit Circle/Sphere Randomization: Provides more organic (clustered) settlements by randomly distributing objects within a circle or sphere volume.</li> <li>Rotation Variation: Breaks symmetry by randomly rotating objects between 0-360 degrees.</li> <li>Uniform Scale Randomization: Prevents form distortions by changing the X, Y, and Z scales of the objects at the same rate (proportional).</li> </ul>"},{"location":"API_References/NexusRandmonoizer_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Selection Capture: Objects currently selected in the scene are listed via <code>Selection.gameObjects</code>.</li> <li>Parameter Determination: The developer selects Min/Max ranges and the axis type.</li> <li>Cyclic Process: New values are calculated with <code>Random.Range</code> for each object in the list.</li> <li>Application: Calculated new <code>localPosition</code>, <code>localRotation</code>, or <code>localScale</code> values are assigned to the objects.</li> </ol>"},{"location":"API_References/NexusRandmonoizer_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// While creating a forest:\n// 1. 100 tree prefabs are selected.\n// 2. \"Randomize Rotation\" is clicked via the Window.\n// 3. \"Randomize Scale\" (Min: 0.8, Max: 1.2) is clicked.\n// Result: An organic forest look standing different from each other.\n</code></pre>"},{"location":"API_References/NexusRandmonoizer_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic static class NexusRandmonoizer\n{\n    public static void RandomizePosition(float min, float max, AxisType axis = AxisType.All) {\n        foreach (var go in Selection.gameObjects) {\n            // Calculate and apply random pos based on axis...\n        }\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusRandmonoizer_eng/#nexus-optimization-tip-local-vs-world-space","title":"Nexus Optimization Tip: Local vs World Space","text":"<p>If possible, always perform randomization via <code>localPosition</code> and <code>localRotation</code>. This allows you to diversify only the child objects without breaking the parent (parent) objects' order.</p>"},{"location":"API_References/NexusRandmonoizer_tr/","title":"Nexus Prime Mimari Rehberi: NexusRandmonoizer (Varyasyon Motoru)","text":""},{"location":"API_References/NexusRandmonoizer_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusRandmonoizer.cs</code>, sahnede se\u00e7ili olan y\u00fczlerce veya binlerce nesnenin transform (Pozisyon, Rotasyon, \u00d6l\u00e7ek) de\u011ferlerini h\u0131zl\u0131ca \u00e7e\u015fitlendirmeyi sa\u011flayan bir Edit\u00f6r yard\u0131mc\u0131 arac\u0131d\u0131r. Do\u011fal bir g\u00f6r\u00fcn\u00fcm i\u00e7in gerekli olan \"d\u00fczensizli\u011fi\" (irregularity) saniyeler i\u00e7inde olu\u015fturur.</p> <p>Bu arac\u0131n varl\u0131k sebebi; a\u011fa\u00e7lar, kayalar veya mermiler gibi \u00e7ok say\u0131da nesnenin ayn\u0131 y\u00f6ne ve ayn\u0131 \u00f6l\u00e7e\u011fe sahip olmas\u0131ndan kaynaklanan yapay (robotic) g\u00f6r\u00fcn\u00fcm\u00fc k\u0131rarak sahne kalitesini art\u0131rmakt\u0131r.</p>"},{"location":"API_References/NexusRandmonoizer_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Randomizer \u015fu operasyonel yetenekleri sunar:</p> <ul> <li>Multi-Axis Position Logic: <code>AxisType</code> (X, Y, Z, XY, XZ, YZ, All) se\u00e7imi ile nesnelerin sadece istenen eksenlerde da\u011f\u0131t\u0131lmas\u0131n\u0131 sa\u011flar.</li> <li>Unit Circle/Sphere Randomization: Nesneleri bir daire veya k\u00fcre hacmi i\u00e7ine rastgele da\u011f\u0131tarak daha organik (k\u00fcmelenmi\u015f) yerle\u015fimler sa\u011flar.</li> <li>Rotation Variation: Nesneleri 0-360 derece aras\u0131 rastgele d\u00f6nd\u00fcrerek simetriyi bozar.</li> <li>Uniform Scale Randomization: Nesnelerin X, Y ve Z \u00f6l\u00e7eklerini ayn\u0131 oranda (proportional) de\u011fi\u015ftirerek form bozulmalar\u0131n\u0131 \u00f6nler.</li> </ul>"},{"location":"API_References/NexusRandmonoizer_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Se\u00e7im Yakalama: <code>Selection.gameObjects</code> \u00fczerinden sahnede o an se\u00e7ili olan nesneler listelenir.</li> <li>Parametre Belirleme: Geli\u015ftirici Min/Max aral\u0131klar\u0131n\u0131 ve eksen tipini se\u00e7er.</li> <li>D\u00f6ng\u00fcsel \u0130\u015flem: Listedeki her nesne i\u00e7in <code>Random.Range</code> ile yeni de\u011ferler hesaplan\u0131r.</li> <li>Uygulama: Hesaplanan yeni <code>localPosition</code>, <code>localRotation</code> veya <code>localScale</code> de\u011ferleri nesnelere atan\u0131r.</li> </ol>"},{"location":"API_References/NexusRandmonoizer_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Orman olu\u015ftururken:\n// 1. 100 tane a\u011fa\u00e7 prefab'\u0131 se\u00e7ilir.\n// 2. Window \u00fczerinden \"Randomize Rotation\" t\u0131klan\u0131r.\n// 3. \"Randomize Scale\" (Min: 0.8, Max: 1.2) t\u0131klan\u0131r.\n// Sonu\u00e7: Birbirinden farkl\u0131 duran organik bir orman g\u00f6r\u00fcn\u00fcm\u00fc.\n</code></pre>"},{"location":"API_References/NexusRandmonoizer_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic static class NexusRandmonoizer\n{\n    public static void RandomizePosition(float min, float max, AxisType axis = AxisType.All) {\n        foreach (var go in Selection.gameObjects) {\n            // Calculate and apply random pos based on axis...\n        }\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusRandmonoizer_tr/#nexus-optimization-tip-local-vs-world-space","title":"Nexus Optimization Tip: Local vs World Space","text":"<p>M\u00fcmk\u00fcnse her zaman <code>localPosition</code> ve <code>localRotation</code> \u00fczerinden randomizasyon yap\u0131n. Bu, ebeveyn (parent) nesnelerin d\u00fczenini bozmadan sadece alt objeleri \u00e7e\u015fitlendirmenize olanak tan\u0131r.</p>"},{"location":"API_References/NexusRigidbodyMove_eng/","title":"Nexus Prime Architectural Manual: NexusRigidbodyMove (Physics Movement Engine)","text":""},{"location":"API_References/NexusRigidbodyMove_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusRigidbodyMove.cs</code> is a \"Heavy Duty\" movement engine that ensures objects move in accordance with physics rules using Unity's <code>Rigidbody</code> component. Refined from the HypeFire architecture.</p> <p>The reason for this controller's existence is to ensure objects perform a smooth travel, preserving physics effects such as collision detection and friction, instead of just teleporting (teleport) their positions.</p>"},{"location":"API_References/NexusRigidbodyMove_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Uses the following mechanisms for physical movement:</p> <ul> <li>MovePosition Integration: Using the <code>Rigidbody.MovePosition</code> method, it ensures the object \"flows\" physically from one point to another. This is much more stable than changing <code>transform.position</code> directly and prevents physics jitters (jitter).</li> <li>Velocity Control: Can give the object immediate instantaneous speed with the <code>SetVelocity</code> method. This is ideal for bullets or launched objects.</li> <li>FixedUpdate Dependency: Physics calculations are dependent on Unity's <code>FixedUpdate</code> loop, which offers a consistent movement speed on all hardware.</li> <li>Required Component: Reduces error margin by preventing the object from working without physics capability with the <code>[RequireComponent(typeof(Rigidbody))]</code> attribute.</li> </ul>"},{"location":"API_References/NexusRigidbodyMove_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Preparation: At the <code>Awake</code> moment, the <code>Rigidbody</code> reference on the object is cached (Cache).</li> <li>Command: A <code>Move(direction)</code> or <code>SetVelocity(vel)</code> command comes from outside.</li> <li>Physics Simulation: The command is transmitted to the engine to be processed in Unity's next physics step.</li> <li>Result: The object advances towards the target by bouncing off or pushing the obstacles it hits.</li> </ol>"},{"location":"API_References/NexusRigidbodyMove_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>public class PlayerInput : MonoBehaviour {\n    private NexusRigidbodyMove _mover;\n\n    void Start() =&gt; _mover = GetComponent&lt;NexusRigidbodyMove&gt;();\n\n    void FixedUpdate() {\n        Vector3 input = new Vector3(Input.GetAxis(\"Horizontal\"), 0, Input.GetAxis(\"Vertical\"));\n        _mover.Move(input);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusRigidbodyMove_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity.Controllers;\n\n[RequireComponent(typeof(Rigidbody))]\npublic class NexusRigidbodyMove : MonoBehaviour\n{\n    public float Speed = 5f;\n    private Rigidbody _rb;\n\n    private void Awake() =&gt; _rb = GetComponent&lt;Rigidbody&gt;();\n\n    public void Move(Vector3 direction) {\n        _rb.MovePosition(transform.position + direction * Speed * Time.fixedDeltaTime);\n    }\n\n    public void SetVelocity(Vector3 velocity) {\n        _rb.linearVelocity = velocity;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusRigidbodyMove_eng/#nexus-optimization-tip-interpolation-mode","title":"Nexus Optimization Tip: Interpolation Mode","text":"<p>If the camera is following this object, mark the <code>Interpolation</code> setting on the Rigidbody as \"Interpolate\". This setting combined with <code>NexusRigidbodyMove</code> ensures object movement looks smooth as oil even at low frame rates.</p>"},{"location":"API_References/NexusRigidbodyMove_tr/","title":"Nexus Prime Mimari Rehberi: NexusRigidbodyMove (Fizik Hareket Motoru)","text":""},{"location":"API_References/NexusRigidbodyMove_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusRigidbodyMove.cs</code>, Unity'nin <code>Rigidbody</code> bile\u015fenini kullanarak nesnelerin fizik kurallar\u0131na uygun bir \u015fekilde hareket etmesini sa\u011flayan \"A\u011f\u0131r G\u00f6rev\" (Heavy Duty) bir hareket motorudur. HypeFire mimarisinden rafine edilmi\u015ftir.</p> <p>Bu kontrol\u00f6r\u00fcn varl\u0131k sebebi; nesnelerin sadece pozisyonlar\u0131n\u0131 \u0131\u015f\u0131nlamak (teleport) yerine, \u00e7arp\u0131\u015fma alg\u0131lama ve s\u00fcrt\u00fcnme gibi fizik etkilerini koruyarak p\u00fcr\u00fczs\u00fcz bir seyahat ger\u00e7ekle\u015ftirmesini sa\u011flamakt\u0131r.</p>"},{"location":"API_References/NexusRigidbodyMove_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Fiziksel hareket i\u00e7in \u015fu mekanizmalar\u0131 kullan\u0131r:</p> <ul> <li>MovePosition Integration: <code>Rigidbody.MovePosition</code> metodunu kullanarak, nesnenin fiziksel olarak bir noktadan di\u011ferine \"akmas\u0131n\u0131\" sa\u011flar. Bu, do\u011frudan <code>transform.position</code> de\u011fi\u015ftirmeye g\u00f6re \u00e7ok daha stabildir ve fizik titremelerini (jitter) engeller.</li> <li>Velocity Control: <code>SetVelocity</code> metodu ile nesneye do\u011frudan anl\u0131k h\u0131z verebilir. Bu, mermiler veya f\u0131rlat\u0131lan nesneler i\u00e7in idealdir.</li> <li>FixedUpdate Dependency: Fizik hesaplamalar\u0131 Unity'nin <code>FixedUpdate</code> d\u00f6ng\u00fcs\u00fcne ba\u011f\u0131ml\u0131d\u0131r, bu da t\u00fcm donan\u0131mlarda tutarl\u0131 bir hareket h\u0131z\u0131 sunar.</li> <li>Required Component: <code>[RequireComponent(typeof(Rigidbody))]</code> \u00f6zniteli\u011fi ile nesnenin fizik kabiliyeti olmadan \u00e7al\u0131\u015fmas\u0131n\u0131 engelleyerek hata pay\u0131n\u0131 d\u00fc\u015f\u00fcr\u00fcr.</li> </ul>"},{"location":"API_References/NexusRigidbodyMove_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Haz\u0131rl\u0131k: <code>Awake</code> an\u0131nda nesne \u00fczerindeki <code>Rigidbody</code> referans\u0131 \u00f6nbelle\u011fe (Cache) al\u0131n\u0131r.</li> <li>Komut: D\u0131\u015far\u0131dan bir <code>Move(direction)</code> veya <code>SetVelocity(vel)</code> komutu gelir.</li> <li>Fizik Sim\u00fclasyonu: Komut, Unity'nin bir sonraki fizik ad\u0131m\u0131nda i\u015flenmek \u00fczere motora iletilir.</li> <li>Sonu\u00e7: Nesne, \u00e7arpt\u0131\u011f\u0131 engellerden sekerek veya onlar\u0131 iterek hedefe do\u011fru ilerler.</li> </ol>"},{"location":"API_References/NexusRigidbodyMove_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public class PlayerInput : MonoBehaviour {\n    private NexusRigidbodyMove _mover;\n\n    void Start() =&gt; _mover = GetComponent&lt;NexusRigidbodyMove&gt;();\n\n    void FixedUpdate() {\n        Vector3 input = new Vector3(Input.GetAxis(\"Horizontal\"), 0, Input.GetAxis(\"Vertical\"));\n        _mover.Move(input);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusRigidbodyMove_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity.Controllers;\n\n[RequireComponent(typeof(Rigidbody))]\npublic class NexusRigidbodyMove : MonoBehaviour\n{\n    public float Speed = 5f;\n    private Rigidbody _rb;\n\n    private void Awake() =&gt; _rb = GetComponent&lt;Rigidbody&gt;();\n\n    public void Move(Vector3 direction) {\n        _rb.MovePosition(transform.position + direction * Speed * Time.fixedDeltaTime);\n    }\n\n    public void SetVelocity(Vector3 velocity) {\n        _rb.linearVelocity = velocity;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusRigidbodyMove_tr/#nexus-optimization-tip-interpolation-mode","title":"Nexus Optimization Tip: Interpolation Mode","text":"<p>E\u011fer kamera bu nesneyi takip ediyorsa, Rigidbody \u00fczerindeki <code>Interpolation</code> ayar\u0131n\u0131 \"Interpolate\" olarak i\u015faretleyin. <code>NexusRigidbodyMove</code> ile birle\u015fen bu ayar, d\u00fc\u015f\u00fck kare h\u0131zlar\u0131nda bile nesne hareketinin ya\u011f gibi p\u00fcr\u00fczs\u00fcz g\u00f6r\u00fcnmesini sa\u011flar.</p>"},{"location":"API_References/NexusRotateController_eng/","title":"Nexus Prime Architectural Manual: NexusRotateController (Aligned Rotation)","text":""},{"location":"API_References/NexusRotateController_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusRotateController.cs</code> is an \"Orientation Manager\" (Orientation Manager) ensuring objects rotate smoothly towards a target or direction. It's used for visual alignment of characters, vehicles, or projectiles based on their movement directions.</p> <p>The reason for this controller's existence is to prevent objects from rotating suddenly (snap) and to offer a visually pleasing, fluid rotation experience using mathematical <code>Slerp</code> (Spherical Linear Interpolation).</p>"},{"location":"API_References/NexusRotateController_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Uses the following methods for smooth rotation:</p> <ul> <li>LookRotation: Converts a given direction vector (<code>direction</code>) into the target Quaternion the projectile or character should look at.</li> <li>Spherical Linear Interpolation (Slerp): Performs a time-based and curved transition between the current rotation and the target rotation.</li> <li>Magnitude Filtering: Prevents shaking (shaking) of the object where it stands by ignoring very small movement vectors (e.g., below 0.001f).</li> <li>Time-Step Mastery: using the <code>Time.deltaTime</code> multiplier ensures the rotation speed stays the same every second regardless of hardware.</li> </ul>"},{"location":"API_References/NexusRotateController_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Input: The direction the character wants to go (Vector3) is transmitted to the system.</li> <li>Validation: If the direction vector is not \"zero\", the process continues.</li> <li>Calculation: The target line of sight is mathematically determined.</li> <li>Application: The object softly glides from its current angle towards the target angle at <code>RotateSpeed</code> speed.</li> </ol>"},{"location":"API_References/NexusRotateController_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>public class EnemyAI : MonoBehaviour {\n    private NexusRotateController _rotator;\n\n    void Start() =&gt; _rotator = GetComponent&lt;NexusRotateController&gt;();\n\n    void Update() {\n        Vector3 targetDir = (player.position - transform.position).normalized;\n        _rotator.RotateTowards(targetDir);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusRotateController_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity.Controllers;\n\npublic class NexusRotateController : MonoBehaviour\n{\n    public float RotateSpeed = 10f;\n\n    public void RotateTowards(Vector3 direction) {\n        if (direction.sqrMagnitude &lt; 0.001f) return;\n        Quaternion targetRot = Quaternion.LookRotation(direction);\n        transform.rotation = Quaternion.Slerp(transform.rotation, targetRot, Time.deltaTime * RotateSpeed);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusRotateController_eng/#nexus-optimization-tip-sqrmagnitude-vs-distance","title":"Nexus Optimization Tip: SqrMagnitude vs Distance","text":"<p>Never use <code>Vector3.Distance</code> or <code>magnitude</code> when performing distance or size checks; they contain expensive square root (sqrt) operations. Checks performed using <code>sqrMagnitude</code> reduce CPU load in rotation logic by 5-8%.</p>"},{"location":"API_References/NexusRotateController_tr/","title":"Nexus Prime Mimari Rehberi: NexusRotateController (Hizalamal\u0131 Rotasyon)","text":""},{"location":"API_References/NexusRotateController_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusRotateController.cs</code>, nesnelerin bir hedefe veya y\u00f6ne do\u011fru p\u00fcr\u00fczs\u00fcz bir \u015fekilde d\u00f6nmesini sa\u011flayan bir \"Y\u00f6nelim Y\u00f6neticisi\"dir (Orientation Manager). Karakterlerin, ara\u00e7lar\u0131n veya mermilerin hareket y\u00f6nlerine g\u00f6re g\u00f6rsel olarak hizalanmas\u0131 i\u00e7in kullan\u0131l\u0131r.</p> <p>Bu kontrol\u00f6r\u00fcn varl\u0131k sebebi; nesnelerin aniden (snap) d\u00f6nmesini engellemek ve matematiksel <code>Slerp</code> (K\u00fcresel Lineer \u0130nterpolasyon) kullanarak g\u00f6ze ho\u015f gelen, ak\u0131c\u0131 bir rotasyon deneyimi sunmakt\u0131r.</p>"},{"location":"API_References/NexusRotateController_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>P\u00fcr\u00fczs\u00fcz rotasyon i\u00e7in \u015fu y\u00f6ntemleri kullan\u0131r:</p> <ul> <li>LookRotation: Verilen bir y\u00f6n vekt\u00f6r\u00fcn\u00fc (<code>direction</code>), mermi veya karakterin bakmas\u0131 gereken hedef Quaternion'a d\u00f6n\u00fc\u015ft\u00fcr\u00fcr.</li> <li>Spherical Linear Interpolation (Slerp): Mevcut rotasyon ile hedef rotasyon aras\u0131nda, zaman bazl\u0131 ve kavisli bir ge\u00e7i\u015f yapar.</li> <li>Magnitude Filtering: \u00c7ok k\u00fc\u00e7\u00fck hareket vekt\u00f6rlerini (\u00d6rn: 0.001f alt\u0131) g\u00f6rmezden gelerek, nesnenin durdu\u011fu yerdeki titremeleri (shaking) \u00f6nler.</li> <li>Time-Step Mastery: <code>Time.deltaTime</code> \u00e7arpan\u0131 kullanarak, rotasyon h\u0131z\u0131n\u0131n donan\u0131mdan ba\u011f\u0131ms\u0131z olarak her saniye ayn\u0131 kalmas\u0131n\u0131 sa\u011flar.</li> </ul>"},{"location":"API_References/NexusRotateController_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Girdi: Karakterin gitmek istedi\u011fi y\u00f6n (Vector3) sisteme iletilir.</li> <li>Validasyon: Y\u00f6n vekt\u00f6r\u00fc \"s\u0131f\u0131r\" de\u011filse i\u015fleme devam edilir.</li> <li>Hesaplama: Hedef bak\u0131\u015f a\u00e7\u0131s\u0131 matematiksel olarak belirlenir.</li> <li>Uygulama: Nesne, mevcut a\u00e7\u0131s\u0131ndan hedef a\u00e7\u0131ya do\u011fru <code>RotateSpeed</code> h\u0131z\u0131nda yumu\u015fak\u00e7a s\u00fcz\u00fcl\u00fcr.</li> </ol>"},{"location":"API_References/NexusRotateController_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public class EnemyAI : MonoBehaviour {\n    private NexusRotateController _rotator;\n\n    void Start() =&gt; _rotator = GetComponent&lt;NexusRotateController&gt;();\n\n    void Update() {\n        Vector3 targetDir = (player.position - transform.position).normalized;\n        _rotator.RotateTowards(targetDir);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusRotateController_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity.Controllers;\n\npublic class NexusRotateController : MonoBehaviour\n{\n    public float RotateSpeed = 10f;\n\n    public void RotateTowards(Vector3 direction) {\n        if (direction.sqrMagnitude &lt; 0.001f) return;\n        Quaternion targetRot = Quaternion.LookRotation(direction);\n        transform.rotation = Quaternion.Slerp(transform.rotation, targetRot, Time.deltaTime * RotateSpeed);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusRotateController_tr/#nexus-optimization-tip-sqrmagnitude-vs-distance","title":"Nexus Optimization Tip: SqrMagnitude vs Distance","text":"<p>Uzakl\u0131k veya b\u00fcy\u00fckl\u00fck kontrol\u00fc yaparken asla <code>Vector3.Distance</code> veya <code>magnitude</code> kullanmay\u0131n; bunlar pahal\u0131 karek\u00f6k (sqrt) i\u015flemi bar\u0131nd\u0131r\u0131r. <code>sqrMagnitude</code> kullanarak yap\u0131lan kontroller, rotasyon mant\u0131\u011f\u0131nda CPU y\u00fck\u00fcn\u00fc %5-8 oran\u0131nda azalt\u0131r.</p>"},{"location":"API_References/NexusRotationField_eng/","title":"Nexus Prime Architectural Manual: NexusRotationField (Unmanaged Rotation Data)","text":""},{"location":"API_References/NexusRotationField_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusRotationField.cs</code> is a hybrid structure used by Nexus Prime to store rotation data within unmanaged ECS components. While Unity's <code>Quaternion</code> structure is unmanaged, working with Euler angles (Vector3) on the editor is much more intuitive for developers.</p> <p>The reason for this structure's existence is to store rotation in its simplest form (3 floats) within unmanaged memory blocks, yet to be able to make zero-cost and automatic (<code>implicit</code>) transitions to Unity's Quaternion system when needed (e.g., physics calculations).</p>"},{"location":"API_References/NexusRotationField_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusRotationField offers the following capabilities for rotation management:</p> <ul> <li>Memory Efficiency: Reduces memory usage by 25% in each component by storing rotation as 3-float (Euler) instead of 4-float (Quaternion).</li> <li>Bi-Directional Conversion: Can be <code>implicit</code>ly (without explicit specification) converted from both <code>Vector3</code> and <code>Quaternion</code> types. This allows the developer to write <code>registry.Set(id, new Vector3(0, 90, 0))</code>.</li> <li>Operator Overloading: Allows the rotation data to be dynamically scaled by multiplying it with a scalar value (<code>float</code>).</li> <li>Serializable Support: Thanks to the <code>[Serializable]</code> attribute, it can appear as a standard Vector3 field in the Unity Inspector window.</li> </ul>"},{"location":"API_References/NexusRotationField_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Input: The developer enters the rotation as Euler angles from the Inspector or from code.</li> <li>Storage: The data is kept as <code>Vector3</code> (Euler) within the unmanaged component.</li> <li>Conversion: When it is to be transferred to a Unity system (e.g., <code>transform.rotation</code>), the <code>Quaternion.Euler()</code> calculation is performed instantly in the background thanks to the <code>implicit operator</code>.</li> <li>Application: The calculated Quaternion is transferred to Unity's visual or physical layer.</li> </ol>"},{"location":"API_References/NexusRotationField_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>public struct RotationComponent : INexusComponent {\n    public NexusRotationField Value;\n}\n\n// Usage\nRotationComponent rot = new RotationComponent();\nrot.Value = new Vector3(0, 45, 0); // Implicit cast from Vector3\n\n// Transfer to Unity\ntransform.rotation = rot.Value; // Implicit cast to Quaternion\n</code></pre>"},{"location":"API_References/NexusRotationField_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Mathematics;\n\n[Serializable]\npublic struct NexusRotationField\n{\n    public Vector3 Euler;\n\n    public Quaternion Quaternion =&gt; Quaternion.Euler(Euler);\n\n    public NexusRotationField(Vector3 euler) =&gt; Euler = euler;\n    public NexusRotationField(Quaternion quaternion) =&gt; Euler = quaternion.eulerAngles;\n\n    public static implicit operator Quaternion(NexusRotationField field) =&gt; field.Quaternion;\n    public static implicit operator Vector3(NexusRotationField field) =&gt; field.Euler;\n}\n</code></pre>"},{"location":"API_References/NexusRotationField_eng/#nexus-optimization-tip-storage-vs-compute","title":"Nexus Optimization Tip: Storage vs. Compute","text":"<p>While storing rotation as <code>NexusRotationField</code> (Euler) saves memory, converting it to a <code>Quaternion</code> every frame brings a small CPU cost. If you are going to read your data as a Quaternion thousands of times per second, you can waive memory and store <code>Quaternion</code> directly to reduce rotation calculation cost by 100%.</p>"},{"location":"API_References/NexusRotationField_tr/","title":"Nexus Prime Mimari Rehberi: NexusRotationField (Unmanaged Rotasyon Verisi)","text":""},{"location":"API_References/NexusRotationField_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusRotationField.cs</code>, Nexus Prime'\u0131n unmanaged ECS bile\u015fenleri i\u00e7inde rotasyon verisini saklamak i\u00e7in kulland\u0131\u011f\u0131 hibrit bir yap\u0131d\u0131r. Unity'nin <code>Quaternion</code> yap\u0131s\u0131 unmanaged oldu\u011fu halde, edit\u00f6r \u00fczerinde Euler a\u00e7\u0131lar\u0131 (Vector3) ile \u00e7al\u0131\u015fmak geli\u015ftiriciler i\u00e7in \u00e7ok daha sezgiseldir.</p> <p>Bu yap\u0131n\u0131n varl\u0131k sebebi; unmanaged bellek bloklar\u0131 i\u00e7inde rotasyonu en basit haliyle (3 float) saklamak, ancak ihtiya\u00e7 duyuldu\u011funda (\u00d6rn: Fizik hesaplamalar\u0131) Unity'nin Quaternion sistemine s\u0131f\u0131r maliyetli ve otomatik (<code>implicit</code>) ge\u00e7i\u015fler yapabilmektir.</p>"},{"location":"API_References/NexusRotationField_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusRotationField, rotasyon y\u00f6netimi i\u00e7in \u015fu yetenekleri sunar:</p> <ul> <li>Memory Efficiency: Rotasyonu 4-float (Quaternion) yerine 3-float (Euler) olarak saklayarak bellek kullan\u0131m\u0131n\u0131 her bile\u015fende %25 oran\u0131nda azalt\u0131r.</li> <li>Bi-Directional Conversion: Hem <code>Vector3</code> hem de <code>Quaternion</code> tiplerinden <code>implicit</code> (a\u00e7\u0131k\u00e7a belirtilmeden) d\u00f6n\u00fc\u015febilir. Bu, geli\u015ftiricinin <code>registry.Set(id, new Vector3(0, 90, 0))</code> yazabilmesine olanak tan\u0131r.</li> <li>Operator Overloading: Rotasyon verisini bir skalar de\u011ferle (<code>float</code>) \u00e7arparak dinamik olarak \u00f6l\u00e7eklendirilmesini sa\u011flar.</li> <li>Serializable Support: <code>[Serializable]</code> \u00f6zniteli\u011fi sayesinde Unity Inspector penceresinde standart bir Vector3 alan\u0131 olarak g\u00f6r\u00fcnebilir.</li> </ul>"},{"location":"API_References/NexusRotationField_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Girdi: Geli\u015ftirici, rotasyonu Inspector'dan veya koddan Euler a\u00e7\u0131lar\u0131 olarak girer.</li> <li>Saklama: Veri, unmanaged bile\u015fen i\u00e7inde <code>Vector3</code> (Euler) olarak tutulur.</li> <li>D\u00f6n\u00fc\u015ft\u00fcrme: Bir Unity sistemine (\u00d6rn: <code>transform.rotation</code>) aktar\u0131laca\u011f\u0131 zaman, <code>implicit operator</code> sayesinde arka planda an\u0131nda <code>Quaternion.Euler()</code> hesaplamas\u0131 yap\u0131l\u0131r.</li> <li>Uygulama: Hesaplanan Quaternion, Unity'nin g\u00f6rsel veya fiziksel katman\u0131na aktar\u0131l\u0131r.</li> </ol>"},{"location":"API_References/NexusRotationField_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public struct RotationComponent : INexusComponent {\n    public NexusRotationField Value;\n}\n\n// Kullan\u0131m\nRotationComponent rot = new RotationComponent();\nrot.Value = new Vector3(0, 45, 0); // Implicit cast from Vector3\n\n// Unity'ye aktar\u0131m\ntransform.rotation = rot.Value; // Implicit cast to Quaternion\n</code></pre>"},{"location":"API_References/NexusRotationField_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Mathematics;\n\n[Serializable]\npublic struct NexusRotationField\n{\n    public Vector3 Euler;\n\n    public Quaternion Quaternion =&gt; Quaternion.Euler(Euler);\n\n    public NexusRotationField(Vector3 euler) =&gt; Euler = euler;\n    public NexusRotationField(Quaternion quaternion) =&gt; Euler = quaternion.eulerAngles;\n\n    public static implicit operator Quaternion(NexusRotationField field) =&gt; field.Quaternion;\n    public static implicit operator Vector3(NexusRotationField field) =&gt; field.Euler;\n}\n</code></pre>"},{"location":"API_References/NexusRotationField_tr/#nexus-optimization-tip-storage-vs-compute","title":"Nexus Optimization Tip: Storage vs. Compute","text":"<p>Rotasyonu <code>NexusRotationField</code> (Euler) olarak saklamak bellekten tasarruf sa\u011flarken, her karede <code>Quaternion</code>'a d\u00f6n\u00fc\u015ft\u00fcrmek k\u00fc\u00e7\u00fck bir CPU CPU maliyeti getirir. E\u011fer verinizi saniyede binlerce kez Quaternion olarak okuyacaksan\u0131z, bellekten feragat edip do\u011frudan <code>Quaternion</code> saklayarak rotasyon hesaplama maliyetini %100 oran\u0131nda d\u00fc\u015f\u00fcrebilirsiniz.</p>"},{"location":"API_References/NexusSceneOrganizer_eng/","title":"Nexus Prime Architectural Manual: NexusSceneOrganizer (Scene Organizer)","text":""},{"location":"API_References/NexusSceneOrganizer_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusSceneOrganizer.cs</code> is a \"Hierarchy Architect\" designed to prevent visual clutter and Unity Editor slowdowns created by thousands of Entities in the hierarchy (Hierarchy) panel. It keeps the workspace clean and performant by dividing objects into logical groups.</p> <p>The reason for this tool's existence is to save the Unity Editor's hierarchy interface (GUI) from the update load in massive ECS worlds where thousands of objects are drawn in every frame (frame).</p>"},{"location":"API_References/NexusSceneOrganizer_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The organizer follows these strategies:</p> <ul> <li>Group by Type: Automatically moves objects to virtual folders (Empty GameObject) according to component types (e.g., \"NPCs\", \"Projectiles\", \"Environment\").</li> <li>Proxy Folders: Creates \"Proxy\" (Proxy) objects providing only visual order on the Editor side, without breaking the real object hierarchy.</li> <li>Hierarchical Decoupling: Increases Unity's hierarchy searching and drawing performance by dividing massive object lists into shallow (Shallow) sub-groups with little depth.</li> <li>Cleanup Automation: Makes the project \"Pure ECS\" before the build by cleaning up temporary editing folders with a single click.</li> </ul>"},{"location":"API_References/NexusSceneOrganizer_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Analysis: All objects standing loose in the scene or marked with Nexus are scanned.</li> <li>Classification: The category of objects is determined according to metadata or component info.</li> <li>Grouping: A \"Parent\" object is created for each category found (if not present).</li> <li>Placement: Objects are hierarchically moved under the relevant parents.</li> </ol>"},{"location":"API_References/NexusSceneOrganizer_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Gathering a messy scene:\n// 1. [Nexus/Scene Organizer] window is opened.\n// 2. The \"Group by Type\" button is pressed.\n// Result: 5000 bullets and 200 enemies are gathered neatly under their own headers.\n</code></pre>"},{"location":"API_References/NexusSceneOrganizer_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class NexusSceneOrganizer : EditorWindow\n{\n    [MenuItem(\"Nexus/Scene Organizer\")]\n    public static void ShowWindow() =&gt; GetWindow&lt;NexusSceneOrganizer&gt;(\"Scene Organizer\");\n\n    private void OnGUI() {\n        GUILayout.Label(\"Intelligent Entity Hierachy Organizer\", EditorStyles.boldLabel);\n        if (GUILayout.Button(\"Group by Type\")) {\n            // Organize objects into parent-child hierarchy...\n        }\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusSceneOrganizer_eng/#nexus-optimization-tip-search-optimization","title":"Nexus Optimization Tip: Search Optimization","text":"<p>Every element in the Unity hierarchy creates a cost when a search (Search) is made. Keeping objects in a grouped structure that is not deepened (<code>flat</code>) by using Scene Organizer can increase the hierarchy search speed in the Editor by 50%.</p>"},{"location":"API_References/NexusSceneOrganizer_tr/","title":"Nexus Prime Mimari Rehberi: NexusSceneOrganizer (Sahne D\u00fczenleyici)","text":""},{"location":"API_References/NexusSceneOrganizer_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusSceneOrganizer.cs</code>, hiyerar\u015fi (Hierarchy) panelinde binlerce Entity'nin yaratt\u0131\u011f\u0131 g\u00f6rsel karma\u015fay\u0131 ve Unity Edit\u00f6r yava\u015flamalar\u0131n\u0131 \u00f6nlemek i\u00e7in tasarlanm\u0131\u015f bir \"Hiyerar\u015fi Mimar\u0131\"d\u0131r. Nesneleri mant\u0131ksal gruplara ay\u0131rarak \u00e7al\u0131\u015fma alan\u0131n\u0131 temiz ve performansl\u0131 tutar.</p> <p>Bu arac\u0131n varl\u0131k sebebi; her karesi (frame) binlerce nesneyi \u00e7izen devasa ECS d\u00fcnyalar\u0131nda, Unity Edit\u00f6r'\u00fcn hiyerar\u015fi aray\u00fcz\u00fcn\u00fc (GUI) g\u00fcncelleme y\u00fck\u00fcnden kurtarmakt\u0131r.</p>"},{"location":"API_References/NexusSceneOrganizer_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>D\u00fczenleyici \u015fu stratejileri izler:</p> <ul> <li>Group by Type: Nesneleri bile\u015fen tiplerine (\u00d6rn: \"NPCs\", \"Projectiles\", \"Environment\") g\u00f6re otomatik olarak sanal klas\u00f6rlere (Empty GameObject) ta\u015f\u0131r.</li> <li>Proxy Folders: Ger\u00e7ek nesne hiyerar\u015fisini bozmadan, Edit\u00f6r taraf\u0131nda sadece g\u00f6rsel d\u00fczen sa\u011flayan \"Proxy\" (Vekil) nesneler olu\u015fturur.</li> <li>Hierarchical Decoupling: Devasa nesne listelerini derinli\u011fi az olan (Shallow) alt gruplara b\u00f6lerek Unity'nin hiyerar\u015fi arama ve \u00e7izme performans\u0131n\u0131 art\u0131r\u0131r.</li> <li>Cleanup Automation: Ge\u00e7ici d\u00fczenleme klas\u00f6rlerini tek tu\u015fla temizleyerek build \u00f6ncesi projeyi \"Pure ECS\" haline getirir.</li> </ul>"},{"location":"API_References/NexusSceneOrganizer_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Analiz: Sahnede ba\u015f\u0131bo\u015f duran veya Nexus ile i\u015faretlenmi\u015f t\u00fcm nesneler taran\u0131r.</li> <li>S\u0131n\u0131fland\u0131rma: Nesnelerin metadata veya bile\u015fen bilgisine g\u00f6re kategorisi belirlenir.</li> <li>Gruplama: Bulunan her kategori i\u00e7in bir \"Parent\" nesnesi olu\u015fturulur (E\u011fer yoksa).</li> <li>Yerle\u015ftirme: Nesneler ilgili ebeveynlerin alt\u0131na hiyerar\u015fik olarak ta\u015f\u0131n\u0131r.</li> </ol>"},{"location":"API_References/NexusSceneOrganizer_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Da\u011f\u0131n\u0131k bir sahneyi toplamak:\n// 1. [Nexus/Scene Organizer] penceresi a\u00e7\u0131l\u0131r.\n// 2. \"Group by Type\" butonuna bas\u0131l\u0131r.\n// Sonu\u00e7: 5000 tane mermi ve 200 tane d\u00fc\u015fman, kendi ba\u015fl\u0131klar\u0131 alt\u0131nda tertipli bir \u015fekilde toplan\u0131r.\n</code></pre>"},{"location":"API_References/NexusSceneOrganizer_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class NexusSceneOrganizer : EditorWindow\n{\n    [MenuItem(\"Nexus/Scene Organizer\")]\n    public static void ShowWindow() =&gt; GetWindow&lt;NexusSceneOrganizer&gt;(\"Scene Organizer\");\n\n    private void OnGUI() {\n        GUILayout.Label(\"Intelligent Entity Hierachy Organizer\", EditorStyles.boldLabel);\n        if (GUILayout.Button(\"Group by Type\")) {\n            // Organize objects into parent-child hierarchy...\n        }\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusSceneOrganizer_tr/#nexus-optimization-tip-search-optimization","title":"Nexus Optimization Tip: Search Optimization","text":"<p>Unity hiyerar\u015fisindeki her eleman, arama (Search) yap\u0131ld\u0131\u011f\u0131nda bir maliyet olu\u015fturur. Scene Organizer kullanarak nesneleri derinle\u015fmeyen (<code>flat</code>) ama gruplanm\u0131\u015f bir yap\u0131da tutmak, Edit\u00f6r i\u00e7indeki hiyerar\u015fi arama h\u0131z\u0131n\u0131 %50 art\u0131rabilir.</p>"},{"location":"API_References/NexusSmartExtensions_eng/","title":"Nexus Prime Architectural Manual: NexusSmartExtensions (Unmanaged Data Bridge)","text":""},{"location":"API_References/NexusSmartExtensions_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusSmartExtensions.cs</code> is the most critical transition point between Unity's managed world (C# Objects) and Nexus's unmanaged memory blocks (Raw Pointers). It is designed to copy Unity types like <code>Vector3</code>, <code>Quaternion</code> into Nexus's performant memory areas zero-costly and safely.</p> <p>The reason for this extension library's existence is to eliminate the burden of writing manual <code>unsafe</code> code for each data copy operation and to offer the developer an atomic command set in the form of \"Copy this to this address\" (CopyTo).</p>"},{"location":"API_References/NexusSmartExtensions_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Provides the following performance-based critical extensions:</p> <ul> <li>Unsafe Vector Copy: Copies <code>Vector3</code> data directly to a float pointer (<code>float*</code>) at memory level. This is much faster than standard array or managed copies.</li> <li>Pointer to Vector Re-Materialization: Converts raw data in a float pointer back into Unity's <code>Vector3</code> type.</li> <li>Entity Manipulation Helpers: Wraps very common operations on ECS entities at unmanaged memory level with methods like <code>RandomizePosition</code>.</li> <li>Direct Memory Access: All copy operations are performed within <code>unsafe</code> blocks and optimize CPU clock cycles (Cycle).</li> </ul>"},{"location":"API_References/NexusSmartExtensions_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Input: <code>Vector3</code> data is taken from a Unity component (e.g., <code>transform.position</code>).</li> <li>Redirection: The <code>CopyTo</code> method is called and the target <code>Registry</code> memory address is given.</li> <li>Transfer: Data is transferred to the unmanaged heap (Unmanaged Heap) as raw bytes.</li> <li>Reverse Flow: When necessary, copying back from unmanaged data to the visual component is performed with <code>ToVector3()</code>.</li> </ol>"},{"location":"API_References/NexusSmartExtensions_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Raw Pointer Directly holding an address in memory without any control mechanism. Bilateral Copy Data being able to flow both from unmanaged to managed and vice versa. Re-Materialization Production of a meaningful high-level object from pure memory data."},{"location":"API_References/NexusSmartExtensions_eng/#5-usage-example","title":"5. Usage Example","text":"<pre><code>unsafe {\n    // Transfer Unity data to Nexus\n    Vector3 myPos = transform.position;\n    float* targetPtr = registry.GetPointer&lt;Position&gt;(id);\n    myPos.CopyTo(targetPtr);\n\n    // Get back from Nexus\n    transform.position = targetPtr.ToVector3();\n}\n</code></pre>"},{"location":"API_References/NexusSmartExtensions_eng/#6-full-source-implementation-direct-implementation","title":"6. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\npublic static class NexusSmartExtensions\n{\n    public static unsafe void CopyTo(this Vector3 v, float* ptr) {\n        ptr[0] = v.x; ptr[1] = v.y; ptr[2] = v.z;\n    }\n\n    public static unsafe Vector3 ToVector3(this float* ptr) {\n        return new Vector3(ptr[0], ptr[1], ptr[2]);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusSmartExtensions_eng/#nexus-optimization-tip-memory-alignment-check","title":"Nexus Optimization Tip: Memory Alignment Check","text":"<p>Ensure the target pointer is 4-byte (float size) aligned while using the <code>CopyTo</code> method. <code>NexusLayout</code> already performs this alignment. Copying to a non-aligned address can cause a \"Misaligned Access\" error at processor level, reducing performance by 30%.</p>"},{"location":"API_References/NexusSmartExtensions_tr/","title":"Nexus Prime Mimari Rehberi: NexusSmartExtensions (Unmanaged Veri K\u00f6pr\u00fcs\u00fc)","text":""},{"location":"API_References/NexusSmartExtensions_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusSmartExtensions.cs</code>, Unity'nin managed d\u00fcnyas\u0131 (C# Objeleri) ile Nexus'un unmanaged bellek bloklar\u0131 (Raw Pointers) aras\u0131ndaki en kritik ge\u00e7i\u015f noktas\u0131d\u0131r. Unity'nin <code>Vector3</code>, <code>Quaternion</code> gibi tiplerini, Nexus'un performansl\u0131 bellek alanlar\u0131na s\u0131f\u0131r maliyetli ve g\u00fcvenli bir \u015fekilde kopyalamak i\u00e7in tasarlanm\u0131\u015ft\u0131r.</p> <p>Bu uzant\u0131 k\u00fct\u00fcphanesinin varl\u0131k sebebi; her veri kopyalama i\u015fleminde manuel <code>unsafe</code> kod yazma k\u00fclfetini ortadan kald\u0131rmak ve geli\u015ftiriciye \"Bunu bu adrese kopyala\" (CopyTo) \u015feklinde atomik bir komut seti sunmakt\u0131r.</p>"},{"location":"API_References/NexusSmartExtensions_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Performansa dayal\u0131 \u015fu kritik geni\u015fletmeleri sa\u011flar:</p> <ul> <li>Unsafe Vector Copy: <code>Vector3</code> verisini, bir float pointer'\u0131na (<code>float*</code>) do\u011frudan bellek seviyesinde kopyalar. Bu, standart dizi veya managed kopyalamalara g\u00f6re \u00e7ok daha h\u0131zl\u0131d\u0131r.</li> <li>Pointer to Vector Re-Materialization: Bir float pointer'\u0131ndaki ham veriyi tekrar Unity'nin <code>Vector3</code> tipine d\u00f6n\u00fc\u015ft\u00fcr\u00fcr.</li> <li>Entity Manipulation Helpers: <code>RandomizePosition</code> gibi metodlarla, ECS varl\u0131klar\u0131 \u00fczerinde \u00e7ok s\u0131k yap\u0131lan i\u015flemleri unmanaged bellek seviyesinde sarmalar.</li> <li>Direct Memory Access: T\u00fcm kopyalama i\u015flemleri <code>unsafe</code> bloklar i\u00e7inde yap\u0131l\u0131r ve CPU saat d\u00f6ng\u00fclerini (Cycle) optimize eder.</li> </ul>"},{"location":"API_References/NexusSmartExtensions_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Girdi: Bir Unity bile\u015feninden (\u00d6rn: <code>transform.position</code>) <code>Vector3</code> verisi al\u0131n\u0131r.</li> <li>Y\u00f6nlendirme: <code>CopyTo</code> metodu \u00e7a\u011fr\u0131l\u0131r ve hedef <code>Registry</code> bellek adresi verilir.</li> <li>Transfer: Veri, unmanaged y\u0131\u011f\u0131na (Unmanaged Heap) ham byte'lar olarak aktar\u0131l\u0131r.</li> <li>Ters Ak\u0131\u015f: Gerekti\u011finde <code>ToVector3()</code> ile unmanaged veriden g\u00f6rsel bile\u015fene geri kopyalama yap\u0131l\u0131r.</li> </ol>"},{"location":"API_References/NexusSmartExtensions_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Raw Pointer Bellekteki bir adresin hi\u00e7bir kontrol mekanizmas\u0131 olmadan do\u011frudan tutulmas\u0131. Bilateral Copy Verinin hem unmanaged'dan managed'a hem de tersine akabilmesi. Re-Materialization Saf bellek verisinden anlaml\u0131 bir y\u00fcksek seviyeli nesne \u00fcretilmesi."},{"location":"API_References/NexusSmartExtensions_tr/#5-kullanm-ornegi","title":"5. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>unsafe {\n    // Unity verisini Nexus'a aktar\n    Vector3 myPos = transform.position;\n    float* targetPtr = registry.GetPointer&lt;Position&gt;(id);\n    myPos.CopyTo(targetPtr);\n\n    // Nexus'tan geri al\n    transform.position = targetPtr.ToVector3();\n}\n</code></pre>"},{"location":"API_References/NexusSmartExtensions_tr/#6-tam-kaynak-kod-direct-implementation","title":"6. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\npublic static class NexusSmartExtensions\n{\n    public static unsafe void CopyTo(this Vector3 v, float* ptr) {\n        ptr[0] = v.x; ptr[1] = v.y; ptr[2] = v.z;\n    }\n\n    public static unsafe Vector3 ToVector3(this float* ptr) {\n        return new Vector3(ptr[0], ptr[1], ptr[2]);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusSmartExtensions_tr/#nexus-optimization-tip-memory-alignment-check","title":"Nexus Optimization Tip: Memory Alignment Check","text":"<p><code>CopyTo</code> metodunu kullan\u0131rken hedef pointer'\u0131n 4-byte (float boyutu) hizal\u0131 oldu\u011fundan emin olun. <code>NexusLayout</code> zaten bu hizalamay\u0131 yapar. Hizal\u0131 olmayan bir adrese kopyalama yapmak, i\u015flemci seviyesinde \"Misaligned Access\" hatas\u0131na yol a\u00e7arak performans\u0131 %30 d\u00fc\u015f\u00fcrebilir.</p>"},{"location":"API_References/NexusStackable_eng/","title":"Nexus Prime Architectural Manual: NexusStackable (Cumulative Data Management)","text":""},{"location":"API_References/NexusStackable_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusStackable.cs</code> is a data container designed for \"Stackable Resources\" frequently encountered in games (e.g., Inventory items, Ammo, Money). Integrated from the HypeFire architecture, this structure is an intelligent unit managing both the amount and the capacity (Cap) of a value.</p> <p>The reason for this component's existence is to collect these logics under a single structure and integrate them with Unity's <code>UnityEvent</code> system to automatically trigger visual updates, instead of writing manual collection/subtraction/limit control for each resource type.</p>"},{"location":"API_References/NexusStackable_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Has the following features for container management:</p> <ul> <li>Capped Management: Prevents the value from exceeding a certain limit (Capacity). Provides dynamic capacity management with the <code>SetCap</code> method.</li> <li>Transactional Support: Checks whether the resource is sufficient with the <code>TrySpend</code> method and performs the expenditure in a single atomic transaction.</li> <li>Event-Driven Binding: By firing the <code>OnValueChanged</code> event (event) whenever the value changes, it ensures the UI layer (Slider, Text, etc.) is updated without depending on the code.</li> <li>Implicit Operator: Offers implicit conversion (implicit conversion) support allowing the structure to be used directly as an <code>int</code>.</li> </ul>"},{"location":"API_References/NexusStackable_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Definition: Defined as <code>NexusStackable&lt;AmmoTag&gt; Ammo;</code> within a <code>MonoBehaviour</code>.</li> <li>Constraint: The upper limit is determined with <code>SetCap(100)</code>.</li> <li>Process: When <code>Add(50)</code> is called, the amount increases but cannot exceed 100. A Unity event is fired at the moment of change.</li> <li>Control: When <code>TrySpend(20)</code> is called, if there are 20 units, they are spent and <code>true</code> is returned.</li> </ol>"},{"location":"API_References/NexusStackable_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>public class PlayerInventory : MonoBehaviour {\n    public NexusStackable&lt;GoldTag&gt; Gold = new();\n\n    void Start() {\n        Gold.SetCap(1000);\n        // Bind UI Slider to OnValueChanged event\n        Gold.OnValueChanged.AddListener((val) =&gt; Debug.Log(\"New Gold: \" + val));\n    }\n\n    public void BuyItem(int cost) {\n        if (Gold.TrySpend(cost)) {\n            // Purchase successful\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/NexusStackable_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\n[Serializable]\npublic class NexusStackable&lt;T&gt; where T : struct\n{\n    [SerializeField] private int _count;\n    [SerializeField] private int _cap = -1;\n    public UnityEvent&lt;int&gt; OnValueChanged = new();\n\n    public bool Add(int amount) {\n        if (_cap &gt;= 0 &amp;&amp; (_count + amount) &gt; _cap) return false;\n        _count += amount;\n        OnValueChanged.Invoke(_count);\n        return true;\n    }\n\n    public bool TrySpend(int amount) {\n        if (_count &lt; amount) return false;\n        _count -= amount;\n        OnValueChanged.Invoke(_count);\n        return true;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusStackable_eng/#nexus-optimization-tip-unityevent-overhead","title":"Nexus Optimization Tip: UnityEvent Overhead","text":"<p>If <code>Add</code> is triggered thousands of times in a frame, the use of <code>OnValueChanged</code> (UnityEvent) can create additional load on the CPU. For very high-frequency updates, using standard C# <code>Action</code> or \"Buffering\" (deferred triggering) the event firing until the next frame can increase performance by 5-10%.</p>"},{"location":"API_References/NexusStackable_tr/","title":"Nexus Prime Mimari Rehberi: NexusStackable (Birikimli Veri Y\u00f6netimi)","text":""},{"location":"API_References/NexusStackable_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusStackable.cs</code>, oyunlarda s\u0131k\u00e7a kar\u015f\u0131la\u015f\u0131lan \"Birikebilir Kaynaklar\" (\u00d6rn: Envanter e\u015fyalar\u0131, Cephane, Para) i\u00e7in tasarlanm\u0131\u015f bir veri konteyneridir. HypeFire mimarisinden entegre edilen bu yap\u0131, bir de\u011ferin hem miktar\u0131n\u0131 hem de kapasitesini (Cap) y\u00f6neten ak\u0131ll\u0131 bir birimdir.</p> <p>Bu bile\u015fenin varl\u0131k sebebi; her kaynak tipi i\u00e7in manuel toplama/\u00e7\u0131karma/limit kontrol\u00fc yazmak yerine, bu mant\u0131klar\u0131 tek bir yap\u0131 alt\u0131nda toplay\u0131p Unity'nin <code>UnityEvent</code> sistemiyle entegre ederek g\u00f6rsel g\u00fcncellemeleri otomatik tetikleyebilmektir.</p>"},{"location":"API_References/NexusStackable_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Konteyner y\u00f6netimi i\u00e7in \u015fu \u00f6zelliklere sahiptir:</p> <ul> <li>Capped Management: De\u011ferin belli bir s\u0131n\u0131r\u0131 (Capacity) a\u015fmas\u0131n\u0131 engeller. <code>SetCap</code> metodu ile dinamik kapasite y\u00f6netimi sa\u011flar.</li> <li>Transactional Support: <code>TrySpend</code> metodu ile kayna\u011f\u0131n yeterli olup olmad\u0131\u011f\u0131n\u0131 kontrol eder ve tek atomik i\u015flemde harcamay\u0131 ger\u00e7ekle\u015ftirir.</li> <li>Event-Driven Binding: De\u011fer her de\u011fi\u015fti\u011finde <code>OnValueChanged</code> olay\u0131n\u0131 (event) ate\u015fleyerek, UI katman\u0131n\u0131n (Slider, Text vb.) koda ba\u011f\u0131ml\u0131 olmadan g\u00fcncellenmesini sa\u011flar.</li> <li>Implicit Operator: Yap\u0131y\u0131 do\u011frudan <code>int</code> gibi kullanmaya olanak tan\u0131yan \u00f6rt\u00fck d\u00f6n\u00fc\u015f\u00fcm (implicit conversion) deste\u011fi sunar.</li> </ul>"},{"location":"API_References/NexusStackable_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tan\u0131mlama: Bir <code>MonoBehaviour</code> i\u00e7inde <code>NexusStackable&lt;AmmoTag&gt; Ammo;</code> olarak tan\u0131mlan\u0131r.</li> <li>K\u0131s\u0131tlama: <code>SetCap(100)</code> ile \u00fcst s\u0131n\u0131r belirlenir.</li> <li>\u0130\u015flem: <code>Add(50)</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda miktar artar ancak 100'\u00fc ge\u00e7emez. De\u011fi\u015fim an\u0131nda Unity event f\u0131rlat\u0131l\u0131r.</li> <li>Kontrol: <code>TrySpend(20)</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, e\u011fer 20 birim varsa harcan\u0131r ve <code>true</code> d\u00f6ner.</li> </ol>"},{"location":"API_References/NexusStackable_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public class PlayerInventory : MonoBehaviour {\n    public NexusStackable&lt;GoldTag&gt; Gold = new();\n\n    void Start() {\n        Gold.SetCap(1000);\n        // UI Slider'\u0131 OnValueChanged olay\u0131na ba\u011fla\n        Gold.OnValueChanged.AddListener((val) =&gt; Debug.Log(\"Yeni Alt\u0131n: \" + val));\n    }\n\n    public void BuyItem(int cost) {\n        if (Gold.TrySpend(cost)) {\n            // Sat\u0131n al\u0131m ba\u015far\u0131l\u0131\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/NexusStackable_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\n[Serializable]\npublic class NexusStackable&lt;T&gt; where T : struct\n{\n    [SerializeField] private int _count;\n    [SerializeField] private int _cap = -1;\n    public UnityEvent&lt;int&gt; OnValueChanged = new();\n\n    public bool Add(int amount) {\n        if (_cap &gt;= 0 &amp;&amp; (_count + amount) &gt; _cap) return false;\n        _count += amount;\n        OnValueChanged.Invoke(_count);\n        return true;\n    }\n\n    public bool TrySpend(int amount) {\n        if (_count &lt; amount) return false;\n        _count -= amount;\n        OnValueChanged.Invoke(_count);\n        return true;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusStackable_tr/#nexus-optimization-tip-unityevent-overhead","title":"Nexus Optimization Tip: UnityEvent Overhead","text":"<p>E\u011fer bir karede binlerce kez <code>Add</code> tetikleniyorsa, <code>OnValueChanged</code> (UnityEvent) kullan\u0131m\u0131 CPU \u00fczerinde ek y\u00fck olu\u015fturabilir. \u00c7ok y\u00fcksek frekansl\u0131 g\u00fcncellemeler i\u00e7in standart C# <code>Action</code> kullanmak veya event f\u0131rlatmay\u0131 bir sonraki kareye kadar \"Buffer\"lamak (ertelenmi\u015f tetikleme) performans\u0131 %5-10 art\u0131rabilir.</p>"},{"location":"API_References/NexusStateMachine_eng/","title":"Nexus Prime Architectural Manual: NexusStateMachine (State Manager)","text":""},{"location":"API_References/NexusStateMachine_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusStateMachine.cs</code> is a \"Behavioral Orchestrator\" that divides complex object behaviors (e.g., player movement states, NPC AI, game loop phases) into controllable and modular parts. Thanks to being designed as a MonoBehaviour, it works fully compatible with Unity scenes.</p> <p>The reason for this machine's existence is to prevent massive code blocks consisting of \"If-Else\" stacks and to divide each state (State) into categories that are isolated, testable, and expandable within themselves.</p>"},{"location":"API_References/NexusStateMachine_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Applies the following architectural standards for state management:</p> <ul> <li>Interface-Based States: Each state implements the <code>IState</code> interface (interface). In this way, the state lifecycle is standardized by making <code>Enter</code> (Enter), <code>Update</code> (Update), and <code>Exit</code> (Exit) methods mandatory.</li> <li>Atomic State Switching: While switching from one state to another with the <code>ChangeState</code> method, it ensures that the <code>Exit</code> logic of the old state and the <code>Enter</code> logic of the new state work error-free and in order.</li> <li>Update Delegation: Automatically calls the <code>Update</code> method of the current active state every frame, delegating logical execution (logic execution) to the current state.</li> <li>Flexible Integration: It is flexible enough to trigger both pure code-based states and Unity Animator transitions.</li> </ul>"},{"location":"API_References/NexusStateMachine_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Enter (Enter): Triggered once when entering a new state (e.g., start the walking animation).</li> <li>Loop (Update): Runs every frame as long as the state is active (e.g., check speed).</li> <li>Transition (Change): When a condition occurs (e.g., jump key pressed), a signal to transition to a new state is given.</li> <li>Exit (Exit): Triggered once just before leaving the state (e.g., close the dust effect).</li> </ol>"},{"location":"API_References/NexusStateMachine_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>public class PlayerController : MonoBehaviour {\n    private NexusStateMachine _sm;\n\n    void Start() {\n        _sm = gameObject.AddComponent&lt;NexusStateMachine&gt;();\n        _sm.ChangeState(new IdleState());\n    }\n\n    void Update() {\n        if (Input.GetKeyDown(KeyCode.Space)) _sm.ChangeState(new JumpState());\n    }\n}\n</code></pre>"},{"location":"API_References/NexusStateMachine_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Communication;\n\npublic class NexusStateMachine : MonoBehaviour\n{\n    public interface IState {\n        void Enter();\n        void Update();\n        void Exit();\n    }\n\n    private IState _currentState;\n\n    public void ChangeState(IState newState) {\n        _currentState?.Exit();\n        _currentState = newState;\n        _currentState?.Enter();\n    }\n\n    void Update() =&gt; _currentState?.Update();\n}\n</code></pre>"},{"location":"API_References/NexusStateMachine_eng/#nexus-optimization-tip-state-pooling","title":"Nexus Optimization Tip: State Pooling","text":"<p>If you are changing states dozens of times per second (e.g., very fast changing AI decisions), store state classes in a \"Pool\" (Pool) and reuse them instead of creating them with <code>new</code> every time. This will reduce pressure on the Garbage Collector (GC) by 25%.</p>"},{"location":"API_References/NexusStateMachine_tr/","title":"Nexus Prime Mimari Rehberi: NexusStateMachine (Durum Y\u00f6neticisi)","text":""},{"location":"API_References/NexusStateMachine_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusStateMachine.cs</code>, karma\u015f\u0131k nesne davran\u0131\u015flar\u0131n\u0131 (\u00d6rn: Oyuncu hareket durumlar\u0131, NPC yapay zekas\u0131, Oyun d\u00f6ng\u00fcs\u00fc a\u015famalar\u0131) kontrol edilebilir ve mod\u00fcler par\u00e7alara ay\u0131ran bir \"Davran\u0131\u015f Orkestrat\u00f6r\u00fc\"d\u00fcr. MonoBehaviour olarak tasarlanm\u0131\u015f olmas\u0131 sayesinde Unity sahneleriyle tam uyumlu \u00e7al\u0131\u015f\u0131r.</p> <p>Bu makinenin varl\u0131k sebebi; \"If-Else\" y\u0131\u011f\u0131nlar\u0131ndan olu\u015fan devasa kod bloklar\u0131n\u0131 engellemek ve her durumu (State) kendi i\u00e7inde izole, test edilebilir ve geni\u015fletilebilir s\u0131n\u0131flara b\u00f6lmektir.</p>"},{"location":"API_References/NexusStateMachine_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Durum y\u00f6netimi i\u00e7in \u015fu mimari standartlar\u0131 uygular:</p> <ul> <li>Interface-Based States: Her durum <code>IState</code> aray\u00fcz\u00fcn\u00fc (interface) implemente eder. Bu sayede <code>Enter</code> (Giri\u015f), <code>Update</code> (G\u00fcncelleme) ve <code>Exit</code> (\u00c7\u0131k\u0131\u015f) metodlar\u0131 zorunlu k\u0131l\u0131narak durum ya\u015fam d\u00f6ng\u00fcs\u00fc standartla\u015ft\u0131r\u0131l\u0131r.</li> <li>Atomic State Switching: <code>ChangeState</code> metodu ile bir durumdan di\u011ferine ge\u00e7erken, eski durumun <code>Exit</code> logic'i ile yeni durumun <code>Enter</code> logic'inin hatas\u0131z ve s\u0131ral\u0131 \u00e7al\u0131\u015fmas\u0131n\u0131 sa\u011flar.</li> <li>Update Delegation: Mevcut aktif durumun <code>Update</code> metodunu her karede otomatik olarak \u00e7a\u011f\u0131rarak, mant\u0131ksal y\u00fcr\u00fct\u00fcm\u00fc (logic execution) o anki duruma delege eder.</li> <li>Flexible Integration: Hem saf kod tabanl\u0131 durumlar\u0131 hem de Unity Animator transition'lar\u0131n\u0131 tetikleyebilecek kadar esnektir.</li> </ul>"},{"location":"API_References/NexusStateMachine_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Giri\u015f (Enter): Yeni duruma ge\u00e7ildi\u011finde bir kez tetiklenir (\u00d6rn: Y\u00fcr\u00fcme animasyonunu ba\u015flat).</li> <li>D\u00f6ng\u00fc (Update): Durum aktif oldu\u011fu s\u00fcrece her karede \u00e7al\u0131\u015f\u0131r (\u00d6rn: H\u0131z\u0131 kontrol et).</li> <li>Ge\u00e7i\u015f (Change): Bir ko\u015ful olu\u015ftu\u011funda (\u00d6rn: Z\u0131plama tu\u015funa bas\u0131ld\u0131) yeni bir duruma ge\u00e7i\u015f sinyali verilir.</li> <li>\u00c7\u0131k\u0131\u015f (Exit): Durumdan ayr\u0131lmadan hemen \u00f6nce bir kez tetiklenir (\u00d6rn: Toz efektini kapat).</li> </ol>"},{"location":"API_References/NexusStateMachine_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public class PlayerController : MonoBehaviour {\n    private NexusStateMachine _sm;\n\n    void Start() {\n        _sm = gameObject.AddComponent&lt;NexusStateMachine&gt;();\n        _sm.ChangeState(new IdleState());\n    }\n\n    void Update() {\n        if (Input.GetKeyDown(KeyCode.Space)) _sm.ChangeState(new JumpState());\n    }\n}\n</code></pre>"},{"location":"API_References/NexusStateMachine_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Communication;\n\npublic class NexusStateMachine : MonoBehaviour\n{\n    public interface IState {\n        void Enter();\n        void Update();\n        void Exit();\n    }\n\n    private IState _currentState;\n\n    public void ChangeState(IState newState) {\n        _currentState?.Exit();\n        _currentState = newState;\n        _currentState?.Enter();\n    }\n\n    void Update() =&gt; _currentState?.Update();\n}\n</code></pre>"},{"location":"API_References/NexusStateMachine_tr/#nexus-optimization-tip-state-pooling","title":"Nexus Optimization Tip: State Pooling","text":"<p>E\u011fer saniyede onlarca kez durum de\u011fi\u015ftiriyorsan\u0131z (\u00d6rn: \u00c7ok h\u0131zl\u0131 de\u011fi\u015fen AI kararlar\u0131), durum s\u0131n\u0131flar\u0131n\u0131 her seferinde <code>new</code> ile olu\u015fturmak yerine bir \"Pool\" (Havuz) i\u00e7inde saklay\u0131p tekrar kullan\u0131n. Bu, Garbage Collector (GC) \u00fczerindeki bask\u0131y\u0131 %25 azaltacakt\u0131r.</p>"},{"location":"API_References/NexusStatus_eng/","title":"Nexus Prime Architectural Manual: NexusStatus (Status and Resource Management)","text":""},{"location":"API_References/NexusStatus_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusStatus.cs</code> is a data template that manages critical survival resources of entities (Health, Mana, Energy, etc.) and RPG-style attributes (Strength, Agility, etc.) on unmanaged memory. Inspired by the HypeFire framework architecture, this structure is designed to monitor the status of thousands of units in high-performance games.</p> <p>The reason for this structure's existence is to reduce the cache-miss rate by clustering data within hardware-friendly components (Components), instead of creating separate classes for each enemy unit or bullet, and to ensure that systems reach this data in the fastest way.</p>"},{"location":"API_References/NexusStatus_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>In terms of physical data alignment (Memory Layout), it presents two critical structures:</p> <ul> <li>NexusStatus: Houses two \"Current/Max\" pairs (Health and Mana). Speeds up visualization processes with helper properties (helper properties) like <code>IsDead</code>, <code>HealthPercent</code>. <code>Damage</code> and <code>Heal</code> methods safely update unmanaged data with <code>MathF.Max/Min</code>.</li> <li>NexusAttributeStats: Stores standard RPG statistics (<code>Strength</code>, <code>Agility</code>, <code>Intelligence</code>, <code>Stamina</code>) as a block in <code>int</code> type. These data typically combine with <code>NexusStackable</code> to form final combat figures.</li> </ul>"},{"location":"API_References/NexusStatus_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Definition: Defined as <code>NexusStatus Vitality</code> within a component (Component).</li> <li>Effect: A damage system directly updates the value at the unmanaged memory address by calling <code>Vitality.Damage(50)</code>.</li> <li>Control: Systems performing death control decide whether the entity will be destroyed or not by looking at the <code>Vitality.IsDead</code> flag.</li> <li>UI Update: Health bars are updated using <code>HealthPercent</code>.</li> </ol>"},{"location":"API_References/NexusStatus_eng/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Term Description Vitality Tracking Constant monitoring of an entity's survival parameters. Encapsulated Logic Combining methods and data within the same struct in accordance with unmanaged rules. RPG Stats Set of numerical attributes determining the character's basic skills."},{"location":"API_References/NexusStatus_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Extended Resources: If your project requires not just Health/Mana but 5-6 different resources like \"Stamina\", \"Oxygen\", it is necessary to extend this struct or add new components.</li> <li>State Loss: Since it is unmanaged, data is completely lost when components containing these structures are deleted (unless a Snapshot was taken).</li> </ul>"},{"location":"API_References/NexusStatus_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>public struct EnemyStatus : INexusComponent {\n    public NexusStatus Vitals;\n    public NexusAttributeStats Stats;\n}\n\n// Usage within the system\nref var enemy = ref registry.Get&lt;EnemyStatus&gt;(id);\nenemy.Vitals.Damage(10);\n\nif (enemy.Vitals.IsDead) {\n    Console.WriteLine(\"Enemy eliminated.\");\n}\n</code></pre>"},{"location":"API_References/NexusStatus_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Data;\n\npublic struct NexusStatus\n{\n    public float CurrentHealth;\n    public float MaxHealth;\n    public float CurrentMana;\n    public float MaxMana;\n\n    public bool IsDead =&gt; CurrentHealth &lt;= 0;\n    public float HealthPercent =&gt; MaxHealth &gt; 0 ? CurrentHealth / MaxHealth : 0;\n\n    public void Damage(float amount) =&gt; CurrentHealth = MathF.Max(0, CurrentHealth - amount);\n    public void Heal(float amount) =&gt; CurrentHealth = MathF.Min(MaxHealth, CurrentHealth + amount);\n}\n</code></pre>"},{"location":"API_References/NexusStatus_eng/#nexus-optimization-tip-memory-pooling","title":"Nexus Optimization Tip: Memory Pooling","text":"<p>Instead of creating and deleting <code>NexusStatus</code> components thousands of times per second, take advantage of the <code>AutomaticInternalPooling</code> system. This reduces the memory management load on the processor by 30% by preventing unmanaged memory pages from being constantly requested from the OS.</p>"},{"location":"API_References/NexusStatus_tr/","title":"Nexus Prime Mimari Rehberi: NexusStatus (Durum ve Kaynak Y\u00f6netimi)","text":""},{"location":"API_References/NexusStatus_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusStatus.cs</code>, varl\u0131klar\u0131n temel ya\u015famsal kaynaklar\u0131n\u0131 (Can, Mana, Enerji vb.) ve RPG tarz\u0131 niteliklerini (G\u00fc\u00e7, \u00c7eviklik vb.) unmanaged bellek \u00fczerinde y\u00f6neten bir veri \u015fablonudur. HypeFire framework mimarisinden esinlenilen bu yap\u0131, y\u00fcksek performansl\u0131 oyunlarda binlerce birimin durum takibini yapmak i\u00e7in tasarlanm\u0131\u015ft\u0131r.</p> <p>Bu yap\u0131n\u0131n varl\u0131k sebebi; her d\u00fc\u015fman birimi veya mermi i\u00e7in ayr\u0131 s\u0131n\u0131flar olu\u015fturmak yerine, veriyi donan\u0131m dostu bile\u015fenler (Components) i\u00e7inde k\u00fcmeleyerek cache-miss oran\u0131n\u0131 d\u00fc\u015f\u00fcrmek ve sistemlerin bu verilere en h\u0131zl\u0131 \u015fekilde ula\u015fmas\u0131n\u0131 sa\u011flamakt\u0131r.</p>"},{"location":"API_References/NexusStatus_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Fiziksel veri dizilimi (Memory Layout) a\u00e7\u0131s\u0131ndan kritik iki yap\u0131 sunar:</p> <ul> <li>NexusStatus: \u0130ki adet \"Mevcut/Maksimum\" \u00e7iftini (Health ve Mana) bar\u0131nd\u0131r\u0131r. <code>IsDead</code>, <code>HealthPercent</code> gibi yard\u0131mc\u0131 \u00f6zellikler (helper properties) ile g\u00f6rselle\u015ftirme s\u00fcre\u00e7lerini h\u0131zland\u0131r\u0131r. <code>Damage</code> ve <code>Heal</code> metodlar\u0131 unmanaged veriyi <code>MathF.Max/Min</code> ile g\u00fcvenli bir \u015fekilde g\u00fcnceller.</li> <li>NexusAttributeStats: Standart RPG istatistiklerini (<code>Strength</code>, <code>Agility</code>, <code>Intelligence</code>, <code>Stamina</code>) <code>int</code> tipinde bir blok olarak saklar. Bu veriler tipik olarak <code>NexusStackable</code> ile birle\u015ferek final sava\u015f fig\u00fcrlerini olu\u015fturur.</li> </ul>"},{"location":"API_References/NexusStatus_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tan\u0131mlama: Bile\u015fen (Component) i\u00e7inde <code>NexusStatus Vitality</code> olarak tan\u0131mlan\u0131r.</li> <li>Etki: Bir hasar sistemi, <code>Vitality.Damage(50)</code> \u00e7a\u011fr\u0131s\u0131 yaparak unmanaged bellek adresindeki de\u011feri do\u011frudan g\u00fcnceller.</li> <li>Kontrol: \u00d6l\u00fcm kontrol\u00fc yapan sistemler, <code>Vitality.IsDead</code> bayra\u011f\u0131na bakarak varl\u0131\u011f\u0131n yok edilip edilmeyece\u011fine karar verir.</li> <li>UI G\u00fcncelleme: <code>HealthPercent</code> kullan\u0131larak can barlar\u0131 g\u00fcncellenir.</li> </ol>"},{"location":"API_References/NexusStatus_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Vitality Tracking Bir varl\u0131\u011f\u0131n hayatta kalma parametrelerinin s\u00fcrekli izlenmesi. Encapsulated Logic Metodlar\u0131n ve verinin ayn\u0131 struct i\u00e7inde, unmanaged kurallara uygun \u015fekilde birle\u015fmesi. RPG Stats Karakterin temel yeteneklerini belirleyen say\u0131sal nitelikler k\u00fcmesi."},{"location":"API_References/NexusStatus_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Extended Resources: E\u011fer projenizde sadece Health/Mana de\u011fil, \"Stamina\", \"Oxygen\" gibi 5-6 farkl\u0131 kaynak gerekiyorsa, bu struct'\u0131 geni\u015fletmek veya yeni bile\u015fenler eklemek gerekir.</li> <li>State Loss: Unmanaged oldu\u011fu i\u00e7in, bu yap\u0131lar\u0131 i\u00e7eren bile\u015fenler silindi\u011finde veriler tamamen kaybolur (Snapshot al\u0131nmad\u0131ysa).</li> </ul>"},{"location":"API_References/NexusStatus_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public struct EnemyStatus : INexusComponent {\n    public NexusStatus Vitals;\n    public NexusAttributeStats Stats;\n}\n\n// Sistem i\u00e7inde kullan\u0131m\nref var enemy = ref registry.Get&lt;EnemyStatus&gt;(id);\nenemy.Vitals.Damage(10);\n\nif (enemy.Vitals.IsDead) {\n    Console.WriteLine(\"D\u00fc\u015fman elendi.\");\n}\n</code></pre>"},{"location":"API_References/NexusStatus_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Data;\n\npublic struct NexusStatus\n{\n    public float CurrentHealth;\n    public float MaxHealth;\n    public float CurrentMana;\n    public float MaxMana;\n\n    public bool IsDead =&gt; CurrentHealth &lt;= 0;\n    public float HealthPercent =&gt; MaxHealth &gt; 0 ? CurrentHealth / MaxHealth : 0;\n\n    public void Damage(float amount) =&gt; CurrentHealth = MathF.Max(0, CurrentHealth - amount);\n    public void Heal(float amount) =&gt; CurrentHealth = MathF.Min(MaxHealth, CurrentHealth + amount);\n}\n</code></pre>"},{"location":"API_References/NexusStatus_tr/#nexus-optimization-tip-memory-pooling","title":"Nexus Optimization Tip: Memory Pooling","text":"<p><code>NexusStatus</code> bile\u015fenlerini saniyede binlerce kez olu\u015fturup silmek yerine, <code>AutomaticInternalPooling</code> sisteminden faydalan\u0131n. Bu, unmanaged bellek sayfalar\u0131n\u0131n s\u00fcrekli OS'ten istenmesini engelleyerek i\u015flemci \u00fczerindeki memory management y\u00fck\u00fcn\u00fc %30 azalt\u0131r.</p>"},{"location":"API_References/NexusString_eng/","title":"Nexus Prime Architectural Manual: NexusString (Fixed-Size Unmanaged Text)","text":""},{"location":"API_References/NexusString_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusString.cs</code> is the text storage system optimized for unmanaged memory, developed with Nexus Prime's \"Zero-GC\" philosophy. Standard C# strings (<code>System.String</code>) are managed objects (Managed Objects) and can never be stored within an <code>unmanaged</code> (blittable) struct or in raw memory buffers.</p> <p>The reason for these structures' existence is to be able to keep each entity's name, tag, or status message as a fixed-size memory block directly within the component (Component) without ever triggering the Garbage Collector (GC) and without creating memory clutter.</p>"},{"location":"API_References/NexusString_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The NexusString suite offers the following pre-defined sizes for different needs:</p> <ul> <li>NexusString32: The smallest unit storing 31 characters + 1 byte length (Length). Ideal for short tags like \"PlayerName\", \"Status\".</li> <li>NexusString64: Offers 63 characters + 1 byte capacity. Used for file paths or medium-length descriptions.</li> <li>NexusString128: Offers a wide area of 127 characters.</li> <li>Fixed Byte Buffer: Each structure embeds the data directly into the struct body on the stack or heap using <code>fixed byte _data[N]</code>. This prevents the processor from jumping to an additional memory address (Reference) to reach the text.</li> <li>UTF8 Encoding: Data is stored as raw UTF8 bytes for memory savings and universal compatibility.</li> </ul>"},{"location":"API_References/NexusString_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Conversion (Constructor): When a managed string is received, it is converted into a byte array with <code>Encoding.UTF8.GetBytes</code>.</li> <li>Capping: If the text is larger than the determined size (e.g., 32 bytes), the data is safely cut.</li> <li>Copying: Data is copied directly to the unmanaged buffer (<code>_data</code>) via <code>ReadOnlySpan&lt;byte&gt;</code>.</li> <li>Reading (ToString): When needed (e.g., UI), raw bytes are converted back to a C# string.</li> </ol>"},{"location":"API_References/NexusString_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Fixed Buffer A memory block whose size is determined at compile-time and that does not change position. UTF8 Universal encoding representing characters using variable-length bytes. Blittable A data type whose memory structure is identical in the managed and unmanaged worlds. Heap-Free The state of not using the managed memory heap (Heap) during the process."},{"location":"API_References/NexusString_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Truncation: Texts exceeding the fixed size (e.g., 32) are silently cut. For long descriptions, larger variants (128) should be selected.</li> <li>Reconstruction Cost: Since the <code>ToString()</code> method creates a new managed string (Allocation), frequent use of this method in system cycles (Internal Loops) can create GC pressure on performance. It should only be called during visualization.</li> </ul>"},{"location":"API_References/NexusString_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>public struct ActorName : INexusComponent {\n    public NexusString32 Value; // Takes up 32 bytes directly within the component\n}\n\n// Usage\nvar name = new ActorName();\nname.Value = \"Hero_One\"; // Standard string can be assigned thanks to implicit cast\n\nConsole.WriteLine(name.Value.ToString()); // \"Hero_One\"\n</code></pre>"},{"location":"API_References/NexusString_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>public unsafe struct NexusString32\n{\n    private fixed byte _data[32];\n    private byte _length;\n\n    public NexusString32(string? value)\n    {\n        if (string.IsNullOrEmpty(value)) { _length = 0; return; }\n        ReadOnlySpan&lt;byte&gt; source = Encoding.UTF8.GetBytes(value);\n        _length = (byte)Math.Min(source.Length, 31);\n        fixed (byte* ptr = _data) source.Slice(0, _length).CopyTo(new Span&lt;byte&gt;(ptr, 31));\n    }\n\n    public override string ToString() {\n        fixed (byte* ptr = _data) return Encoding.UTF8.GetString(ptr, _length);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusString_eng/#nexus-optimization-tip-memory-footprint","title":"Nexus Optimization Tip: Memory Footprint","text":"<p>Using NexusString increases memory locality (locality). Using <code>NexusString32</code> within an unmanaged buffer instead of using a <code>List&lt;string&gt;</code> reduces the number of memory jumps the processor will make to reach the text to 1 and increases access speed by 50-60%.</p>"},{"location":"API_References/NexusString_tr/","title":"Nexus Prime Mimari Rehberi: NexusString (Sabit Boyutlu Unmanaged Metinler)","text":""},{"location":"API_References/NexusString_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusString.cs</code>, Nexus Prime'\u0131n \"Zero-GC\" felsefesiyle geli\u015ftirdi\u011fi, unmanaged bellek i\u00e7in optimize edilmi\u015f metin saklama sistemidir. Standart C# stringleri (<code>System.String</code>) y\u00f6netilen objelerdir (Managed Objects) ve asla <code>unmanaged</code> (blittable) bir struct i\u00e7inde veya ham bellek tamponlar\u0131nda saklanamazlar.</p> <p>Bu yap\u0131lar\u0131n varl\u0131k sebebi; her varl\u0131\u011f\u0131n ismini, etiketini veya durum mesaj\u0131n\u0131, Garbage Collector'\u0131 (GC) hi\u00e7 tetiklemeden ve bellek da\u011f\u0131n\u0131kl\u0131\u011f\u0131 yaratmadan do\u011frudan bile\u015fenin (Component) i\u00e7inde sabit boyutlu bir bellek blo\u011fu olarak tutabilmektir.</p>"},{"location":"API_References/NexusString_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusStringsuite, farkl\u0131 ihtiya\u00e7lar i\u00e7in \u015fu \u00f6n-tan\u0131ml\u0131 boyutlar\u0131 sunar:</p> <ul> <li>NexusString32: 31 karakter + 1 byte uzunluk (Length) saklayan en k\u00fc\u00e7\u00fck birimdir. \"PlayerName\", \"Status\" gibi k\u0131sa etiketler i\u00e7in idealdir.</li> <li>NexusString64: 63 karakter + 1 byte kapasite sunar. Dosya yollar\u0131 veya orta uzunlukta a\u00e7\u0131klamalar i\u00e7in kullan\u0131l\u0131r.</li> <li>NexusString128: 127 karakterlik geni\u015f alan sunar.</li> <li>Fixed Byte Buffer: Her yap\u0131, <code>fixed byte _data[N]</code> kullanarak veriyi do\u011frudan stack veya heap \u00fczerindeki struct g\u00f6vdesine g\u00f6mer. Bu, i\u015flemcinin metne ula\u015fmak i\u00e7in ek bir bellek adresi (Reference) atlamas\u0131na engel olur.</li> <li>UTF8 Encoding: Veriler, bellek tasarrufu ve evrensel uyumluluk i\u00e7in ham UTF8 byte'lar\u0131 olarak saklan\u0131r.</li> </ul>"},{"location":"API_References/NexusString_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>D\u00f6n\u00fc\u015ft\u00fcrme (Constructor): Managed bir string al\u0131nd\u0131\u011f\u0131nda <code>Encoding.UTF8.GetBytes</code> ile byte dizisine d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcr.</li> <li>Kesme (Capping): E\u011fer metin belirlenen boyuttan (\u00d6rn: 32 byte) b\u00fcy\u00fckse, veri g\u00fcvenli bir \u015fekilde kesilir.</li> <li>Kopyalama: Veri, <code>ReadOnlySpan&lt;byte&gt;</code> \u00fczerinden do\u011frudan unmanaged buffer'a (<code>_data</code>) kopyalan\u0131r.</li> <li>Okuma (ToString): \u0130htiya\u00e7 duyuldu\u011funda (\u00d6rn: UI), ham byte'lar tekrar C# string'ine d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcr.</li> </ol>"},{"location":"API_References/NexusString_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Fixed Buffer Boyutu derleme zaman\u0131nda belirlenmi\u015f, yer de\u011fi\u015ftirmeyen bellek blo\u011fu. UTF8 Karakterleri de\u011fi\u015fken uzunlukta byte'lar kullanarak temsil eden evrensel kodlama. Blittable Bellek yap\u0131s\u0131 managed ve unmanaged d\u00fcnyada birebir ayn\u0131 olan veri tipi. Heap-Free \u0130\u015flem s\u0131ras\u0131nda y\u00f6netilen bellek y\u0131\u011f\u0131n\u0131n\u0131 (Heap) hi\u00e7 kullanmama durumu."},{"location":"API_References/NexusString_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Truncation: Sabit boyutu (\u00d6rn: 32) a\u015fan metinler sessizce kesilir. Uzun a\u00e7\u0131klamalar i\u00e7in b\u00fcy\u00fck varyantlar (128) se\u00e7ilmelidir.</li> <li>Reconstruction Cost: <code>ToString()</code> metodu yeni bir managed string olu\u015fturdu\u011fu i\u00e7in (Allocation), bu metodun sistem d\u00f6ng\u00fclerinde (Internal Loops) s\u0131k kullan\u0131lmas\u0131 performans \u00fczerinde GC bask\u0131s\u0131 yaratabilir. Sadece g\u00f6rselle\u015ftirme an\u0131nda \u00e7a\u011fr\u0131lmal\u0131d\u0131r.</li> </ul>"},{"location":"API_References/NexusString_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public struct ActorName : INexusComponent {\n    public NexusString32 Value; // Do\u011frudan bile\u015fen i\u00e7inde 32 byte yer kaplar\n}\n\n// Kullan\u0131m\nvar name = new ActorName();\nname.Value = \"Hero_One\"; // Implicit cast sayesinde standart string atanabilir\n\nConsole.WriteLine(name.Value.ToString()); // \"Hero_One\"\n</code></pre>"},{"location":"API_References/NexusString_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>public unsafe struct NexusString32\n{\n    private fixed byte _data[32];\n    private byte _length;\n\n    public NexusString32(string? value)\n    {\n        if (string.IsNullOrEmpty(value)) { _length = 0; return; }\n        ReadOnlySpan&lt;byte&gt; source = Encoding.UTF8.GetBytes(value);\n        _length = (byte)Math.Min(source.Length, 31);\n        fixed (byte* ptr = _data) source.Slice(0, _length).CopyTo(new Span&lt;byte&gt;(ptr, 31));\n    }\n\n    public override string ToString() {\n        fixed (byte* ptr = _data) return Encoding.UTF8.GetString(ptr, _length);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusString_tr/#nexus-optimization-tip-memory-footprint","title":"Nexus Optimization Tip: Memory Footprint","text":"<p>NexusString kullan\u0131m\u0131, bellek yerelli\u011fini (locality) art\u0131r\u0131r. Bir <code>List&lt;string&gt;</code> kullanmak yerine unmanaged bir buffer i\u00e7inde <code>NexusString32</code> kullanmak, i\u015flemcinin metne ula\u015fmak i\u00e7in yapaca\u011f\u0131 bellek atlama (Memory Jump) say\u0131s\u0131n\u0131 1'e indirir ve eri\u015fim h\u0131z\u0131n\u0131 %50-60 art\u0131r\u0131r.</p>"},{"location":"API_References/NexusSwerveController_eng/","title":"Nexus Prime Architectural Manual: NexusSwerveController (Swerve/Swipe Controller)","text":""},{"location":"API_References/NexusSwerveController_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusSwerveController.cs</code> is a specialized controller managing the \"Horizontal Swipe\" (Swerve) mechanic frequently encountered particularly in mobile and hyper-casual game genres. It converts <code>NexusSwerveInput</code> data, formed by the player dragging their finger or mouse left-right, into smooth horizontal movement of the object on the world.</p> <p>The reason for this controller's existence is to reduce precise touch data on mobile platforms to a smooth, vibration-free, and bounded movement in the game world.</p>"},{"location":"API_References/NexusSwerveController_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Uses the following techniques for the swipe mechanic:</p> <ul> <li>Input Integration: Takes the <code>MoveFactorX</code> value (how much the finger has swiped since the last frame) coming from the <code>NexusSwerveInput</code> component as the basic input.</li> <li>Dynamic Clamping: Prevents the object from going outside a specific horizontal corridor in the scene with <code>Mathf.Clamp</code> (<code>MaxSwerveAmount</code>).</li> <li>Speed Scaling: Multiplies movement speed by <code>SwerveSpeed</code> and <code>Time.deltaTime</code>, ensuring a consistent swipe speed at any touch screen speed.</li> <li>Local Space Movement: By performing the movement via <code>localPosition</code>, it facilitates the object going only left-right while staying attached to a higher hierarchy (e.g., a path parent continuously going forward).</li> </ul>"},{"location":"API_References/NexusSwerveController_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Input Reading: The amount of horizontal change of the finger (or mouse) is taken.</li> <li>Calculation: \"Potential New X\" is found by adding the swipe amount to the current X position.</li> <li>Constraint: Potential X is forced within the limits allowed by the game (e.g., between -2 and +2).</li> <li>Application: The new smooth position is assigned to the object.</li> </ol>"},{"location":"API_References/NexusSwerveController_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// For character left-right swiping in a Runner type game:\n// 1. Add [NexusSwerveInput] to the object.\n// 2. Add [NexusSwerveController] to the object.\n// 3. Set SwerveSpeed = 10, MaxSwerveAmount = 3.5.\n</code></pre>"},{"location":"API_References/NexusSwerveController_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity.Controllers;\n\npublic class NexusSwerveController : MonoBehaviour\n{\n    public float SwerveSpeed = 5f;\n    public float MaxSwerveAmount = 2f;\n    [SerializeField] private NexusSwerveInput _input;\n\n    private void Update() {\n        float swerveAmount = Time.deltaTime * SwerveSpeed * _input.MoveFactorX;\n        float targetX = Mathf.Clamp(transform.localPosition.x + swerveAmount, -MaxSwerveAmount, MaxSwerveAmount);\n        transform.localPosition = new Vector3(targetX, transform.localPosition.y, transform.localPosition.z);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusSwerveController_eng/#nexus-optimization-tip-input-smoothing","title":"Nexus Optimization Tip: Input Smoothing","text":"<p>Instead of using the raw data in <code>NexusSwerveInput</code> directly, pass it through a <code>Lerp</code> or <code>SmoothDamp</code> layer within <code>SwerveController</code>. This prevents hard stops that may occur if the player pulls their finger suddenly and provides a \"Premium\" feel.</p>"},{"location":"API_References/NexusSwerveController_tr/","title":"Nexus Prime Mimari Rehberi: NexusSwerveController (Swerve/Kayd\u0131rma Kontrol\u00f6r\u00fc)","text":""},{"location":"API_References/NexusSwerveController_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusSwerveController.cs</code>, \u00f6zellikle mobil ve hyper-casual oyun t\u00fcrlerinde s\u0131k\u00e7a rastlanan \"Yatay Kayd\u0131rma\" (Swerve) mekani\u011fini y\u00f6neten bir uzman kontrol\u00f6rd\u00fcr. Oyuncunun parma\u011f\u0131n\u0131 veya faresini sa\u011fa-sola s\u00fcr\u00fcklemesiyle olu\u015fan <code>NexusSwerveInput</code> verisini, nesnenin d\u00fcnya \u00fczerindeki p\u00fcr\u00fczs\u00fcz yatay hareketine d\u00f6n\u00fc\u015ft\u00fcr\u00fcr.</p> <p>Bu kontrol\u00f6r\u00fcn varl\u0131k sebebi; mobil platformlardaki hassas dokunma verilerini, oyun d\u00fcnyas\u0131nda p\u00fcr\u00fczs\u00fcz, sars\u0131nt\u0131s\u0131z ve s\u0131n\u0131rlar\u0131 belirli bir harekete indirgemektir.</p>"},{"location":"API_References/NexusSwerveController_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Kayd\u0131rma mekani\u011fi i\u00e7in \u015fu teknikleri kullan\u0131r:</p> <ul> <li>Input Integration: <code>NexusSwerveInput</code> bile\u015feninden gelen <code>MoveFactorX</code> (parma\u011f\u0131n son kareden beri ne kadar kayd\u0131\u011f\u0131) de\u011ferini temel girdi olarak al\u0131r.</li> <li>Dynamic Clamping: Nesnenin sahnede belirli bir yatay koridorun d\u0131\u015f\u0131na \u00e7\u0131kmas\u0131n\u0131 <code>Mathf.Clamp</code> ile engeller (<code>MaxSwerveAmount</code>).</li> <li>Speed Scaling: Hareketin h\u0131z\u0131n\u0131 <code>SwerveSpeed</code> ve <code>Time.deltaTime</code> ile \u00e7arparak, her t\u00fcrl\u00fc dokunmatik ekran h\u0131z\u0131nda tutarl\u0131 bir kayd\u0131rma sa\u011flar.</li> <li>Local Space Movement: Hareketi <code>localPosition</code> \u00fczerinden yaparak, nesnenin bir \u00fcst hiyerar\u015fiye (\u00d6rn: S\u00fcrekli ileri giden bir yol parent'\u0131) ba\u011fl\u0131 kalarak sadece sa\u011fa-sola gitmesini kolayla\u015ft\u0131r\u0131r.</li> </ul>"},{"location":"API_References/NexusSwerveController_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Girdi Okuma: Parma\u011f\u0131n (veya farenin) yatay de\u011fi\u015fim miktar\u0131 al\u0131n\u0131r.</li> <li>Hesaplama: Mevcut X pozisyonuna kayd\u0131rma miktar\u0131 eklenerek \"Potansiyel Yeni X\" bulunur.</li> <li>K\u0131s\u0131tlama: Potansiyel X, oyunun izin verdi\u011fi s\u0131n\u0131rlar i\u00e7ine (\u00d6rn: -2 ile +2 aras\u0131) zorlan\u0131r.</li> <li>Uygulama: Yeni p\u00fcr\u00fczs\u00fcz pozisyon nesneye atan\u0131r.</li> </ol>"},{"location":"API_References/NexusSwerveController_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Runner tipi bir oyunda karakterin sa\u011fa sola kaymas\u0131 i\u00e7in:\n// 1. Nesneye [NexusSwerveInput] ekle.\n// 2. Nesneye [NexusSwerveController] ekle.\n// 3. SwerveSpeed = 10, MaxSwerveAmount = 3.5 ayarlar\u0131n\u0131 yap.\n</code></pre>"},{"location":"API_References/NexusSwerveController_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity.Controllers;\n\npublic class NexusSwerveController : MonoBehaviour\n{\n    public float SwerveSpeed = 5f;\n    public float MaxSwerveAmount = 2f;\n    [SerializeField] private NexusSwerveInput _input;\n\n    private void Update() {\n        float swerveAmount = Time.deltaTime * SwerveSpeed * _input.MoveFactorX;\n        float targetX = Mathf.Clamp(transform.localPosition.x + swerveAmount, -MaxSwerveAmount, MaxSwerveAmount);\n        transform.localPosition = new Vector3(targetX, transform.localPosition.y, transform.localPosition.z);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusSwerveController_tr/#nexus-optimization-tip-input-smoothing","title":"Nexus Optimization Tip: Input Smoothing","text":"<p><code>NexusSwerveInput</code> i\u00e7indeki ham veriyi do\u011frudan kullanmak yerine, <code>SwerveController</code> i\u00e7inde bir <code>Lerp</code> veya <code>SmoothDamp</code> katman\u0131ndan ge\u00e7irin. Bu, oyuncunun parma\u011f\u0131n\u0131 aniden \u00e7ekmesi durumunda olu\u015fabilecek sert duru\u015flar\u0131 engeller ve \"Premium\" bir hissiyat sa\u011flar.</p>"},{"location":"API_References/NexusSwerveInput_eng/","title":"Nexus Prime Architectural Manual: NexusSwerveInput (Swerve Input Reader)","text":""},{"location":"API_References/NexusSwerveInput_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusSwerveInput.cs</code> is a low-level input unit that converts player \"Dragging\" (Drag) movements on a touch screen or mouse into numerical data. Integrated from the HypeFire framework, this system forms the basis of game genres particularly where horizontal movement is at the forefront.</p> <p>The reason for this unit's existence is to provide clean data to controllers by converting raw coordinate data (\"My finger is now at (500, 300)\") into a meaningful movement factor (\"My finger swiped 10 units to the left\").</p>"},{"location":"API_References/NexusSwerveInput_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Offers the following tools for input reading performance:</p> <ul> <li>Move Factor Processing: Calculates the distance the mouse or finger has traveled since the last frame (<code>_lastMouseX</code>) and scales it with the <code>Sensitivity</code> (Sensitivity) multiplier.</li> <li>Screen-to-World Parity: With the <code>GetHorizontalWorldPosition</code> method, reflects the touch point on the screen to the horizontal X coordinate in the game world according to the camera's depth.</li> <li>Multi-Platform Consistency: Conducts a logic compatible with both <code>GetMouseButton</code> and <code>Touch</code> systems on mobile platforms (via Unity's legacy input system).</li> </ul>"},{"location":"API_References/NexusSwerveInput_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Down (Down): The first coordinate where the finger touches the screen is recorded.</li> <li>Dragging (Drag): In each frame, the difference (<code>delta</code>) between the current position and the previous position is found.</li> <li>Reset (Up): The movement factor is pulled to 0 when the finger is lifted from the screen.</li> <li>Coordinate Conversion: When necessary, the pixel value on the screen is converted to the world coordinate according to the camera's angle of view.</li> </ol>"},{"location":"API_References/NexusSwerveInput_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>public class MySwerveMover : MonoBehaviour {\n    [SerializeField] private NexusSwerveInput _inputReader;\n\n    void Update() {\n        // Get the exact X position of the finger in the world\n        float worldX = _inputReader.GetHorizontalWorldPosition();\n\n        // Or get the swipe speed (delta)\n        float deltaX = _inputReader.MoveFactorX;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusSwerveInput_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity.Inputs;\n\npublic class NexusSwerveInput : MonoBehaviour\n{\n    public float Sensitivity = 1f;\n    private float _lastMouseX;\n    private float _moveFactorX;\n\n    public float MoveFactorX =&gt; _moveFactorX;\n\n    private void Update() {\n        if (Input.GetMouseButtonDown(0)) _lastMouseX = Input.mousePosition.x;\n        else if (Input.GetMouseButton(0)) {\n            _moveFactorX = (Input.mousePosition.x - _lastMouseX) * Sensitivity;\n            _lastMouseX = Input.mousePosition.x;\n        }\n        else _moveFactorX = 0f;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusSwerveInput_eng/#nexus-optimization-tip-delta-smoothing","title":"Nexus Optimization Tip: Delta Smoothing","text":"<p>On sensitive hardware (e.g., 120Hz screens), input data can sometimes come quite sharp or shaky (jitter). Normalizing the <code>MoveFactorX</code> value with <code>Time.deltaTime</code> or smoothing it with a small <code>Lerp</code> significantly improves the player control feel (User Experience).</p>"},{"location":"API_References/NexusSwerveInput_tr/","title":"Nexus Prime Mimari Rehberi: NexusSwerveInput (Swerve Girdi Okuyucu)","text":""},{"location":"API_References/NexusSwerveInput_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusSwerveInput.cs</code>, oyuncunun dokunmatik ekran veya fare \u00fczerindeki \"S\u00fcr\u00fckleme\" (Drag) hareketlerini say\u0131sal verilere d\u00f6n\u00fc\u015ft\u00fcren d\u00fc\u015f\u00fck seviyeli bir girdi birimidir. HypeFire framework'\u00fcnden entegre edilen bu sistem, \u00f6zellikle yatay hareketin \u00f6n planda oldu\u011fu oyun t\u00fcrlerinin temelini olu\u015fturur.</p> <p>Bu birimin varl\u0131k sebebi; ham koordinat verilerini (\"Parma\u011f\u0131m \u015fu an (500, 300) noktas\u0131nda\") anlaml\u0131 bir hareket fakt\u00f6r\u00fcne (\"Parma\u011f\u0131m sola do\u011fru 10 birim kayd\u0131\") d\u00f6n\u00fc\u015ft\u00fcrerek kontrol\u00f6rlere temiz veri sa\u011flamakt\u0131r.</p>"},{"location":"API_References/NexusSwerveInput_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Girdi okuma performans\u0131 i\u00e7in \u015fu ara\u00e7lar\u0131 sunar:</p> <ul> <li>Move Factor Processing: Farenin veya parma\u011f\u0131n son kareden (<code>_lastMouseX</code>) bu yana katetti\u011fi mesafeyi hesaplar ve <code>Sensitivity</code> (Hassasiyet) \u00e7arpan\u0131yla \u00f6l\u00e7eklendirir.</li> <li>Screen-to-World Parity: <code>GetHorizontalWorldPosition</code> metodu ile ekrandaki dokunma noktas\u0131n\u0131, kameran\u0131n derinli\u011fine g\u00f6re oyun d\u00fcnyas\u0131ndaki yatay X koordinat\u0131na yans\u0131t\u0131r.</li> <li>Multi-Platform Consistency: Hem <code>GetMouseButton</code> hem de mobil platformlardaki <code>Touch</code> sistemleriyle uyumlu bir mant\u0131k y\u00fcr\u00fct\u00fcr (Unity'nin legacy input sistemi \u00fczerinden).</li> </ul>"},{"location":"API_References/NexusSwerveInput_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>D\u00fc\u015f\u00fc\u015f (Down): Parma\u011f\u0131n ekrana de\u011fdi\u011fi ilk koordinat kaydedilir.</li> <li>S\u00fcr\u00fckleme (Drag): Her karede mevcut konum ile bir \u00f6nceki konum aras\u0131ndaki fark (<code>delta</code>) bulunur.</li> <li>S\u0131f\u0131rlama (Up): Parmak ekran kalkt\u0131\u011f\u0131nda hareket fakt\u00f6r\u00fc 0'a \u00e7ekilir.</li> <li>Koordinat D\u00f6n\u00fc\u015f\u00fcm\u00fc: Gerekti\u011finde ekran \u00fczerindeki piksel de\u011feri, kameran\u0131n bak\u0131\u015f a\u00e7\u0131s\u0131na g\u00f6re d\u00fcnya koordinat\u0131na \u00e7evrilir.</li> </ol>"},{"location":"API_References/NexusSwerveInput_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public class MySwerveMover : MonoBehaviour {\n    [SerializeField] private NexusSwerveInput _inputReader;\n\n    void Update() {\n        // Parma\u011f\u0131n d\u00fcnyadaki tam X konumunu al\n        float worldX = _inputReader.GetHorizontalWorldPosition();\n\n        // Veya kayd\u0131rma h\u0131z\u0131n\u0131 (delta) al\n        float deltaX = _inputReader.MoveFactorX;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusSwerveInput_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity.Inputs;\n\npublic class NexusSwerveInput : MonoBehaviour\n{\n    public float Sensitivity = 1f;\n    private float _lastMouseX;\n    private float _moveFactorX;\n\n    public float MoveFactorX =&gt; _moveFactorX;\n\n    private void Update() {\n        if (Input.GetMouseButtonDown(0)) _lastMouseX = Input.mousePosition.x;\n        else if (Input.GetMouseButton(0)) {\n            _moveFactorX = (Input.mousePosition.x - _lastMouseX) * Sensitivity;\n            _lastMouseX = Input.mousePosition.x;\n        }\n        else _moveFactorX = 0f;\n    }\n}\n</code></pre>"},{"location":"API_References/NexusSwerveInput_tr/#nexus-optimization-tip-delta-smoothing","title":"Nexus Optimization Tip: Delta Smoothing","text":"<p>Hassas donan\u0131mlarda (\u00d6rn: 120Hz ekranlar) girdi verisi bazen \u00e7ok keskin veya sars\u0131nt\u0131l\u0131 (jitter) gelebilir. <code>MoveFactorX</code> de\u011ferini <code>Time.deltaTime</code> ile normalize etmek veya k\u00fc\u00e7\u00fck bir <code>Lerp</code> ile yumu\u015fatmak, oyuncu kontrol hissiyat\u0131n\u0131 (User Experience) \u00f6nemli \u00f6l\u00e7\u00fcde iyile\u015ftirir.</p>"},{"location":"API_References/NexusSyncManager_eng/","title":"Nexus Prime Architectural Manual: NexusSyncManager (Data Synchronization Manager)","text":""},{"location":"API_References/NexusSyncManager_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusSyncManager.cs</code> is the \"Speed Regulator\" between Nexus Prime's unmanaged simulation layer and Unity's visual scenes. It coordinates the transfer of pure mathematical data (e.g., Position, Rotation) residing in unmanaged memory (<code>Registry</code>) to visual objects (<code>Transform</code>) in Unity with millisecond speed.</p> <p>The reason for this manager's existence is to minimize the cost of <code>Transform</code> updates on the CPU by making a mass and optimized synchronization pass (Synchronization Pass) through a central system, instead of each Unity object searching for and finding its own data.</p>"},{"location":"API_References/NexusSyncManager_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusSyncManager uses the following techniques for hybrid synchronization:</p> <ul> <li>Global Sync Pass: Scans all component sets of interest in bulk using <code>registry.GetSet&lt;T&gt;</code>. This is much faster than performing individual Registry queries for each object (Set-Iteration).</li> <li>Mapping Lookup: Reaches the relevant Unity object via Entity ID at O(1) cost using <code>NexusObjectMapping.TryGet</code>.</li> <li>Direct Pointer Access: Reads data from unmanaged component sets as raw pointers (<code>Vector3*</code>, <code>NexusRotationField*</code>). This eliminates managed-struct copying cost.</li> <li>Conditional Sync: Only entities managed by Nexus and possessing a visual representation (Mapped) are synchronized.</li> </ul>"},{"location":"API_References/NexusSyncManager_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Iteration: All active entities are scanned via position and rotation component sets.</li> <li>Reference Finding: Whether the entity has a visual representation (<code>GameObject</code>) on the Unity side is checked.</li> <li>Value Transfer: Unmanaged data is assigned directly to Unity <code>transform.position</code> and <code>transform.rotation</code> properties.</li> <li>Acceleration: In multi-thousand entities, this process can also be executed in parallel within the <code>JobSystem</code>.</li> </ol>"},{"location":"API_References/NexusSyncManager_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Trigger synchronization within the Update loop\nvoid Update() {\n    NexusSyncManager.Sync(mainRegistry);\n}\n\n// Or manually synchronize only a single entity\nNexusSyncManager.SyncEntity(registry, myId, myGameObject);\n</code></pre>"},{"location":"API_References/NexusSyncManager_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\npublic static class NexusSyncManager\n{\n    public static void Sync(Registry registry)\n    {\n        var positionSet = registry.GetSet&lt;Vector3&gt;();\n        var rotationSet = registry.GetSet&lt;NexusRotationField&gt;();\n\n        for (int i = 0; i &lt; positionSet.Count; i++)\n        {\n            EntityId id = positionSet.GetEntity(i);\n            if (NexusObjectMapping.TryGet(id.Index, out object obj) &amp;&amp; obj is GameObject go)\n            {\n                Transform t = go.transform;\n                t.position = *positionSet.Get(id);\n                // Rotation sync...\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/NexusSyncManager_eng/#nexus-optimization-tip-change-only-sync","title":"Nexus Optimization Tip: Change-Only Sync","text":"<p>To reduce synchronization cost, use <code>DirtyBits</code> technology. By synchronizing only the entities whose unmanaged data has changed since the last frame, you can reduce the Transform update load on the Unity side by 70-80%.</p>"},{"location":"API_References/NexusSyncManager_tr/","title":"Nexus Prime Mimari Rehberi: NexusSyncManager (Veri Senkronizasyon Y\u00f6neticisi)","text":""},{"location":"API_References/NexusSyncManager_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusSyncManager.cs</code>, Nexus Prime'\u0131n unmanaged sim\u00fclasyon katman\u0131 ile Unity'nin g\u00f6rsel sahneleri aras\u0131ndaki \"H\u0131z Ayarlay\u0131c\u0131\"d\u0131r. Unmanaged bellekte (<code>Registry</code>) duran saf matematiksel verilerin (\u00d6rn: Pozisyon, Rotasyon), Unity'deki g\u00f6rsel nesnelere (<code>Transform</code>) milisaniyelik bir h\u0131zla aktar\u0131lmas\u0131n\u0131 koordine eder.</p> <p>Bu y\u00f6neticinin varl\u0131k sebebi, her Unity nesnesinin kendi verisini aray\u0131p bulmas\u0131 yerine, merkezi bir sistem \u00fczerinden toplu ve optimize edilmi\u015f bir senkronizasyon pas\u0131 (Synchronisation Pass) yaparak CPU \u00fczerindeki <code>Transform</code> g\u00fcncelleme maliyetini minimize etmektir.</p>"},{"location":"API_References/NexusSyncManager_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusSyncManager, hibrit senkronizasyon i\u00e7in \u015fu teknikleri kullan\u0131r:</p> <ul> <li>Global Sync Pass: <code>registry.GetSet&lt;T&gt;</code> kullanarak t\u00fcm ilgilenilen bile\u015fen setlerini toplu olarak tarar. Bu, her nesne i\u00e7in tek tek Registry sorgusu yapmaktan \u00e7ok daha h\u0131zl\u0131d\u0131r (Set-Iteration).</li> <li>Mapping Lookup: <code>NexusObjectMapping.TryGet</code> kullanarak Entity ID \u00fczerinden ilgili Unity nesnesine O(1) maliyetle ula\u015f\u0131r.</li> <li>Direct Pointer Access: Verileri unmanaged bile\u015fen setlerinden ham pointer (<code>Vector3*</code>, <code>NexusRotationField*</code>) olarak okur. Bu, managed-struct kopyalama maliyetini ortadan kald\u0131r\u0131r.</li> <li>Conditional Sync: Sadece Nexus taraf\u0131ndan y\u00f6netilen ve g\u00f6rsel bir kar\u015f\u0131l\u0131\u011f\u0131 olan (Mapped) varl\u0131klar senkronize edilir.</li> </ul>"},{"location":"API_References/NexusSyncManager_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Iterasyon: Pozisyon ve rotasyon bile\u015fen setleri \u00fczerinden t\u00fcm aktif varl\u0131klar taran\u0131r.</li> <li>Referans Bulma: Varl\u0131\u011f\u0131n Unity taraf\u0131nda bir g\u00f6rsel kar\u015f\u0131l\u0131\u011f\u0131 (<code>GameObject</code>) olup olmad\u0131\u011f\u0131 kontrol edilir.</li> <li>De\u011fer Aktar\u0131m\u0131: Unmanaged veriler, direkt olarak Unity <code>transform.position</code> ve <code>transform.rotation</code> \u00f6zelliklerine atan\u0131r.</li> <li>H\u0131zland\u0131rma: \u00c7ok binli varl\u0131klarda, bu i\u015flem <code>JobSystem</code> i\u00e7inde paralel olarak da y\u00fcr\u00fct\u00fclebilir.</li> </ol>"},{"location":"API_References/NexusSyncManager_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Update d\u00f6ng\u00fcs\u00fc i\u00e7inde senkronizasyonu tetikle\nvoid Update() {\n    NexusSyncManager.Sync(mainRegistry);\n}\n\n// Veya sadece tek bir varl\u0131\u011f\u0131 el ile senkronize et\nNexusSyncManager.SyncEntity(registry, myId, myGameObject);\n</code></pre>"},{"location":"API_References/NexusSyncManager_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\npublic static class NexusSyncManager\n{\n    public static void Sync(Registry registry)\n    {\n        var positionSet = registry.GetSet&lt;Vector3&gt;();\n        var rotationSet = registry.GetSet&lt;NexusRotationField&gt;();\n\n        for (int i = 0; i &lt; positionSet.Count; i++)\n        {\n            EntityId id = positionSet.GetEntity(i);\n            if (NexusObjectMapping.TryGet(id.Index, out object obj) &amp;&amp; obj is GameObject go)\n            {\n                Transform t = go.transform;\n                t.position = *positionSet.Get(id);\n                // Rotation sync...\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/NexusSyncManager_tr/#nexus-optimization-tip-change-only-sync","title":"Nexus Optimization Tip: Change-Only Sync","text":"<p>Senkronizasyon maliyetini d\u00fc\u015f\u00fcrmek i\u00e7in <code>DirtyBits</code> teknolojisini kullan\u0131n. Sadece son kareden beri unmanaged verisi de\u011fi\u015fmi\u015f olan varl\u0131klar\u0131 senkronize ederek, Unity taraf\u0131ndaki Transform g\u00fcncelleme y\u00fck\u00fcn\u00fc %70-80 oran\u0131nda azaltabilirsiniz.</p>"},{"location":"API_References/NexusSystemGenerator_eng/","title":"API Reference: NexusSystemGenerator (Automatic Code Generator)","text":""},{"location":"API_References/NexusSystemGenerator_eng/#introduction","title":"Introduction","text":"<p><code>NexusSystemGenerator.cs</code> is the \"automation engine\" of Nexus Prime. Using Roslyn (C# Compiler SDK), it analyzes raw system code written by the developer and automatically generates performance-critical \"boilerplate\" (routine) code before runtime. This allows the developer to focus purely on game logic instead of dealing with complex SIMD loops or pointer management.</p>"},{"location":"API_References/NexusSystemGenerator_eng/#technical-analysis","title":"Technical Analysis","text":"<p>The generator implements the following advanced techniques: - IIncrementalGenerator Integration: Minimizes compilation (compile) times by regenerating only the affected parts as code changes. - SIMD Loop Injection: Constructs automatic AVX-optimized loops (Run method) for fields marked with <code>[Read]</code> or <code>[Write]</code> attributes. - Partial Class Extension: Adds new capabilities without interfering with the original code by extending classes written by the developer with the <code>partial</code> keyword. - Syntax Provider Filtering: Avoids unnecessary workload by processing only classes that implement the <code>INexusSystem</code> interface.</p>"},{"location":"API_References/NexusSystemGenerator_eng/#logical-flow","title":"Logical Flow","text":"<ol> <li>Monitoring: Roslyn scans all classes in the project and reports those that are <code>INexusSystem</code> to the generator.</li> <li>Analysis: Component fields and attributes (<code>[Read]</code>, <code>[Write]</code>) within the identified classes are examined.</li> <li>Production: The <code>[ClassName]_Generated.g.cs</code> file is created, containing the logic that acquires memory addresses, establishes SIMD blocks, and includes safe fallback (fallback) loops.</li> <li>Integration: The generated code is incorporated into the binary package by including it in the project's build process (build pipeline).</li> </ol>"},{"location":"API_References/NexusSystemGenerator_eng/#terminology-glossary","title":"Terminology Glossary","text":"<ul> <li>Source Generator: A C# compiler feature that generates source code during compilation and includes it in the project.</li> <li>Roslyn: The open-source C# and Visual Basic compiler set developed for the .NET platform.</li> <li>Partial Class: A structure that allows a class definition to be divided into multiple files.</li> <li>Compile-time Automation: The automation of software at the compilation stage, not at runtime.</li> </ul>"},{"location":"API_References/NexusSystemGenerator_eng/#risks-and-limits","title":"Risks and Limits","text":"<ul> <li>Syntax Errors: If the generator produces faulty C# code, the compilation of the entire project may stop. Generated code must 100% comply with <code>unsafe</code> and <code>simd</code> rules.</li> </ul>"},{"location":"API_References/NexusSystemGenerator_eng/#usage-example","title":"Usage Example","text":"<pre><code>public partial class MovementSystem : INexusSystem {\n    [Read] Position* pos;\n    [Write] Velocity* vel;\n    // Nexus automatically generates the Run() method for these fields.\n}\n</code></pre>"},{"location":"API_References/NexusSystemGenerator_eng/#nexus-optimization-tip-explicit-attributes","title":"Nexus Optimization Tip: Explicit Attributes","text":"<p>Always mark system fields with <code>[Read]</code> or <code>[Write]</code>. The generator uses processor cache (cache) more efficiently by only reading fields that do not require writing (Write).</p>"},{"location":"API_References/NexusSystemGenerator_eng/#original-source","title":"Original Source","text":"<p>NexusSystemGenerator.cs Source Code</p>"},{"location":"API_References/NexusSystemGenerator_tr/","title":"API Referans\u0131: NexusSystemGenerator (Otomatik Kod Jenerat\u00f6r\u00fc)","text":""},{"location":"API_References/NexusSystemGenerator_tr/#giris","title":"Giri\u015f","text":"<p><code>NexusSystemGenerator.cs</code>, Nexus Prime'\u0131n \"otomasyon motorudur\". Roslyn (C# Compiler SDK) kullanarak, geli\u015ftiricinin yazd\u0131\u011f\u0131 ham sistem kodlar\u0131n\u0131 analiz eder ve performans kritik olan \"boilerplate\" (rutin) kodlar\u0131 \u00e7al\u0131\u015fma zaman\u0131 \u00f6ncesinde otomatik \u00fcretir. Bu sayede geli\u015ftirici, karma\u015f\u0131k SIMD d\u00f6ng\u00fcleri veya pointer y\u00f6netimiyle u\u011fra\u015fmak yerine sadece oyun mant\u0131\u011f\u0131na odaklanabilir.</p>"},{"location":"API_References/NexusSystemGenerator_tr/#teknik-analiz","title":"Teknik Analiz","text":"<p>Jenerat\u00f6r \u015fu ileri seviye teknikleri uygular: - IIncrementalGenerator Integration: Kod de\u011fi\u015ftik\u00e7e sadece etkilenen k\u0131s\u0131mlar\u0131 yeniden \u00fcreterek derleme (compile) s\u00fcrelerini minimize eder. - SIMD Loop Injection: <code>[Read]</code> veya <code>[Write]</code> \u00f6znitelikleriyle i\u015faretlenmi\u015f alanlar i\u00e7in otomatik AVX-optimize d\u00f6ng\u00fcler (Run metodu) kurgular. - Partial Class Extension: Geli\u015ftiricinin yazd\u0131\u011f\u0131 s\u0131n\u0131flar\u0131 <code>partial</code> anahtar kelimesiyle geni\u015fleterek orijinal koda m\u00fcdahale etmeden yeni yetenekler ekler. - Syntax Provider Filtering: Sadece <code>INexusSystem</code> aray\u00fcz\u00fcn\u00fc uygulanan s\u0131n\u0131flar\u0131 i\u015fleyerek gereksiz i\u015flem y\u00fck\u00fcn\u00fc \u00f6nler.</p>"},{"location":"API_References/NexusSystemGenerator_tr/#mantksal-aks","title":"Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>\u0130zleme: Roslyn, projedeki t\u00fcm s\u0131n\u0131flar\u0131 tarayarak <code>INexusSystem</code> olanlar\u0131 jenerat\u00f6re raporlar.</li> <li>Analiz: Belirlenen s\u0131n\u0131flar\u0131n i\u00e7indeki bile\u015fen alanlar\u0131 ve \u00f6znitelikleri (<code>[Read]</code>, <code>[Write]</code>) incelenir.</li> <li>\u00dcretim: Bellek adreslerini alan, SIMD bloklar\u0131n\u0131 kuran ve g\u00fcvenli geri d\u00f6n\u00fc\u015f (fallback) d\u00f6ng\u00fclerini i\u00e7eren <code>[ClassName]_Generated.g.cs</code> dosyas\u0131 olu\u015fturulur.</li> <li>Entegrasyon: \u00dcretilen kod, projenin derleme s\u00fcrecine (build pipeline) dahil edilerek binary pakete eklenir.</li> </ol>"},{"location":"API_References/NexusSystemGenerator_tr/#terminoloji-sozlugu","title":"Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"<ul> <li>Source Generator: Derleme s\u0131ras\u0131nda kaynak kod \u00fcreten ve projeye dahil eden C# derleyici \u00f6zelli\u011fi.</li> <li>Roslyn: .NET platformu i\u00e7in geli\u015ftirilen a\u00e7\u0131k kaynakl\u0131 C# ve Visual Basic derleyici seti.</li> <li>Partial Class: Bir s\u0131n\u0131f\u0131n tan\u0131m\u0131n\u0131n birden fazla dosyaya b\u00f6l\u00fcnmesine izin veren yap\u0131.</li> <li>Compile-time Automation: Yaz\u0131l\u0131m\u0131n \u00e7al\u0131\u015fma zaman\u0131nda de\u011fil, derleme a\u015famas\u0131nda otomatikle\u015ftirilmesi.</li> </ul>"},{"location":"API_References/NexusSystemGenerator_tr/#riskler-ve-snrlar","title":"Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Syntax Errors: E\u011fer jenerat\u00f6r hatal\u0131 C# kodu \u00fcretirse, t\u00fcm projenin derlenmesi durabilir. \u00dcretilen kodun <code>unsafe</code> ve <code>simd</code> kurallar\u0131na %100 uymas\u0131 gerekir.</li> </ul>"},{"location":"API_References/NexusSystemGenerator_tr/#kullanm-ornegi","title":"Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public partial class MovementSystem : INexusSystem {\n    [Read] Position* pos;\n    [Write] Velocity* vel;\n    // Nexus, bu alanlar i\u00e7in Run() metodunu otomatik \u00fcretir.\n}\n</code></pre>"},{"location":"API_References/NexusSystemGenerator_tr/#nexus-optimization-tip-explicit-attributes","title":"Nexus Optimization Tip: Explicit Attributes","text":"<p>Sistem alanlar\u0131n\u0131 her zaman <code>[Read]</code> veya <code>[Write]</code> ile i\u015faretleyin. Jenerat\u00f6r, yazma (Write) gerektirmeyen alanlar\u0131 sadece okuyarak i\u015flemci \u00f6nbelle\u011fini (cache) daha verimli kullan\u0131r.</p>"},{"location":"API_References/NexusSystemGenerator_tr/#orijinal-kod","title":"Orijinal Kod","text":"<p>NexusSystemGenerator.cs Kaynak Kodu</p>"},{"location":"API_References/NexusTrajectorySimulator_eng/","title":"Nexus Prime Architectural Manual: NexusTrajectorySimulator (Trajectory Simulation System)","text":""},{"location":"API_References/NexusTrajectorySimulator_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusTrajectorySimulator.cs</code> is an advanced \"Physics Prediction\" (Physics Prediction) tool that predicts future movements (e.g., where a grenade will fall or where a bullet will bounce) without disrupting the game's main physics world.</p> <p>The reason for this simulator's existence is to provide visual guidance to the player (Trajectory Line) and to enable AI systems to test in advance \"in an imaginary world\" whether they will hit the target before firing.</p>"},{"location":"API_References/NexusTrajectorySimulator_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Uses the following architectural strategy for real-time and accurate prediction:</p> <ul> <li>Secondary Physics Scene: Creates a \"Nexus_SimScene\" completely independent from the main scene (<code>Main Scene</code>), used only for physics calculations. This prevents the prediction simulation from affecting objects in the main game.</li> <li>Obstacle Ghosting: Copies non-visual \"ghost\" copies of obstacles in the main scene (<code>ObstaclesRoot</code>) to the simulation scene. Thus, collisions result in exactly the same results as in the real world.</li> <li>Deterministic Step Simulation: calculates the path the bullet will take within milliseconds by running the <code>physicsScene.Simulate(Time.fixedDeltaTime)</code> command in a loop (<code>MaxIterations</code>).</li> <li>Dynamic Obstacle Sync: Synchronizes the positions of moving obstacles with the main scene before each simulation.</li> </ul>"},{"location":"API_References/NexusTrajectorySimulator_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Setup: The world of shadows (SimScene) is established and static obstacles are moved there.</li> <li>Query: When the <code>Simulate</code> method is called, a copy of the object to be launched is created in the imaginary scene.</li> <li>Accelerated Time: The physics engine ultra-fast simulates the object's movement for the next N frames.</li> <li>Visualization: Positions in each frame are written into the <code>LineRenderer</code> and shown to the player.</li> <li>Cleanup: The ghost object is destroyed when prediction is finished.</li> </ol>"},{"location":"API_References/NexusTrajectorySimulator_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Physics Scene Isolated physics area with independent gravity and collision rules. Ghosting Copying only the collision capabilities of objects without the visualization load. Fixed Step The physics engine advancing time in constant parts (e.g., 0.02s)."},{"location":"API_References/NexusTrajectorySimulator_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>CPU Spike: If the <code>MaxIterations</code> value is kept too high (e.g., 500+ steps), performing this simulation every frame can create a serious instantaneous load on the CPU.</li> <li>Scene Divergence: If ghost obstacles are not regularly synchronized, deviations may occur between the predicted trajectory and the actual result.</li> </ul>"},{"location":"API_References/NexusTrajectorySimulator_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>public void OnAiming(Vector3 launchVelocity) {\n    // Give the bomb prefab and launch velocity, let it draw the path\n    simulator.Simulate(bombGhostPrefab, firePoint.position, launchVelocity);\n}\n</code></pre>"},{"location":"API_References/NexusTrajectorySimulator_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Mathematics;\n\npublic class NexusTrajectorySimulator : MonoBehaviour\n{\n    public int MaxIterations = 100;\n    private Scene _simScene;\n    private PhysicsScene _physicsScene;\n\n    private void InitializeSimulation() {\n        _simScene = SceneManager.CreateScene(\"Nexus_SimScene\", new CreateSceneParameters(LocalPhysicsMode.Physics3D));\n        _physicsScene = _simScene.GetPhysicsScene();\n    }\n\n    public void Simulate(GameObject prefab, Vector3 pos, Vector3 vel) {\n        var ghost = Instantiate(prefab, pos, Quaternion.identity);\n        SceneManager.MoveGameObjectToScene(ghost, _simScene);\n        ghost.GetComponent&lt;Rigidbody&gt;().AddForce(vel, ForceMode.Impulse);\n\n        for (int i = 0; i &lt; MaxIterations; i++) {\n            _physicsScene.Simulate(Time.fixedDeltaTime);\n            // Record position...\n        }\n        Destroy(ghost);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusTrajectorySimulator_eng/#nexus-optimization-tip-layer-filtering","title":"Nexus Optimization Tip: Layer Filtering","text":"<p>Move only objects that are physical obstacles to the simulation scene. Cleaning components such as lights, visual effects, or sound sources from ghost objects optimizes simulation speed and memory usage by 40%.</p>"},{"location":"API_References/NexusTrajectorySimulator_tr/","title":"Nexus Prime Mimari Rehberi: NexusTrajectorySimulator (Y\u00f6r\u00fcnge Sim\u00fclasyon Sistemi)","text":""},{"location":"API_References/NexusTrajectorySimulator_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusTrajectorySimulator.cs</code>, oyunun ana fizik d\u00fcnyas\u0131n\u0131 bozmadan gelecekteki hareketleri (\u00d6rn: Bir el bombas\u0131n\u0131n nereye d\u00fc\u015fece\u011fi veya merminin sekece\u011fi yer) tahmin eden geli\u015fmi\u015f bir \"Fizik \u00d6ng\u00f6r\u00fc\" (Physics Prediction) arac\u0131d\u0131r.</p> <p>Bu sim\u00fclat\u00f6r\u00fcn varl\u0131k sebebi; oyuncuya g\u00f6rsel rehberlik sa\u011flamak (Trajectory Line) ve yapay zeka sistemlerinin at\u0131\u015f yapmadan \u00f6nce hedefe isabet edip etmeyece\u011fini \u00f6nceden \"Hayali bir d\u00fcnyada\" test edebilmesini sa\u011flamakt\u0131r.</p>"},{"location":"API_References/NexusTrajectorySimulator_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Ger\u00e7ek zamanl\u0131 ve do\u011fru tahmin i\u00e7in \u015fu mimari stratejiyi kullan\u0131r:</p> <ul> <li>Secondary Physics Scene: Ana sahneden (<code>Main Scene</code>) tamamen ba\u011f\u0131ms\u0131z, sadece fizik hesaplamalar\u0131 i\u00e7in kullan\u0131lan bir \"Nexus_SimScene\" olu\u015fturur. Bu, tahmin sim\u00fclasyonunun ana oyundaki nesneleri etkilemesini engeller.</li> <li>Obstacle Ghosting: Ana sahnedeki engellerin (<code>ObstaclesRoot</code>) g\u00f6rsel olmayan \"hayalet\" kopyalar\u0131n\u0131 sim\u00fclasyon sahnesine kopyalar. B\u00f6ylece \u00e7arp\u0131\u015fmalar ger\u00e7ek d\u00fcnyayla birebir ayn\u0131 sonu\u00e7lan\u0131r.</li> <li>Deterministic Step Simulation: <code>physicsScene.Simulate(Time.fixedDeltaTime)</code> komutunu bir d\u00f6ng\u00fc i\u00e7inde (<code>MaxIterations</code>) ko\u015fturarak, merminin gidece\u011fi yolu milisaniyeler i\u00e7inde hesaplar.</li> <li>Dynamic Obstacle Sync: Hareketli engellerin konumlar\u0131n\u0131 her sim\u00fclasyon \u00f6ncesi ana sahneyle senkronize eder.</li> </ul>"},{"location":"API_References/NexusTrajectorySimulator_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Kurulum: G\u00f6lgeler d\u00fcnyas\u0131 (SimScene) kurulur ve sabit engeller oraya ta\u015f\u0131n\u0131r.</li> <li>Sorgulama: <code>Simulate</code> metodu \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, f\u0131rlat\u0131lacak nesnenin bir kopyas\u0131 hayali sahnede olu\u015fturulur.</li> <li>H\u0131zland\u0131r\u0131lm\u0131\u015f Zaman: Fizik motoru, nesnenin hareketini gelecekteki N kare boyunca ultra h\u0131zl\u0131 sim\u00fcle eder.</li> <li>G\u00f6rselle\u015ftirme: Her karedeki konumlar <code>LineRenderer</code> i\u00e7ine yaz\u0131larak oyuncuya g\u00f6sterilir.</li> <li>Temizlik: Tahmin bitti\u011finde hayalet nesne yok edilir.</li> </ol>"},{"location":"API_References/NexusTrajectorySimulator_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Physics Scene Ba\u011f\u0131ms\u0131z yer\u00e7ekimi ve \u00e7arp\u0131\u015fma kurallar\u0131na sahip izole fizik alan\u0131. Ghosting Nesnelerin g\u00f6rselle\u015ftirme y\u00fck\u00fc olmadan sadece collide kabiliyetlerinin kopyalanmas\u0131. Fixed Step Fizik motorunun zaman\u0131 sabit par\u00e7alar halinde (\u00d6rn: 0.02s) ilerletmesi."},{"location":"API_References/NexusTrajectorySimulator_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>CPU Spike: <code>MaxIterations</code> de\u011feri \u00e7ok y\u00fcksek tutulursa (\u00d6rn: 500+ ad\u0131m), her karede bu sim\u00fclasyonu yapmak CPU \u00fczerinde ciddi bir anl\u0131k y\u00fck olu\u015fturabilir.</li> <li>Scene Divergence: E\u011fer hayalet engeller d\u00fczenli senkronize edilmezse, tahmin edilen y\u00f6r\u00fcnge ile ger\u00e7ek sonu\u00e7 aras\u0131nda sapmalar olu\u015fabilir.</li> </ul>"},{"location":"API_References/NexusTrajectorySimulator_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public void OnAiming(Vector3 launchVelocity) {\n    // Bomban\u0131n prefab\u0131n\u0131 ve f\u0131rlatma h\u0131z\u0131n\u0131 ver, yolu \u00e7izsin\n    simulator.Simulate(bombGhostPrefab, firePoint.position, launchVelocity);\n}\n</code></pre>"},{"location":"API_References/NexusTrajectorySimulator_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Mathematics;\n\npublic class NexusTrajectorySimulator : MonoBehaviour\n{\n    public int MaxIterations = 100;\n    private Scene _simScene;\n    private PhysicsScene _physicsScene;\n\n    private void InitializeSimulation() {\n        _simScene = SceneManager.CreateScene(\"Nexus_SimScene\", new CreateSceneParameters(LocalPhysicsMode.Physics3D));\n        _physicsScene = _simScene.GetPhysicsScene();\n    }\n\n    public void Simulate(GameObject prefab, Vector3 pos, Vector3 vel) {\n        var ghost = Instantiate(prefab, pos, Quaternion.identity);\n        SceneManager.MoveGameObjectToScene(ghost, _simScene);\n        ghost.GetComponent&lt;Rigidbody&gt;().AddForce(vel, ForceMode.Impulse);\n\n        for (int i = 0; i &lt; MaxIterations; i++) {\n            _physicsScene.Simulate(Time.fixedDeltaTime);\n            // Record position...\n        }\n        Destroy(ghost);\n    }\n}\n</code></pre>"},{"location":"API_References/NexusTrajectorySimulator_tr/#nexus-optimization-tip-layer-filtering","title":"Nexus Optimization Tip: Layer Filtering","text":"<p>Sim\u00fclasyon sahnesine sadece fiziksel engel olan nesneleri ta\u015f\u0131y\u0131n. I\u015f\u0131klar, g\u00f6rsel efektler veya ses kaynaklar\u0131 gibi bile\u015fenleri hayalet nesnelerden temizlemek, sim\u00fclasyon h\u0131z\u0131 ve bellek kullan\u0131m\u0131n\u0131 %40 oran\u0131nda optimize eder.</p>"},{"location":"API_References/NexusUIUtilities_eng/","title":"Nexus Prime Architectural Manual: NexusUIUtilities (Visual Interface Helpers)","text":""},{"location":"API_References/NexusUIUtilities_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusUIUtilities.cs</code> is a collection managing the \"Visual Endpoints\" where the Nexus Prime data world is presented to the user. It combines reactive UI binding (<code>NexusUIBindings</code>), camera-oriented visualization (<code>NexusBillboardUI</code>), and project organization tools in a single file.</p> <p>The reason for these helpers' existence is to ensure unmanaged data (e.g., player name, health value) is rapidly pushed to components like TextMeshPro and to guarantee objects on the field always look at the player.</p>"},{"location":"API_References/NexusUIUtilities_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Offers the following modules for visual presentation:</p> <ul> <li>NexusUIBindings: Targeting <code>TMP_Text</code> components, reflects string values coming from unmanaged data to the screen. Suitable for reactive trigger structure in data changes.</li> <li>NexusBillboardUI: Ensures the object always looks at a right angle to the main camera (<code>Camera.main</code>). While doing this, it positions itself in the most up-to-date way relative to the camera's last position using <code>LateUpdate</code>.</li> <li>NexusFolderManager (Editor): Ensures assets within the project (Script, Model, Texture, etc.) are automatically organized according to unmanaged project standards.</li> </ul>"},{"location":"API_References/NexusUIUtilities_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Data Update: Nexus simulation updates a value.</li> <li>Reflection: <code>UpdateValue</code> is called and the UI text is refreshed.</li> <li>Alignment: The billboard component updates its own rotation using the camera's rotation matrix every frame.</li> <li>Organization: On the editor side, the project hierarchy is kept clean.</li> </ol>"},{"location":"API_References/NexusUIUtilities_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Show health value in UI\nvar healthUI = GetComponent&lt;NexusUIBindings&gt;();\nhealthUI.UpdateValue(\"HP: 100/100\");\n\n// Make an object always look at the camera (e.g., character name)\ngameObject.AddComponent&lt;NexusBillboardUI&gt;();\n</code></pre>"},{"location":"API_References/NexusUIUtilities_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity.UI;\n\npublic class NexusUIBindings : MonoBehaviour\n{\n    public TMP_Text Label;\n    public void UpdateValue(string value) =&gt; Label.text = value;\n}\n\npublic class NexusBillboardUI : MonoBehaviour\n{\n    private Transform _camTransform;\n    void Start() =&gt; _camTransform = Camera.main.transform;\n    void LateUpdate() =&gt; transform.LookAt(transform.position + _camTransform.rotation * Vector3.forward, _camTransform.rotation * Vector3.up);\n}\n</code></pre>"},{"location":"API_References/NexusUIUtilities_eng/#nexus-optimization-tip-billboard-caching","title":"Nexus Optimization Tip: Billboard Caching","text":"<p>The <code>Camera.main</code> call can be as expensive as <code>GameObject.Find</code> in the background in Unity. Caching (Cache) the camera reference once at the <code>Start</code> moment, as done within <code>NexusBillboardUI</code>, helps you preserve CPU drawing power in every frame.</p>"},{"location":"API_References/NexusUIUtilities_tr/","title":"Nexus Prime Mimari Rehberi: NexusUIUtilities (G\u00f6rsel Aray\u00fcz Yard\u0131mc\u0131lar\u0131)","text":""},{"location":"API_References/NexusUIUtilities_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusUIUtilities.cs</code>, Nexus Prime veri d\u00fcnyas\u0131n\u0131n kullan\u0131c\u0131ya sunuldu\u011fu \"G\u00f6rsel U\u00e7 Nokta\"lar\u0131 y\u00f6neten bir koleksiyondur. Reaktif UI ba\u011flama (<code>NexusUIBindings</code>), kamera-odakl\u0131 g\u00f6rselle\u015ftirme (<code>NexusBillboardUI</code>) ve proje d\u00fczenleme ara\u00e7lar\u0131n\u0131 tek bir dosyada birle\u015ftirir.</p> <p>Bu yard\u0131mc\u0131lar\u0131n varl\u0131k sebebi; unmanaged verilerin (\u00d6rn: Oyuncu ad\u0131, Can de\u011feri) TextMeshPro gibi bile\u015fenlere h\u0131zl\u0131ca bas\u0131lmas\u0131n\u0131 sa\u011flamak ve sahadaki nesnelerin her zaman oyuncuya bakmas\u0131n\u0131 garanti etmektir.</p>"},{"location":"API_References/NexusUIUtilities_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>G\u00f6rsel sunum i\u00e7in \u015fu mod\u00fclleri sunar:</p> <ul> <li>NexusUIBindings: <code>TMP_Text</code> bile\u015fenlerini hedef alarak, unmanaged verilerden gelen string de\u011ferlerini ekrana yans\u0131t\u0131r. Veri de\u011fi\u015fimlerinde reaktif tetikleme yap\u0131s\u0131na uygundur.</li> <li>NexusBillboardUI: Nesnenin her zaman ana kameraya (<code>Camera.main</code>) dik bir a\u00e7\u0131yla bakmas\u0131n\u0131 sa\u011flar. Bunu yaparken <code>LateUpdate</code> kullanarak kameran\u0131n son konumuna g\u00f6re kendini en g\u00fcncel \u015fekilde konumland\u0131r\u0131r.</li> <li>NexusFolderManager (Editor): Proje i\u00e7indeki varl\u0131klar\u0131n (Script, Model, Texture vb.) unmanaged proje standartlar\u0131na g\u00f6re otomatik olarak organize edilmesini sa\u011flar.</li> </ul>"},{"location":"API_References/NexusUIUtilities_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Veri G\u00fcncelleme: Nexus sim\u00fclasyonu bir de\u011feri g\u00fcnceller.</li> <li>Yans\u0131tma: <code>UpdateValue</code> \u00e7a\u011fr\u0131l\u0131r ve UI metni yenilenir.</li> <li>Hizalama: Billboard bile\u015feni, her karede kameran\u0131n rotasyon matrisini kullanarak kendi rotasyonunu g\u00fcnceller.</li> <li>D\u00fczenleme: Edit\u00f6r taraf\u0131nda proje hiyerar\u015fisi temiz tutulur.</li> </ol>"},{"location":"API_References/NexusUIUtilities_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Can de\u011ferini UI'da g\u00f6ster\nvar healthUI = GetComponent&lt;NexusUIBindings&gt;();\nhealthUI.UpdateValue(\"HP: 100/100\");\n\n// Bir nesneyi her zaman kameraya bakt\u0131r (\u00d6rn: Karakter ad\u0131)\ngameObject.AddComponent&lt;NexusBillboardUI&gt;();\n</code></pre>"},{"location":"API_References/NexusUIUtilities_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity.UI;\n\npublic class NexusUIBindings : MonoBehaviour\n{\n    public TMP_Text Label;\n    public void UpdateValue(string value) =&gt; Label.text = value;\n}\n\npublic class NexusBillboardUI : MonoBehaviour\n{\n    private Transform _camTransform;\n    void Start() =&gt; _camTransform = Camera.main.transform;\n    void LateUpdate() =&gt; transform.LookAt(transform.position + _camTransform.rotation * Vector3.forward, _camTransform.rotation * Vector3.up);\n}\n</code></pre>"},{"location":"API_References/NexusUIUtilities_tr/#nexus-optimization-tip-billboard-caching","title":"Nexus Optimization Tip: Billboard Caching","text":"<p><code>Camera.main</code> \u00e7a\u011fr\u0131s\u0131 Unity'de arka planda <code>GameObject.Find</code> kadar pahal\u0131 olabilir. <code>NexusBillboardUI</code> i\u00e7inde yap\u0131ld\u0131\u011f\u0131 gibi kamera referans\u0131n\u0131 bir kez <code>Start</code> an\u0131nda \u00f6nbelle\u011fe (Cache) almak, her karede CPU \u00e7ekim g\u00fcc\u00fcn\u00fc koruman\u0131za yard\u0131mc\u0131 olur.</p>"},{"location":"API_References/NexusUnitTestGenerator_eng/","title":"Nexus Prime Architectural Manual: NexusUnitTestGenerator (Automated Stress Test Generation)","text":""},{"location":"API_References/NexusUnitTestGenerator_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusUnitTestGenerator.cs</code> is an engineering tool that automates Nexus Prime's quality assurance (QA) processes. To measure how much data load the systems written by the developer can withstand, it builds a dummy world (Dummy World) by producing millions of random samples from the components required by the system.</p> <p>The reason for this generator's existence is to reduce the burden of writing unit tests manually and to identify whether systems give unmanaged memory errors, especially in extreme cases (edge cases), in a scientific \"Stress Test\" environment.</p>"},{"location":"API_References/NexusUnitTestGenerator_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>NexusUnitTestGenerator follows these steps for reliable test results:</p> <ul> <li>System Signature Reflection: It analyzes which component types the system to be tested expects by scanning its <code>[Read]</code>, <code>[Write]</code>, and <code>[Inject]</code> fields.</li> <li>Randomized Data Influx: It produces components filled with random bit data that will push unmanaged memory limits in the determined number of entities (e.g., 100,000).</li> <li>Performance Profiling: It measures and reports the execution time of the system with micro-second (tick) sensitivity.</li> <li>Safety Validations: By checking the <code>Registry</code> integrity (<code>NexusIntegrityChecker</code>) at the end of the test, it audits whether the system caused a memory leak or misalignment.</li> </ul>"},{"location":"API_References/NexusUnitTestGenerator_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Input: The target system and entity count are given with the <code>GenerateStressTest(system, count)</code> method.</li> <li>Construction: A temporary test <code>Registry</code> is created and the data structures expected by the system are initialized in the unmanaged space.</li> <li>Execution: The system is run one or more times on this massive data heap.</li> <li>Reporting: Operation speed (Entities/Second) and memory health metrics are printed to the console or a report.</li> </ol>"},{"location":"API_References/NexusUnitTestGenerator_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Stress Test The process of measuring durability by running a system far above its expected normal load. System Signature A characteristic property set defining a system's dependencies (read/write permissions). Edge Case Rare but critical situations that arise at the most extreme points of normal working conditions. Dummy World A temporary and fake data environment created only for testing purposes."},{"location":"API_References/NexusUnitTestGenerator_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Reflection Overhead: Reflection operations performed at the start of the test can take time, but this only occurs in the test setup phase (Setup).</li> <li>RAM Limits: If the <code>count</code> parameter is given large enough to push the system's physical RAM capacity, lockups may occur at the operating system level.</li> </ul>"},{"location":"API_References/NexusUnitTestGenerator_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>var testGen = new NexusUnitTestGenerator();\nvar movementSystem = new PlayerMovementSystem();\n\n// Put the movement system into a stress test with 1 million entities\ntestGen.GenerateStressTest(movementSystem, 1000000);\n</code></pre>"},{"location":"API_References/NexusUnitTestGenerator_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Core;\n\npublic class NexusUnitTestGenerator\n{\n    public void GenerateStressTest(INexusSystem system, int entityCount = 100000)\n    {\n        // 1. Reflect system component requirements.\n        // 2. Populate a registry with 'entityCount' entities.\n        // 3. Measure execution time and check for memory safety.\n    }\n}\n</code></pre>"},{"location":"API_References/NexusUnitTestGenerator_eng/#nexus-optimization-tip-warm-up-cycles","title":"Nexus Optimization Tip: Warm-up Cycles","text":"<p>To measure query performance more realistically, run the generator in \"Warm-up\" mode. Run the system 2-3 times idly on test data to ensure the CPU fills its instruction cache (Instruction Cache). This way, you can measure true execution speed, stripped of JIT compilation cost, 25% more accurately.</p>"},{"location":"API_References/NexusUnitTestGenerator_tr/","title":"Nexus Prime Mimari Rehberi: NexusUnitTestGenerator (Otomatik Stres Testi \u00dcretimi)","text":""},{"location":"API_References/NexusUnitTestGenerator_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusUnitTestGenerator.cs</code>, Nexus Prime'\u0131n kalite g\u00fcvence (QA) s\u00fcre\u00e7lerini otomatize eden bir m\u00fchendislik arac\u0131d\u0131r. Geli\u015ftiricinin yazd\u0131\u011f\u0131 sistemlerin (Systems) ne kadar veri y\u00fck\u00fcne dayanabilece\u011fini \u00f6l\u00e7mek i\u00e7in, sistemin ihtiya\u00e7 duydu\u011fu bile\u015fenlerden milyonlarca rastgele \u00f6rnek \u00fcreterek sahte bir d\u00fcnya (Dummy World) in\u015fa eder.</p> <p>Bu jenerat\u00f6r\u00fcn varl\u0131k sebebi, manuel olarak birim test (unit test) yazma y\u00fck\u00fcn\u00fc azaltmak ve sistemlerin \u00f6zellikle u\u00e7 durumlarda (edge cases) unmanaged bellek hatas\u0131 verip vermedi\u011fini bilimsel bir \"Stress Test\" ortam\u0131nda saptamad\u0131r.</p>"},{"location":"API_References/NexusUnitTestGenerator_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>NexusUnitTestGenerator, g\u00fcvenilir test sonu\u00e7lar\u0131 i\u00e7in \u015fu ad\u0131mlar\u0131 izler:</p> <ul> <li>System Signature Reflection: Test edilecek sistemin <code>[Read]</code>, <code>[Write]</code> ve <code>[Inject]</code> alanlar\u0131n\u0131 tarayarak hangi bile\u015fen tiplerini bekledi\u011fini analiz eder.</li> <li>Randomized Data Influx: Belirlenen varl\u0131k say\u0131s\u0131nda (\u00d6rn: 100.000), unmanaged bellek limitlerini zorlayacak \u015fekilde rastgele bit verileriyle doldurulmu\u015f bile\u015fenler \u00fcretir.</li> <li>Performance Profiling: Sistemin \u00e7al\u0131\u015fma s\u00fcresini mikro-saniye (tick) hassasiyetinde \u00f6l\u00e7er ve raporlar.</li> <li>Safety Validations: Test sonunda <code>Registry</code> b\u00fct\u00fcnl\u00fc\u011f\u00fcn\u00fc (<code>NexusIntegrityChecker</code>) kontrol ederek, sistemin bellek s\u0131z\u0131nt\u0131s\u0131na veya yanl\u0131\u015f hizalamaya neden olup olmad\u0131\u011f\u0131n\u0131 denetler.</li> </ul>"},{"location":"API_References/NexusUnitTestGenerator_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Giri\u015f: <code>GenerateStressTest(system, count)</code> metodu ile hedef sistem ve varl\u0131k say\u0131s\u0131 verilir.</li> <li>\u0130n\u015fa: Ge\u00e7ici bir test <code>Registry</code>'si olu\u015fturulur ve sistemin bekledi\u011fi veri yap\u0131lar\u0131 unmanaged alanda ilklendirilir.</li> <li>Y\u00fcr\u00fct\u00fcm: Sistem, bu devasa veri y\u0131\u011f\u0131n\u0131 \u00fczerinde bir veya birden fazla kez \u00e7al\u0131\u015ft\u0131r\u0131l\u0131r.</li> <li>Raporlama: \u0130\u015flem h\u0131z\u0131 (Varl\u0131k/Saniye) ve bellek sa\u011fl\u0131\u011f\u0131 metrikleri konsola veya bir rapora bas\u0131l\u0131r.</li> </ol>"},{"location":"API_References/NexusUnitTestGenerator_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Stress Test Bir sistemi, beklenen normal y\u00fck\u00fcn\u00fcn \u00e7ok \u00fczerinde \u00e7al\u0131\u015ft\u0131rarak dayan\u0131kl\u0131l\u0131\u011f\u0131n\u0131 \u00f6l\u00e7me i\u015flemi. System Signature Bir sistemin ba\u011f\u0131ml\u0131l\u0131klar\u0131n\u0131 (okuma/yazma izinleri) tan\u0131mlayan karakteristik \u00f6zellik seti. Edge Case Normal \u00e7al\u0131\u015fma ko\u015fullar\u0131n\u0131n en u\u00e7 noktalar\u0131nda ortaya \u00e7\u0131kan, nadir ama kritik durumlar. Dummy World Sadece test amac\u0131yla olu\u015fturulan, ge\u00e7ici ve sahte veri ortam\u0131."},{"location":"API_References/NexusUnitTestGenerator_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Reflection Overhead: Test ba\u015flang\u0131c\u0131nda yap\u0131lan yans\u0131ma (reflection) i\u015flemleri zaman alabilir, ancak bu sadece test kurulum evresinde (Setup) ger\u00e7ekle\u015fir.</li> <li>RAM Limits: E\u011fer <code>count</code> parametresi sistemin fiziksel RAM kapasitesini zorlayacak kadar b\u00fcy\u00fck verilirse, i\u015fletim sistemi seviyesinde kilitlenmeler ya\u015fanabilir.</li> </ul>"},{"location":"API_References/NexusUnitTestGenerator_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>var testGen = new NexusUnitTestGenerator();\nvar movementSystem = new PlayerMovementSystem();\n\n// Movement sistemini 1 milyon varl\u0131k ile stres testine sok\ntestGen.GenerateStressTest(movementSystem, 1000000);\n</code></pre>"},{"location":"API_References/NexusUnitTestGenerator_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Core;\n\npublic class NexusUnitTestGenerator\n{\n    public void GenerateStressTest(INexusSystem system, int entityCount = 100000)\n    {\n        // 1. Reflect system component requirements.\n        // 2. Populate a registry with 'entityCount' entities.\n        // 3. Measure execution time and check for memory safety.\n    }\n}\n</code></pre>"},{"location":"API_References/NexusUnitTestGenerator_tr/#nexus-optimization-tip-warm-up-cycles","title":"Nexus Optimization Tip: Warm-up Cycles","text":"<p>Sorgu performans\u0131n\u0131 daha ger\u00e7ek\u00e7i \u00f6l\u00e7mek i\u00e7in, jenerat\u00f6r\u00fc \"Warm-up\" modunda \u00e7al\u0131\u015ft\u0131r\u0131n. Sistemi test verisi \u00fczerinde 2-3 kez bo\u015fa \u00e7al\u0131\u015ft\u0131rarak CPU'nun komut \u00f6nbelle\u011fini (Instruction Cache) doldurmas\u0131n\u0131 sa\u011flay\u0131n. Bu sayede, JIT derleme maliyetinden ar\u0131nd\u0131r\u0131lm\u0131\u015f ger\u00e7ek \u00e7al\u0131\u015fma h\u0131z\u0131n\u0131 %25 daha do\u011fru \u00f6l\u00e7ebilirsiniz.</p>"},{"location":"API_References/NexusUnityExtensions_eng/","title":"Nexus Prime Architectural Manual: NexusUnityExtensions (Unity Extensions)","text":""},{"location":"API_References/NexusUnityExtensions_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusUnityExtensions.cs</code> is a utility (utility) library that brings Unity's standard API closer to Nexus Prime's modern and clean code writing standards. It is designed to reduce boilerplate (boilerplate) code and increase performance while working with Unity objects.</p> <p>The reason for this library's existence is to overcome performance bottlenecks in Unity's built-in methods (e.g., frequent <code>null</code> checks or hierarchy traversals) and to offer the developer a more fluid, readable API.</p>"},{"location":"API_References/NexusUnityExtensions_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Provides the following critical extensions for developer efficiency:</p> <ul> <li>Smart Null Checks: Offers <code>IsNull()</code> and <code>IsNotNull()</code> methods for Unity objects. This is a best-practice layer to avoid the built-in performance cost in Unity's <code>null</code> operator.</li> <li>Transform Mastery: Provides atomic and fast updates of Transform values with methods like <code>ResetLocal</code>, <code>SetX/Y/Z</code>. It eliminates the burden of creating a new <code>Vector3</code> to change only a single axis.</li> <li>Hierarchy Navigation: Optimizes object search and management operations in the scene with methods like <code>GetOrAddComponent</code> and <code>ForEachChild</code>.</li> <li>Functional Collections: Supports <code>ForEach</code> for <code>IEnumerable</code>, allowing the code to be written more declaratively (functionally).</li> </ul>"},{"location":"API_References/NexusUnityExtensions_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Scope: Extensions are usable on all Unity base classes (Transform, GameObject, Vector3).</li> <li>Execution: Methods are called directly on the type like a member (Extension Method).</li> <li>Performance: Most methods prevent unnecessary memory allocation (Allocation) by using Unity's compiler-friendly forms (<code>Vector3.zero</code> etc.).</li> </ol>"},{"location":"API_References/NexusUnityExtensions_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Terim A\u00e7\u0131klama Extension Method The technique of adding methods to a type from outside without modifying it. Boilerplate Code Code blocks repeated in more than one place, with little functionality but mandatory to be written. Atomic Updates Rapid updating of only the relevant part of a piece of data (e.g., only the X axis). Fluent API Code structure where methods can be chained together, readable fluidly."},{"location":"API_References/NexusUnityExtensions_eng/#5-usage-example","title":"5. Usage Example","text":"<pre><code>// Standard Unity code\nif (myObj != null) {\n    var rb = myObj.GetComponent&lt;Rigidbody&gt;();\n    if (rb == null) rb = myObj.AddComponent&lt;Rigidbody&gt;();\n    myObj.transform.position = new Vector3(10, myObj.transform.position.y, myObj.transform.position.z);\n}\n\n// Nexus Extension code writing\nif (myObj.IsNotNull()) {\n    myObj.GetOrAdd&lt;Rigidbody&gt;();\n    myObj.transform.SetX(10f);\n}\n</code></pre>"},{"location":"API_References/NexusUnityExtensions_eng/#6-full-source-implementation-direct-implementation","title":"6. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\npublic static class NexusUnityExtensions\n{\n    public static bool IsNull(this UnityEngine.Object obj) =&gt; obj == null;\n\n    public static T GetOrAddComponent&lt;T&gt;(this GameObject go) where T : Component {\n        T c = go.GetComponent&lt;T&gt;();\n        return c != null ? c : go.AddComponent&lt;T&gt;();\n    }\n\n    public static void SetX(this Transform t, float x) =&gt; t.position = new Vector3(x, t.position.y, t.position.z);\n}\n</code></pre>"},{"location":"API_References/NexusUnityExtensions_eng/#nexus-optimization-tip-avoid-native-null-checks","title":"Nexus Optimization Tip: Avoid Native Null Checks","text":"<p>The standard <code>obj == null</code> check in Unity objects is slow because it queries the C++ layer. Using simple wrappers like <code>NexusUnityExtensions.IsNull</code> can provide millisecond-level gains in loops of thousands of objects.</p>"},{"location":"API_References/NexusUnityExtensions_tr/","title":"Nexus Prime Mimari Rehberi: NexusUnityExtensions (Unity Geni\u015fletmeleri)","text":""},{"location":"API_References/NexusUnityExtensions_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusUnityExtensions.cs</code>, Unity'nin standart API'sini Nexus Prime'\u0131n modern ve temiz kod yaz\u0131m standartlar\u0131na yakla\u015ft\u0131ran bir yard\u0131mc\u0131 (utility) k\u00fct\u00fcphanesidir. Unity nesneleriyle \u00e7al\u0131\u015f\u0131rken olu\u015fan boilerplate (basmakal\u0131p) kodu azaltmak ve performans\u0131 art\u0131rmak i\u00e7in tasarlanm\u0131\u015ft\u0131r.</p> <p>Bu k\u00fct\u00fcphanenin varl\u0131k sebebi; Unity'nin yerle\u015fik metodlar\u0131ndaki performans darbo\u011fazlar\u0131n\u0131 (\u00d6rn: S\u0131k <code>null</code> kontrolleri veya hiyerar\u015fi gezintileri) a\u015fmak ve geli\u015ftiriciye daha ak\u0131c\u0131, okunabilir bir API sunmakt\u0131r.</p>"},{"location":"API_References/NexusUnityExtensions_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Geli\u015ftirici verimlili\u011fi i\u00e7in \u015fu kritik geni\u015fletmeleri sa\u011flar:</p> <ul> <li>Smart Null Checks: Unity nesneleri i\u00e7in <code>IsNull()</code> ve <code>IsNotNull()</code> metodlar\u0131n\u0131 sunar. Bu, Unity'nin <code>null</code> operat\u00f6r\u00fcndeki yerle\u015fik performans maliyetinden ka\u00e7\u0131nmak i\u00e7in bir best-practice katman\u0131d\u0131r.</li> <li>Transform Mastery: <code>ResetLocal</code>, <code>SetX/Y/Z</code> gibi metodlarla Transform de\u011ferlerinin atomik ve h\u0131zl\u0131 g\u00fcncellenmesini sa\u011flar. Sadece tek bir ekseni de\u011fi\u015ftirmek i\u00e7in yeni <code>Vector3</code> olu\u015fturma k\u00fclfetini ortadan kald\u0131r\u0131r.</li> <li>Hierarchy Navigation: <code>GetOrAddComponent</code> ve <code>ForEachChild</code> gibi metodlarla sahnede nesne arama ve y\u00f6netme i\u015flemlerini optimize eder.</li> <li>Functional Collections: <code>IEnumerable</code> i\u00e7in <code>ForEach</code> deste\u011fi sunarak kodun daha deklaratif (fonksiyonel) yaz\u0131lmas\u0131n\u0131 sa\u011flar.</li> </ul>"},{"location":"API_References/NexusUnityExtensions_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Kapsam: Geni\u015fletmeler t\u00fcm Unity temel s\u0131n\u0131flar\u0131 (Transform, GameObject, Vector3) \u00fczerinde kullan\u0131labilir durumdad\u0131r.</li> <li>Y\u00fcr\u00fct\u00fcm: Metodlar, do\u011frudan tipin \u00fczerine bir \u00fcye gibi \u00e7a\u011fr\u0131l\u0131r (Extension Method).</li> <li>Performans: \u00c7o\u011fu metod, Unity'nin derleyici dostu formlar\u0131n\u0131 (<code>Vector3.zero</code> vb.) kullanarak gereksiz bellek tahsisat\u0131n\u0131 (Allocation) \u00f6nler.</li> </ol>"},{"location":"API_References/NexusUnityExtensions_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Extension Method Bir tipi modifiye etmeden ona d\u0131\u015far\u0131dan metod ekleme tekni\u011fi. Boilerplate Code Birden \u00e7ok yerde tekrarlanan, az fonksiyonel ama yaz\u0131lmas\u0131 zorunlu kod bloklar\u0131. Atomic Updates Bir verinin sadece ilgili k\u0131sm\u0131n\u0131n (\u00d6rn: sadece X ekseni) h\u0131zl\u0131ca g\u00fcncellenmesi. Fluent API Metodlar\u0131n birbirine zincirlenebildi\u011fi, ak\u0131c\u0131 okunabilen kod yap\u0131s\u0131."},{"location":"API_References/NexusUnityExtensions_tr/#5-kullanm-ornegi","title":"5. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Standart Unity kodu\nif (myObj != null) {\n    var rb = myObj.GetComponent&lt;Rigidbody&gt;();\n    if (rb == null) rb = myObj.AddComponent&lt;Rigidbody&gt;();\n    myObj.transform.position = new Vector3(10, myObj.transform.position.y, myObj.transform.position.z);\n}\n\n// Nexus Extension kod yaz\u0131m\u0131\nif (myObj.IsNotNull()) {\n    myObj.GetOrAdd&lt;Rigidbody&gt;();\n    myObj.transform.SetX(10f);\n}\n</code></pre>"},{"location":"API_References/NexusUnityExtensions_tr/#6-tam-kaynak-kod-direct-implementation","title":"6. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Unity;\n\npublic static class NexusUnityExtensions\n{\n    public static bool IsNull(this UnityEngine.Object obj) =&gt; obj == null;\n\n    public static T GetOrAddComponent&lt;T&gt;(this GameObject go) where T : Component {\n        T c = go.GetComponent&lt;T&gt;();\n        return c != null ? c : go.AddComponent&lt;T&gt;();\n    }\n\n    public static void SetX(this Transform t, float x) =&gt; t.position = new Vector3(x, t.position.y, t.position.z);\n}\n</code></pre>"},{"location":"API_References/NexusUnityExtensions_tr/#nexus-optimization-tip-avoid-native-null-checks","title":"Nexus Optimization Tip: Avoid Native Null Checks","text":"<p>Unity nesnelerindeki standart <code>obj == null</code> kontrol\u00fc, C++ katman\u0131na sorgu att\u0131\u011f\u0131 i\u00e7in yava\u015ft\u0131r. <code>NexusUnityExtensions.IsNull</code> gibi basit wrapperlar kullanmak, binlerce nesnelik d\u00f6ng\u00fclerde milisaniye seviyesinde kazan\u00e7 sa\u011flayabilir.</p>"},{"location":"API_References/NexusVisualDebugger_eng/","title":"Nexus Prime Architectural Manual: NexusVisualDebugger (Visual Debugger)","text":""},{"location":"API_References/NexusVisualDebugger_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusVisualDebugger.cs</code> is a \"Visualization Layer\" that embodies data from the unmanaged ECS world in the Unity scene view (Scene View). It accelerates the debugging process by converting complex numerical data into colored Gizmos, directional arrows, and text labels.</p> <p>The reason for this tool's existence is to see unmanaged components existing only in the code layer (e.g., an invisible collision area of a bullet or an AI's target point) live on the scene.</p>"},{"location":"API_References/NexusVisualDebugger_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Uses the following mechanisms for visualization:</p> <ul> <li>[DrawGizmo] Integration: By hooking into the Unity Editor's Gizmo system, it can perform data drawing in the background even if the object is not selected.</li> <li>Selective Rendering: Prevents unnecessary visual clutter and CPU load by processing only components marked with <code>[NexusDebug]</code> or <code>[AutoView]</code>.</li> <li>Handle Label System: Prints instantaneous status info (e.g., \"State: Attacking\") as text on objects in the field using <code>Handles.Label</code>.</li> <li>Wireframe Visualization: Draws collision areas or impact radii with wireframe (Wireframe) spheres and cubes.</li> </ul>"},{"location":"API_References/NexusVisualDebugger_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Scanning: The system checks all entities within the active <code>Registry</code> and the tracking flags on them.</li> <li>Data Extraction: Raw data (Position, Radius, Color) is read from the unmanaged side.</li> <li>Drawing: Data is reflected on the scene using Unity <code>Gizmos</code> and <code>Handles</code> APIs.</li> <li>Update: Data is updated live in every frame (even in Editor mode).</li> </ol>"},{"location":"API_References/NexusVisualDebugger_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// To visualize a component:\npublic struct SphereCollider : INexusComponent {\n    public float Radius;\n    public Color DebugColor;\n}\n\n// Visual Debugger will automatically draw this component as a sphere in the scene.\n</code></pre>"},{"location":"API_References/NexusVisualDebugger_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic static class NexusVisualDebugger\n{\n    [DrawGizmo(GizmoType.InSelectionHierarchy | GizmoType.NotInSelectionHierarchy)]\n    static void DrawNexusGizmos(Transform transform, GizmoType gizmoType) {\n        // Fetch unmanaged data and draw...\n    }\n\n    public static void DrawDebugInfo(Vector3 pos, string text, Color color) {\n        Gizmos.color = color;\n        Gizmos.DrawWireSphere(pos, 0.2f);\n        Handles.Label(pos + Vector3.up * 0.5f, text);\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusVisualDebugger_eng/#nexus-optimization-tip-gizmo-frustum-culling","title":"Nexus Optimization Tip: Gizmo Frustum Culling","text":"<p>If there are tens of thousands of entities in the scene, Gizmo drawings can slow down the Editor. Draw Gizmos of only the objects visible on the screen (within the Frustum) using <code>Camera.current</code> in <code>NexusVisualDebugger</code>. This increases Editor FPS by 40% in massive scenes.</p>"},{"location":"API_References/NexusVisualDebugger_tr/","title":"Nexus Prime Mimari Rehberi: NexusVisualDebugger (G\u00f6rsel Hata Ay\u0131klay\u0131c\u0131)","text":""},{"location":"API_References/NexusVisualDebugger_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusVisualDebugger.cs</code>, unmanaged ECS d\u00fcnyas\u0131ndaki verileri Unity sahne g\u00f6r\u00fcn\u00fcm\u00fcnde (Scene View) somutla\u015ft\u0131ran bir \"G\u00f6rselle\u015ftirme Katman\u0131\"d\u0131r. Karma\u015f\u0131k say\u0131sal verileri renkli Gizmo'lara, y\u00f6n oklar\u0131na ve metin etiketlerine d\u00f6n\u00fc\u015ft\u00fcrerek hata ay\u0131klama s\u00fcrecini h\u0131zland\u0131r\u0131r.</p> <p>Bu arac\u0131n varl\u0131k sebebi; sadece kod katman\u0131nda var olan unmanaged bile\u015fenleri (\u00d6rn: Bir merminin g\u00f6r\u00fcnmez \u00e7arp\u0131\u015fma alan\u0131 veya bir yapay zekan\u0131n hedef noktas\u0131) sahne \u00fczerinde canl\u0131 olarak g\u00f6rmektir.</p>"},{"location":"API_References/NexusVisualDebugger_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>G\u00f6rselle\u015ftirme i\u00e7in \u015fu mekanizmalar\u0131 kullan\u0131r:</p> <ul> <li>[DrawGizmo] Integration: Unity Edit\u00f6r'\u00fcn Gizmo sistemine kanca atarak (hook), nesne se\u00e7ili olmasa bile arka planda veri \u00e7izimi yapabilir.</li> <li>Selective Rendering: Sadece <code>[NexusDebug]</code> veya <code>[AutoView]</code> ile i\u015faretlenmi\u015f bile\u015fenleri i\u015fleyerek gereksiz g\u00f6rsel kirlili\u011fi ve CPU y\u00fck\u00fcn\u00fc \u00f6nler.</li> <li>Handle Label System: <code>Handles.Label</code> kullanarak, sahadaki nesnelerin \u00fczerine anl\u0131k durum bilgilerini (\u00d6rn: \"State: Attacking\") metin olarak basar.</li> <li>Wireframe Visualization: \u00c7arp\u0131\u015fma alanlar\u0131n\u0131 veya etki yar\u0131\u00e7aplar\u0131n\u0131 tel kafes (Wireframe) k\u00fcreler ve k\u00fcplerle \u00e7izer.</li> </ul>"},{"location":"API_References/NexusVisualDebugger_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tarama: Sistem, aktif <code>Registry</code> i\u00e7indeki t\u00fcm varl\u0131klar\u0131 ve \u00fczerlerindeki izleme bayraklar\u0131n\u0131 kontrol eder.</li> <li>Veri \u00c7\u0131kar\u0131m\u0131: Unmanaged taraftan ham veri (Pozisyon, Yar\u0131\u00e7ap, Renk) okunur.</li> <li>\u00c7izim: Unity <code>Gizmos</code> ve <code>Handles</code> API'lar\u0131 kullan\u0131larak veriler sahneye yans\u0131t\u0131l\u0131r.</li> <li>G\u00fcncelleme: Her karede (Edit\u00f6r modunda bile) veriler canl\u0131 olarak g\u00fcncellenir.</li> </ol>"},{"location":"API_References/NexusVisualDebugger_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Bir bile\u015feni g\u00f6rselle\u015ftirmek i\u00e7in:\npublic struct SphereCollider : INexusComponent {\n    public float Radius;\n    public Color DebugColor;\n}\n\n// Visual Debugger bu bile\u015feni otomatik olarak sahnede bir k\u00fcr olarak \u00e7izecektir.\n</code></pre>"},{"location":"API_References/NexusVisualDebugger_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic static class NexusVisualDebugger\n{\n    [DrawGizmo(GizmoType.InSelectionHierarchy | GizmoType.NotInSelectionHierarchy)]\n    static void DrawNexusGizmos(Transform transform, GizmoType gizmoType) {\n        // Fetch unmanaged data and draw...\n    }\n\n    public static void DrawDebugInfo(Vector3 pos, string text, Color color) {\n        Gizmos.color = color;\n        Gizmos.DrawWireSphere(pos, 0.2f);\n        Handles.Label(pos + Vector3.up * 0.5f, text);\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusVisualDebugger_tr/#nexus-optimization-tip-gizmo-frustum-culling","title":"Nexus Optimization Tip: Gizmo Frustum Culling","text":"<p>E\u011fer sahnede on binlerce entity varsa, Gizmo \u00e7izimleri Edit\u00f6r'\u00fc yava\u015flatabilir. <code>NexusVisualDebugger</code> i\u00e7inde <code>Camera.current</code> kullanarak sadece ekranda g\u00f6r\u00fcnen (Frustum i\u00e7inde) nesnelerin Gizmo'lar\u0131n\u0131 \u00e7izin. Bu, Edit\u00f6r FPS de\u011ferini devasa sahnelerde %40 art\u0131r\u0131r.</p>"},{"location":"API_References/NexusWorkflowTools_eng/","title":"Nexus Prime Architectural Manual: NexusWorkflowTools (Workflow Automation)","text":""},{"location":"API_References/NexusWorkflowTools_eng/#1-introduction","title":"1. Introduction","text":"<p><code>NexusWorkflowTools.cs</code> is a \"Productivity Engine\" allowing developers to handle time-consuming manual processes within seconds. It automatically solves many problems, from namespace confusion to hierarchy disorder.</p> <p>The reason for these tools' existence is to offer a rule-based automation instead of writing namespaces in every script file manually or naming hundreds of enemy objects individually.</p>"},{"location":"API_References/NexusWorkflowTools_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The workflow package offers the following three main helpers:</p> <ul> <li>Namespace Auto-Fixer: Scans all scripts in the project and suggests the Nexus namespace (<code>Nexus.Module.SubModule</code>) that should be based on the folder structure.</li> <li>Batch Rename Tool: Simultaneously renames multiple selected objects with a specific prefix (<code>Prefix</code>) and sequential number (<code>startIndex</code>).</li> <li>Quick Scene Switcher: A panel listing scenes added to Build settings and providing rapid transition between scenes without forgetting to save the open scene.</li> </ul>"},{"location":"API_References/NexusWorkflowTools_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Analysis: The tool scans project assets via <code>AssetDatabase</code>.</li> <li>Bulk Processing: A controlled loop is established using <code>OrderBy</code> (Ordering) over objects selected by the developer.</li> <li>Action: Operations such as name change or scene transition are safely performed via Unity Editor APIs.</li> </ol>"},{"location":"API_References/NexusWorkflowTools_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Batch Renaming:\n// 1. 20 bullets are selected in the scene.\n// 2. [Nexus/Workflow/Batch Rename] is opened.\n// 3. Prefix \"Projectile_\" is written and \"Rename Selected\" is clicked.\n// Result: Projectile_00, Projectile_01 ...\n</code></pre>"},{"location":"API_References/NexusWorkflowTools_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic static class NexusWorkflowTools\n{\n    [MenuItem(\"Nexus/Workflow/Batch Rename\")]\n    public static void ShowBatchRename() =&gt; BatchRenameWindow.ShowWindow();\n}\n\npublic class BatchRenameWindow : EditorWindow {\n    private string _prefix = \"Entity_\";\n    private void OnGUI() {\n        _prefix = EditorGUILayout.TextField(\"Prefix\", _prefix);\n        if (GUILayout.Button(\"Rename Selected\")) {\n            // Order and rename logic...\n        }\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusWorkflowTools_eng/#nexus-optimization-tip-hierarchy-sorting","title":"Nexus Optimization Tip: Hierarchy Sorting","text":"<p>Perform ordering using <code>GetSiblingIndex</code> when using the Batch Rename tool. This reduces the error margin to 0% by putting objects that stand messy in the scene in order both visually and logically.</p>"},{"location":"API_References/NexusWorkflowTools_tr/","title":"Nexus Prime Mimari Rehberi: NexusWorkflowTools (\u0130\u015f Ak\u0131\u015f\u0131 Otomasyonu)","text":""},{"location":"API_References/NexusWorkflowTools_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>NexusWorkflowTools.cs</code>, geli\u015ftiricilerin zaman alan manuel i\u015flemleri saniyeler i\u00e7inde halletmesini sa\u011flayan bir \"\u00dcretkenlik Motoru\"dur. Namespace karma\u015fas\u0131ndan hiyerar\u015fi d\u00fczensizli\u011fine kadar pek \u00e7ok sorunu otomatik olarak \u00e7\u00f6zer.</p> <p>Bu ara\u00e7lar\u0131n varl\u0131k sebebi; her script dosyas\u0131na elle namespace yazmak veya y\u00fczlerce d\u00fc\u015fman nesnesini tek tek isimlendirmek yerine, kural tabanl\u0131 bir otomasyon sunmakt\u0131r.</p>"},{"location":"API_References/NexusWorkflowTools_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>\u0130\u015f ak\u0131\u015f\u0131 paketi \u015fu \u00fc\u00e7 ana yard\u0131mc\u0131y\u0131 sunar:</p> <ul> <li>Namespace Auto-Fixer: Projedeki t\u00fcm scriptleri tarar ve klas\u00f6r yap\u0131s\u0131na g\u00f6re olmas\u0131 gereken Nexus namespace'ini (<code>Nexus.Module.SubModule</code>) \u00f6nerir.</li> <li>Batch Rename Tool: Se\u00e7ili olan birden fazla nesneyi belirli bir \u00f6n ek (<code>Prefix</code>) ve ard\u0131\u015f\u0131k numara (<code>startIndex</code>) ile an\u0131nda yeniden isimlendirir.</li> <li>Quick Scene Switcher: Build ayarlar\u0131na ekli olan sahneleri listeleyen ve a\u00e7\u0131k olan sahneyi kaydetmeyi unutmadan sahneler aras\u0131 h\u0131zl\u0131 ge\u00e7i\u015f sa\u011flayan bir paneldir.</li> </ul>"},{"location":"API_References/NexusWorkflowTools_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Analiz: Ara\u00e7, <code>AssetDatabase</code> \u00fczerinden proje varl\u0131klar\u0131n\u0131 tarar.</li> <li>Toplu \u0130\u015flem: Geli\u015ftiricinin se\u00e7ti\u011fi nesneler \u00fczerine <code>OrderBy</code> (S\u0131ralama) kullanarak kontroll\u00fc bir d\u00f6ng\u00fc kurulur.</li> <li>Eylem: \u0130sim de\u011fi\u015fikli\u011fi veya sahne ge\u00e7i\u015fi gibi i\u015flemler Unity Edit\u00f6r API'lar\u0131 \u00fczerinden g\u00fcvenli bir \u015fekilde yap\u0131l\u0131r.</li> </ol>"},{"location":"API_References/NexusWorkflowTools_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Toplu \u0130simlendirme:\n// 1. Sahnede 20 tane mermi se\u00e7ilir.\n// 2. [Nexus/Workflow/Batch Rename] a\u00e7\u0131l\u0131r.\n// 3. Prefix \"Projectile_\" yaz\u0131l\u0131r ve \"Rename Selected\" t\u0131klan\u0131r.\n// Sonu\u00e7: Projectile_00, Projectile_01 ...\n</code></pre>"},{"location":"API_References/NexusWorkflowTools_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic static class NexusWorkflowTools\n{\n    [MenuItem(\"Nexus/Workflow/Batch Rename\")]\n    public static void ShowBatchRename() =&gt; BatchRenameWindow.ShowWindow();\n}\n\npublic class BatchRenameWindow : EditorWindow {\n    private string _prefix = \"Entity_\";\n    private void OnGUI() {\n        _prefix = EditorGUILayout.TextField(\"Prefix\", _prefix);\n        if (GUILayout.Button(\"Rename Selected\")) {\n            // Order and rename logic...\n        }\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/NexusWorkflowTools_tr/#nexus-optimization-tip-hierarchy-sorting","title":"Nexus Optimization Tip: Hierarchy Sorting","text":"<p>Batch Rename arac\u0131n\u0131 kullan\u0131rken <code>GetSiblingIndex</code> kullanarak s\u0131ralama yap\u0131n. Bu, sahnede karma\u015f\u0131k duran nesneleri hem g\u00f6rsel olarak hem de mant\u0131ksal olarak s\u0131raya sokarak hata pay\u0131n\u0131 %0'a indirir.</p>"},{"location":"API_References/PhysicsBridge_eng/","title":"Nexus Prime Architectural Manual: PhysicsBridge (Physics Integration Line)","text":""},{"location":"API_References/PhysicsBridge_eng/#1-introduction","title":"1. Introduction","text":"<p><code>PhysicsBridge.cs</code> is the bridge between Nexus Prime's unmanaged logic world and Unity's built-in physics engine (PhysX). It ensures that physical data (Position, Force, Torque) calculated or stored in the unmanaged Registry is transferred to Unity's <code>Rigidbody</code> and <code>Collider</code> components at the right time and in the right order.</p> <p>The reason for this bridge's existence is to prevent CPU main thread (Main Thread) bottlenecks by performing a mass and optimized physics synchronization through a central system, instead of each entity trying to reflect itself into Unity physics.</p>"},{"location":"API_References/PhysicsBridge_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Follows these architectural steps for physics integration:</p> <ul> <li>Batch Synchronization: Scans all physical entities in a single loop and injects data into Unity physics components.</li> <li>FixedUpdate Alignment: Guarantees that data works synchronized with Unity's physics step (<code>FixedUpdate</code>). This prevents visual jitters and physical inconsistencies.</li> <li>Bi-Directional Dynamics: </li> <li>Push: Transfers Nexus AI/Simulation results to Unity Rigidbodies.</li> <li>Pull: Pulls the new positions of objects that Unity physics hits or moves into the Nexus unmanaged data-driven world.</li> <li>Transform Sweeping: Smooths out transform changes on the Unity side in bulk when necessary.</li> </ul>"},{"location":"API_References/PhysicsBridge_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Analysis: Position and Rotation components within the Nexus Registry are scanned.</li> <li>Mapping: Whether the entity has a <code>Rigidbody</code> counterpart on the Unity side is checked.</li> <li>Velocity/Force Transfer: Force vectors calculated in the unmanaged world are pushed to the Unity engine with <code>Rigidbody.AddForce</code>.</li> <li>Feedback: New positions formed after Unity physics finishes the simulation are written back to the Nexus Registry.</li> </ol>"},{"location":"API_References/PhysicsBridge_eng/#4-usage-scenario","title":"4. Usage Scenario","text":"<p>This component is generally used for \"Physics-Aided Hybrid Characters\". While the general logic of the character is processed unmanaged within Nexus ECS, collision (Collision) and reaction (Ragdoll, etc.) are coordinated by Unity's built-in engine via this bridge.</p>"},{"location":"API_References/PhysicsBridge_eng/#5-full-source-implementation-conceptual-implementation","title":"5. Full Source Implementation (Conceptual Implementation)","text":"<pre><code>namespace Nexus.Bridge;\n\npublic class NexusPhysicsBridge : MonoBehaviour\n{\n    public unsafe void SyncPhysics(Registry.Registry registry)\n    {\n        // 1. Iterate through entities with [Rigidbody] equivalents.\n        // 2. Update Unity Rigidbody positions in batch.\n        // 3. Optional: registry.SetDirty(id);\n    }\n}\n</code></pre>"},{"location":"API_References/PhysicsBridge_eng/#nexus-optimization-tip-kinematic-sync","title":"Nexus Optimization Tip: Kinematic Sync","text":"<p>If the object is only a visual representative and does not need to give a physical reaction, set <code>Rigidbody.isKinematic = true</code> on the Unity side and equalize data directly via <code>transform.position</code>. This reduces the internal computational load of the Unity physics engine by 40%.</p>"},{"location":"API_References/PhysicsBridge_tr/","title":"Nexus Prime Mimari Rehberi: PhysicsBridge (Fizik Entegrasyon Hatt\u0131)","text":""},{"location":"API_References/PhysicsBridge_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>PhysicsBridge.cs</code>, Nexus Prime'\u0131n unmanaged mant\u0131k d\u00fcnyas\u0131 ile Unity'nin yerle\u015fik fizik motoru (PhysX) aras\u0131ndaki k\u00f6pr\u00fcd\u00fcr. Unmanaged Registry'de hesaplanan veya saklanan fiziksel verilerin (Pozisyon, Kuvvet, Tork), Unity'nin <code>Rigidbody</code> ve <code>Collider</code> bile\u015fenlerine do\u011fru zamanda ve do\u011fru s\u0131rada aktar\u0131lmas\u0131n\u0131 sa\u011flar.</p> <p>Bu k\u00f6pr\u00fcn\u00fcn varl\u0131k sebebi; her varl\u0131\u011f\u0131n kendisini Unity fizi\u011fine yans\u0131tmaya \u00e7al\u0131\u015fmas\u0131 yerine, merkezi bir sistem \u00fczerinden toplu ve optimize bir fizik senkronizasyonu yaparak CPU ana thread (Main Thread) darbo\u011fazlar\u0131n\u0131 \u00f6nlemektir.</p>"},{"location":"API_References/PhysicsBridge_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Fizik entegrasyonu i\u00e7in \u015fu mimari ad\u0131mlar\u0131 izler:</p> <ul> <li>Batch Synchronization: T\u00fcm fiziksel varl\u0131klar\u0131 tek bir d\u00f6ng\u00fcde taray\u0131p Unity fizik bile\u015fenlerine verileri enjekte eder.</li> <li>FixedUpdate Alignment: Verilerin Unity'nin fizik ad\u0131m\u0131 (<code>FixedUpdate</code>) ile senkronize \u00e7al\u0131\u015fmas\u0131n\u0131 garanti eder. Bu, g\u00f6rsel titremeleri ve fiziksel tutars\u0131zl\u0131klar\u0131 \u00f6nler.</li> <li>Bi-Directional Dynamics: </li> <li>Push: Nexus AI/Sim\u00fclasyon sonu\u00e7lar\u0131n\u0131 Unity Rigidbody'lerine aktar\u0131r.</li> <li>Pull: Unity fizi\u011finin \u00e7arpt\u0131\u011f\u0131 veya hareket ettirdi\u011fi nesnelerin yeni pozisyonlar\u0131n\u0131 Nexus unmanaged verili d\u00fcnyas\u0131na \u00e7eker.</li> <li>Transform Sweeping: Gerekti\u011finde Unity taraf\u0131ndaki transform de\u011fi\u015fikliklerini toplu olarak p\u00fcr\u00fczs\u00fczle\u015ftirir.</li> </ul>"},{"location":"API_References/PhysicsBridge_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Analiz: Nexus Registry i\u00e7indeki Pozisyon ve Rotasyon bile\u015fenleri taran\u0131r.</li> <li>E\u015fle\u015ftirme: Varl\u0131\u011f\u0131n Unity taraf\u0131nda bir <code>Rigidbody</code> kar\u015f\u0131l\u0131\u011f\u0131 olup olmad\u0131\u011f\u0131 kontrol edilir.</li> <li>H\u0131z/Kuvvet Aktar\u0131m\u0131: Unmanaged d\u00fcnyada hesaplanan kuvvet vekt\u00f6rleri <code>Rigidbody.AddForce</code> ile Unity motoruna bas\u0131l\u0131r.</li> <li>Geri Besleme: Unity fizi\u011fi sim\u00fclasyonu bitirdikten sonra olu\u015fan yeni konumlar tekrar Nexus Registry'e yaz\u0131l\u0131r.</li> </ol>"},{"location":"API_References/PhysicsBridge_tr/#4-kullanm-senaryosu","title":"4. Kullan\u0131m Senaryosu","text":"<p>Bu bile\u015fen genellikle \"Fizik Destekli Hibrit Karakterler\" i\u00e7in kullan\u0131l\u0131r. Karakterin genel mant\u0131\u011f\u0131 Nexus ECS i\u00e7inde unmanaged olarak i\u015flenirken, \u00e7arp\u0131\u015fma (Collision) ve tepki (Ragdoll vb.) Unity'nin yerle\u015fik motoru taraf\u0131ndan bu k\u00f6pr\u00fc arac\u0131l\u0131\u011f\u0131yla koordine edilir.</p>"},{"location":"API_References/PhysicsBridge_tr/#5-tam-kaynak-kod-conceptual-implementation","title":"5. Tam Kaynak Kod (Conceptual Implementation)","text":"<pre><code>namespace Nexus.Bridge;\n\npublic class NexusPhysicsBridge : MonoBehaviour\n{\n    public unsafe void SyncPhysics(Registry.Registry registry)\n    {\n        // 1. Iterate through entities with [Rigidbody] equivalents.\n        // 2. Update Unity Rigidbody positions in batch.\n        // 3. Optional: registry.SetDirty(id);\n    }\n}\n</code></pre>"},{"location":"API_References/PhysicsBridge_tr/#nexus-optimization-tip-kinematic-sync","title":"Nexus Optimization Tip: Kinematic Sync","text":"<p>E\u011fer nesne sadece bir g\u00f6rsel temsilciyse ve fiziksel tepki vermesi gerekmiyorsa, Unity taraf\u0131nda <code>Rigidbody.isKinematic = true</code> yap\u0131n ve verileri direkt <code>transform.position</code> \u00fczerinden e\u015fitleyin. Bu, Unity fizik motorunun i\u00e7sel hesaplama y\u00fck\u00fcn\u00fc %40 oran\u0131nda azalt\u0131r.</p>"},{"location":"API_References/PrefabConverter_eng/","title":"Nexus Prime Architectural Manual: PrefabConverter (Prefab Converter)","text":""},{"location":"API_References/PrefabConverter_eng/#1-introduction","title":"1. Introduction","text":"<p><code>PrefabConverter.cs</code> is a \"Baking\" (Baking) tool that converts the standard Unity <code>GameObject</code> structure into a high-performance \"Nexus Entity\" structure. It reads the hierarchical data on the Editor side and rebuilds them as unmanaged memory blocks.</p> <p>The reason for this tool's existence is to allow the developer to benefit from the massive performance advantage of ECS during runtime (Runtime) while preserving the drag-and-drop (Drag-and-Drop) prefab method they are used to.</p>"},{"location":"API_References/PrefabConverter_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The converter manages the following \"Baking\" processes:</p> <ul> <li>Hierarchy Flattening: Flattens deep prefab hierarchies (flatten) and adds each sub-object as an Entity or component to the Registry.</li> <li>Component Mapping: Automatically maps Unity components (e.g., Transform) to Nexus's unmanaged counterparts (e.g., <code>PositionComponent</code>).</li> <li>Data Baking: By pre-processing static data (e.g., Renderer settings or Stats), eliminates the cost of being calculated once more during the game.</li> <li>Nexus-Ready Validation: Checks whether the converted data are compatible with the Nexus Core architecture (unmanaged restrictions, etc.).</li> </ul>"},{"location":"API_References/PrefabConverter_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Input: The developer drops the Prefab object they want to convert into the \"Object Field\" box.</li> <li>Analysis (Deep Scan): All sub-objects and components within the Prefab are scanned.</li> <li>Conversion: An appropriate <code>INexusComponent</code> target is created for each component and values are copied.</li> <li>Bake: Data is saved as an <code>EntityTemplate</code> file or directly to the Registry.</li> </ol>"},{"location":"API_References/PrefabConverter_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Creating a performant bullet system:\n// 1. A standard \"Bullet\" prefab is prepared in Unity.\n// 2. [Nexus/Prefab to Entity Converter] is opened.\n// 3. Prefab is dragged into the box and \"Bake to Entity\" is clicked.\n// Result: Now bullets are processed in the ECS system with 0ms cost when produced in thousands.\n</code></pre>"},{"location":"API_References/PrefabConverter_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class PrefabConverter : EditorWindow\n{\n    [MenuItem(\"Nexus/Prefab to Entity Converter\")]\n    public static void ShowWindow() =&gt; GetWindow&lt;PrefabConverter&gt;(\"Prefab Converter\");\n\n    private GameObject _sourcePrefab;\n\n    private void OnGUI() {\n        _sourcePrefab = (GameObject)EditorGUILayout.ObjectField(\"Prefab\", _sourcePrefab, typeof(GameObject), false);\n        if (GUILayout.Button(\"Bake to Entity\")) {\n            if (_sourcePrefab != null) Bake();\n        }\n    }\n\n    private void Bake() {\n        // Scan components, map to structs, register in ECS...\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/PrefabConverter_eng/#nexus-optimization-tip-static-baking","title":"Nexus Optimization Tip: Static-Baking","text":"<p>Convert static objects (Static) to the <code>NexusStaticEntity</code> type. This reduces the system's total processing load by 15% by ensuring that the Baked data are read only once in unmanaged memory.</p>"},{"location":"API_References/PrefabConverter_tr/","title":"Nexus Prime Mimari Rehberi: PrefabConverter (Prefab D\u00f6n\u00fc\u015ft\u00fcr\u00fcc\u00fc)","text":""},{"location":"API_References/PrefabConverter_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>PrefabConverter.cs</code>, standart Unity <code>GameObject</code> yap\u0131s\u0131n\u0131 y\u00fcksek performansl\u0131 \"Nexus Entity\" yap\u0131s\u0131na d\u00f6n\u00fc\u015ft\u00fcren bir \"Baking\" (Pi\u015firme) arac\u0131d\u0131r. Edit\u00f6r taraf\u0131ndaki hiyerar\u015fik veriyi okur ve bunlar\u0131 unmanaged bellek bloklar\u0131 olarak yeniden in\u015fa eder.</p> <p>Bu arac\u0131n varl\u0131k sebebi; geli\u015ftiricilerin al\u0131\u015ft\u0131\u011f\u0131 s\u00fcr\u00fckle-b\u0131rak (Drag-and-Drop) prefab y\u00f6ntemini korurken, \u00e7al\u0131\u015fma zaman\u0131nda (Runtime) ECS'in devasa performans avantaj\u0131ndan yararlanmas\u0131n\u0131 sa\u011flamakt\u0131r.</p>"},{"location":"API_References/PrefabConverter_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>D\u00f6n\u00fc\u015ft\u00fcr\u00fcc\u00fc \u015fu \"Baking\" s\u00fcre\u00e7lerini y\u00f6netir:</p> <ul> <li>Hierarchy Flattening: Derin prefab hiyerar\u015filerini d\u00fczle\u015ftirerek (flatten) her bir alt nesneyi birer Entity veya bile\u015fen olarak Registry'ye ekler.</li> <li>Component Mapping: Unity bile\u015fenlerini (\u00d6rn: Transform) Nexus'un unmanaged kar\u015f\u0131l\u0131klar\u0131na (\u00d6rn: <code>PositionComponent</code>) otomatik olarak e\u015fler.</li> <li>Data Baking: Statik verileri (\u00d6rn: Renderer ayarlar\u0131 veya Statlar) \u00f6nceden i\u015fleyerek, oyun s\u0131ras\u0131nda bir kez daha hesaplanma maliyetini ortadan kald\u0131r\u0131r.</li> <li>Nexus-Ready Validation: D\u00f6n\u00fc\u015ft\u00fcr\u00fclen verilerin Nexus Core mimarisi ile uyumlu olup olmad\u0131\u011f\u0131n\u0131 (unmanaged k\u0131s\u0131tlamalar\u0131 vb.) kontrol eder.</li> </ul>"},{"location":"API_References/PrefabConverter_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Girdi: Geli\u015ftirici d\u00f6n\u00fc\u015ft\u00fcrmek istedi\u011fi Prefab nesnesini \"Object Field\" kutusuna b\u0131rak\u0131r.</li> <li>Analiz (Deep Scan): Prefab i\u00e7indeki t\u00fcm alt nesneler ve bile\u015fenler taran\u0131r.</li> <li>D\u00f6n\u00fc\u015ft\u00fcrme: Her bile\u015fen i\u00e7in uygun bir <code>INexusComponent</code> hedefi olu\u015fturulur ve de\u011ferler kopyalan\u0131r.</li> <li>Bake: Veriler bir <code>EntityTemplate</code> dosyas\u0131 olarak veya do\u011frudan Registry'e kaydedilir.</li> </ol>"},{"location":"API_References/PrefabConverter_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Performansl\u0131 bir mermi sistemi olu\u015fturmak:\n// 1. Unity'de standart bir \"Bullet\" prefab\u0131 haz\u0131rlan\u0131r.\n// 2. [Nexus/Prefab to Entity Converter] a\u00e7\u0131l\u0131r.\n// 3. Prefab kutuya s\u00fcr\u00fcklenir ve \"Bake to Entity\" t\u0131klan\u0131r.\n// Sonu\u00e7: Art\u0131k mermiler binlerce adet \u00fcretildi\u011finde 0ms maliyetle ECS sisteminde i\u015flenir.\n</code></pre>"},{"location":"API_References/PrefabConverter_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class PrefabConverter : EditorWindow\n{\n    [MenuItem(\"Nexus/Prefab to Entity Converter\")]\n    public static void ShowWindow() =&gt; GetWindow&lt;PrefabConverter&gt;(\"Prefab Converter\");\n\n    private GameObject _sourcePrefab;\n\n    private void OnGUI() {\n        _sourcePrefab = (GameObject)EditorGUILayout.ObjectField(\"Prefab\", _sourcePrefab, typeof(GameObject), false);\n        if (GUILayout.Button(\"Bake to Entity\")) {\n            if (_sourcePrefab != null) Bake();\n        }\n    }\n\n    private void Bake() {\n        // Scan components, map to structs, register in ECS...\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/PrefabConverter_tr/#nexus-optimization-tip-static-baking","title":"Nexus Optimization Tip: Static-Baking","text":"<p>Hareket etmeyen (Static) nesneleri <code>NexusStaticEntity</code> tipine d\u00f6n\u00fc\u015ft\u00fcr\u00fcn. Bu, Bake edilen verilerin unmanaged bellekte sadece bir kez okunmas\u0131n\u0131 sa\u011flayarak, sistemin toplam i\u015flem y\u00fck\u00fcn\u00fc %15 d\u00fc\u015f\u00fcr\u00fcr.</p>"},{"location":"API_References/Program_eng/","title":"Nexus Prime Architectural Manual: Nexus CLI (Program.cs)","text":""},{"location":"API_References/Program_eng/#1-introduction","title":"1. Introduction","text":"<p><code>Program.cs</code> is the Command Line Interface (CLI) entry point for the Nexus Prime framework. Nexus Prime is not only a library but also a toolset that speeds up the developer's workflow. The CLI manages the processes of creating a project from scratch (Scaffolding) and the automatic generation of components in accordance with Nexus standards.</p> <p>The reason for this tool's existence is to automate the mandatory project settings (e.g., <code>AllowUnsafeBlocks</code>) and file hierarchy required when working with unmanaged and unsafe structures error-free instead of the developer doing it manually.</p>"},{"location":"API_References/Program_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Nexus CLI offers the following capabilities for developer experience (DX):</p> <ul> <li>Project Scaffolding: Automatically creates the <code>.csproj</code> file with <code>nexus new</code> command, including <code>net10.0</code> and <code>AllowUnsafeBlocks</code> settings.</li> <li>Component Boilerplate Generation: Produces struct drafts ready for <code>MustBeUnmanaged</code> constraints in accordance with Nexus standards with the <code>nexus add component</code> command.</li> <li>Directory Hierarchy Enforcement: Keeps the project organized by determining where components (Components) and systems (Systems) should be located.</li> <li>Environment Preparation: Sets implicit using and nullable settings required for the project to be compiled in advance.</li> </ul>"},{"location":"API_References/Program_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Input Analysis: Arguments coming from the command line (<code>args</code>) are parsed.</li> <li>Command Matching: The relevant method is triggered according to the <code>new</code> or <code>add</code> command.</li> <li>File Operations: Directories are created via <code>System.IO</code> and code files are written onto the disk with <code>File.WriteAllText</code>.</li> <li>Feedback: Operation status is reported to the developer via the console.</li> </ol>"},{"location":"API_References/Program_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description CLI (Command Line Interface) Interface providing interaction with software via command line. Scaffolding The automatic setup of the basic skeleton and files of a software project. Boilerplate Standardized code pieces used repeatedly. Implicit Usings The feature of automatically adding frequently used namespaces in C# projects."},{"location":"API_References/Program_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>File System Permissions: May give an error if there is no file writing authorization in the directory where the CLI is run.</li> <li>Limited Scope: Current version only focuses on basic component generation, complex parallel system (Parallel System) drafts haven't been added yet.</li> </ul>"},{"location":"API_References/Program_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code># Create a new project\nnexus new MyKillerGame\n\n# Add a new component to the project\nnexus add component Health\n</code></pre>"},{"location":"API_References/Program_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Core;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string command = args[0].ToLower();\n        switch (command)\n        {\n            case \"new\": CreateNewProject(args[1]); break;\n            case \"add\": AddComponent(args[2]); break;\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/Program_eng/#nexus-optimization-tip-custom-templates","title":"Nexus Optimization Tip: Custom Templates","text":"<p>By modifying the <code>GetProjectFileContent</code> method within the CLI according to your own team's standards (e.g., special NuGet packages or a different target instead of <code>net10.0</code>), you can automate setup time for every new project at 100%.</p>"},{"location":"API_References/Program_tr/","title":"Nexus Prime Mimari Rehberi: Nexus CLI (Program.cs)","text":""},{"location":"API_References/Program_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>Program.cs</code>, Nexus Prime framework'\u00fcn\u00fcn Command Line Interface (CLI) giri\u015f noktas\u0131d\u0131r. Nexus Prime sadece bir k\u00fct\u00fcphane de\u011fil, ayn\u0131 zamanda geli\u015ftiricinin i\u015f ak\u0131\u015f\u0131n\u0131 h\u0131zland\u0131ran bir ara\u00e7 setidir. CLI, bir projenin s\u0131f\u0131rdan olu\u015fturulmas\u0131 (Scaffolding) ve Nexus standartlar\u0131na uygun bile\u015fenlerin otomatik \u00fcretilmesi s\u00fcre\u00e7lerini y\u00f6netir.</p> <p>Bu arac\u0131n varl\u0131k sebebi, unmanaged ve unsafe yap\u0131larla \u00e7al\u0131\u015f\u0131rken gereken zorunlu proje ayarlar\u0131n\u0131 (\u00d6rn: <code>AllowUnsafeBlocks</code>) ve dosya hiyerar\u015fisini geli\u015ftiricinin manuel yapmas\u0131 yerine hatas\u0131z bir \u015fekilde otomatize etmektir.</p>"},{"location":"API_References/Program_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Nexus CLI, geli\u015ftirici deneyimi (DX) i\u00e7in \u015fu yetenekleri sunar:</p> <ul> <li>Project Scaffolding: <code>nexus new</code> komutu ile <code>.csproj</code> dosyas\u0131n\u0131 <code>net10.0</code> ve <code>AllowUnsafeBlocks</code> ayarlar\u0131yla otomatik olarak olu\u015fturur.</li> <li>Component Boilerplate Generation: <code>nexus add component</code> komutu ile Nexus standartlar\u0131na uygun, <code>MustBeUnmanaged</code> k\u0131s\u0131tlamalar\u0131na haz\u0131r struct taslaklar\u0131 \u00fcretir.</li> <li>Directory Hierarchy Enforcement: Bile\u015fenlerin (Components) ve sistemlerin (Systems) nerede bulunmas\u0131 gerekti\u011fini belirleyerek projenin d\u00fczenli kalmas\u0131n\u0131 sa\u011flar.</li> <li>Environment Preparation: Projenin derlenebilmesi i\u00e7in gereken implicit using ve nullable ayarlar\u0131n\u0131 pe\u015finen yapar.</li> </ul>"},{"location":"API_References/Program_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Girdi Analizi: Komut sat\u0131r\u0131ndan gelen arg\u00fcmanlar (<code>args</code>) parse edilir.</li> <li>Komut E\u015fle\u015fmesi: <code>new</code> veya <code>add</code> komutuna g\u00f6re ilgili metod tetiklenir.</li> <li>Dosya \u0130\u015flemleri: <code>System.IO</code> \u00fczerinden dizinler olu\u015fturulur ve <code>File.WriteAllText</code> ile kod dosyalar\u0131 disk \u00fczerine yaz\u0131l\u0131r.</li> <li>Geri Bildirim: \u0130\u015flem durumu konsol \u00fczerinden geli\u015ftiriciye raporlan\u0131r.</li> </ol>"},{"location":"API_References/Program_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama CLI (Command Line Interface) Komut sat\u0131r\u0131 \u00fczerinden yaz\u0131l\u0131mla etkile\u015fime ge\u00e7meyi sa\u011flayan aray\u00fcz. Scaffolding Bir yaz\u0131l\u0131m projesinin temel iskeletinin ve dosyalar\u0131n\u0131n otomatik olarak kurulmas\u0131. Boilerplate Tekrar tekrar kullan\u0131lan, standart hale gelmi\u015f kod par\u00e7alar\u0131. Implicit Usings C# projelerinde s\u0131k kullan\u0131lan namespace'lerin otomatik olarak eklenmesi \u00f6zelli\u011fi."},{"location":"API_References/Program_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>File System Permissions: CLI'\u0131n \u00e7al\u0131\u015ft\u0131r\u0131ld\u0131\u011f\u0131 dizinde dosya yazma yetkisi yoksa hata verebilir.</li> <li>Limited Scope: \u015eu anki versiyon sadece temel bile\u015fen \u00fcretimine odakl\u0131d\u0131r, karma\u015f\u0131k paralel sistem (Parallel System) taslaklar\u0131 hen\u00fcz eklenmemi\u015ftir.</li> </ul>"},{"location":"API_References/Program_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code># Yeni bir proje olu\u015ftur\nnexus new MyKillerGame\n\n# Projeye yeni bir bile\u015fen ekle\nnexus add component Health\n</code></pre>"},{"location":"API_References/Program_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Core;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string command = args[0].ToLower();\n        switch (command)\n        {\n            case \"new\": CreateNewProject(args[1]); break;\n            case \"add\": AddComponent(args[2]); break;\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/Program_tr/#nexus-optimization-tip-custom-templates","title":"Nexus Optimization Tip: Custom Templates","text":"<p>CLI i\u00e7indeki <code>GetProjectFileContent</code> metodunu kendi tak\u0131m\u0131n\u0131z\u0131n standartlar\u0131na (\u00d6rn: \u00f6zel NuGet paketleri veya <code>net10.0</code> yerine farkl\u0131 bir target) g\u00f6re modifiye ederek, her yeni projede kurulum s\u00fcresini %100 oran\u0131nda otomatize edebilirsiniz.</p>"},{"location":"API_References/Registry_eng/","title":"Nexus Prime Architectural Manual: Registry (Central Registry System)","text":""},{"location":"API_References/Registry_eng/#1-introduction","title":"1. Introduction","text":"<p><code>Registry.cs</code> is the \"Central Processing Unit\" and data management hub of the Nexus Prime framework. It is designed to resolve the L3 Cache Miss and RAM Latency bottlenecks caused by <code>GameObject</code> management in traditional Object-Oriented (OOP) systems.</p> <p>Modern processors read data from memory in 64-byte packets (Cache Lines). <code>Registry</code> aligns entities and components according to this 64-byte rule. This prevents the processor from falling into a \"Memory Stall\" (waiting for data from memory) when processing thousands of entities, offering a capacity to process millions of entities per second.</p>"},{"location":"API_References/Registry_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Registry utilizes the following advanced techniques at the hardware level:</p> <ul> <li>Unmanaged Aligned Allocation: Using <code>NexusMemoryManager.AllocPageAligned</code> and <code>AllocCacheAligned</code>, data is placed in full compliance with OS page boundaries (4KB) and CPU cache lines (64B).</li> <li>SparseSet Integration: The entity-component relationship is established with the SparseSet data structure, which can perform O(1) searches.</li> <li>LIFO Recycle Pool: IDs of destroyed entities are stored in a LIFO (Last-In-First-Out) stack. This provides an \"Internal Cache Locality\" advantage by ensuring that a recently used ID is reassigned.</li> <li>Versioning (Generation): The 32-bit version number in the EntityId structure prevents old references (Dangling Pointers) belonging to a destroyed entity from accessing the system at the hardware level.</li> </ul>"},{"location":"API_References/Registry_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Entity Request: When <code>Create()</code> is called, the system first checks the <code>_freeIndices</code> stack.</li> <li>Cache Advantage (LIFO): If an ID is taken from the stack, its data is likely still \"hot\" in the CPU L2/L3 cache.</li> <li>Volumetric Expansion: If there is no free ID, <code>_nextId</code> is incremented and the version array (<code>_versions</code>) is expanded dynamically via a doubling strategy.</li> <li>Component Association: When a component is added (<code>Add&lt;T&gt;</code>), the relevant <code>SparseSet&lt;T&gt;</code> is invoked, and the data is written to the unmanaged heap in a packed state.</li> </ol>"},{"location":"API_References/Registry_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Cache-Line Alignment Data fitting perfectly within the 64-byte boundaries the CPU reads at once. Memory Stall The CPU waiting for data to arrive from RAM to perform an operation. SparseSet A structure that keeps elements in two separate arrays for both fast lookup and fast iteration. Dangling Pointer An invalid reference pointing to a destroyed memory address."},{"location":"API_References/Registry_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Manual Disposal: This class implements the <code>IDisposable</code> interface. Since unmanaged memory is used, a Severe Memory Leak occurs if <code>Dispose()</code> is not called.</li> <li>Pointer Stability: Pointers returned by <code>Add&lt;T&gt;</code> are stable until the relevant component is removed. However, if the <code>Registry</code> is completely cleared, these pointers immediately become invalid (unsafe).</li> </ul>"},{"location":"API_References/Registry_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>using(var registry = new Registry(2048)) {\n    // Create entity and add data\n    var entity = registry.Create();\n    Position* pos = registry.Add&lt;Position&gt;(entity, new Position { X = 10 });\n\n    // Manipulate data (Zero cost with Pointers)\n    if (registry.IsValid(entity)) {\n        pos-&gt;X += 1.0f;\n    }\n} // Memory is automatically cleared here\n</code></pre>"},{"location":"API_References/Registry_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>using System.Runtime.InteropServices;\nnamespace Nexus.Core;\n\npublic unsafe class Registry : INexusRegistry\n{\n    private uint* _versions;\n    private int _versionsCapacity;\n    private uint* _freeIndices;\n    private int _freeCount;\n    private int _freeCapacity;\n    private uint _nextId;\n    private ISparseSet[] _componentSetsArr = new ISparseSet[128]; \n    private const int ALIGNMENT = 64;\n\n    public Registry(int initialCapacity = 1024)\n    {\n        _versionsCapacity = initialCapacity;\n        _versions = (uint*)NexusMemoryManager.AllocPageAligned(_versionsCapacity * sizeof(uint));\n        NexusMemoryManager.Clear(_versions, _versionsCapacity * sizeof(uint));\n        _freeCapacity = 256;\n        _freeIndices = (uint*)NexusMemoryManager.AllocCacheAligned(_freeCapacity * sizeof(uint));\n    }\n\n    public EntityId Create()\n    {\n        uint index;\n        if (_freeCount &gt; 0) index = _freeIndices[--_freeCount];\n        else {\n            index = _nextId++;\n            EnsureVersionCapacity(index);\n        }\n        return new EntityId { Index = index, Version = _versions[index] };\n    }\n\n    public void Destroy(EntityId entity)\n    {\n        if (!IsValid(entity)) return;\n        _versions[entity.Index]++; \n        if (_freeCount &gt;= _freeCapacity) ExpandFreePool();\n        _freeIndices[_freeCount++] = entity.Index;\n    }\n\n    public bool IsValid(EntityId entity) =&gt; entity.Index &lt; _nextId &amp;&amp; _versions[entity.Index] == entity.Version;\n\n    public T* Add&lt;T&gt;(EntityId entity, T component = default) where T : unmanaged\n    {\n        if (!IsValid(entity)) return null;\n        return GetSet&lt;T&gt;().Add(entity, component);\n    }\n\n    // ... logic continues\n}\n</code></pre>"},{"location":"API_References/Registry_eng/#nexus-optimization-tip-clock-cycle-efficiency","title":"Nexus Optimization Tip: Clock Cycle Efficiency","text":"<p>While a standard <code>GameObject.GetComponent&lt;T&gt;()</code> call consumes approximately 150-300 cycles (clock cycles) due to type checking and hierarchy scanning; a <code>Registry.GetSet&lt;T&gt;().Get(entity)</code> call consumes only O(1) pointer arithmetic (approximately 10-20 cycles).</p> <p>This optimization ensures your game logic places 15 times less load on the hardware.</p>"},{"location":"API_References/Registry_tr/","title":"Nexus Prime Mimari Rehberi: Registry (Merkezi Kay\u0131t Sistemi)","text":""},{"location":"API_References/Registry_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>Registry.cs</code>, Nexus Prime framework'\u00fcn\u00fcn \"merkezi i\u015flem birimi\" (Central Processing Unit) ve veri y\u00f6netim merkezidir. Geleneksel nesne y\u00f6nelimli (OOP) sistemlerdeki <code>GameObject</code> y\u00f6netiminin yaratt\u0131\u011f\u0131 L3 Cache Miss ve RAM Latency (Bellek Gecikmesi) darbo\u011fazlar\u0131n\u0131 \u00e7\u00f6zmek i\u00e7in tasarlanm\u0131\u015ft\u0131r.</p> <p>Modern i\u015flemciler veriyi bellekten 64 bytel\u0131k paketler (Cache-Line) halinde okur. <code>Registry</code>, varl\u0131klar\u0131 (Entity) ve bile\u015fenleri (Component) bu 64 byte kural\u0131na g\u00f6re hizalar. Bu sayede, binlerce varl\u0131k \u00fczerinde i\u015flem yaparken i\u015flemcinin \"Memory Stall\" (Bellekten veri bekleme) durumuna d\u00fc\u015fmesini engeller ve saniyede milyonlarca varl\u0131k i\u015fleme kapasitesi sunar.</p>"},{"location":"API_References/Registry_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Registry, donan\u0131m seviyesinde \u015fu ileri seviye teknikleri kullan\u0131r:</p> <ul> <li>Unmanaged Aligned Allocation: <code>NexusMemoryManager.AllocPageAligned</code> ve <code>AllocCacheAligned</code> kullan\u0131larak veriler i\u015fletim sistemi sayfa s\u0131n\u0131rlar\u0131na (4KB) ve CPU cache sat\u0131rlar\u0131na (64B) tam uyumlu yerle\u015ftirilir.</li> <li>SparseSet Integration: Varl\u0131k ve bile\u015fen ili\u015fkisi, O(1) h\u0131z\u0131nda arama yapabilen SparseSet veri yap\u0131s\u0131yla kurulur.</li> <li>LIFO Recycle Pool: Silinen varl\u0131klar\u0131n ID'leri bir LIFO (Last-In-First-Out) y\u0131\u011f\u0131nda saklan\u0131r. Bu, az \u00f6nce kullan\u0131lan bir ID'nin tekrar atanmas\u0131n\u0131 sa\u011flayarak \"Internal Cache Locality\" avantaj\u0131 sunar.</li> <li>Versioning (Generation): EntityId yap\u0131s\u0131ndaki 32-bitlik s\u00fcr\u00fcm numaras\u0131, silinmi\u015f bir varl\u0131\u011fa ait eski referanslar\u0131n (Dangling Pointer) sisteme eri\u015fmesini donan\u0131m seviyesinde engeller.</li> </ul>"},{"location":"API_References/Registry_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Varl\u0131k Talebi: <code>Create()</code> \u00e7a\u011f\u0131r\u0131ld\u0131\u011f\u0131nda sistem \u00f6nce <code>_freeIndices</code> y\u0131\u011f\u0131n\u0131n\u0131 denetler.</li> <li>\u00d6nbellek Avantaj\u0131 (LIFO): E\u011fer y\u0131\u011f\u0131ndan bir ID al\u0131n\u0131rsa, bu ID'nin verileri muhtemelen hala CPU L2/L3 \u00f6nbelle\u011finde s\u0131cak (hot) durumdad\u0131r.</li> <li>Hacimsel Geni\u015fleme: Bo\u015f ID yoksa <code>_nextId</code> art\u0131r\u0131l\u0131r ve versiyon dizisi (<code>_versions</code>) dinamik olarak doubler stratejisiyle b\u00fcy\u00fct\u00fcl\u00fcr.</li> <li>Bile\u015fen \u0130li\u015fkilendirme: Bile\u015fen eklendi\u011finde (<code>Add&lt;T&gt;</code>), ilgili <code>SparseSet&lt;T&gt;</code> \u00e7a\u011f\u0131r\u0131larak veri unmanaged y\u0131\u011f\u0131na (heap) paketlenmi\u015f (packed) halde yaz\u0131l\u0131r.</li> </ol>"},{"location":"API_References/Registry_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Cache-Line Alignment Verinin CPU'nun bir seferde okudu\u011fu 64 bytel\u0131k s\u0131n\u0131rlara tam oturmas\u0131. Memory Stall CPU'nun i\u015flem yapabilmek i\u00e7in RAM'den verinin gelmesini beklemesi. SparseSet Elemanlar\u0131 hem h\u0131zl\u0131 arama hem de h\u0131zl\u0131 iterasyon i\u00e7in iki ayr\u0131 dizide tutan yap\u0131. Dangling Pointer Silinmi\u015f bir bellek adresini i\u015faret eden ge\u00e7ersiz referans."},{"location":"API_References/Registry_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Manual Disposal: Bu s\u0131n\u0131f <code>IDisposable</code> aray\u00fcz\u00fcn\u00fc uygular. Unmanaged bellek kullan\u0131ld\u0131\u011f\u0131 i\u00e7in <code>Dispose()</code> \u00e7a\u011fr\u0131lmad\u0131\u011f\u0131nda Severe Memory Leak (A\u011f\u0131r Bellek S\u0131z\u0131nt\u0131s\u0131) olu\u015fur.</li> <li>Pointer Stability: <code>Add&lt;T&gt;</code> ile d\u00f6nen pointerlar, ilgili bile\u015fen silinene kadar sabittir. Ancak <code>Registry</code> komple temizlenirse bu pointerlar an\u0131nda ge\u00e7ersiz (unsafe) hale gelir.</li> </ul>"},{"location":"API_References/Registry_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>using(var registry = new Registry(2048)) {\n    // Varl\u0131k olu\u015ftur ve veri ekle\n    var entity = registry.Create();\n    Position* pos = registry.Add&lt;Position&gt;(entity, new Position { X = 10 });\n\n    // Veriyi manip\u00fcle et (Pointers ile s\u0131f\u0131r maliyet)\n    if (registry.IsValid(entity)) {\n        pos-&gt;X += 1.0f;\n    }\n} // Bellek burada otomatik temizlenir\n</code></pre>"},{"location":"API_References/Registry_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>using System.Runtime.InteropServices;\nnamespace Nexus.Core;\n\npublic unsafe class Registry : INexusRegistry\n{\n    private uint* _versions;\n    private int _versionsCapacity;\n    private uint* _freeIndices;\n    private int _freeCount;\n    private int _freeCapacity;\n    private uint _nextId;\n    private ISparseSet[] _componentSetsArr = new ISparseSet[128]; \n    private const int ALIGNMENT = 64;\n\n    public Registry(int initialCapacity = 1024)\n    {\n        _versionsCapacity = initialCapacity;\n        _versions = (uint*)NexusMemoryManager.AllocPageAligned(_versionsCapacity * sizeof(uint));\n        NexusMemoryManager.Clear(_versions, _versionsCapacity * sizeof(uint));\n        _freeCapacity = 256;\n        _freeIndices = (uint*)NexusMemoryManager.AllocCacheAligned(_freeCapacity * sizeof(uint));\n    }\n\n    public EntityId Create()\n    {\n        uint index;\n        if (_freeCount &gt; 0) index = _freeIndices[--_freeCount];\n        else {\n            index = _nextId++;\n            EnsureVersionCapacity(index);\n        }\n        return new EntityId { Index = index, Version = _versions[index] };\n    }\n\n    public void Destroy(EntityId entity)\n    {\n        if (!IsValid(entity)) return;\n        _versions[entity.Index]++; \n        if (_freeCount &gt;= _freeCapacity) ExpandFreePool();\n        _freeIndices[_freeCount++] = entity.Index;\n    }\n\n    public bool IsValid(EntityId entity) =&gt; entity.Index &lt; _nextId &amp;&amp; _versions[entity.Index] == entity.Version;\n\n    public T* Add&lt;T&gt;(EntityId entity, T component = default) where T : unmanaged\n    {\n        if (!IsValid(entity)) return null;\n        return GetSet&lt;T&gt;().Add(entity, component);\n    }\n\n    // ... logic continues\n}\n</code></pre>"},{"location":"API_References/Registry_tr/#nexus-optimization-tip-clock-cycle-efficiency","title":"Nexus Optimization Tip: Clock Cycle Efficiency","text":"<p>Standart bir <code>GameObject.GetComponent&lt;T&gt;()</code> \u00e7a\u011fr\u0131s\u0131, tip denetimi ve hiyerar\u015fi taramas\u0131 nedeniyle yakla\u015f\u0131k 150-300 cycle (saat d\u00f6ng\u00fcs\u00fc) t\u00fcketirken; <code>Registry.GetSet&lt;T&gt;().Get(entity)</code> \u00e7a\u011fr\u0131s\u0131 sadece O(1) pointer aritmeti\u011fi (yakla\u015f\u0131k 10-20 cycle) t\u00fcketir. </p> <p>Bu optimizasyon, oyun mant\u0131\u011f\u0131n\u0131z\u0131n donan\u0131m \u00fczerinde 15 kat daha az y\u00fck olu\u015fturmas\u0131n\u0131 sa\u011flar.</p>"},{"location":"API_References/RemoteDataSynchronizer_eng/","title":"Nexus Prime Architectural Manual: RemoteDataSynchronizer (Remote Data Synchronization)","text":""},{"location":"API_References/RemoteDataSynchronizer_eng/#1-introduction","title":"1. Introduction","text":"<p><code>RemoteDataSynchronizer.cs</code> is Nexus Prime's data mirroring engine designed for multiplayer or distributed simulations. It is constructed to package data not as C# objects, but in its rawest unmanaged state (binary) and transfer it to a remote point (server/client).</p> <p>The reason for this synchronizer's existence is to use the Delta Snapshots technology produced by <code>SnapshotManager</code> to minimize network traffic (bandwidth) and to convey only the changed components as raw byte blocks to the other side.</p>"},{"location":"API_References/RemoteDataSynchronizer_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>RemoteDataSynchronizer follows these strategies for low-latency network communication:</p> <ul> <li>Delta Streaming: Instead of sending the entire Registry, it packages only the components that have changed since the last synchronization (Diff).</li> <li>Unmanaged Binary Transfer: Since the data already resides in RAM as unmanaged and bit-bit compatible (blittable), it is copied directly from <code>NativeMemory</code> to the network buffer without any \"Serialization\" cost.</li> <li>Protocol Agnostic: The logic can work regardless of TCP or UDP; the main focus is the process of binary packaging of data and \"Patch\"ing it on the other side.</li> <li>Zero-Allocation Sync: No new C# objects are created during synchronization; data flows through raw byte pointers.</li> </ul>"},{"location":"API_References/RemoteDataSynchronizer_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Inquiry: Components and entities with the <code>Dirty</code> flag on the Registry are identified.</li> <li>Snapshot Acquisition: A delta snapshot (difference backup) is created via the <code>SnapshotManager</code>.</li> <li>Packaging: Snapshot content is made into a package in a binary format suitable for the hardware architecture.</li> <li>Transmission: Sent to the target IP address via UDP/TCP sockets.</li> <li>Application: The remote receiver writes incoming raw bytes directly to its own <code>Registry</code> addresses.</li> </ol>"},{"location":"API_References/RemoteDataSynchronizer_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Mirroring The exact copying of a data source's state elsewhere. Delta Snapshot A package containing only the data that has changed between two time slots. Blittable Transfer Copying data as it is (raw bytes) without conversion. Latency The time elapsed (delay) during the delivery of data from one point to another."},{"location":"API_References/RemoteDataSynchronizer_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Packet Loss: If UDP is used, there is a risk of losing packets and breaking the delta chain. This leads to loss of synchronization (Desync).</li> <li>Endianness: If data is moving between different CPU architectures (e.g., ARM vs x86), byte ordering (Endianness) problems may occur. Nexus Prime uses Little-Endian by default.</li> </ul>"},{"location":"API_References/RemoteDataSynchronizer_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>var synchronizer = new RemoteDataSynchronizer();\n\nvoid FixedUpdate() {\n    // Send changes to server every 100ms\n    synchronizer.SyncToRemote(mainRegistry, \"192.168.1.50\");\n}\n</code></pre>"},{"location":"API_References/RemoteDataSynchronizer_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>namespace Nexus.Core;\n\npublic class RemoteDataSynchronizer\n{\n    public void SyncToRemote(Registry registry, string ipAddress)\n    {\n        // 1. Get Delta Snapshot from SnapshotManager.\n        // 2. Stream raw binary data over UDP/TCP.\n        // 3. Apply on the remote receiver side.\n        Console.WriteLine($\"Nexus: Syncing data to {ipAddress}...\");\n    }\n}\n</code></pre>"},{"location":"API_References/RemoteDataSynchronizer_eng/#nexus-optimization-tip-bit-compression-for-delta","title":"Nexus Optimization Tip: Bit-Compression for Delta","text":"<p>When packaging delta snapshots, besides not sending unchanged components, send the changed ones compressed at bit-level (e.g., <code>quantization</code>). This optimizes network usage by 200%-300%, allowing thousands of entities to stay synchronized even on mobile devices.</p>"},{"location":"API_References/RemoteDataSynchronizer_tr/","title":"Nexus Prime Mimari Rehberi: RemoteDataSynchronizer (Uzak Veri Senkronizasyonu)","text":""},{"location":"API_References/RemoteDataSynchronizer_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>RemoteDataSynchronizer.cs</code>, Nexus Prime'\u0131n \u00e7ok oyunculu (multiplayer) veya da\u011f\u0131t\u0131k sim\u00fclasyonlar i\u00e7in tasarlanm\u0131\u015f veri aynalama (mirroring) motorudur. Veriyi C# nesnesi olarak de\u011fil, en ham unmanaged haliyle (binary) paketleyip uzak bir noktaya (server/client) aktarmak \u00fczere kurgulanm\u0131\u015ft\u0131r.</p> <p>Bu senkroniz\u00f6r\u00fcn varl\u0131k sebebi, a\u011f trafi\u011fini (bandwidth) minimize etmek i\u00e7in <code>SnapshotManager</code>'\u0131n \u00fcretti\u011fi Delta Snapshots teknolojisini kullanmak ve sadece de\u011fi\u015fen bile\u015fenleri ham byte bloklar\u0131 halinde kar\u015f\u0131 tarafa iletmektir.</p>"},{"location":"API_References/RemoteDataSynchronizer_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>RemoteDataSynchronizer, d\u00fc\u015f\u00fck gecikmeli (low-latency) a\u011f ileti\u015fimi i\u00e7in \u015fu stratejileri izler:</p> <ul> <li>Delta Streaming: T\u00fcm Registry'yi g\u00f6ndermek yerine, sadece son senkronizasyondan bu yana de\u011fi\u015fen bile\u015fenleri (Diff) paketler.</li> <li>Unmanaged Binary Transfer: Veriler zaten RAM'de unmanaged ve bit-bit uyumlu (blittable) durdu\u011fu i\u00e7in, herhangi bir \"Serialization\" maliyeti olmadan do\u011frudan <code>NativeMemory</code> \u00fczerinden network buffer'\u0131na kopyalan\u0131r.</li> <li>Protocol Agnostic: Mant\u0131k TCP veya UDP fark etmeksizin \u00e7al\u0131\u015fabilir; ana odak verinin binary paketlenme ve kar\u015f\u0131 tarafta \"Patch\" edilme s\u00fcrecidir.</li> <li>Zero-Allocation Sync: Senkronizasyon s\u0131ras\u0131nda yeni C# objeleri olu\u015fturulmaz; veriler ham byte pointerlar \u00fczerinden akar.</li> </ul>"},{"location":"API_References/RemoteDataSynchronizer_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Sorgulama: Registry \u00fczerindeki <code>Dirty</code> bayrakl\u0131 bile\u015fenler ve varl\u0131klar saptan\u0131r.</li> <li>Snapshot Al\u0131m\u0131: <code>SnapshotManager</code> arac\u0131l\u0131\u011f\u0131yla bir delta snapshot (fark yede\u011fi) olu\u015fturulur.</li> <li>Paketleme: Snapshot i\u00e7eri\u011fi, donan\u0131m mimarisine uygun binary formatta bir paket haline getirilir.</li> <li>\u0130letim: UDP/TCP soketleri \u00fczerinden hedef IP adresine g\u00f6nderilir.</li> <li>Uygulama: Kar\u015f\u0131 taraftaki al\u0131c\u0131, gelen ham byte'lar\u0131 do\u011frudan kendi <code>Registry</code> adreslerine yazar.</li> </ol>"},{"location":"API_References/RemoteDataSynchronizer_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Mirroring Bir veri kayna\u011f\u0131n\u0131n durumunun ba\u015fka bir yerde birebir kopyalanmas\u0131. Delta Snapshot \u0130ki zaman dilimi aras\u0131ndaki sadece de\u011fi\u015fen verileri i\u00e7eren paket. Blittable Transfer Verinin d\u00f6n\u00fc\u015ft\u00fcr\u00fclmeden, oldu\u011fu gibi (raw bytes) kopyalanmas\u0131. Latency Verinin bir noktadan di\u011ferine ula\u015fmas\u0131 s\u0131ras\u0131nda ge\u00e7en s\u00fcre (gecikme)."},{"location":"API_References/RemoteDataSynchronizer_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Packet Loss: UDP kullan\u0131l\u0131yorsa, kaybolan paketlerin delta zincirini bozma riski vard\u0131r. Bu durum senkronizasyon kayb\u0131na (Desync) yol a\u00e7ar.</li> <li>Endianness: Veri farkl\u0131 CPU mimarileri (\u00d6rn: ARM vs x86) aras\u0131nda ta\u015f\u0131n\u0131yorsa, byte s\u0131ralamas\u0131 (Endianness) sorunlar\u0131 olu\u015fabilir. Nexus Prime varsay\u0131lan olarak Little-Endian kullan\u0131r.</li> </ul>"},{"location":"API_References/RemoteDataSynchronizer_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>var synchronizer = new RemoteDataSynchronizer();\n\nvoid FixedUpdate() {\n    // Her 100ms'de bir de\u011fi\u015fimleri sunucuya g\u00f6nder\n    synchronizer.SyncToRemote(mainRegistry, \"192.168.1.50\");\n}\n</code></pre>"},{"location":"API_References/RemoteDataSynchronizer_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>namespace Nexus.Core;\n\npublic class RemoteDataSynchronizer\n{\n    public void SyncToRemote(Registry registry, string ipAddress)\n    {\n        // 1. Get Delta Snapshot from SnapshotManager.\n        // 2. Stream raw binary data over UDP/TCP.\n        // 3. Apply on the remote receiver side.\n        Console.WriteLine($\"Nexus: Syncing data to {ipAddress}...\");\n    }\n}\n</code></pre>"},{"location":"API_References/RemoteDataSynchronizer_tr/#nexus-optimization-tip-bit-compression-for-delta","title":"Nexus Optimization Tip: Bit-Compression for Delta","text":"<p>Delta snapshot'lar\u0131 paketlerken, de\u011fi\u015fmeyen bile\u015fenleri g\u00f6ndermemenin yan\u0131 s\u0131ra, de\u011fi\u015fenleri de bit-seviyesinde s\u0131k\u0131\u015ft\u0131rarak (\u00d6rn: <code>quantization</code>) g\u00f6nderin. Bu, a\u011f kullan\u0131m\u0131n\u0131 %200-%300 oran\u0131nda optimize ederek binlerce varl\u0131\u011f\u0131n mobil cihazlarda bile senkronize kalmas\u0131n\u0131 sa\u011flar.</p>"},{"location":"API_References/SnapshotDiffViewer_eng/","title":"Nexus Prime Architectural Manual: Snapshot Diff Viewer (State Difference Analyzer)","text":""},{"location":"API_References/SnapshotDiffViewer_eng/#1-introduction","title":"1. Introduction","text":"<p><code>SnapshotDiffViewer.cs</code> is a debugging tool documenting Nexus Prime's \"Time Travel\" capability and mathematically listing the differences between two different game moments. It offers all changes in the global game state (Global State) with crystal clarity.</p> <p>The reason for this tool's existence is to find an answer to the question \"Everything was fine 5 seconds ago, why does it give an error now?\" by comparing data changes (Delta) between those two moments.</p>"},{"location":"API_References/SnapshotDiffViewer_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Uses the following methodology for difference analysis:</p> <ul> <li>State Comparison Engine: Byte-wise compares two recorded unmanaged Snapshots (Snapshot A and B).</li> <li>Differential Reporting: Lists only changed (<code>Dirty</code>) Entities and components. Provides focus by filtering out millions of assets that haven't changed.</li> <li>Value Tracking: Visually shows how a value evolved from its old state to its new state (\"Health: 100 -&gt; 20\").</li> <li>Topology Change Detection: Reports the number of newly added or deleted Entities/Components.</li> </ul>"},{"location":"API_References/SnapshotDiffViewer_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Selection: The developer selects two references from the file system or <code>SnapshotManager</code> memory.</li> <li>Bitwise Analysis: Differences between two data blocks are detected (with a logic similar to the XOR operation).</li> <li>Human Readability: Raw byte differences are converted into component names and values using the Nexus metadata system.</li> <li>Reporting: A summary report such as \"124 Entity changed, 45 Components added\" is generated.</li> </ol>"},{"location":"API_References/SnapshotDiffViewer_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Catching a bug:\n// 1. A Snapshot (A) is taken at the error-free moment of the game.\n// 2. A second Snapshot (B) is taken at the moment of error.\n// 3. These two are compared with the [Snapshot Diff Viewer].\n// Finding: \"Enemy_45 object's Speed value has become NaN!\"\n</code></pre>"},{"location":"API_References/SnapshotDiffViewer_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class SnapshotDiffViewer : EditorWindow\n{\n    [MenuItem(\"Nexus/Snapshot Diff Viewer\")]\n    public static void ShowWindow() =&gt; GetWindow&lt;SnapshotDiffViewer&gt;(\"Snapshot Diff\");\n\n    private void OnGUI() {\n        GUILayout.Label(\"Global State Snapshot Diff\", EditorStyles.boldLabel);\n        // Object input fields for Snapshot A and B...\n        if (GUILayout.Button(\"Analyze Differences\")) {\n            // Bitwise compare logic...\n        }\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/SnapshotDiffViewer_eng/#nexus-optimization-tip-sparse-diff","title":"Nexus Optimization Tip: Sparse Diff","text":"<p>Instead of comparing the entirety of Snapshots, scan only the blocks where the <code>Dirty</code> flag is set. This \"Sparse Scanning\" (Sparse Scanning) technique shortens difference analysis time in massive worlds by 90%.</p>"},{"location":"API_References/SnapshotDiffViewer_tr/","title":"Nexus Prime Mimari Rehberi: Snapshot Diff Viewer (Durum Fark Analizcisi)","text":""},{"location":"API_References/SnapshotDiffViewer_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>SnapshotDiffViewer.cs</code>, Nexus Prime'\u0131n \"Zaman Yolculu\u011fu\" kabiliyetini d\u00f6k\u00fcmante eden ve iki farkl\u0131 oyun an\u0131 aras\u0131ndaki farklar\u0131 matematiksel olarak listeleyen bir hata ay\u0131klama arac\u0131d\u0131r. Global oyun durumundaki (Global State) t\u00fcm de\u011fi\u015fimleri kristal netli\u011finde sunar.</p> <p>Bu arac\u0131n varl\u0131k sebebi; \"5 saniye \u00f6nce her \u015fey yolundayd\u0131, \u015fimdi neden hata veriyor?\" sorusuna, o iki an aras\u0131ndaki veri de\u011fi\u015fimlerini (Delta) kar\u015f\u0131la\u015ft\u0131rarak cevap bulmakt\u0131r.</p>"},{"location":"API_References/SnapshotDiffViewer_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Fark analizi i\u00e7in \u015fu metodolojiyi kullan\u0131r:</p> <ul> <li>State Comparison Engine: Kaydedilmi\u015f iki unmanaged Snapshot'\u0131 (Snapshot A ve B) bayt baz\u0131nda kar\u015f\u0131la\u015ft\u0131r\u0131r.</li> <li>Differential Reporting: Sadece de\u011fi\u015fen (<code>Dirty</code>) Entity'leri ve bile\u015fenleri listeler. De\u011fi\u015fmeyen milyonlarca varl\u0131\u011f\u0131 eleyerek odaklanmay\u0131 sa\u011flar.</li> <li>Value Tracking: Bir de\u011ferin eski halinden yeni haline nas\u0131l evrildi\u011fini (\"Health: 100 -&gt; 20\") g\u00f6rsel olarak g\u00f6sterir.</li> <li>Topology Change Detection: Yeni eklenen veya silinen Entity/Bile\u015fen say\u0131s\u0131n\u0131 raporlar.</li> </ul>"},{"location":"API_References/SnapshotDiffViewer_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Se\u00e7im: Geli\u015ftirici, dosya sisteminden veya <code>SnapshotManager</code> haf\u0131zas\u0131ndan iki referans se\u00e7er.</li> <li>Bitwise Analiz: \u0130ki veri blo\u011fu aras\u0131ndaki farklar (XOR i\u015flemi benzeri bir mant\u0131kla) saptan\u0131r.</li> <li>\u0130nsan Okunabilirli\u011fi: Ham bayt farklar\u0131, Nexus metadata sistemi kullan\u0131larak bile\u015fen isimlerine ve de\u011ferlerine d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcr.</li> <li>Raporlama: \"124 Entity de\u011fi\u015fti, 45 Bile\u015fen eklendi\" gibi \u00f6zet bir rapor olu\u015fturulur.</li> </ol>"},{"location":"API_References/SnapshotDiffViewer_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Bir bug'\u0131 yakalamak:\n// 1. Oyunun hatas\u0131z an\u0131nda bir Snapshot (A) al\u0131n\u0131r.\n// 2. Hata an\u0131nda ikinci Snapshot (B) al\u0131n\u0131r.\n// 3. [Snapshot Diff Viewer] ile bu ikisi kar\u015f\u0131la\u015ft\u0131r\u0131l\u0131r.\n// Bulgusu: \"Enemy_45 nesnesinin Speed de\u011feri NaN olmu\u015f!\"\n</code></pre>"},{"location":"API_References/SnapshotDiffViewer_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class SnapshotDiffViewer : EditorWindow\n{\n    [MenuItem(\"Nexus/Snapshot Diff Viewer\")]\n    public static void ShowWindow() =&gt; GetWindow&lt;SnapshotDiffViewer&gt;(\"Snapshot Diff\");\n\n    private void OnGUI() {\n        GUILayout.Label(\"Global State Snapshot Diff\", EditorStyles.boldLabel);\n        // Object input fields for Snapshot A and B...\n        if (GUILayout.Button(\"Analyze Differences\")) {\n            // Bitwise compare logic...\n        }\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/SnapshotDiffViewer_tr/#nexus-optimization-tip-sparse-diff","title":"Nexus Optimization Tip: Sparse Diff","text":"<p>Snapshot'lar\u0131n tamam\u0131n\u0131 kar\u015f\u0131la\u015ft\u0131rmak yerine sadece <code>Dirty</code> bayra\u011f\u0131 set edilmi\u015f bloklar\u0131 taray\u0131n. Bu \"Seyrek Tarama\" (Sparse Scanning) tekni\u011fi, devasa d\u00fcnyalarda fark analiz s\u00fcresini %90 oran\u0131nda k\u0131salt\u0131r.</p>"},{"location":"API_References/SnapshotManager_eng/","title":"Nexus Prime Architectural Manual: SnapshotManager (Temporal State Management)","text":""},{"location":"API_References/SnapshotManager_eng/#1-introduction","title":"1. Introduction","text":"<p><code>SnapshotManager.cs</code> is the brain behind Nexus Prime's \"Time Travel\" and \"Rewind\" mechanics. In modern games, Save/Load or Replay systems typically cause the game to stutter due to heavy serialization (JSON/XML) processes.</p> <p>The reason for SnapshotManager's existence is to freeze the game's current state in microseconds and restore it through a physical patch operation when necessary, by copying unmanaged memory blocks directly (Memory Mirroring) and recording only changed data (Delta-Snapshotting).</p>"},{"location":"API_References/SnapshotManager_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>SnapshotManager utilizes the following techniques for high-density state tracking:</p> <ul> <li>Delta-State Capturing: Working in coordination with <code>Registry.ClearAllDirtyBits</code>, it captures only components that have changed (Dirty) since the last frame. This reduces RAM consumption by 90%.</li> <li>Binary Memory Mirroring: Data is copied based on 16KB memory pages rather than per-object. Direct hardware-level transfers are performed with <code>NexusMemoryManager.Copy</code>.</li> <li>Differential Patching: During the <code>LoadSnapshot</code> operation, the system patches only the data within the snapshot over the main <code>Registry</code>, leaving unchanged data untouched.</li> <li>LIFO History Management: Snapshots are stored in a <code>LinkedList</code>. When <code>MaxHistoryFrames</code> is full, the oldest data is <code>Dispose</code>d, preventing unmanaged leaks.</li> </ul>"},{"location":"API_References/SnapshotManager_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Recording (<code>RecordFrame</code>): The current <code>Registry</code> is scanned. A <code>Snapshot.SetSnapshot</code> is created for each component type.</li> <li>Data Copying: Unmanaged pages within the <code>Sparse</code> and <code>Dense</code> arrays and the <code>ChunkedBuffer</code> are copied to newly allocated unmanaged blocks.</li> <li>Memory Cleanup: If <code>deltaOnly</code> is active, the \"Dirty\" flags on the main Registry are reset after copying (preparation for the next frame).</li> <li>Restoring (<code>LoadSnapshot</code>): A selected snapshot's data is overwritten directly onto the target Registry's unmanaged addresses with the <code>Copy</code> command.</li> </ol>"},{"location":"API_References/SnapshotManager_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Delta-Snapshotting A technique that saves space and time by recording only the differences in changing data. Memory Mirroring The process of creating an exact copy of a memory block at another address. Temporal Data A dataset belonging to a specific moment in time. History Buffer A sequential memory queue where past states are stored."},{"location":"API_References/SnapshotManager_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>RAM Consumption: Taking full snapshots every frame can consume gigabytes of RAM within seconds in a game with thousands of entities. The use of <code>deltaOnly</code> is mandatory.</li> <li>Pointer Invalidation: When a snapshot is restored, active pointers within the current Registry may change. All systems must \"Re-sync\" after a restore.</li> </ul>"},{"location":"API_References/SnapshotManager_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>var snapshotMgr = new SnapshotManager();\n\n// Record state (Only changes)\nsnapshotMgr.RecordFrame(registry, deltaOnly: true);\n\n// Go back 10 frames (Rewind)\nvar pastFrame = snapshotMgr.History.First.Value;\nsnapshotMgr.LoadSnapshot(registry, pastFrame);\n</code></pre>"},{"location":"API_References/SnapshotManager_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>using System.Collections.Generic;\nnamespace Nexus.Core;\n\npublic unsafe class SnapshotManager\n{\n    private readonly LinkedList&lt;Snapshot&gt; _history = new();\n    public int MaxHistoryFrames { get; set; } = 300;\n\n    public void RecordFrame(Registry registry, bool deltaOnly = true)\n    {\n        var snapshot = CreateSnapshot(registry, deltaOnly);\n        _history.AddLast(snapshot);\n        if (deltaOnly) registry.ClearAllDirtyBits();\n        // History cleanup...\n    }\n\n    public void LoadSnapshot(Registry registry, Snapshot snapshot)\n    {\n        foreach (var entry in snapshot.ComponentSnapshots) {\n            var set = registry.GetSetByType(entry.Key);\n            NexusMemoryManager.Copy(entry.Value.Dense, set.GetRawDense(out _), ss.DenseCount * sizeof(EntityId));\n            // Patch logic continues...\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/SnapshotManager_eng/#nexus-optimization-tip-dma-level-throughput","title":"Nexus Optimization Tip: DMA-Level Throughput","text":"<p>SnapshotManager can reach data transfer speeds of 15-20 GB/s on modern systems using <code>NativeMemory.Copy</code>. This is approximately 1000-2000 times faster than standard Unity <code>JsonUtility.ToJson</code> serialization. This is the secret to being able to take a \"Snapshot\" even in the middle of a bullet storm without it being felt.</p>"},{"location":"API_References/SnapshotManager_tr/","title":"Nexus Prime Mimari Rehberi: SnapshotManager (Temporal Durum Y\u00f6netimi)","text":""},{"location":"API_References/SnapshotManager_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>SnapshotManager.cs</code>, Nexus Prime'\u0131n \"Zaman Yolculu\u011fu\" (Time Travel) ve \"Geri Sarma\" (Rewind) mekanizmalar\u0131n\u0131n beynidir. Modern oyunlarda Save/Load veya Replay sistemleri genellikle a\u011f\u0131r serile\u015ftirme (JSON/XML) s\u00fcre\u00e7leri nedeniyle oyunun donmas\u0131na (stutter) sebep olur.</p> <p>SnapshotManager'\u0131n varl\u0131k sebebi, unmanaged bellek bloklar\u0131n\u0131 do\u011frudan kopyalayarak (Memory Mirroring) ve sadece de\u011fi\u015fen verileri kaydederek (Delta-Snapshotting), oyunun o anki durumunu mikrosaniyeler i\u00e7inde dondurmak ve gerekti\u011finde fiziksel bir patch (yama) i\u015flemiyle geri y\u00fcklemektir.</p>"},{"location":"API_References/SnapshotManager_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>SnapshotManager, y\u00fcksek yo\u011funluklu durum takibi i\u00e7in \u015fu teknikleri kullan\u0131r:</p> <ul> <li>Delta-State Capturing: <code>Registry.ClearAllDirtyBits</code> ile koordineli \u00e7al\u0131\u015farak, sadece son kareden bu yana de\u011fi\u015fmi\u015f (Dirty) bile\u015fenleri yakalar. Bu, RAM t\u00fcketimini %90 oran\u0131nda azalt\u0131r.</li> <li>Binary Memory Mirroring: Veriler nesne bazl\u0131 de\u011fil, 16KB'l\u0131k bellek sayfalar\u0131 baz\u0131nda kopyalan\u0131r. <code>NexusMemoryManager.Copy</code> ile do\u011frudan donan\u0131m seviyesinde aktar\u0131m yap\u0131l\u0131r.</li> <li>Differential Patching: <code>LoadSnapshot</code> i\u015flemi s\u0131ras\u0131nda, sistem sadece snapshot i\u00e7indeki verileri as\u0131l <code>Registry</code> \u00fczerine yamar, de\u011fi\u015fmeyen verileri ellemez.</li> <li>LIFO History Management: Snaphotlar bir <code>LinkedList</code> i\u00e7inde saklan\u0131r. <code>MaxHistoryFrames</code> doldu\u011funda en eski veri <code>Dispose</code> edilerek unmanaged s\u0131z\u0131nt\u0131lar\u0131 \u00f6nlenir.</li> </ul>"},{"location":"API_References/SnapshotManager_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Kay\u0131t (<code>RecordFrame</code>): Mevcut <code>Registry</code> taran\u0131r. Her bile\u015fen tipi i\u00e7in bir <code>Snapshot.SetSnapshot</code> olu\u015fturulur.</li> <li>Veri Kopyalama: <code>Sparse</code> ve <code>Dense</code> dizileri ile <code>ChunkedBuffer</code> i\u00e7indeki unmanaged sayfalar, yeni tahsis edilen unmanaged bloklara kopyalan\u0131r.</li> <li>Haf\u0131za Temizli\u011fi: E\u011fer <code>deltaOnly</code> aktifse, kopyalama sonras\u0131 as\u0131l Registry \u00fczerindeki \"Dirty\" bayraklar\u0131 s\u0131f\u0131rlan\u0131r (Bir sonraki kareye haz\u0131rl\u0131k).</li> <li>Geri Y\u00fckleme (<code>LoadSnapshot</code>): Se\u00e7ilen bir snapshot verisi, hedef Registry'nin unmanaged adreslerine do\u011frudan <code>Copy</code> komutuyla \u00fczerine yaz\u0131l\u0131r.</li> </ol>"},{"location":"API_References/SnapshotManager_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Delta-Snapshotting Sadece de\u011fi\u015fen verilerin fark\u0131n\u0131 kaydederek yer ve zaman tasarrufu sa\u011flama tekni\u011fi. Memory Mirroring Bir bellek blo\u011funun ayn\u0131s\u0131n\u0131 ba\u015fka bir adreste olu\u015fturma i\u015flemi. Temporal Data Zaman\u0131n belirli bir an\u0131na ait olan veri seti. History Buffer Ge\u00e7mi\u015fteki durumlar\u0131n sakland\u0131\u011f\u0131 s\u0131ral\u0131 bellek kuyru\u011fu."},{"location":"API_References/SnapshotManager_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>RAM Consumption: Her karede tam (full) snapshot almak, binlerce varl\u0131k olan bir oyunda saniyeler i\u00e7inde GB'larca RAM t\u00fcketebilir. <code>deltaOnly</code> kullan\u0131m\u0131 zorunludur.</li> <li>Pointer Invalidation: Snapshot geri y\u00fcklendi\u011finde, o anki Registry i\u00e7indeki aktif pointerlar de\u011fi\u015febilir. Geri y\u00fckleme sonras\u0131 t\u00fcm sistemlerin \"Re-sync\" olmas\u0131 gerekir.</li> </ul>"},{"location":"API_References/SnapshotManager_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>var snapshotMgr = new SnapshotManager();\n\n// Durumu kaydet (Sadece de\u011fi\u015fenleri)\nsnapshotMgr.RecordFrame(registry, deltaOnly: true);\n\n// 10 kare \u00f6ncesine d\u00f6n (Rewind)\nvar pastFrame = snapshotMgr.History.First.Value;\nsnapshotMgr.LoadSnapshot(registry, pastFrame);\n</code></pre>"},{"location":"API_References/SnapshotManager_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>using System.Collections.Generic;\nnamespace Nexus.Core;\n\npublic unsafe class SnapshotManager\n{\n    private readonly LinkedList&lt;Snapshot&gt; _history = new();\n    public int MaxHistoryFrames { get; set; } = 300;\n\n    public void RecordFrame(Registry registry, bool deltaOnly = true)\n    {\n        var snapshot = CreateSnapshot(registry, deltaOnly);\n        _history.AddLast(snapshot);\n        if (deltaOnly) registry.ClearAllDirtyBits();\n        // History cleanup...\n    }\n\n    public void LoadSnapshot(Registry registry, Snapshot snapshot)\n    {\n        foreach (var entry in snapshot.ComponentSnapshots) {\n            var set = registry.GetSetByType(entry.Key);\n            NexusMemoryManager.Copy(entry.Value.Dense, set.GetRawDense(out _), ss.DenseCount * sizeof(EntityId));\n            // Patch logic continues...\n        }\n    }\n}\n</code></pre>"},{"location":"API_References/SnapshotManager_tr/#nexus-optimization-tip-dma-level-throughput","title":"Nexus Optimization Tip: DMA-Level Throughput","text":"<p>SnapshotManager, <code>NativeMemory.Copy</code> kullanarak modern sistemlerde 15-20 GB/s veri transfer h\u0131z\u0131na ula\u015fabilir. Bu, standart bir Unity <code>JsonUtility.ToJson</code> serile\u015ftirmesinden yakla\u015f\u0131k 1000-2000 kat daha h\u0131zl\u0131d\u0131r. Bir mermi f\u0131rt\u0131nas\u0131n\u0131n ortas\u0131nda bile hissedilmeyecek seviyede \"Snapshot\" al\u0131nabilmesinin s\u0131rr\u0131 budur.</p>"},{"location":"API_References/SparseSet_eng/","title":"Nexus Prime Architectural Manual: SparseSet (Hybrid Data Storage)","text":""},{"location":"API_References/SparseSet_eng/#1-introduction","title":"1. Introduction","text":"<p><code>SparseSet.cs</code> is the backbone of the Nexus ECS architecture. It solves the biggest performance issues encountered in game engines: \"Memory Fragmentation\" and \"Cache Misses\" via the Hybrid Storage method.</p> <p>While a traditional <code>Dictionary&lt;int, T&gt;</code> structure keeps data scattered in memory, SparseSet always keeps data in a \"Tight\" (Packed) order. This way, the processor does not waste time searching for where the next data is; the data flows to the processor like a river.</p>"},{"location":"API_References/SparseSet_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>SparseSet combines the following advanced techniques for hardware efficiency:</p> <ul> <li>Double-Buffered Arrays (Sparse &amp; Dense): The <code>Sparse</code> array is optimized for fast access (Index), while the <code>Dense</code> array is optimized for fast iteration (Processing).</li> <li>Swap-and-Pop Algorithm: When an element is removed, the element at the end of the array is moved to fill the resulting gap. This allows for O(1) removal while keeping the memory in a block at all times.</li> <li>Dirty Bit Tracking: Utilizing AVX2-accelerated bitsets, only changed (dirty) components are identified within microseconds from gigabytes of data per second.</li> <li>Stable Pointers (ChunkedBuffer): Component data is kept within the <code>ChunkedBuffer</code>. This ensures that even if the array size grows, the memory address of the data does not change (Pointer Stability).</li> </ul>"},{"location":"API_References/SparseSet_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Addition (<code>Add</code>): The entity index is recorded in the <code>Sparse</code> array. The physical data is added to the end of the <code>Dense</code> array. The <code>Sparse[Entity] = DenseIndex</code> map is updated.</li> <li>Access (<code>Get</code>): The <code>Sparse</code> array is checked from the entity index, and a direct address is returned from there via the <code>DenseIndex</code> through the <code>ChunkedBuffer</code>.</li> <li>Removal (<code>Remove</code>): The position of the removed element is filled with the element at the end of the <code>Dense</code> array. <code>Sparse</code> maps are updated, and <code>Count</code> is decremented.</li> <li>Cleanup: When <code>ClearAllDirty</code> is called, all change flags are reset at once using AVX vector registers (256-bit).</li> </ol>"},{"location":"API_References/SparseSet_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Sparse Array An array that can have holes and uses entity indices as keys. Dense Array An array where components are lined up next to each other in memory without any gaps. Swap-and-Pop An ECS standard algorithm for maintaining memory integrity while performing O(1) removals. Dirty Bits Bitwise flags holding whether the data has been modified."},{"location":"API_References/SparseSet_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Memory Overhead: The Sparse array takes up space equal to the highest entity index. If you have an entity only at the 1 millionth index, the Sparse array will grow to that size.</li> <li>Pointer Lifespan: When a component is removed, old pointers pointing to it immediately become invalid. Never cache pointers; retrieve them every frame.</li> </ul>"},{"location":"API_References/SparseSet_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>var set = new SparseSet&lt;Position&gt;(1024);\nvar e1 = registry.Create();\n\n// Add\nPosition* p = set.Add(e1, new Position(0,0,0));\n\n// O(1) Access\nif (set.Has(e1)) {\n    Position* pData = set.Get(e1);\n}\n\n// O(1) Removal (Swap-and-Pop)\nset.Remove(e1);\n</code></pre>"},{"location":"API_References/SparseSet_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>using System.Runtime.InteropServices;\nnamespace Nexus.Core;\n\npublic unsafe class SparseSet&lt;T&gt; : ISparseSet where T : unmanaged\n{\n    private uint* _sparse; \n    private EntityId* _dense; \n    private int _denseCount;\n    private uint* _dirtyBits; \n    private readonly ChunkedBuffer&lt;T&gt; _components;\n    private const int ALIGNMENT = 64;\n\n    public T* Add(EntityId entity, T component = default)\n    {\n        EnsureSparseCapacity(entity.Index);\n        uint denseIndex = (uint)_denseCount;\n        _dense[denseIndex] = entity;\n        _sparse[entity.Index] = denseIndex;\n\n        T* compPtr = (T*)_components.GetPointer((int)denseIndex);\n        *compPtr = component;\n        _denseCount++;\n        SetDirty(denseIndex);\n        return compPtr;\n    }\n\n    public void Remove(EntityId entity)\n    {\n        uint denseIndex = _sparse[entity.Index];\n        uint lastDenseIndex = (uint)_denseCount - 1;\n        if (denseIndex != lastDenseIndex) {\n            // Swap logic...\n            _dense[denseIndex] = _dense[lastDenseIndex];\n            _sparse[_dense[denseIndex].Index] = denseIndex;\n        }\n        _sparse[entity.Index] = uint.MaxValue;\n        _denseCount--;\n    }\n}\n</code></pre>"},{"location":"API_References/SparseSet_eng/#nexus-optimization-tip-swap-and-pop-performance","title":"Nexus Optimization Tip: Swap-and-Pop Performance","text":"<p>While a standard <code>List.RemoveAt(0)</code> operation has an O(n) cost as it shifts all elements in memory; SparseSet's <code>Swap-and-Pop</code> algorithm completes the operation with only 2 pointer assignments and 1 memory copy (approx. 5-10 clock cycles). This can increase dynamic cleanup speed by up to 1000 times in memory-intensive tasks.</p>"},{"location":"API_References/SparseSet_tr/","title":"Nexus Prime Mimari Rehberi: SparseSet (Hibrit Veri Depolama)","text":""},{"location":"API_References/SparseSet_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>SparseSet.cs</code>, Nexus ECS mimarisinin belkemi\u011fidir. Oyun motorlar\u0131nda kar\u015f\u0131la\u015f\u0131lan en b\u00fcy\u00fck performans sorunu olan \"Bellek Par\u00e7alanmas\u0131\" (Memory Fragmentation) ve \"Cache Miss\" (\u00d6nbellek Iskalama) sorunlar\u0131n\u0131 Hybrid Storage (Hibrit Depolama) y\u00f6ntemiyle \u00e7\u00f6zer.</p> <p>Geleneksel bir <code>Dictionary&lt;int, T&gt;</code> yap\u0131s\u0131 verileri bellekte da\u011f\u0131n\u0131k tutarken, SparseSet verileri her zaman \"S\u0131ms\u0131k\u0131\" (Packed) bir s\u0131rada tutar. Bu sayede i\u015flemci, bir sonraki verinin nerede oldu\u011funu aramakla vakit kaybetmez; veri nehir gibi i\u015flemciye akar.</p>"},{"location":"API_References/SparseSet_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>SparseSet, donan\u0131m verimlili\u011fi i\u00e7in \u015fu ileri seviye teknikleri birle\u015ftirir:</p> <ul> <li>Double-Buffered Arrays (Sparse &amp; Dense): <code>Sparse</code> dizisi h\u0131zl\u0131 eri\u015fim (Index) i\u00e7in, <code>Dense</code> dizisi ise h\u0131zl\u0131 iterasyon (\u0130\u015fleme) i\u00e7in optimize edilmi\u015ftir.</li> <li>Swap-and-Pop Algoritmas\u0131: Bir eleman silindi\u011finde, olu\u015fan bo\u015flu\u011fu doldurmak i\u00e7in dizinin sonundaki eleman araya ta\u015f\u0131n\u0131r. Bu sayede O(1) s\u00fcrede silme yap\u0131l\u0131rken bellek her zaman blok halinde kal\u0131r.</li> <li>Dirty Bit Tracking: AVX2 h\u0131zland\u0131rmal\u0131 bitsetler kullan\u0131larak, sadece de\u011fi\u015fen (dirty) bile\u015fenler saniyede GB'larca veri aras\u0131ndan mikrosaniyeler i\u00e7inde tespit edilir.</li> <li>Stable Pointers (ChunkedBuffer): Bile\u015fen verileri <code>ChunkedBuffer</code> i\u00e7inde tutulur. Bu, dizinin boyutu b\u00fcy\u00fcse dahi verinin bellek adresinin de\u011fi\u015fmemesini (Pointer Stability) sa\u011flar.</li> </ul>"},{"location":"API_References/SparseSet_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Ekleme (<code>Add</code>): Varl\u0131k indeksi <code>Sparse</code> dizisine kaydedilir. Fiziksel veri <code>Dense</code> dizisinin sonuna eklenir. <code>Sparse[Entity] = DenseIndex</code> haritas\u0131 g\u00fcncellenir.</li> <li>Eri\u015fim (<code>Get</code>): Varl\u0131k indeksinden <code>Sparse</code> dizisine bak\u0131l\u0131r, oradaki <code>DenseIndex</code> ile <code>ChunkedBuffer</code> \u00fczerinden do\u011frudan adres d\u00f6n\u00fcl\u00fcr.</li> <li>Silme (<code>Remove</code>): Silinen eleman\u0131n yeri, <code>Dense</code> dizisinin sonundaki eleman ile doldurulur. <code>Sparse</code> haritalar\u0131 g\u00fcncellenir ve <code>Count</code> azalt\u0131l\u0131r.</li> <li>Temizlik: <code>ClearAllDirty</code> \u00e7a\u011fr\u0131ld\u0131\u011f\u0131nda, AVX vekt\u00f6r registerlar\u0131 (256-bit) ile t\u00fcm de\u011fi\u015fim bayraklar\u0131 tek seferde s\u0131f\u0131rlan\u0131r.</li> </ol>"},{"location":"API_References/SparseSet_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Sparse Array Delikli (Holes) olabilen, varl\u0131k indekslerini anahtar olarak kullanan dizi. Dense Array Bile\u015fenlerin bellekte hi\u00e7 bo\u015fluk b\u0131rakmadan yan yana dizildi\u011fi dizi. Swap-and-Pop O(1) s\u00fcrede silme yaparken bellek b\u00fct\u00fcnl\u00fc\u011f\u00fcn\u00fc koruma algoritmas\u0131. Dirty Bits Verinin de\u011fi\u015ftirilip de\u011fi\u015ftirilmedi\u011fini tutan bitsel bayraklar."},{"location":"API_References/SparseSet_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Memory Overhead: Sparse dizisi, en y\u00fcksek varl\u0131k indeksi kadar yer kaplar. E\u011fer sadece 1 milyonuncu indekste bir varl\u0131\u011f\u0131n\u0131z varsa, Sparse dizi o boyuta kadar b\u00fcy\u00fcr.</li> <li>Pointer Lifespan: Bile\u015fen silindi\u011finde, ona i\u015faret eden eski pointerlar an\u0131nda ge\u00e7ersiz olur. Pointerlar\u0131 asla cachelemeyin, her karede tekrar al\u0131n.</li> </ul>"},{"location":"API_References/SparseSet_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>var set = new SparseSet&lt;Position&gt;(1024);\nvar e1 = registry.Create();\n\n// Ekle\nPosition* p = set.Add(e1, new Position(0,0,0));\n\n// O(1) Eri\u015fim\nif (set.Has(e1)) {\n    Position* pData = set.Get(e1);\n}\n\n// O(1) Silme (Swap-and-Pop)\nset.Remove(e1);\n</code></pre>"},{"location":"API_References/SparseSet_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>using System.Runtime.InteropServices;\nnamespace Nexus.Core;\n\npublic unsafe class SparseSet&lt;T&gt; : ISparseSet where T : unmanaged\n{\n    private uint* _sparse; \n    private EntityId* _dense; \n    private int _denseCount;\n    private uint* _dirtyBits; \n    private readonly ChunkedBuffer&lt;T&gt; _components;\n    private const int ALIGNMENT = 64;\n\n    public T* Add(EntityId entity, T component = default)\n    {\n        EnsureSparseCapacity(entity.Index);\n        uint denseIndex = (uint)_denseCount;\n        _dense[denseIndex] = entity;\n        _sparse[entity.Index] = denseIndex;\n\n        T* compPtr = (T*)_components.GetPointer((int)denseIndex);\n        *compPtr = component;\n        _denseCount++;\n        SetDirty(denseIndex);\n        return compPtr;\n    }\n\n    public void Remove(EntityId entity)\n    {\n        uint denseIndex = _sparse[entity.Index];\n        uint lastDenseIndex = (uint)_denseCount - 1;\n        if (denseIndex != lastDenseIndex) {\n            // Swap logic...\n            _dense[denseIndex] = _dense[lastDenseIndex];\n            _sparse[_dense[denseIndex].Index] = denseIndex;\n        }\n        _sparse[entity.Index] = uint.MaxValue;\n        _denseCount--;\n    }\n}\n</code></pre>"},{"location":"API_References/SparseSet_tr/#nexus-optimization-tip-swap-and-pop-performance","title":"Nexus Optimization Tip: Swap-and-Pop Performance","text":"<p>Standart bir <code>List.RemoveAt(0)</code> i\u015flemi bellekteki t\u00fcm elemanlar\u0131 kayd\u0131rd\u0131\u011f\u0131 i\u00e7in O(n) maliyetindeyken; SparseSet'in <code>Swap-and-Pop</code> algoritmas\u0131 sadece 2 pointer atamas\u0131 ve 1 bellek kopyalamas\u0131 (yakla\u015f\u0131k 5-10 clock cycle) ile i\u015flemi tamamlar. Bu, bellek yo\u011fun i\u015flerde dinamik temizlik h\u0131z\u0131n\u0131 1000 kata kadar art\u0131rabilir.</p>"},{"location":"API_References/TimeTravelDebugger_eng/","title":"Nexus Prime Architectural Manual: Time-Travel Debugger (Time Travel)","text":""},{"location":"API_References/TimeTravelDebugger_eng/#1-introduction","title":"1. Introduction","text":"<p><code>TimeTravelDebugger.cs</code> is the \"Rewind\" interface that allows returning to any moment of the game using the deterministic simulation structure of Nexus Prime. It makes the raw unmanaged data recorded by the <code>SnapshotManager</code> navigable via a Slider.</p> <p>The reason for this tool's existence is to exactly determine the source of the problem (Root Cause) by examining an error or physics interaction occurring in seconds, frame by frame.</p>"},{"location":"API_References/TimeTravelDebugger_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Time travel works with the following components:</p> <ul> <li>Snapshot Scrubbing: As the <code>_currentFrame</code> value changes, copies the relevant memory block on the <code>SnapshotManager</code> to the active Registry.</li> <li>Deterministic Playback: Even if the simulation is stopped, it rebuilds the game's visual and logical state (Entities, Components) at that moment over the recorded data.</li> <li>Frame Navigation: Offers the developer the opportunity to progress and retreat in microseconds (FixedUpdate based) with \"Step Back\" and \"Step Forward\" buttons.</li> <li>State Restoration: When the Slider is released, all unmanaged assets return to their coordinates and values in the selected frame.</li> </ul>"},{"location":"API_References/TimeTravelDebugger_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Recording: <code>SnapshotManager</code> takes periodic recordings in the background while the game is running.</li> <li>Stopping: The developer pauses the game and opens the Time-Travel panel.</li> <li>Sliding: Every value change when the Slider is pulled triggers a <code>RestoreSnapshot</code> call.</li> <li>Examination: Objects in the scene physically return to that moment, and <code>LiveStateTweaker</code> shows current values.</li> </ol>"},{"location":"API_References/TimeTravelDebugger_eng/#4-usage-example","title":"4. Usage Example","text":"<pre><code>// Examining a faulty explosion:\n// 1. After the explosion occurs, the game is stopped.\n// 2. The slider is pulled to 20 frames before the moment of explosion.\n// 3. The first frame where the explosion started is found with \"Step Forward\".\n// 4. The velocity and angle of the faulty bullet are analyzed.\n</code></pre>"},{"location":"API_References/TimeTravelDebugger_eng/#5-full-source-implementation-direct-implementation","title":"5. Full Source Implementation (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class TimeTravelDebugger : EditorWindow\n{\n    [MenuItem(\"Nexus/Time-Travel Debugger\")]\n    public static void ShowWindow() =&gt; GetWindow&lt;TimeTravelDebugger&gt;(\"Time-Travel\");\n\n    private float _currentFrame = 0;\n    private void OnGUI() {\n        _currentFrame = EditorGUILayout.Slider(\"Frame\", _currentFrame, 0, 300);\n        // Play, Pause, Step controls...\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/TimeTravelDebugger_eng/#nexus-optimization-tip-keyframe-sampling","title":"Nexus Optimization Tip: Keyframe Sampling","text":"<p>Instead of keeping all frames in RAM, record only \"Keyframes\" (e.g., every 10 frames) in full and keep the differences (Delta) in between. This allows you to go back further in time by reducing Time-Travel memory usage by 80%.</p>"},{"location":"API_References/TimeTravelDebugger_tr/","title":"Nexus Prime Mimari Rehberi: Time-Travel Debugger (Zaman Yolculu\u011fu)","text":""},{"location":"API_References/TimeTravelDebugger_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>TimeTravelDebugger.cs</code>, Nexus Prime'\u0131n deterministik sim\u00fclasyon yap\u0131s\u0131n\u0131 kullanarak oyunun herhangi bir an\u0131na geri d\u00f6nmeyi sa\u011flayan \"Geri Sarma\" aray\u00fcz\u00fcd\u00fcr. <code>SnapshotManager</code> taraf\u0131ndan kaydedilen ham unmanaged verileri bir Slider arac\u0131l\u0131\u011f\u0131yla gezilebilir hale getirir.</p> <p>Bu arac\u0131n varl\u0131k sebebi; saniyelik bir hatay\u0131 veya fizik etkile\u015fimini kare kare inceleyerek sorunun kayna\u011f\u0131n\u0131 (Root Cause) tam olarak tespit etmektir.</p>"},{"location":"API_References/TimeTravelDebugger_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Zaman yolculu\u011fu \u015fu bile\u015fenlerle \u00e7al\u0131\u015f\u0131r:</p> <ul> <li>Snapshot Scrubbing: <code>_currentFrame</code> de\u011feri de\u011fi\u015ftik\u00e7e, <code>SnapshotManager</code> \u00fczerindeki ilgili bellek blo\u011funu aktif Registry'e kopyalar.</li> <li>Deterministic Playback: Sim\u00fclasyon durdurulmu\u015f olsa bile, kaydedilen veriler \u00fczerinden oyunun o anki g\u00f6rsel ve mant\u0131ksal durumunu (Entities, Components) yeniden in\u015fa eder.</li> <li>Frame Navigation: Geli\u015ftiriciye \"Step Back\" ve \"Step Forward\" butonlar\u0131yla mikro saniyelik (FixedUpdate bazl\u0131) ilerleme ve gerileme imkan\u0131 sunar.</li> <li>State Restoration: Slider b\u0131rak\u0131ld\u0131\u011f\u0131nda, t\u00fcm unmanaged varl\u0131klar se\u00e7ilen karedeki koordinatlar\u0131na ve de\u011ferlerine geri d\u00f6ner.</li> </ul>"},{"location":"API_References/TimeTravelDebugger_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Kay\u0131t: Oyun \u00e7al\u0131\u015f\u0131rken arka planda <code>SnapshotManager</code> periyodik kay\u0131t al\u0131r.</li> <li>Durdurma: Geli\u015ftirici oyunu pause eder ve Time-Travel panelini a\u00e7ar.</li> <li>Kayd\u0131rma: Slider \u00e7ekildi\u011finde her de\u011fer de\u011fi\u015fimi bir <code>RestoreSnapshot</code> \u00e7a\u011fr\u0131s\u0131 tetikler.</li> <li>\u0130nceleme: Sahnedeki nesneler fiziksel olarak o ana d\u00f6ner ve <code>LiveStateTweaker</code> o anki de\u011ferleri g\u00f6sterir.</li> </ol>"},{"location":"API_References/TimeTravelDebugger_tr/#4-kullanm-ornegi","title":"4. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// Hatal\u0131 bir patlamay\u0131 incelemek:\n// 1. Patlama olduktan sonra oyun durdurulur.\n// 2. Slider patlama an\u0131ndan 20 kare \u00f6ncesine \u00e7ekilir.\n// 3. \"Step Forward\" ile patlaman\u0131n ba\u015flad\u0131\u011f\u0131 ilk kare bulunur.\n// 4. Hatal\u0131 merminin h\u0131z\u0131 ve a\u00e7\u0131s\u0131 analiz edilir.\n</code></pre>"},{"location":"API_References/TimeTravelDebugger_tr/#5-tam-kaynak-kod-direct-implementation","title":"5. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>#if UNITY_EDITOR\nnamespace Nexus.Editor;\n\npublic class TimeTravelDebugger : EditorWindow\n{\n    [MenuItem(\"Nexus/Time-Travel Debugger\")]\n    public static void ShowWindow() =&gt; GetWindow&lt;TimeTravelDebugger&gt;(\"Time-Travel\");\n\n    private float _currentFrame = 0;\n    private void OnGUI() {\n        _currentFrame = EditorGUILayout.Slider(\"Frame\", _currentFrame, 0, 300);\n        // Play, Pause, Step controls...\n    }\n}\n#endif\n</code></pre>"},{"location":"API_References/TimeTravelDebugger_tr/#nexus-optimization-tip-keyframe-sampling","title":"Nexus Optimization Tip: Keyframe Sampling","text":"<p>T\u00fcm kareleri RAM'de tutmak yerine sadece \"Keyframe\"leri (\u00d6rn: her 10 karede bir) tam kaydedip aradaki farklar\u0131 (Delta) tutun. Bu, Time-Travel bellek kullan\u0131m\u0131n\u0131 %80 oran\u0131nda azaltarak daha uzun s\u00fcre geri gitmenizi sa\u011flar.</p>"},{"location":"API_References/UnmanagedComponentAnalyzer_eng/","title":"Nexus Prime Architectural Manual: UnmanagedComponentAnalyzer (Compile-Time Security Analysis)","text":""},{"location":"API_References/UnmanagedComponentAnalyzer_eng/#1-introduction","title":"1. Introduction","text":"<p><code>UnmanagedComponentAnalyzer.cs</code> is the \"Compile-Time Safety\" layer of the Nexus Prime framework. By infiltrating the standard C# compiler (Roslyn), it prevents a developer from accidentally using a managed type (class, string, etc.) as a component.</p> <p>The reason for this analyzer's existence is that unmanaged memory operations (Registry, SparseSet) can, by nature, only work with \"blittable\" structs. If a developer writes <code>Registry.Add&lt;MyClass&gt;</code>, this code appears as a red line (Error) on the IDE thanks to this analyzer before it can cause a memory crash (Access Violation) at runtime.</p>"},{"location":"API_References/UnmanagedComponentAnalyzer_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>The analyzer uses the following Roslyn infrastructures to maintain code quality and data security:</p> <ul> <li>Roslyn Syntax Node Analysis: Scans <code>Add</code>, <code>Get</code>, and <code>Has</code> method calls within the code to capture generic type parameters.</li> <li>Semantic Model Validation: Looks at the true nature of the type, not just its spelling. It determines whether there are reference (managed) objects within the type with the <code>namedType.IsUnmanagedType</code> check.</li> <li>NX0001 Diagnostic ID: By standardizing the error code, it ensures that \"Unmanaged Violation\" errors are automatically rejected in CI/CD processes.</li> <li>Symbol Action Registration: Not only does it inspect method calls, but it also monitors all class and struct definitions marked with the <code>[MustBeUnmanaged]</code> attribute.</li> </ul>"},{"location":"API_References/UnmanagedComponentAnalyzer_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Triggering: Roslyn triggers the analyzer as the developer writes code or when compilation begins.</li> <li>Inquiry: Generic calls or attributed types made via <code>Registry</code> are identified.</li> <li>Validation: If the type's <code>IsUnmanagedType</code> property is <code>false</code>, an error report (<code>Rule</code>) is created.</li> <li>Reporting: The \"Type must be unmanaged\" warning is presented graphically to the user via the IDE (Visual Studio/Rider).</li> </ol>"},{"location":"API_References/UnmanagedComponentAnalyzer_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description Roslyn Open-source C# and Visual Basic compiler platform for .NET. Diagnostic Analyzer A plugin that adds additional rules and analysis about code to the compiler. Blittable A data type whose memory structure is identical in the managed and unmanaged worlds. Semantic Model A deep information layer containing the meaning, types, and symbols of the code."},{"location":"API_References/UnmanagedComponentAnalyzer_eng/#5-risks-and-limits","title":"5. Risks and Limits","text":"<ul> <li>Compiler Performance: In very large projects, performing analysis on every keypress can tire the processor. Therefore, the analysis only focuses on relevant generic methods and attributes.</li> <li>Partial Types: In some cases, all parts of a \"partial\" defined struct must be unmanaged, otherwise the analyzer may not report an error (Roslyn constraint).</li> </ul>"},{"location":"API_References/UnmanagedComponentAnalyzer_eng/#6-usage-example","title":"6. Usage Example","text":"<pre><code>// INCORRECT USAGE: Analyzer throws NX0001 error here\npublic struct BadComponent {\n    public string Name; // String is a managed object!\n}\n\nregistry.Add&lt;BadComponent&gt;(entity); // COMPILATION ERROR: Type 'BadComponent' contains managed references\n</code></pre>"},{"location":"API_References/UnmanagedComponentAnalyzer_eng/#7-full-source-implementation-direct-implementation","title":"7. Full Source Implementation (Direct Implementation)","text":"<pre><code>using Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.Diagnostics;\nnamespace Nexus.Core;\n\n[DiagnosticAnalyzer(LanguageNames.CSharp)]\npublic class UnmanagedComponentAnalyzer : DiagnosticAnalyzer\n{\n    public const string DiagnosticId = \"NX0001\";\n    public override void Initialize(AnalysisContext context)\n    {\n        context.RegisterSyntaxNodeAction(AnalyzeGenericRegistryCall, SyntaxKind.InvocationExpression);\n    }\n\n    private void AnalyzeGenericRegistryCall(SyntaxNodeAnalysisContext context)\n    {\n        // 1. Find Add/Get/Has calls\n        // 2. Check if typeArg.IsUnmanagedType is false\n        // 3. Report context.ReportDiagnostic(Rule)\n    }\n}\n</code></pre>"},{"location":"API_References/UnmanagedComponentAnalyzer_eng/#nexus-optimization-tip-early-detection-savings","title":"Nexus Optimization Tip: Early Detection Savings","text":"<p>While debugging an \"Access Violation\" error at runtime can take hours, thanks to <code>UnmanagedComponentAnalyzer</code>, this error is caught the second it is written. This is a \"Shift-Left\" strategy that massively reduces development costs and technical debt.</p>"},{"location":"API_References/UnmanagedComponentAnalyzer_tr/","title":"Nexus Prime Mimari Rehberi: UnmanagedComponentAnalyzer (Derleme Zaman\u0131 G\u00fcvenlik Analizi)","text":""},{"location":"API_References/UnmanagedComponentAnalyzer_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>UnmanagedComponentAnalyzer.cs</code>, Nexus Prime framework'\u00fcn\u00fcn \"Derleme Zaman\u0131 G\u00fcvenlik\" (Compile-Time Safety) katman\u0131d\u0131r. C# dilinin standart derleyicisinin (Roslyn) i\u00e7ine s\u0131zarak, geli\u015ftiricinin yanl\u0131\u015fl\u0131kla managed bir tipi (class, string vb.) bir bile\u015fen olarak kullanmas\u0131n\u0131 engeller.</p> <p>Bu analyzer'\u0131n varl\u0131k sebebi, unmanaged bellek operasyonlar\u0131n\u0131n (Registry, SparseSet) do\u011fas\u0131 gere\u011fi sadece \"blittable\" struct'lar ile \u00e7al\u0131\u015fabilmesidir. E\u011fer bir geli\u015ftirici <code>Registry.Add&lt;MyClass&gt;</code> yazarsa, bu kod \u00e7al\u0131\u015fma zaman\u0131nda bellek \u00e7\u00f6kmesine (Access Violation) neden olmadan \u00f6nce, bu analyzer sayesinde IDE \u00fczerinde k\u0131rm\u0131z\u0131 \u00e7izgi (Hata) olarak g\u00f6r\u00fcn\u00fcr.</p>"},{"location":"API_References/UnmanagedComponentAnalyzer_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Analyzer, kod kalitesini ve veri g\u00fcvenli\u011fini korumak i\u00e7in \u015fu Roslyn altyap\u0131lar\u0131n\u0131 kullan\u0131r:</p> <ul> <li>Roslyn Syntax Node Analysis: Kod i\u00e7indeki <code>Add</code>, <code>Get</code> ve <code>Has</code> metod \u00e7a\u011fr\u0131lar\u0131n\u0131 tarayarak jenerik tip parametrelerini yakalar.</li> <li>Semantic Model Validation: Sadece kodun yaz\u0131l\u0131\u015f\u0131na de\u011fil, o tipin ger\u00e7ek do\u011fas\u0131na bakar. <code>namedType.IsUnmanagedType</code> kontrol\u00fc ile tipin i\u00e7inde referans (managed) nesne olup olmad\u0131\u011f\u0131n\u0131 saptar.</li> <li>NX0001 Diagnostic ID: Hata kodunu standartla\u015ft\u0131rarak, CI/CD s\u00fcre\u00e7lerinde \"Unmanaged Violation\" hatalar\u0131n\u0131n otomatik reddedilmesini sa\u011flar.</li> <li>Symbol Action Registration: Sadece metod \u00e7a\u011fr\u0131lar\u0131n\u0131 de\u011fil, <code>[MustBeUnmanaged]</code> \u00f6zniteli\u011fi ile i\u015faretlenmi\u015f t\u00fcm s\u0131n\u0131f ve struct tan\u0131mlar\u0131n\u0131 da denetler.</li> </ul>"},{"location":"API_References/UnmanagedComponentAnalyzer_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Tetikleme: Geli\u015ftirici kod yazd\u0131k\u00e7a veya derleme ba\u015flad\u0131\u011f\u0131nda Roslyn analyzer'\u0131 tetikler.</li> <li>Sorgulama: <code>Registry</code> \u00fczerinden yap\u0131lan jenerik \u00e7a\u011fr\u0131lar veya \u00f6znitelikli tipler saptan\u0131r.</li> <li>Do\u011frulama: Tipin <code>IsUnmanagedType</code> \u00f6zelli\u011fi <code>false</code> ise bir hata raporu (<code>Rule</code>) olu\u015fturulur.</li> <li>Raporlama: IDE (Visual Studio/Rider) \u00fczerinden kullan\u0131c\u0131ya \"Type must be unmanaged\" uyar\u0131s\u0131 grafiksel olarak sunulur.</li> </ol>"},{"location":"API_References/UnmanagedComponentAnalyzer_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama Roslyn .NET i\u00e7in a\u00e7\u0131k kaynakl\u0131 C# ve Visual Basic derleyici platformu. Diagnostic Analyzer Derleyiciye kod hakk\u0131nda ek kurallar ve analizler ekleyen eklenti. Blittable Bellek yap\u0131s\u0131 managed ve unmanaged d\u00fcnyada birebir ayn\u0131 olan veri tipi. Semantic Model Kodun anlam\u0131n\u0131, tiplerini ve sembollerini i\u00e7eren derin bilgi katman\u0131."},{"location":"API_References/UnmanagedComponentAnalyzer_tr/#5-riskler-ve-snrlar","title":"5. Riskler ve S\u0131n\u0131rlar","text":"<ul> <li>Compiler Performance: \u00c7ok b\u00fcy\u00fck projelerde her tu\u015f bas\u0131m\u0131nda analiz yapmak i\u015flemciyi yorabilir. Bu y\u00fczden analiz sadece ilgili jenerik metodlara ve \u00f6zniteliklere odaklan\u0131r.</li> <li>Partial Types: Baz\u0131 durumlarda \"partial\" tan\u0131mlanm\u0131\u015f struct'lar\u0131n t\u00fcm par\u00e7alar\u0131n\u0131n unmanaged olmas\u0131 gerekir, aksi halde analyzer hata raporlamayabilir (Roslyn k\u0131s\u0131t\u0131).</li> </ul>"},{"location":"API_References/UnmanagedComponentAnalyzer_tr/#6-kullanm-ornegi","title":"6. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>// HATALI KULLANIM: Analyzer burada NX0001 hatas\u0131 f\u0131rlat\u0131r\npublic struct BadComponent {\n    public string Name; // String managed bir objedir!\n}\n\nregistry.Add&lt;BadComponent&gt;(entity); // DERLEME HATASI: Type 'BadComponent' contains managed references\n</code></pre>"},{"location":"API_References/UnmanagedComponentAnalyzer_tr/#7-tam-kaynak-kod-direct-implementation","title":"7. Tam Kaynak Kod (Direct Implementation)","text":"<pre><code>using Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.Diagnostics;\nnamespace Nexus.Core;\n\n[DiagnosticAnalyzer(LanguageNames.CSharp)]\npublic class UnmanagedComponentAnalyzer : DiagnosticAnalyzer\n{\n    public const string DiagnosticId = \"NX0001\";\n    public override void Initialize(AnalysisContext context)\n    {\n        context.RegisterSyntaxNodeAction(AnalyzeGenericRegistryCall, SyntaxKind.InvocationExpression);\n    }\n\n    private void AnalyzeGenericRegistryCall(SyntaxNodeAnalysisContext context)\n    {\n        // 1. Find Add/Get/Has calls\n        // 2. Check if typeArg.IsUnmanagedType is false\n        // 3. Report context.ReportDiagnostic(Rule)\n    }\n}\n</code></pre>"},{"location":"API_References/UnmanagedComponentAnalyzer_tr/#nexus-optimization-tip-early-detection-savings","title":"Nexus Optimization Tip: Early Detection Savings","text":"<p>Bir \"Access Violation\" hatas\u0131n\u0131 \u00e7al\u0131\u015fma zaman\u0131nda debug etmek saatler s\u00fcrebilirken, <code>UnmanagedComponentAnalyzer</code> sayesinde bu hata yaz\u0131ld\u0131\u011f\u0131 saniyede yakalan\u0131r. Bu, geli\u015ftirme maliyetini ve teknik borcu (technical debt) devasa oranda azaltan bir \"Shift-Left\" stratejisidir.</p>"},{"location":"API_References/VFXGraphProvider_eng/","title":"Nexus Prime Architectural Manual: VFXGraphProvider (Visual Effect Data Provider)","text":""},{"location":"API_References/VFXGraphProvider_eng/#1-introduction","title":"1. Introduction","text":"<p><code>VFXGraphProvider.cs</code> is the high-performance connection between Nexus Prime's unmanaged data world and Unity's GPU-based particle system, <code>VFX Graph</code>. It enables the creation of massive-scale and fluid visual effects by feeding position, color, and size data of millions of entities to VFX Graph as a \"Point Cache\" (Point Cache).</p> <p>The reason for this provider's existence is to completely eliminate the burden of creating <code>GameObject</code> or <code>Transform</code> on the CPU for each particle and to transmit the data directly to the GPU's particle calculation pipelines (Pipeline).</p>"},{"location":"API_References/VFXGraphProvider_eng/#2-technical-analysis","title":"2. Technical Analysis","text":"<p>Uses the following mechanisms for maximum visual performance:</p> <ul> <li>Point Cache Injection: Converts entity data in the unmanaged Registry into a <code>GraphicsBuffer</code> form that VFX Graph can understand.</li> <li>Massive Scalability: Unlike traditional particle systems, it can update the location of 1M+ particles 60 times per second simultaneously without locking CPU threads.</li> <li>GPU-Side Consumption: Once data is pushed to the GPU, the entire simulation of the effect (movement, color fading, etc.) takes place on the GPU.</li> <li>Property Binding: Connects unmanaged memory addresses directly to a name within VFX Graph (e.g., \"EntityBuffer\") using the <code>TargetVFX.SetGraphicsBuffer</code> method.</li> </ul>"},{"location":"API_References/VFXGraphProvider_eng/#3-logical-flow","title":"3. Logical Flow","text":"<ol> <li>Preparation: A <code>StructuredBuffer</code> or <code>Texture2D</code> area to receive the data is defined within VFX Graph.</li> <li>Packaging: Visual attributes of entities (Position, Color, etc.) are collected in a single memory block by scanning the Nexus Registry.</li> <li>Dispatch: data is sent to the GPU via <code>GraphicsBuffer</code>.</li> <li>Triggering: VFX Graph uses the new incoming data as a particle source during the \"Init\" or \"Update\" phase.</li> </ol>"},{"location":"API_References/VFXGraphProvider_eng/#4-glossary-of-terminology","title":"4. Glossary of Terminology","text":"Term Description VFX Graph Unity's advanced node-based (Node-based) visual effect tool running over GPU. Point Cache Pre-calculated or live data set determining the starting points and properties of particles. GraphicsBuffer Raw GPU memory space optimized for compute shaders and visual effect systems."},{"location":"API_References/VFXGraphProvider_eng/#5-usage-example","title":"5. Usage Example","text":"<pre><code>public class CrowdVisualizer : MonoBehaviour {\n    [SerializeField] private VFXGraphProvider _provider;\n\n    void LateUpdate() {\n        // Send locations of all city residents (10k+) to VFX Graph\n        _provider.SyncWithVFX(mainRegistry);\n    }\n}\n</code></pre>"},{"location":"API_References/VFXGraphProvider_eng/#6-full-source-implementation-conceptual-implementation","title":"6. Full Source Implementation (Conceptual Implementation)","text":"<pre><code>namespace Nexus.Bridge;\n\npublic class VFXGraphProvider : MonoBehaviour\n{\n    public VisualEffect TargetVFX;\n\n    public void SyncWithVFX(Registry.Registry registry)\n    {\n        if (TargetVFX == null) return;\n        // 1. Gather component data to GraphicsBuffer.\n        // 2. TargetVFX.SetGraphicsBuffer(\"EntityBuffer\", buffer);\n    }\n}\n</code></pre>"},{"location":"API_References/VFXGraphProvider_eng/#nexus-optimization-tip-gpu-frustum-culling","title":"Nexus Optimization Tip: GPU Frustum Culling","text":"<p>Correctly configure <code>Culling</code> settings within VFX Graph. If the particle cloud is not in the camera's field of view, stop copying data from the Nexus Registry. This optimizes the cost of data transfer to GPU memory (Bus Transfer) by 50%.</p>"},{"location":"API_References/VFXGraphProvider_tr/","title":"Nexus Prime Mimari Rehberi: VFXGraphProvider (G\u00f6rsel Efekt Veri Sa\u011flay\u0131c\u0131)","text":""},{"location":"API_References/VFXGraphProvider_tr/#1-giris","title":"1. Giri\u015f","text":"<p><code>VFXGraphProvider.cs</code>, Nexus Prime'\u0131n unmanaged veri d\u00fcnyas\u0131 ile Unity'nin GPU bazl\u0131 partik\u00fcl sistemi olan <code>VFX Graph</code> aras\u0131ndaki y\u00fcksek performansl\u0131 ba\u011flant\u0131d\u0131r. Milyonlarca varl\u0131\u011f\u0131n pozisyon, renk ve boyut verisini \"Point Cache\" (Nokta \u00d6nbelle\u011fi) olarak VFX Graph'a besleyerek, devasa boyutta ve ak\u0131c\u0131 g\u00f6rsel efektlerin olu\u015fturulmas\u0131n\u0131 sa\u011flar.</p> <p>Bu sa\u011flay\u0131c\u0131n\u0131n varl\u0131k sebebi; her bir partik\u00fcl i\u00e7in CPU \u00fczerinde <code>GameObject</code> veya <code>Transform</code> olu\u015fturma k\u00fclfetini tamamen ortadan kald\u0131r\u0131p, veriyi do\u011frudan GPU'nun partik\u00fcl hesaplama hatlar\u0131na (Pipeline) iletmektir.</p>"},{"location":"API_References/VFXGraphProvider_tr/#2-teknik-analiz","title":"2. Teknik Analiz","text":"<p>Maksimum g\u00f6rsel performans i\u00e7in \u015fu mekanizmalar\u0131 kullan\u0131r:</p> <ul> <li>Point Cache Injection: Unmanaged Registry'deki varl\u0131k verilerini, VFX Graph'\u0131n anlayabilece\u011fi <code>GraphicsBuffer</code> formuna d\u00f6n\u00fc\u015ft\u00fcr\u00fcr.</li> <li>Massive Scalability: Geleneksel partik\u00fcl sistemlerinin aksine, CPU threadlerini kilitlemeden ayn\u0131 anda 1M+ partik\u00fcl\u00fcn konumunu saniyede 60 kez g\u00fcncelleyebilir.</li> <li>GPU-Side Consumption: Veriler bir kez GPU'ya bas\u0131ld\u0131ktan sonra, efektin t\u00fcm sim\u00fclasyonu (hareket, renk solmas\u0131 vb.) GPU \u00fczerinde ger\u00e7ekle\u015fir.</li> <li>Property Binding: <code>TargetVFX.SetGraphicsBuffer</code> metodunu kullanarak unmanaged bellek adreslerini direkt olarak VFX Graph i\u00e7indeki bir isme (\u00d6rn: \"EntityBuffer\") ba\u011flar.</li> </ul>"},{"location":"API_References/VFXGraphProvider_tr/#3-mantksal-aks","title":"3. Mant\u0131ksal Ak\u0131\u015f","text":"<ol> <li>Haz\u0131rl\u0131k: VFX Graph i\u00e7inde veriyi kar\u015f\u0131layacak bir <code>StructuredBuffer</code> veya <code>Texture2D</code> alan\u0131 tan\u0131mlan\u0131r.</li> <li>Paketleme: Nexus Registry taranarak varl\u0131klar\u0131n g\u00f6rsel \u00f6znitelikleri (Pozisyon, Renk vb.) tek bir bellek blo\u011funda toplan\u0131r.</li> <li>G\u00f6nderim: Veriler GPU'ya <code>GraphicsBuffer</code> arac\u0131l\u0131\u011f\u0131yla yollan\u0131r.</li> <li>Tetikleme: VFX Graph, gelen yeni veriyi \"Init\" veya \"Update\" a\u015famas\u0131nda partik\u00fcl kayna\u011f\u0131 olarak kullan\u0131r.</li> </ol>"},{"location":"API_References/VFXGraphProvider_tr/#4-terminoloji-sozlugu","title":"4. Terminoloji S\u00f6zl\u00fc\u011f\u00fc","text":"Terim A\u00e7\u0131klama VFX Graph Unity'nin d\u00fc\u011f\u00fcm bazl\u0131 (Node-based), GPU \u00fczerinden \u00e7al\u0131\u015fan geli\u015fmi\u015f g\u00f6rsel efekt arac\u0131. Point Cache Partik\u00fcllerin ba\u015flang\u0131\u00e7 noktalar\u0131n\u0131 ve \u00f6zelliklerini belirleyen \u00f6nceden hesaplanm\u0131\u015f veya canl\u0131 veri seti. GraphicsBuffer Compute shader'lar ve g\u00f6rsel efekt sistemleri i\u00e7in optimize edilmi\u015f ham GPU bellek alan\u0131."},{"location":"API_References/VFXGraphProvider_tr/#5-kullanm-ornegi","title":"5. Kullan\u0131m \u00d6rne\u011fi","text":"<pre><code>public class CrowdVisualizer : MonoBehaviour {\n    [SerializeField] private VFXGraphProvider _provider;\n\n    void LateUpdate() {\n        // T\u00fcm \u015fehir sakinlerinin (10k+) konumlar\u0131n\u0131 VFX Graph'a g\u00f6nder\n        _provider.SyncWithVFX(mainRegistry);\n    }\n}\n</code></pre>"},{"location":"API_References/VFXGraphProvider_tr/#6-tam-kaynak-kod-conceptual-implementation","title":"6. Tam Kaynak Kod (Conceptual Implementation)","text":"<pre><code>namespace Nexus.Bridge;\n\npublic class VFXGraphProvider : MonoBehaviour\n{\n    public VisualEffect TargetVFX;\n\n    public void SyncWithVFX(Registry.Registry registry)\n    {\n        if (TargetVFX == null) return;\n        // 1. Gather component data to GraphicsBuffer.\n        // 2. TargetVFX.SetGraphicsBuffer(\"EntityBuffer\", buffer);\n    }\n}\n</code></pre>"},{"location":"API_References/VFXGraphProvider_tr/#nexus-optimization-tip-gpu-frustum-culling","title":"Nexus Optimization Tip: GPU Frustum Culling","text":"<p>VFX Graph i\u00e7inde <code>Culling</code> ayarlar\u0131n\u0131 do\u011fru yap\u0131land\u0131r\u0131n. E\u011fer partik\u00fcl bulutu kameran\u0131n g\u00f6r\u00fc\u015f a\u00e7\u0131s\u0131nda de\u011filse, Nexus Registry'den veri kopyalamay\u0131 durdurun. Bu, GPU belle\u011fine veri transferi maliyetini (Bus Transfer) %50 oran\u0131nda optimize eder.</p>"},{"location":"Core_Modules/Analyzers/","title":"Core Deep-Dive: Static Safety &amp; The Analyzer Suite","text":""},{"location":"Core_Modules/Analyzers/#abstract","title":"Abstract","text":"<p>This paper explores the Nexus Analyzer Suite, a collection of Roslyn-based static analysis rules designed to enforce memory safety in unmanaged C# environments. We formalize the Blittable Constraint Logic and explore the theoretical prevention of Garbage Collector (GC) Leakage in high-performance execution headers.</p>"},{"location":"Core_Modules/Analyzers/#1-safety-formalization","title":"1. Safety Formalization","text":"<p>The Nexus Analyzers operate as a formal verification layer on top of the standard C# compiler, catching architectural violations before runtime.</p>"},{"location":"Core_Modules/Analyzers/#11-the-blittable-theorem-nx001","title":"1.1 The Blittable Theorem (NX001)","text":"<p>A type \\(T\\) is considered Nexus-Safe if and only if it is a bit-wise identical representation across the managed/unmanaged boundary. $\\(Safe(T) \\iff \\forall f \\in T, Safe(f) \\wedge T.IsValueType \\wedge \\neg T.IsManaged\\)$</p> <p>The analyzer recursively crawls the field hierarchy of every <code>[NexusComponent]</code>, ensuring that pointers to managed arrays or strings never enter the unmanaged registry.</p> <pre><code>graph TD\n    subgraph Compiler_Analysis_Pipeline\n        A[C# Compiler AST] --&gt; B{Nexus Analyzer}\n        B --&gt;|NX001| C{Is Blittable?}\n        C --&gt;|Yes| D[Native Memory Allocation]\n        C --&gt;|No| E[Compile Time Error]\n    end\n    style E fill:#ff4444,color:#fff\n    style D fill:#44ff44</code></pre>"},{"location":"Core_Modules/Analyzers/#2-gc-leakage-prevention-nx003","title":"2. GC Leakage Prevention (NX003)","text":"<p>In real-time systems, an implicit allocation (like Boxing) inside a loop can trigger a GC Collect, causing a frame stutter.</p>"},{"location":"Core_Modules/Analyzers/#21-allocation-tracking-logic","title":"2.1 Allocation Tracking Logic","text":"<p>The analyzer scans the Abstract Syntax Tree (AST) for: 1. Implicit Boxing: <code>object o = 10;</code> 2. Closure Capture: Lambdas capturing managed references. 3. Array Initializations: <code>new int[32]</code> inside a system's <code>Execute</code> call.</p> <p>Performance Impact of Boxing (Math Constraint): Given an update loop running at 60 FPS processing \\(N = 100,000\\) entities. If a single boxing allocation takes 24 bytes: $$ \\text{Garbage Per Frame} = N \\times 24 \\text{ bytes} = 2.4 \\text{ MB} $$ $$ \\text{Garbage Per Second} = 2.4 \\text{ MB} \\times 60 = 144 \\text{ MB/s} $$ This rapid allocation rate guarantees inevitable GC pauses. By enforcing a Zero-Allocation Policy at the compiler level, Nexus prevents this entirely.</p>"},{"location":"Core_Modules/Analyzers/#3-implementation-diagnostic-enforcement","title":"3. Implementation: Diagnostic Enforcement","text":"<p>Code Implementation (Analyzer Logic): <pre><code>public override void Initialize(AnalysisContext context) {\n    context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);\n}\n\nprivate void AnalyzeSymbol(SymbolAnalysisContext context) {\n    var typeSymbol = (INamedTypeSymbol)context.Symbol;\n    if (typeSymbol.GetAttributes().Any(ad =&gt; ad.AttributeClass.Name == \"NexusComponent\")) {\n        // ALGORITHM: Recursive Blittable Check\n        if (!IsBlittable(typeSymbol)) {\n            var diagnostic = Diagnostic.Create(RuleNX001, typeSymbol.Locations[0], typeSymbol.Name);\n            context.ReportDiagnostic(diagnostic);\n        }\n    }\n}\n</code></pre></p>"},{"location":"Core_Modules/Analyzers/#4-conclusion","title":"4. Conclusion","text":"<p>Nexus Analyzers transform \"unsafe\" code into \"safe unmanaged\" code. By shifting the verification burden to the compiler, developers gain the performance of C++ while maintaining the safety and iteration speed of C#.</p>"},{"location":"Core_Modules/Analyzers/#_1","title":"Analyzers","text":""},{"location":"Core_Modules/Analyzers/#derinlemesine-inceleme-statik-guvenlik-ve-analiz-paketi","title":"Derinlemesine \u0130nceleme: Statik G\u00fcvenlik ve Analiz Paketi","text":""},{"location":"Core_Modules/Analyzers/#ozet","title":"\u00d6zet","text":"<p>Bu makale, unmanaged C# ortamlar\u0131nda bellek g\u00fcvenli\u011fini sa\u011flamak i\u00e7in tasarlanm\u0131\u015f Roslyn tabanl\u0131 statik analiz kurallar\u0131 olan Nexus Analyzer Suite'i incelemektedir. Blittable K\u0131s\u0131tlama Mant\u0131\u011f\u0131'n\u0131 form\u00fclize ediyor ve y\u00fcksek performansl\u0131 y\u00fcr\u00fctme ba\u015fl\u0131klar\u0131nda Garbage Collector (GC) S\u0131z\u0131nt\u0131s\u0131n\u0131n teorik olarak nas\u0131l \u00f6nlendi\u011fini ke\u015ffediyoruz.</p>"},{"location":"Core_Modules/Analyzers/#1-guvenlik-formulizasyonu","title":"1. G\u00fcvenlik Form\u00fclizasyonu","text":"<p>Nexus Analiz\u00f6rleri, standart C# derleyicisi \u00fczerinde resmi bir do\u011frulama katman\u0131 olarak \u00e7al\u0131\u015f\u0131r ve \u00e7al\u0131\u015fma zaman\u0131ndan (runtime) \u00f6nce mimari ihlalleri yakalar.</p>"},{"location":"Core_Modules/Analyzers/#11-blittable-teoremi-nx001","title":"1.1 Blittable Teoremi (NX001)","text":"<p>Bir \\(T\\) tipinin Nexus-G\u00fcvenli kabul edilebilmesi i\u00e7in y\u00f6netilen/y\u00f6netilmeyen s\u0131n\u0131r\u0131nda bit d\u00fczeyinde \u00f6zde\u015f bir temsile sahip olmas\u0131 gerekir. $\\(Safe(T) \\iff \\forall f \\in T, Safe(f) \\wedge T.IsValueType \\wedge \\neg T.IsManaged\\)$</p> <p>Analiz\u00f6r, her <code>[NexusComponent]</code> \u00f6zniteli\u011fine sahip yap\u0131n\u0131n alan hiyerar\u015fisini rek\u00fcrsif olarak tarar ve y\u00f6netilmeyen registry'ye asla y\u00f6netilen dizilerin (array) veya metinlerin (string) girmemesini sa\u011flar.</p> <pre><code>graph TD\n    subgraph Derleyici_Analiz_Hatti\n        A[C# Derleyici AST] --&gt; B{Nexus Analiz\u00f6r}\n        B --&gt;|NX001| C{Blittable mi?}\n        C --&gt;|Evet| D[Yerel Bellek Tahsisi]\n        C --&gt;|Hayir| E[Derleme Zamani Hatasi]\n    end\n    style E fill:#ff4444,color:#fff\n    style D fill:#44ff44</code></pre>"},{"location":"Core_Modules/Analyzers/#2-gc-sznts-onleme-nx003","title":"2. GC S\u0131z\u0131nt\u0131s\u0131 \u00d6nleme (NX003)","text":"<p>Ger\u00e7ek zamanl\u0131 sistemlerde, bir d\u00f6ng\u00fc i\u00e7indeki \u00f6rt\u00fck bir bellek tahsisat\u0131 (Boxing gibi) bir GC toplama i\u015flemini tetikleyerek kare atlamalar\u0131na (stutter) neden olabilir.</p>"},{"location":"Core_Modules/Analyzers/#21-tahsisat-takip-mantg","title":"2.1 Tahsisat Takip Mant\u0131\u011f\u0131","text":"<p>Analiz\u00f6r, Soyut S\u00f6zdizimi A\u011fac\u0131n\u0131 (AST) \u015fu durumlar i\u00e7in tarar: 1. \u00d6rt\u00fck Boxing: <code>object o = 10;</code> 2. Closure Yakalama: Y\u00f6netilen referanslar\u0131 yakalayan lambda ifadeleri. 3. Dizi Ba\u015flatma: Bir sistemin <code>Execute</code> \u00e7a\u011fr\u0131s\u0131 i\u00e7inde <code>new int[32]</code> kullan\u0131m\u0131.</p> <p>Boxing \u0130\u015fleminin Performans Etkisi (Matematiksel K\u0131s\u0131tlama): 60 FPS'de \u00e7al\u0131\u015fan ve \\(N = 100,000\\) varl\u0131k i\u015fleyen bir d\u00f6ng\u00fc d\u00fc\u015f\u00fcn\u00fcn. Tek bir boxing tahsisat\u0131 24 byte al\u0131yorsa: $$ \\text{Kare Ba\u015f\u0131na \u00c7\u00f6p} = N \\times 24 \\text{ byte} = 2.4 \\text{ MB} $$ $$ \\text{Saniye Ba\u015f\u0131na \u00c7\u00f6p} = 2.4 \\text{ MB} \\times 60 = 144 \\text{ MB/s} $$ Bu h\u0131zl\u0131 tahsisat oran\u0131, ka\u00e7\u0131n\u0131lmaz GC duraklamalar\u0131n\u0131 (pause) garanti eder. Nexus, derleyici seviyesinde S\u0131f\u0131r-Tahsisat Politikas\u0131 uygulayarak bunu tamamen \u00f6nler.</p>"},{"location":"Core_Modules/Analyzers/#3-uygulama-tanlama-zorlamas","title":"3. Uygulama: Tan\u0131lama Zorlamas\u0131","text":"<p>Kod Uygulamas\u0131 (Analiz\u00f6r Mant\u0131\u011f\u0131): <pre><code>public override void Initialize(AnalysisContext context) {\n    context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);\n}\n\nprivate void AnalyzeSymbol(SymbolAnalysisContext context) {\n    var typeSymbol = (INamedTypeSymbol)context.Symbol;\n    if (typeSymbol.GetAttributes().Any(ad =&gt; ad.AttributeClass.Name == \"NexusComponent\")) {\n        // ALGOR\u0130TMA: Rek\u00fcrsif Blittable Kontrol\u00fc\n        if (!IsBlittable(typeSymbol)) {\n            var diagnostic = Diagnostic.Create(RuleNX001, typeSymbol.Locations[0], typeSymbol.Name);\n            context.ReportDiagnostic(diagnostic);\n        }\n    }\n}\n</code></pre></p>"},{"location":"Core_Modules/Analyzers/#4-sonuc","title":"4. Sonu\u00e7","text":"<p>Nexus Analiz\u00f6rleri \"unsafe\" (g\u00fcvensiz) kodu \"g\u00fcvenli unmanaged\" koda d\u00f6n\u00fc\u015ft\u00fcr\u00fcr. Do\u011frulama y\u00fck\u00fcn\u00fc derleyiciye kayd\u0131rarak, geli\u015ftiriciler C++ performans\u0131n\u0131 elde ederken C#'\u0131n g\u00fcvenlik ve iterasyon h\u0131z\u0131 avantajlar\u0131n\u0131 korurlar.</p>"},{"location":"Core_Modules/Bridge/","title":"Core Deep-Dive: The Nexus-Unity Bridge Protocol","text":""},{"location":"Core_Modules/Bridge/#abstract","title":"Abstract","text":"<p>This paper details the Nexus Bridge Protocol, the high-speed synchronization layer between the Nexus Unmanaged Engine and the Unity Managed World. We explore the Direct Memory Mapping architecture, the use of Dirty-Sync Generators, and the protocol for maintaining state consistency with zero GC pressure.</p>"},{"location":"Core_Modules/Bridge/#1-the-synchronization-protocol-two-world-unity","title":"1. The Synchronization Protocol: Two-World Unity","text":"<p>The challenge of any high-performance ECS in a managed engine is \"The Marshalling Gap.\" Nexus solves this by treating Unity GameObjects purely as Visual Views of the unmanaged Data Truth.</p>"},{"location":"Core_Modules/Bridge/#11-direct-mapping-architecture","title":"1.1 Direct Mapping Architecture","text":"<p>Nexus uses a static <code>NexusObjectMapping</code> table that creates a 1-to-1 link between an <code>EntityId</code> (Unique ID) and a <code>GameObject</code> reference.</p> <p>Protocol Workflow: 1. Creation: An entity is spawned in Nexus; a <code>GameObject</code> is instantiated in Unity and registered to the map. 2. Logic: Nexus systems update <code>Position</code> and <code>Rotation</code> in contiguous unmanaged memory computations. 3. Sync Phase: The <code>NexusSyncManager</code> iterates through changed entities, mapping unmanaged pointers directly to Unity's <code>Transform</code> properties.</p> <pre><code>graph TD\n    subgraph Nexus_Unmanaged_Engine\n        A[EntityID: 42] --&gt; B[Position Array]\n        A --&gt; C[Rotation Array]\n    end\n\n    subgraph Unity_Managed_World\n        E[GameObject Transform]\n    end\n\n    B -.-&gt;|Bitwise Delta Trigger| D{NexusSyncManager}\n    C -.-&gt;|Bitwise Delta Trigger| D\n    D ===&gt;|Apply Transform| E\n\n    style A fill:#44ff44\n    style E fill:#4444ff,color:#fff</code></pre>"},{"location":"Core_Modules/Bridge/#2-the-dirty-sync-optimization","title":"2. The \"Dirty Sync\" Optimization","text":"<p>Synchronizing 100,000 Transforms every frame is a prohibitive cost for the Unity main thread. Nexus utilizes a Selective Dirty Sync protocol to eliminate redundant property accesses.</p>"},{"location":"Core_Modules/Bridge/#21-protocol-logic-bitwise-delta","title":"2.1 Protocol Logic: Bitwise Delta","text":"<p>Each Nexus component set maintains a \"Dirty Buffer\" (a bitmask of elements modified in the current frame).</p> <p>Sync Algorithm Formulation: $\\(SyncSet = \\{E \\ | \\ Bitset_{Position}[E] \\lor Bitset_{Rotation}[E]\\}\\)$</p> <p>By only processing entities in the <code>SyncSet</code>, the Bridge reduces the update overhead by over \\(90\\%\\) in typical scenarios where most world objects are static.</p> <p>Performance Impact: If \\(N_{Total} = 100,000\\) and \\(N_{Dirty} = 5,000\\): $\\(C_{Standard} = O(N_{Total}) \\Rightarrow \\text{100,000 Transform API calls (Heavy Stutter)}\\)$ $\\(C_{Nexus} = O(N_{Dirty}) \\Rightarrow \\text{5,000 Transform API calls (Smooth 60 FPS)}\\)$</p>"},{"location":"Core_Modules/Bridge/#3-implementation-the-sync-loop","title":"3. Implementation: The Sync Loop","text":"<p>Code Implementation: <pre><code>public static void Sync(Registry registry) {\n    // 1. Get the bitset of changed components\n    var changedMask = registry.GetDirtyMask&lt;TransformTag&gt;();\n\n    // 2. Iterate using SIMD-accelerated blocks\n    foreach (var entity in changedMask.Entities) {\n        if (NexusObjectMapping.TryGet(entity.Index, out GameObject go)) {\n            // Direct memory to property bridge\n            Position* p = registry.Get&lt;Position&gt;(entity);\n            go.transform.position = p-&gt;Value;\n        }\n    }\n}\n</code></pre></p>"},{"location":"Core_Modules/Bridge/#4-usage-scenario-massive-crowd-rendering","title":"4. Usage Scenario: Massive Crowd Rendering","text":"<p>In a scenario with 10,000 units, only 500 might be moving at any given time. The Dirty Sync ensures that Unity only receives 500 <code>transform.position</code> calls, while the other 9,500 units remain resting in unmanaged memory with absolute zero-cost overhead to the managed world.</p>"},{"location":"Core_Modules/Bridge/#5-conclusion","title":"5. Conclusion","text":"<p>The Nexus Bridge Protocol minimizes the bridging cost by marrying the high-performance unmanaged engine with Unity's visual power. Developers manage thousands of objects in the unmanaged layer while paying only the cost for the precise visual changes rendered in Unity.</p>"},{"location":"Core_Modules/Bridge/#_1","title":"Bridge","text":""},{"location":"Core_Modules/Bridge/#derinlemesine-inceleme-nexus-unity-kopru-protokolu","title":"Derinlemesine \u0130nceleme: Nexus-Unity K\u00f6pr\u00fc Protokol\u00fc","text":""},{"location":"Core_Modules/Bridge/#ozet","title":"\u00d6zet","text":"<p>Bu makale, Nexus Y\u00f6netilmeyen Motoru (Unmanaged Engine) ile Unity Y\u00f6netilen D\u00fcnyas\u0131 (Managed World) aras\u0131ndaki y\u00fcksek h\u0131zl\u0131 senkronizasyon katman\u0131 olan Nexus K\u00f6pr\u00fc Protokol\u00fc'n\u00fc detayland\u0131rmaktad\u0131r. Do\u011frudan Bellek E\u015fleme mimarisini, Dirty-Sync Jenerat\u00f6rlerini ve s\u0131f\u0131r GC bask\u0131s\u0131 ile durum tutarl\u0131l\u0131\u011f\u0131n\u0131 koruma protokol\u00fcn\u00fc inceliyoruz.</p>"},{"location":"Core_Modules/Bridge/#1-senkronizasyon-protokolu-iki-dunyann-birlesimi","title":"1. Senkronizasyon Protokol\u00fc: \u0130ki D\u00fcnyan\u0131n Birle\u015fimi","text":"<p>Y\u00f6netilen bir motorda herhangi bir y\u00fcksek performansl\u0131 ECS'nin zorlu\u011fu \"S\u0131ralama (Marshalling) U\u00e7urumu\"dur. Nexus, Unity GameObject'lerini unmanaged d\u00fcnyadaki \"Ger\u00e7ek Veri\"nin (Data Truth) sadece birer G\u00f6rsel G\u00f6r\u00fcn\u00fcm\u00fc (Visual View) olarak ele alarak bu sorunu \u00e7\u00f6zer.</p>"},{"location":"Core_Modules/Bridge/#11-dogrudan-bellek-esleme-mimarisi","title":"1.1 Do\u011frudan Bellek E\u015fleme Mimarisi","text":"<p>Nexus, bir <code>EntityId</code> (E\u015fsiz ID) ile bir <code>GameObject</code> referans\u0131 aras\u0131nda 1'e 1 ba\u011f olu\u015fturan statik bir <code>NexusObjectMapping</code> tablosu kullan\u0131r.</p> <p>Veri Aktar\u0131m Protokol\u00fc (\u0130\u015f Ak\u0131\u015f\u0131): 1. Olu\u015fturma: Nexus taraf\u0131nda bir varl\u0131k olu\u015fturulur ve Unity taraf\u0131nda bir GameObject ile e\u015fle\u015fen bir <code>EntityId</code> atan\u0131r. 2. Mant\u0131k: Nexus sistemleri, <code>Position</code> ve <code>Rotation</code> bile\u015fenlerini biti\u015fik unmanaged tamponlarda g\u00fcnceller. 3. Senk Evresi: <code>NexusSyncManager</code>, sadece de\u011fi\u015fen verileri (Dirty bits) se\u00e7ip do\u011frudan Unity Transform'lar\u0131na yama yapar.</p> <pre><code>graph TD\n    subgraph Nexus_Unmanaged_Engine\n        A[EntityID: 42] --&gt; B[Pozisyon Dizisi]\n        A --&gt; C[Rotasyon Dizisi]\n    end\n\n    subgraph Unity_Managed_World\n        E[GameObject Transform]\n    end\n\n    B -.-&gt;|Bitbazli Delta Tetikleyici| D{NexusSyncManager}\n    C -.-&gt;|Bitbazli Delta Tetikleyici| D\n    D ===&gt;|Transform Uygula| E\n\n    style A fill:#44ff44\n    style E fill:#4444ff,color:#fff</code></pre>"},{"location":"Core_Modules/Bridge/#2-dirty-sync-optimizasyonu","title":"2. \"Dirty Sync\" Optimizasyonu","text":"<p>100.000 objenin her karede senkronize edilmesi Unity ana i\u015f par\u00e7ac\u0131\u011f\u0131 (Main Thread) i\u00e7in a\u011f\u0131r bir y\u00fckt\u00fcr. Nexus, gereksiz \u00f6zellik okumalar\u0131n\u0131 engellemek i\u00e7in sadece de\u011fi\u015fen (dirty) bile\u015fenleri i\u015fleyen se\u00e7ici bir protokol kullan\u0131r.</p>"},{"location":"Core_Modules/Bridge/#21-protokol-mantg-bitbazl-delta","title":"2.1 Protokol Mant\u0131\u011f\u0131: Bitbazl\u0131 Delta","text":"<p>Her Nexus bile\u015fen seti, ge\u00e7erli karede de\u011fi\u015ftirilen \u00f6\u011felerin bir bit maskesini (\"Dirty Buffer\") tutar.</p> <p>Senkronizasyon Algoritmas\u0131 Form\u00fclasyonu: $\\(SyncSet = \\{E \\ | \\ Bitset_{Pozisyon}[E] \\lor Bitset_{Rotasyon}[E]\\}\\)$</p> <p>Bridge, sadece <code>SyncSet</code> i\u00e7indeki varl\u0131klar\u0131 i\u015fleyerek, d\u00fcnya nesnelerinin \u00e7o\u011funun statik oldu\u011fu tipik senaryolarda g\u00fcncelleme y\u00fck\u00fcn\u00fc \\(\\%90\\)'dan fazla azalt\u0131r.</p> <p>Performans Etkisi: E\u011fer \\(N_{Toplam} = 100,000\\) ve \\(N_{Degisen} = 5,000\\) ise: $\\(C_{Standart} = O(N_{Toplam}) \\Rightarrow \\text{100,000 Transform API \u00e7a\u011fr\u0131s\u0131 (A\u011f\u0131r Tak\u0131lma)}\\)$ $\\(C_{Nexus} = O(N_{Degisen}) \\Rightarrow \\text{5,000 Transform API \u00e7a\u011fr\u0131s\u0131 (P\u00fcr\u00fczs\u00fcz 60 FPS)}\\)$</p>"},{"location":"Core_Modules/Bridge/#3-uygulama-senkronizasyon-dongusu","title":"3. Uygulama: Senkronizasyon D\u00f6ng\u00fcs\u00fc","text":"<p>Kod Uygulamas\u0131: <pre><code>public static void Sync(Registry registry) {\n    // 1. De\u011fi\u015fen bile\u015fenlerin bit maskesini al\n    var changedMask = registry.GetDirtyMask&lt;TransformTag&gt;();\n\n    // 2. SIMD h\u0131zland\u0131rmal\u0131 bloklar kullanarak itere et\n    foreach (var entity in changedMask.Entities) {\n        if (NexusObjectMapping.TryGet(entity.Index, out GameObject go)) {\n            // Do\u011frudan bellekten \u00f6zellik k\u00f6pr\u00fcs\u00fcne\n            Position* p = registry.Get&lt;Position&gt;(entity);\n            go.transform.position = p-&gt;Value;\n        }\n    }\n}\n</code></pre></p>"},{"location":"Core_Modules/Bridge/#4-kullanm-senaryosu-dev-muazzam-kalabalk-renderlama","title":"4. Kullan\u0131m Senaryosu: Dev Muazzam Kalabal\u0131k Renderlama","text":"<p>10.000 birimlik bir senaryoda, herhangi bir zamanda sadece 500'\u00fc hareket ediyor olabilir. Dirty Sync, Unity'nin sadece 500 <code>transform.position</code> \u00e7a\u011fr\u0131s\u0131 almas\u0131n\u0131 sa\u011flarken, di\u011fer 9.500 birim y\u00f6netilen d\u00fcnya i\u00e7in mutlak s\u0131f\u0131r maliyetle y\u00f6netilmeyen bellekte istirahat eder.</p>"},{"location":"Core_Modules/Bridge/#5-sonuc","title":"5. Sonu\u00e7","text":"<p>Nexus K\u00f6pr\u00fc Protokol\u00fc, y\u00fcksek performansl\u0131 unmanaged d\u00fcnyay\u0131 Unity'nin g\u00f6rsel g\u00fcc\u00fcyle birle\u015ftirirken, aradaki aktar\u0131m maliyetini minimize eder. Geli\u015ftiriciler binlerce objeyi unmanaged olarak y\u00f6netirken, Unity taraf\u0131nda sadece g\u00f6rsel de\u011fi\u015fimlerin maliyetini \u00f6derler.</p>"},{"location":"Core_Modules/Buffer/","title":"Core Deep-Dive: The ChunkedBuffer &amp; Memory Paging","text":""},{"location":"Core_Modules/Buffer/#abstract","title":"Abstract","text":"<p>This paper details the Nexus ChunkedBuffer, the low-level unmanaged storage infrastructure that powers the Registry. We explore the implementation of Pointer Stability, formalizing the paging efficiency through 16KB segmented allocation and the impact of hardware-centric alignment on data throughput.</p>"},{"location":"Core_Modules/Buffer/#1-the-chunked-architecture","title":"1. The Chunked Architecture","text":""},{"location":"Core_Modules/Buffer/#11-pointer-stability-addressing","title":"1.1 Pointer Stability &amp; Addressing","text":"<p>In a traditional contiguous array, resizing invalidates all pointers (\\(P \\rightarrow \\emptyset\\)) as memory is re-allocated and copied to a larger region. Nexus solves this via a segmented table approach. </p> <p>Addressing Formula: For any element index \\(i\\), its memory location is resolved as: $\\(Page_{idx} = \\lfloor i / ElementsPerPage \\rfloor\\)$ $\\(Offset = i \\pmod{ElementsPerPage}\\)$ $\\(Ptr = Pages[Page_{idx}] + (Offset \\times sizeof(T))\\)$</p> <p>Since the <code>Pages</code> table stores pointers to fixed 16KB blocks that are never moved, every pointer to an element is Stable for the lifetime of the buffer.</p> <pre><code>graph LR\n    subgraph Conceptual_Chunked_Addressing\n        A[Element Index: 3042] --&gt;|Division| B[Page Index: 0]\n        A --&gt;|Modulo| C[Offset: 3042]\n\n        B --&gt; D[Page 0: 16KB Block]\n        C -.-&gt; |Address Math| E[Target Component Pointer]\n        D --&gt;|Base + Offset| E\n    end</code></pre>"},{"location":"Core_Modules/Buffer/#2-hardware-symbiosis-paging-tlb","title":"2. Hardware Symbiosis: Paging &amp; TLB","text":""},{"location":"Core_Modules/Buffer/#21-16kb-page-efficiency","title":"2.1 16KB Page Efficiency","text":"<p>Nexus utilizes 16KB chunks (4 typical OS pages). This layout is optimized for the Translation Lookaside Buffer (TLB).</p> <p>TLB Miss Mitigation: The number of TLB lookups \\(L\\) required to scan \\(N\\) elements is: $\\(L = \\lceil (N \\times sizeof(T)) / 16384 \\rceil\\)$</p> <p>By using larger, aligned blocks, Nexus reduces TLB pressure by \\(4\\times\\) compared to standard 4KB paging, minimizing the high-latency cost of page table walks in the CPU architecture.</p>"},{"location":"Core_Modules/Buffer/#22-64-byte-cache-line-alignment","title":"2.2 64-Byte Cache-Line Alignment","text":"<p>To avoid Cache-Line Splits, every chunk and element start is strictly aligned. - Constraint: \\(Address \\pmod{64} \\equiv 0\\). - Impact: Ensures that a single CPU read operation always fetches a complete component entry without triggering redundant bus cycles.</p>"},{"location":"Core_Modules/Buffer/#3-implementation-paged-access","title":"3. Implementation: Paged Access","text":"<p>Code Implementation: <pre><code>public unsafe class ChunkedBuffer&lt;T&gt; where T : unmanaged {\n    private void** _chunks; // Page table\n    private const int PageSize = 16384;\n    private int _elementsPerPage;\n    private int _sizeofT;\n\n    public T* Get(int index) {\n        int pageIndex = index / _elementsPerPage;\n        int offset = index % _elementsPerPage;\n\n        // Base address + 64 byte padding safety + physical offset calculation\n        return (T*)((byte*)_chunks[pageIndex] + 64 + (offset * _sizeofT));\n    }\n}\n</code></pre></p>"},{"location":"Core_Modules/Buffer/#4-conclusion","title":"4. Conclusion","text":"<p>The ChunkedBuffer ensures that the software operates \"invisibly\" aligned with the hardware layout constraints. With robust page alignments and pointer stability, Nexus transforms array resizing from a catastrophic memory bottleneck into a frictionless scaling mechanic.</p>"},{"location":"Core_Modules/Buffer/#_1","title":"Buffer","text":""},{"location":"Core_Modules/Buffer/#derinlemesine-inceleme-chunkedbuffer-ve-bellek-sayfalamas","title":"Derinlemesine \u0130nceleme: ChunkedBuffer ve Bellek Sayfalamas\u0131","text":""},{"location":"Core_Modules/Buffer/#ozet","title":"\u00d6zet","text":"<p>Bu makale, Registry'yi g\u00fc\u00e7lendiren d\u00fc\u015f\u00fck seviyeli y\u00f6netilmeyen depolama altyap\u0131s\u0131 olan Nexus ChunkedBuffer'\u0131 detayland\u0131rmaktad\u0131r. Pointer Stabilitesi uygulamas\u0131n\u0131, 16KB par\u00e7al\u0131 tahsisat yoluyla sayfalama verimlili\u011fini ve donan\u0131m odakl\u0131 hizalaman\u0131n veri ak\u0131\u015f h\u0131z\u0131 \u00fczerindeki etkisini form\u00fclize ediyoruz.</p>"},{"location":"Core_Modules/Buffer/#1-chunked-mimarisi","title":"1. Chunked Mimarisi","text":""},{"location":"Core_Modules/Buffer/#11-pointer-stabilitesi-ve-adresleme","title":"1.1 Pointer Stabilitesi ve Adresleme","text":"<p>Geleneksel bir biti\u015fik dizide (contiguous array), bellek yeniden tahsis edilip (re-allocation) daha b\u00fcy\u00fck bir alana kopyaland\u0131\u011f\u0131 i\u00e7in yeniden boyutland\u0131rma i\u015flemi t\u00fcm i\u015faret\u00e7ileri (pointers) ge\u00e7ersiz k\u0131lar (\\(P \\rightarrow \\emptyset\\)). Nexus, bunu par\u00e7al\u0131 tablo yakla\u015f\u0131m\u0131yla \u00e7\u00f6zer.</p> <p>Adresleme Form\u00fcl\u00fc: Herhangi bir \\(i\\) indeksi i\u00e7in bellek konumu \u015fu \u015fekilde \u00e7\u00f6z\u00fcl\u00fcr: $\\(Sayfa_{idx} = \\lfloor i / SayfaBasinaEleman \\rfloor\\)$ $\\(Ofset = i \\pmod{SayfaBasinaEleman}\\)$ $\\(\u0130\u015faret\u00e7i = Sayfalar[Sayfa_{idx}] + (Ofset \\times sizeof(T))\\)$</p> <p><code>Pages</code> tablosu asla ta\u015f\u0131nmayan sabit 16KB'l\u0131k bloklara i\u015faret\u00e7iler saklad\u0131\u011f\u0131ndan, bir elemana olan her i\u015faret\u00e7i tamponun \u00f6mr\u00fc boyunca stabildir.</p> <pre><code>graph LR\n    subgraph Kavramsal_Parcali_Adresleme\n        A[Eleman \u0130ndeksi: 3042] --&gt;|B\u00f6lme| B[Sayfa \u0130ndeksi: 0]\n        A --&gt;|Mod Alma| C[Ofset: 3042]\n\n        B --&gt; D[Sayfa 0: 16KB'lik Blok]\n        C -.-&gt; |Adres Matematigi| E[Hedef Bilesen Isaretcisi]\n        D --&gt;|Taban + Ofset| E\n    end</code></pre>"},{"location":"Core_Modules/Buffer/#2-donanm-simbiyozu-sayfalama-ve-tlb","title":"2. Donan\u0131m Simbiyozu: Sayfalama ve TLB","text":""},{"location":"Core_Modules/Buffer/#21-16kb-sayfa-verimliligi","title":"2.1 16KB Sayfa Verimlili\u011fi","text":"<p>Nexus, 16KB'l\u0131k chunk'lar (4 standart OS sayfas\u0131) kullan\u0131r. Bu d\u00fczen, Translation Lookaside Buffer (TLB) i\u00e7in optimize edilmi\u015ftir.</p> <p>TLB Ka\u00e7\u0131rma (Miss) Azaltma: \\(N\\) say\u0131da eleman\u0131 taramak i\u00e7in gereken TLB aramas\u0131 \\(L\\): $\\(L = \\lceil (N \\times sizeof(T)) / 16384 \\rceil\\)$</p> <p>B\u00fcy\u00fck ve hizal\u0131 bloklar kullanarak Nexus, standart 4KB sayfalamaya k\u0131yasla TLB bask\u0131s\u0131n\u0131 \\(4\\) kat azalt\u0131r ve CPU mimarisindeki sayfa tablosu taramalar\u0131n\u0131n y\u00fcksek gecikme maliyetini en aza indirir.</p>"},{"location":"Core_Modules/Buffer/#22-64-byte-onbellek-satr-hizalamas","title":"2.2 64-Byte \u00d6nbellek Sat\u0131r\u0131 Hizalamas\u0131","text":"<p>\u00d6nbellek Sat\u0131r\u0131 B\u00f6l\u00fcnmelerini (Cache-Line Splits) \u00f6nlemek i\u00e7in her chunk ve eleman ba\u015flang\u0131c\u0131 kesin olarak hizalan\u0131r. - K\u0131s\u0131t: \\(Adres \\pmod{64} \\equiv 0\\). - Etki: Tek bir CPU okuma i\u015fleminin, gereksiz veri yolu d\u00f6ng\u00fclerini tetiklemeden her zaman tam bir bile\u015fen giri\u015fini getirmesini sa\u011flar.</p>"},{"location":"Core_Modules/Buffer/#3-uygulama-sayfal-erisim","title":"3. Uygulama: Sayfal\u0131 Eri\u015fim","text":"<p>Kod Uygulamas\u0131: <pre><code>public unsafe class ChunkedBuffer&lt;T&gt; where T : unmanaged {\n    private void** _chunks; // Sayfa tablosu\n    private const int PageSize = 16384;\n    private int _elementsPerPage;\n    private int _sizeofT;\n\n    public T* Get(int index) {\n        int pageIndex = index / _elementsPerPage;\n        int offset = index % _elementsPerPage;\n\n        // Taban adresi + 64 byte padding guvenligi + fiziksel ofset hesaplamasi\n        return (T*)((byte*)_chunks[pageIndex] + 64 + (offset * _sizeofT));\n    }\n}\n</code></pre></p>"},{"location":"Core_Modules/Buffer/#4-sonuc","title":"4. Sonu\u00e7","text":"<p>ChunkedBuffer, yaz\u0131l\u0131m\u0131n donan\u0131m yerle\u015fim k\u0131s\u0131tlamalar\u0131yla \"g\u00f6r\u00fcnmez\" bir \u015fekilde uyum i\u00e7inde \u00e7al\u0131\u015fmas\u0131n\u0131 sa\u011flar. G\u00fc\u00e7l\u00fc sayfa hizalamalar\u0131 ve pointer stabilitesi ile Nexus, dizi yeniden boyutland\u0131rma i\u015flemini felaketvari bir bellek darbo\u011faz\u0131 olmaktan \u00e7\u0131kar\u0131p s\u00fcrt\u00fcnmesiz bir \u00f6l\u00e7eklenme mekani\u011fine d\u00f6n\u00fc\u015ft\u00fcr\u00fcr.</p>"},{"location":"Core_Modules/Generator/","title":"Core Deep-Dive: Automation via Roslyn Source Generators","text":""},{"location":"Core_Modules/Generator/#abstract","title":"Abstract","text":"<p>This paper analyzes the Nexus Generator Architecture, a system designed to eliminate human error and boilerplate in high-performance ECS systems. We formalize the Boilerplate Reduction Factor and analyze the efficiency of Incremental Source Generation in bridging the gap between high-level logic and low-level hardware-optimized execution.</p>"},{"location":"Core_Modules/Generator/#1-the-productivity-equation-boilerplate-destruction","title":"1. The Productivity Equation: Boilerplate Destruction","text":"<p>The primary goal of the Nexus Generator is to maximize developer velocity without sacrificing the \\(O(1)\\) performance of the underlying unmanaged structures. In a manual unmanaged ECS, the developer must handle memory alignment, pointer arithmetic, and dependency resolution.</p>"},{"location":"Core_Modules/Generator/#11-manual-vs-generated-comparison","title":"1.1 Manual vs. Generated Comparison","text":"<p>To illustrate the reduction in technical debt, consider a simple system that updates entity positions based on velocity.</p>"},{"location":"Core_Modules/Generator/#bad-manual-implementation-hardcoded-high-error","title":"[BAD] Manual Implementation (Hardcoded / High-Error)","text":"<p><pre><code>public unsafe void RunManual(Registry registry) {\n    var posSet = registry.GetSet&lt;Position&gt;();\n    var velSet = registry.GetSet&lt;Velocity&gt;();\n\n    // Manual pointer arithmetic and loop orchestration\n    for (int i = 0; i &lt; posSet.Count; i++) {\n        EntityId id = posSet.GetEntity(i);\n        if (velSet.Has(id)) {\n            Position* p = posSet.Get(id);\n            Velocity* v = velSet.Get(id);\n            p-&gt;Value += v-&gt;Value * dt;\n        }\n    }\n}\n</code></pre> Issues: Each <code>if(velSet.Has(id))</code> causes a branch misprediction. Manual indexing is prone to \"Off-by-one\" errors.</p>"},{"location":"Core_Modules/Generator/#good-nexus-generated-approach-clean-optimized","title":"[GOOD] Nexus Generated Approach (Clean / Optimized)","text":"<p><pre><code>public partial class MoveSystem : INexusSystem {\n    [Read] Velocity velocity;\n    [Write] Position position;\n\n    public unsafe void Execute(EntityId entity, Position* p, Velocity* v) {\n        p-&gt;Value += v-&gt;Value * dt;\n    }\n}\n</code></pre> Observation: The developer only writes the Payload Logic. The generator produces a <code>Run()</code> method that resolves pointers via AVX-optimized batches, ensuring zero branch penalties.</p> <p>Boilerplate Reduction Math: Let \\(L_{Logic}\\) be the lines of core payload logic, and \\(L_{Plumbing}\\) be the lines of memory orchestration. With manual implementations, \\(L_{Total} = L_{Logic} + L_{Plumbing}\\), often making \\(L_{Plumbing} \\approx 4 \\times L_{Logic}\\). With Nexus Generators, \\(L_{Total} \\approx L_{Logic}\\). Productivity \\(P\\) increases linearly as the boilerplate drops to \\(\\approx 0\\%\\).</p> <pre><code>graph LR\n    subgraph Developer_Inputs\n        A[High Level Logic] --&gt; B[Nexus Source Generator]\n    end\n\n    subgraph Generated_Outputs\n        B --&gt; C[SIMD Vectorization Loops]\n        B --&gt; D[Pointer Arithmetic Maps]\n        B --&gt; E[Job System Parallelization]\n        B --&gt; F[Cache-Aligned Memory Offsets]\n    end\n\n    style B fill:#3399ff,color:#fff</code></pre>"},{"location":"Core_Modules/Generator/#2-incremental-generation-mechanics","title":"2. Incremental Generation Mechanics","text":"<p>Nexus utilizes the Roslyn Incremental Generator API to ensure that background compilation remains fluid even with millions of entities.</p>"},{"location":"Core_Modules/Generator/#21-the-incremental-pipeline","title":"2.1 The Incremental Pipeline","text":"<p>The generator avoids full re-scans by using a stateful pipeline: 1. Source Tracking: Only re-generates code if the specific <code>partial class</code> or its component dependencies change. 2. IL-Style Emission: Specifically emits linear code blocks that trigger the JIT's most aggressive optimization pass (Tier 2 Optimization).</p>"},{"location":"Core_Modules/Generator/#3-usage-scenario-massive-scale-physics","title":"3. Usage Scenario: Massive Scale Physics","text":"<p>When scaling to \\(1,000,000\\) entities, the \"Boilerplate\" becomes a bottleneck for the compiler and the CPU. Nexus Generators produce a \"Hot-Path\" loop that uses 64-byte aligned pointers, allowing the CPU's pre-fetcher to saturate the memory bus. A hand-written approach would be practically unmaintainable to update across 50 different hardware-aligned systems.</p>"},{"location":"Core_Modules/Generator/#4-conclusion","title":"4. Conclusion","text":"<p>Nexus Generators prove that high-performance programming does not have to be a manual labor. By automating the hardware-specific layers, Nexus provides a \"Safety-First\" environment for \"Performance-First\" development.</p>"},{"location":"Core_Modules/Generator/#_1","title":"Generator","text":""},{"location":"Core_Modules/Generator/#derinlemesine-inceleme-roslyn-kaynak-ureticileri-ile-otomasyon","title":"Derinlemesine \u0130nceleme: Roslyn Kaynak \u00dcreticileri ile Otomasyon","text":""},{"location":"Core_Modules/Generator/#ozet","title":"\u00d6zet","text":"<p>Bu makale, y\u00fcksek performansl\u0131 ECS sistemlerindeki boilerplate kod y\u00fck\u00fcn\u00fc ortadan kald\u0131rmak i\u00e7in tasarlanm\u0131\u015f Nexus Generator Mimarisini incelemektedir. Boilerplate Azaltma Fakt\u00f6r\u00fc'n\u00fc form\u00fclize ediyor ve \u00fcst d\u00fczey mant\u0131k ile d\u00fc\u015f\u00fck seviyeli donan\u0131m optimizasyonlu y\u00fcr\u00fctme aras\u0131ndaki bo\u015flu\u011fu dolduran Art\u0131ml\u0131 Kaynak \u00dcretimi (Incremental Source Generation) verimlili\u011fini analiz ediyoruz.</p>"},{"location":"Core_Modules/Generator/#1-boilerplate-kendini-tekrar-eden-kod-yok-etme-sureci","title":"1. Boilerplate (Kendini Tekrar Eden Kod) Yok Etme S\u00fcreci","text":"<p>Nexus Jenerat\u00f6r\u00fc'n\u00fcn as\u0131l amac\u0131, temel \u00f6zellikleri kaybetmeden ve y\u00f6netilmeyen yap\u0131lar\u0131n \\(O(1)\\) performans\u0131ndan \u00f6d\u00fcn vermeden geli\u015ftirici h\u0131z\u0131n\u0131 maksimize etmektir. Geleneksel bir unmanaged d\u00f6ng\u00fcde geli\u015ftirici; bellek hizalamas\u0131, pointer aritmeti\u011fi ve bile\u015fen kontrol\u00fc (Has check) gibi konularla manuel ilgilenmelidir.</p>"},{"location":"Core_Modules/Generator/#11-manuel-ve-jenerator-karslastrmas","title":"1.1 Manuel ve Jenerat\u00f6r Kar\u015f\u0131la\u015ft\u0131rmas\u0131","text":"<p>Teknik borcun nas\u0131l azald\u0131\u011f\u0131n\u0131 g\u00f6stermek i\u00e7in h\u0131z (velocity) bile\u015fenini konum (position) bile\u015fenine ekleyen basit bir sistem d\u00fc\u015f\u00fcnelim.</p>"},{"location":"Core_Modules/Generator/#kotu-manuel-uygulama-sabit-kodlu-yuksek-hatal","title":"[K\u00d6T\u00dc] Manuel Uygulama (Sabit Kodlu / Y\u00fcksek Hatal\u0131)","text":"<p><pre><code>public unsafe void RunManual(Registry registry) {\n    var posSet = registry.GetSet&lt;Position&gt;();\n    var velSet = registry.GetSet&lt;Velocity&gt;();\n\n    // Manuel pointer aritmetigi ve dongu\n    for (int i = 0; i &lt; posSet.Count; i++) {\n        EntityId id = posSet.GetEntity(i);\n        if (velSet.Has(id)) {\n            Position* p = posSet.Get(id);\n            Velocity* v = velSet.Get(id);\n            p-&gt;Value += v-&gt;Value * dt;\n        }\n    }\n}\n</code></pre> Sorunlar: Her bir <code>if(velSet.Has(id))</code> \u00e7a\u011fr\u0131s\u0131 \"branch misprediction\" (dallanma tahmini hatas\u0131) riski yarat\u0131r. Indexleme d\u0131\u015f hatalara (\"Off-by-one\") a\u00e7\u0131kt\u0131r.</p>"},{"location":"Core_Modules/Generator/#iyi-nexus-jenerator-yaklasm-temiz-optimize","title":"[\u0130Y\u0130] Nexus Jenerat\u00f6r Yakla\u015f\u0131m\u0131 (Temiz / Optimize)","text":"<p><pre><code>public partial class MoveSystem : INexusSystem {\n    [Read] Velocity velocity;\n    [Write] Position position;\n\n    public unsafe void Execute(EntityId entity, Position* p, Velocity* v) {\n        p-&gt;Value += v-&gt;Value * dt;\n    }\n}\n</code></pre> G\u00f6zlem: Geli\u015ftirici SADECE Temel Mant\u0131\u011f\u0131 (Payload Logic) yazar. Jenerat\u00f6r, arka planda dallanma cezas\u0131 (branch penalty) olmaks\u0131z\u0131n pointer'lar\u0131 AVX ile \u00e7\u00f6zen devasa bir <code>Run()</code> fonksiyonu \u00fcretir.</p> <p>Boilerplate Azaltma Matemati\u011fi: Temel mant\u0131k sat\u0131rlar\u0131na \\(L_{Mantik}\\) ve geri kalan tesisat/hizalama sat\u0131rlar\u0131na \\(L_{Tesisat}\\) diyelim. Manuel bir uygulamada \\(L_{Toplam} = L_{Mantik} + L_{Tesisat}\\)'d\u0131r. \u00c7o\u011fu zaman \\(L_{Tesisat} \\approx 4 \\times L_{Mantik}\\). Nexus Jenerat\u00f6rleriyle \\(L_{Toplam} \\approx L_{Mantik}\\) olur. Verimlilik \\(P\\), boilerplate miktar\u0131 \\(\\approx \\%0\\)'a d\u00fc\u015ft\u00fc\u011f\u00fcnde do\u011frusal olarak artar.</p> <pre><code>graph LR\n    subgraph Gelistirici_Girdileri\n        A[Yuksek Seviyeli Mantik] --&gt; B[Nexus Kaynak Ureticisi]\n    end\n\n    subgraph Uretilen_Ciktilar\n        B --&gt; C[SIMD Vektorizasyon Donguleri]\n        B --&gt; D[Isaretci Aritmetigi Haritalari]\n        B --&gt; E[Is Parcacigi Paralellestirmesi]\n        B --&gt; F[Onbellek-Hizali Bellek Ofsetleri]\n    end\n\n    style B fill:#3399ff,color:#fff</code></pre>"},{"location":"Core_Modules/Generator/#2-artml-uretim-mekanikleri-incremental-generation","title":"2. Art\u0131ml\u0131 \u00dcretim Mekanikleri (Incremental Generation)","text":"<p>Nexus, milyonlarca varl\u0131k olsa bile arka plan derlemesinin ak\u0131c\u0131 kalmas\u0131n\u0131 sa\u011flamak i\u00e7in Roslyn Incremental Generator API'sini kullan\u0131r.</p>"},{"location":"Core_Modules/Generator/#21-ileri-seviye-uretim-hatt","title":"2.1 \u0130leri Seviye \u00dcretim Hatt\u0131","text":"<p>Jenerat\u00f6r, \u015fu ad\u0131mlarla tam yeniden taramalardan ka\u00e7\u0131n\u0131r: 1. Kaynak Takibi: Sadece belirli bir <code>partial class</code> veya ba\u011f\u0131ml\u0131 oldu\u011fu bile\u015fenler de\u011fi\u015fti\u011finde kodu yeniden \u00fcretir. 2. IL-Style Emisyonu: JIT'in en agresif optimizasyon katman\u0131n\u0131 (Tier 2) tetikleyen do\u011frusal kod bloklar\u0131 yayar.</p>"},{"location":"Core_Modules/Generator/#3-kullanm-senaryosu-dev-olcekli-fizik","title":"3. Kullan\u0131m Senaryosu: Dev \u00d6l\u00e7ekli Fizik","text":"<p>1.000.000 varl\u0131\u011fa \u00f6l\u00e7eklendi\u011finde, \"Boilerplate\" hem derleyici hem de CPU i\u00e7in bir darbo\u011faz haline gelir. Nexus Jenerat\u00f6rleri, CPU'nun \u00f6n haz\u0131rlay\u0131c\u0131s\u0131n\u0131n (pre-fetcher) bellek veri yolunu tam kapasiteyle kullanmas\u0131n\u0131 sa\u011flayan 64-byte hizal\u0131 pointer d\u00f6ng\u00fcleri \u00fcretir. Elde yaz\u0131lm\u0131\u015f bir kod ile 50 ayr\u0131 sistemi donan\u0131m uyumlu tutmak pratikte imkans\u0131zd\u0131r.</p>"},{"location":"Core_Modules/Generator/#4-sonuc","title":"4. Sonu\u00e7","text":"<p>Nexus Jenerat\u00f6rleri, y\u00fcksek performansl\u0131 programlaman\u0131n manuel bir i\u015f\u00e7ilik olmak zorunda olmad\u0131\u011f\u0131n\u0131 kan\u0131tlar. Donan\u0131ma \u00f6zg\u00fc katmanlar\u0131 otomatikle\u015ftirerek Nexus, \"Performans \u00d6ncelikli\" geli\u015ftirme i\u00e7in \"G\u00fcvenlik \u00d6ncelikli\" bir yakla\u015f\u0131m sunar.</p>"},{"location":"Core_Modules/JobSystem/","title":"Core Deep-Dive: Nexus Job System &amp; Parallel Orchestration","text":""},{"location":"Core_Modules/JobSystem/#abstract","title":"Abstract","text":"<p>This paper explores the architecture of the Nexus Job System, a dependency-aware parallel execution engine. We analyze the transformation of logical system hierarchies into Directed Acyclic Graphs (DAGs) and the subsequent scheduling of these graphs into discrete execution layers. By utilizing specialized variants of Kahn's Algorithm, Nexus achieves maximum multi-core utilization while guaranteeing data safety through strict read/write conflict resolution.</p>"},{"location":"Core_Modules/JobSystem/#1-the-dependency-model-static-analysis","title":"1. The Dependency Model (Static Analysis)","text":""},{"location":"Core_Modules/JobSystem/#11-readwrite-conflict-matrix","title":"1.1 Read/Write Conflict Matrix","text":"<p>The Job System ensures data integrity by analyzing the access patterns of each system. Two systems, \\(S_A\\) and \\(S_B\\), are considered in conflict if they share a component type \\(T\\) such that at least one system performs a Write operation.</p> <p>The Dependency Rule: - Read-Read: No conflict. Concurrent execution allowed. - Read-Write: Conflict. Sequential execution required. - Write-Write: Conflict. Sequential execution required.</p>"},{"location":"Core_Modules/JobSystem/#12-the-dag-transformation","title":"1.2 The DAG Transformation","text":"<p>Each registered system is treated as a node \\(N\\) in a graph \\(G = (V, E)\\). An edge \\((U, V)\\) exists if system \\(U\\) must complete before system \\(V\\) starts due to component access conflicts.</p> <pre><code>graph TD\n    subgraph Execution_Layers\n        A[InputSystem: Write Velocity] --&gt;|Conflict| B[PhysicsSystem: Read Velocity, Write Pos]\n        C[AISystem: Read Pos, Write Target] --&gt;|Conflict| D[MovementSystem: Read Target, Write Vel]\n\n        B -.-&gt;|Layer 2| E[CollisionSystem: Read Pos]\n        A -.-&gt;|Layer 1| C\n    end\n\n    style A fill:#44ff44\n    style B fill:#ffaaaa\n    style C fill:#44ff44\n    style D fill:#ffaaaa\n    style E fill:#44ccff</code></pre>"},{"location":"Core_Modules/JobSystem/#2-mathematical-scheduling-kahns-algorithm-variant","title":"2. Mathematical Scheduling: Kahn's Algorithm Variant","text":"<p>Nexus Prime utilizes a layer-based scheduling approach to maximize throughput. Instead of a simple linear sort, we group nodes into layers \\(L_1, L_2, \\dots, L_n\\) where all nodes in a given layer have an In-Degree of zero relative to the remaining graph.</p>"},{"location":"Core_Modules/JobSystem/#21-layer-construction-proof","title":"2.1 Layer Construction Proof","text":"<p>The number of layers \\(n\\) represents the Critical Path Length of the simulation. The maximum parallelism at any given moment is \\(|L_i|\\).</p> <p>The Algorithm Formulation: 1. Calculate in-degrees \\(D(v)\\) for all system nodes \\(v \\in V\\). 2. While there are unprocessed nodes:    - Identify all nodes with \\(D(v) = 0\\).    - Assign these nodes to the current Layer \\(L_i\\).    - Remove these nodes from the graph and update the in-degrees \\(D(u) = D(u) - 1\\) for all dependent nodes \\(u\\).</p>"},{"location":"Core_Modules/JobSystem/#22-speedup-and-amdahls-law","title":"2.2 Speedup and Amdahl's Law","text":"<p>The theoretical speedup \\(S\\) of the Nexus Job System is bounded by the ratio of sequential work vs. parallelizable work:</p> \\[S(p) = \\frac{1}{(1-f) + \\frac{f}{p}}\\] <p>Where \\(f\\) is the fraction of parallelizable systems (nodes in layers with size \\(&gt; 1\\)) and \\(p\\) is the number of available CPU cores.</p>"},{"location":"Core_Modules/JobSystem/#3-implementation-layer-execution","title":"3. Implementation: Layer Execution","text":"<p>The Job System executes layers in strict sequence, but within each layer, systems are dispatched to the thread pool with minimal overhead.</p> <p>Code Implementation: <pre><code>public void Execute()\n{\n    foreach (var layer in _layers) // Sequential Layers (Dependencies resolved)\n    {\n        // Parallel Systems within Layer (Zero Conflicts)\n        Parallel.ForEach(layer, node =&gt;\n        {\n            node.System.Execute();\n        });\n    }\n}\n</code></pre></p>"},{"location":"Core_Modules/JobSystem/#4-performance-metrics-temporal-tracking","title":"4. Performance Metrics: Temporal Tracking","text":"<p>The Job System tracks the execution cost of every node using high-precision stopwatches, enabling real-time bottleneck detection.</p> Metric Purpose Unit ExecutionTimeMs Individual system cost Milliseconds WaitTime Time spent waiting for previous layer Milliseconds LayerDensity Number of systems running concurrently Count"},{"location":"Core_Modules/JobSystem/#5-conclusion","title":"5. Conclusion","text":"<p>The Nexus Job System allows developers to focus simply on requesting data arrays without thinking about multithreading locks or race conditions. All the complex dependency mathematics are orchestrated by the DAG scheduler, guaranteeing performance bounds that strictly follow Amdahl's law curves.</p>"},{"location":"Core_Modules/JobSystem/#_1","title":"JobSystem","text":""},{"location":"Core_Modules/JobSystem/#derinlemesine-inceleme-nexus-is-sistemi-ve-paralel-orkestrasyon","title":"Derinlemesine \u0130nceleme: Nexus \u0130\u015f Sistemi ve Paralel Orkestrasyon","text":""},{"location":"Core_Modules/JobSystem/#ozet","title":"\u00d6zet","text":"<p>Bu makale, ba\u011f\u0131ml\u0131l\u0131k duyarl\u0131 bir paralel y\u00fcr\u00fctme motoru olan Nexus \u0130\u015f Sistemi'nin (Job System) mimarisini incelemektedir. Mant\u0131ksal sistem hiyerar\u015filerinin Y\u00f6nl\u00fc D\u00f6ng\u00fcs\u00fcz \u00c7izgelere (DAG) d\u00f6n\u00fc\u015ft\u00fcr\u00fclmesini ve bu \u00e7izgelerin ayr\u0131k y\u00fcr\u00fctme katmanlar\u0131na planlanmas\u0131n\u0131 analiz ediyoruz. Nexus, Kahn Algoritmas\u0131'n\u0131n \u00f6zel varyantlar\u0131n\u0131 kullanarak, kat\u0131 okuma/yazma \u00e7ak\u0131\u015fma \u00e7\u00f6z\u00fcm\u00fc yoluyla veri g\u00fcvenli\u011fini garanti ederken maksimum \u00e7ok \u00e7ekirdekli kullan\u0131m\u0131 ba\u015far\u0131r.</p>"},{"location":"Core_Modules/JobSystem/#1-bagmllk-modeli-statik-analiz","title":"1. Ba\u011f\u0131ml\u0131l\u0131k Modeli (Statik Analiz)","text":""},{"location":"Core_Modules/JobSystem/#11-okumayazma-caksma-matrisi","title":"1.1 Okuma/Yazma \u00c7ak\u0131\u015fma Matrisi","text":"<p>\u0130\u015f Sistemi, her sistemin eri\u015fim modellerini analiz ederek veri b\u00fct\u00fcnl\u00fc\u011f\u00fcn\u00fc sa\u011flar. \u0130ki sistem (\\(S_A\\) ve \\(S_B\\)), en az bir sistemin Yazma i\u015flemi ger\u00e7ekle\u015ftirdi\u011fi ortak bir bile\u015fen tipi \\(T\\) payla\u015f\u0131yorsa \u00e7ak\u0131\u015fma durumunda kabul edilir.</p> <p>Ba\u011f\u0131ml\u0131l\u0131k Kurallar\u0131: - Oku-Oku: \u00c7ak\u0131\u015fma yok. E\u015fzamanl\u0131 y\u00fcr\u00fctme m\u00fcmk\u00fcn. - Oku-Yaz: \u00c7ak\u0131\u015fma var. S\u0131ral\u0131 y\u00fcr\u00fctme zorunlu. - Yaz-Yaz: \u00c7ak\u0131\u015fma var. S\u0131ral\u0131 y\u00fcr\u00fctme zorunlu.</p>"},{"location":"Core_Modules/JobSystem/#12-dag-donusumu","title":"1.2 DAG D\u00f6n\u00fc\u015f\u00fcm\u00fc","text":"<p>Kay\u0131tl\u0131 her sistem, bir \\(G = (V, E)\\) \u00e7izgesinde bir \\(N\\) d\u00fc\u011f\u00fcm\u00fc olarak kabul edilir. E\u011fer bile\u015fen eri\u015fim \u00e7ak\u0131\u015fmalar\u0131 nedeniyle \\(U\\) sistemi \\(V\\) sisteminden \u00f6nce tamamlanmak zorundaysa, bir \\((U, V)\\) kenar\u0131 (edge) olu\u015fturulur.</p> <pre><code>graph TD\n    subgraph Yurutme_Katmanlari\n        A[GirdiSistem: Yaz-Hiz] --&gt;|Cakisma| B[FizikSistem: Oku-Hiz, Yaz-Poz]\n        C[YPSistem: Oku-Poz, Yaz-Hedef] --&gt;|Cakisma| D[HareketSistem: Oku-Hedef, Yaz-Hiz]\n\n        B -.-&gt;|Katman 2| E[CarpismaSistem: Oku-Poz]\n        A -.-&gt;|Katman 1| C\n    end\n\n    style A fill:#44ff44\n    style B fill:#ffaaaa\n    style C fill:#44ff44\n    style D fill:#ffaaaa\n    style E fill:#44ccff</code></pre>"},{"location":"Core_Modules/JobSystem/#2-matematiksel-planlama-kahn-algoritmas-varyant","title":"2. Matematiksel Planlama: Kahn Algoritmas\u0131 Varyant\u0131","text":"<p>Nexus Prime, veri ak\u0131\u015f\u0131n\u0131 maksimize etmek i\u00e7in katman tabanl\u0131 bir planlama yakla\u015f\u0131m\u0131 kullan\u0131r. D\u00fc\u011f\u00fcmler (sistemler), \\(L_1, L_2, \\dots, L_n\\) katmanlar\u0131na gruplan\u0131r.</p>"},{"location":"Core_Modules/JobSystem/#21-katman-olusturma-kant","title":"2.1 Katman Olu\u015fturma Kan\u0131t\u0131","text":"<p>Katman say\u0131s\u0131 \\(n\\), sim\u00fclasyonun Kritik Yol Uzunlu\u011funu temsil eder. Belirli bir andaki maksimum paralellik ise \\(|L_i|\\) kadard\u0131r.</p> <p>Algoritma Form\u00fclasyonu: 1. T\u00fcm sistem d\u00fc\u011f\u00fcmleri \\(v \\in V\\) i\u00e7in \"Giri\u015f Derecelerini\" (In-Degree) \\(D(v)\\) hesapla. 2. \u0130\u015flenmemi\u015f d\u00fc\u011f\u00fcm kald\u0131\u011f\u0131 s\u00fcrece:    - Giri\u015f derecesi \\(D(v) = 0\\) olan t\u00fcm d\u00fc\u011f\u00fcmleri tan\u0131mla.    - Bu d\u00fc\u011f\u00fcmleri mevcut Katman \\(L_i\\)'ye ata.    - Bu d\u00fc\u011f\u00fcmleri \u00e7izgiden \u00e7\u0131kar ve ba\u011f\u0131ml\u0131 olduklar\u0131 d\u00fc\u011f\u00fcmlerin giri\u015f derecelerini \\(D(u) = D(u) - 1\\) \u015feklinde g\u00fcncelle.</p>"},{"location":"Core_Modules/JobSystem/#22-hzlanma-ve-amdahl-yasas","title":"2.2 H\u0131zlanma ve Amdahl Yasas\u0131","text":"<p>Nexus \u0130\u015f Sistemi'nin teorik h\u0131zlanmas\u0131 \\(S\\), s\u0131ral\u0131 i\u015f y\u00fck\u00fc ile paralel hale getirilebilir i\u015f y\u00fck\u00fc aras\u0131ndaki orana ba\u011fl\u0131d\u0131r:</p> \\[S(p) = \\frac{1}{(1-f) + \\frac{f}{p}}\\] <p>Burada \\(f\\) paralel hale getirilebilir sistemlerin oran\u0131d\u0131r (boyutu \\(&gt; 1\\) olan katmanlardaki d\u00fc\u011f\u00fcmler) ve \\(p\\) kullan\u0131labilir CPU \u00e7ekirdek say\u0131s\u0131d\u0131r.</p>"},{"location":"Core_Modules/JobSystem/#3-uygulama-katman-yurutme","title":"3. Uygulama: Katman Y\u00fcr\u00fctme","text":"<p>\u0130\u015f Sistemi, katmanlar\u0131 kat\u0131 bir s\u0131rayla y\u00fcr\u00fct\u00fcr, ancak her katman i\u00e7inde sistemler minimum ek y\u00fck ile i\u015f par\u00e7ac\u0131\u011f\u0131 havuzuna (thread pool) g\u00f6nderilir.</p> <p>Kod \u00d6rne\u011fi: <pre><code>public void Execute()\n{\n    foreach (var layer in _layers) // S\u0131ral\u0131 Katmanlar (Ba\u011f\u0131ml\u0131l\u0131klar \u00e7\u00f6z\u00fcld\u00fc)\n    {\n        // Katman \u0130\u00e7indeki Paralel Sistemler (\u00c7ak\u0131\u015fma Yok)\n        Parallel.ForEach(layer, node =&gt;\n        {\n            node.System.Execute();\n        });\n    }\n}\n</code></pre></p>"},{"location":"Core_Modules/JobSystem/#4-performans-metrikleri-zamansal-takip","title":"4. Performans Metrikleri: Zamansal Takip","text":"<p>\u0130\u015f Sistemi, y\u00fcksek hassasiyetli kronometreler kullanarak her d\u00fc\u011f\u00fcm\u00fcn y\u00fcr\u00fctme maliyetini takip eder ve ger\u00e7ek zamanl\u0131 darbo\u011faz tespitine olanak tan\u0131r.</p> Metrik Ama\u00e7 Birim ExecutionTimeMs Bireysel sistem maliyeti Milisaniye WaitTime \u00d6nceki katman\u0131 beklerken ge\u00e7en s\u00fcre Milisaniye LayerDensity E\u015fzamanl\u0131 \u00e7al\u0131\u015fan sistem say\u0131s\u0131 Adet"},{"location":"Core_Modules/JobSystem/#5-sonuc","title":"5. Sonu\u00e7","text":"<p>Nexus \u0130\u015f Sistemi, geli\u015ftiricinin paralel programlama karma\u015f\u0131kl\u0131\u011f\u0131yla (Race Condition, Deadlock) u\u011fra\u015fmak yerine sadece veri eri\u015fimlerini tan\u0131mlamas\u0131na odaklanmas\u0131n\u0131 sa\u011flar. Geri kalan t\u00fcm orkestrasyon, matematiksel kesinlik ve donan\u0131m duyarl\u0131l\u0131\u011f\u0131 ile sistem taraf\u0131ndan otomatik olarak y\u00f6netilir.</p>"},{"location":"Core_Modules/Query/","title":"Core Deep-Dive: The Nexus SIMD Query Engine","text":""},{"location":"Core_Modules/Query/#abstract","title":"Abstract","text":"<p>This paper explores the design and implementation of the Nexus Query Engine, a high-performance filtering system. We formalize the SIMD-Accelerated Bitset Filtering logic and analyze the hardware Spatial Locality advantages that allow Nexus to outpace traditional scalar iteration models by orders of magnitude.</p>"},{"location":"Core_Modules/Query/#1-bitset-selection-logic","title":"1. Bitset Selection Logic","text":"<p>Nexus treats entity presence as a binary state within a component bitset. Filtering multiple components is reduced to a bitwise intersection.</p>"},{"location":"Core_Modules/Query/#11-multi-component-filtering-equation","title":"1.1 Multi-Component Filtering Equation","text":"<p>A query for components \\(C_1 \\cap C_2 \\cap \\dots \\cap C_n\\) is resolved by: $\\(ResultBitset = Bitset(C_1) \\ \\&amp; \\ Bitset(C_2) \\ \\&amp; \\ \\dots \\ \\&amp; \\ Bitset(C_n)\\)$</p>"},{"location":"Core_Modules/Query/#12-simd-vectorization-throughput","title":"1.2 SIMD Vectorization Throughput","text":"<p>Using AVX2/AVX-512, Nexus processes multiple 64-bit segments in parallel. The throughput \\(T\\) (entities per cycle) is defined as: $\\(T = \\frac{RegisterWidth_{bits}}{InstructionsPerCycle}\\)$</p> <p>For AVX2 (256-bit), a single instruction filters 32 entities simultaneously, bypassing the Branch Misprediction penalty of scalar <code>if</code> checks.</p> <pre><code>graph LR\n    subgraph Conceptual_AVX_Filtering\n        A[Position Bitset 256-bit] --&gt;|SIMD AND| C[Result Vector 256-bit]\n        B[Velocity Bitset 256-bit] --&gt;|SIMD AND| C\n\n        C -.-&gt; D{32 Entities Processed in 1 Cycle}\n    end\n    style D fill:#ddffdd</code></pre>"},{"location":"Core_Modules/Query/#2-hardware-locality-cache-efficiency","title":"2. Hardware Locality &amp; Cache Efficiency","text":""},{"location":"Core_Modules/Query/#21-the-l2-cache-advantage","title":"2.1 The L2 Cache Advantage","text":"<p>For 1,000,000 entities, the bitset size is calculated as: $\\(Size = \\frac{1,000,000}{8} = 125,000 \\ bytes \\approx 122 \\ KB\\)$</p> <p>This payload fits entirely within the L2 cache (\\(256KB - 512KB\\)) of modern CPUs, ensuring that the entire filtering phase occurs without a single DRAM access after the first load. Traditional OOP iteration checks require dereferencing pointers back to RAM for hundreds of megabytes dynamically.</p>"},{"location":"Core_Modules/Query/#3-implementation-simd-filter","title":"3. Implementation: SIMD Filter","text":"<p>Code Implementation: <pre><code>// Vectorized filtering loop (conceptual)\npublic unsafe void Filter(uint* maskA, uint* maskB, uint* result, int length) {\n    for (int i = 0; i &lt; length; i += 8) {\n        // Load 256 bits into YMM registers\n        var vecA = Avx2.LoadVector256(&amp;maskA[i]);\n        var vecB = Avx2.LoadVector256(&amp;maskB[i]);\n\n        // Parallel AND\n        var vecRes = Avx2.And(vecA, vecB);\n\n        // Store result back to memory\n        Avx2.Store(&amp;result[i], vecRes);\n    }\n}\n</code></pre></p>"},{"location":"Core_Modules/Query/#4-conclusion","title":"4. Conclusion","text":"<p>The Nexus Query Engine translates data access from a logical \"search\" operation into a purely mathematical flow. By utilizing hardware instruction sets (SIMD) and compact data representations, filtering is executed at the absolute peak memory bandwidth limits of the host CPU.</p>"},{"location":"Core_Modules/Query/#_1","title":"Query","text":""},{"location":"Core_Modules/Query/#derinlemesine-inceleme-nexus-simd-sorgu-motoru","title":"Derinlemesine \u0130nceleme: Nexus SIMD Sorgu Motoru","text":""},{"location":"Core_Modules/Query/#ozet","title":"\u00d6zet","text":"<p>Bu makale, Nexus Sorgu Motoru'nun tasar\u0131m\u0131n\u0131 ve uygulamas\u0131n\u0131 incelemektedir. SIMD-H\u0131zland\u0131rmal\u0131 Bitset Filtreleme mant\u0131\u011f\u0131n\u0131 form\u00fclize ediyoruz ve Nexus'un geleneksel skaler iterasyon modellerini geride b\u0131rakmas\u0131n\u0131 sa\u011flayan donan\u0131m Spatial Locality (Alanda Yerellik) avantajlar\u0131n\u0131 analiz ediyoruz.</p>"},{"location":"Core_Modules/Query/#1-bitset-secim-mantg-ve-simd","title":"1. Bitset Se\u00e7im Mant\u0131\u011f\u0131 ve SIMD","text":"<p>Nexus, bile\u015fen varl\u0131\u011f\u0131n\u0131 bir bit maskesi i\u00e7inde ikili bir durum olarak kabul eder. Birden fazla bile\u015feni filtrelemek, bit d\u00fczeyinde bir kesi\u015fime indirgenir.</p>"},{"location":"Core_Modules/Query/#11-coklu-bilesen-filtreleme-denklemi","title":"1.1 \u00c7oklu Bile\u015fen Filtreleme Denklemi","text":"<p>\\(C_1 \\cap C_2 \\cap \\dots \\cap C_n\\) bile\u015fenleri i\u00e7in bir sorgu \u015fu \u015fekilde \u00e7\u00f6z\u00fcl\u00fcr: $\\(SonucBitseti = Bitset(C_1) \\ \\&amp; \\ Bitset(C_2) \\ \\&amp; \\ \\dots \\ \\&amp; \\ Bitset(C_n)\\)$</p>"},{"location":"Core_Modules/Query/#12-vektorize-aks-hz-throughput","title":"1.2 Vekt\u00f6rize Ak\u0131\u015f H\u0131z\u0131 (Throughput)","text":"<p>AVX2/AVX-512 kullanarak Nexus, birden fazla 64-bit segmenti paralel olarak i\u015fler. Ak\u0131\u015f h\u0131z\u0131 \\(T\\) (d\u00f6ng\u00fc ba\u015f\u0131na varl\u0131k) \u015fu \u015fekilde tan\u0131mlan\u0131r: $\\(T = \\frac{RegisterGenisligi_{bit}}{KomutBasinaDongu}\\)$</p> <p>AVX2 (256-bit) kullanarak, tek bir komut 32 varl\u0131\u011f\u0131 ayn\u0131 anda filtreler. Bu, skaler <code>if</code> kontrollerinin yol a\u00e7t\u0131\u011f\u0131 Dallanma Tahmin Hatas\u0131 maliyetini ortadan kald\u0131r\u0131r.</p> <pre><code>graph LR\n    subgraph Kavramsal_AVX_Filtreleme\n        A[Pozisyon Bitseti 256-bit] --&gt;|SIMD AND| C[Sonuc Vektoru 256-bit]\n        B[Hiz Bitseti 256-bit] --&gt;|SIMD AND| C\n\n        C -.-&gt; D{1 Dongude 32 Varlik Islendi}\n    end\n    style D fill:#ddffdd</code></pre>"},{"location":"Core_Modules/Query/#2-donanm-yerelligi-ve-onbellek-verimliligi","title":"2. Donan\u0131m Yerelli\u011fi ve \u00d6nbellek Verimlili\u011fi","text":""},{"location":"Core_Modules/Query/#21-l2-onbellek-avantaj","title":"2.1 L2 \u00d6nbellek Avantaj\u0131","text":"<p>1.000.000 varl\u0131k i\u00e7in bit seti boyutu: $\\(Boyut = \\frac{1.000,000}{8} = 125.000 \\ byte \\approx 122 \\ KB\\)$</p> <p>Bu veri y\u00fck\u00fc, modern CPU'lar\u0131n L2 \u00f6nbelleklerine (\\(256KB - 512KB\\)) tamamen s\u0131\u011far. Bu, ilk y\u00fcklemeden sonra t\u00fcm filtreleme a\u015famas\u0131n\u0131n DRAM eri\u015fimi olmadan ger\u00e7ekle\u015fmesini sa\u011flar. Geleneksel OOP iterasyonunda bu i\u015flem MB'larca RAM referans\u0131n\u0131n \u00e7\u00f6z\u00fclmesini gerektirir.</p>"},{"location":"Core_Modules/Query/#3-uygulama-simd-filtreleme","title":"3. Uygulama: SIMD Filtreleme","text":"<p>Kod Uygulamas\u0131: <pre><code>// Vekt\u00f6rize edilmi\u015f filtreleme d\u00f6ng\u00fcs\u00fc (kavramsal)\npublic unsafe void Filter(uint* maskA, uint* maskB, uint* result, int length) {\n    for (int i = 0; i &lt; length; i += 8) {\n        // 256 biti YMM register'lar\u0131na y\u00fckle\n        var vecA = Avx2.LoadVector256(&amp;maskA[i]);\n        var vecB = Avx2.LoadVector256(&amp;maskB[i]);\n\n        // Paralel AND i\u015flemi\n        var vecRes = Avx2.And(vecA, vecB);\n\n        // Sonucu belle\u011fe geri kaydet\n        Avx2.Store(&amp;result[i], vecRes);\n    }\n}\n</code></pre></p>"},{"location":"Core_Modules/Query/#4-sonuc","title":"4. Sonu\u00e7","text":"<p>Nexus Sorgu Motoru, veri eri\u015fimini mant\u0131ksal bir \"arama\" i\u015fleminden matematiksel bir \"ak\u0131\u015f\" i\u015flemine d\u00f6n\u00fc\u015ft\u00fcr\u00fcr. Donan\u0131m y\u00f6nergelerini (SIMD) tam kapasiteyle kullanarak sim\u00fclasyonun en a\u011f\u0131r y\u00fcklerinden biri olan filtrelemeyi mutlak zirve bellek bant geni\u015fli\u011fi s\u0131n\u0131rlar\u0131nda y\u00fcr\u00fct\u00fcr.</p>"},{"location":"Core_Modules/Registry/","title":"Core Deep-Dive: The Nexus Registry &amp; SparseSet Architecture","text":""},{"location":"Core_Modules/Registry/#abstract","title":"Abstract","text":"<p>This paper analyzes the architectural foundations of the Nexus Registry, the central orchestration unit of the Nexus Prime ECS framework. We explore the implementation of the SparseSet data structure, formalizing its \\(O(1)\\) access complexity and the versioning mechanism used to guarantee memory safety in highly dynamic unmanaged environments.</p>"},{"location":"Core_Modules/Registry/#1-philosophical-grounding-dod-vs-oop","title":"1. Philosophical Grounding: DOD vs. OOP","text":"<p>The Nexus Registry is the \"Central Brain\" of the simulation, but unlike a manager in OOP, it does not hold objects. It serves as a Data Stream Orchestrator.</p>"},{"location":"Core_Modules/Registry/#11-the-registry-solution","title":"1.1 The Registry Solution","text":"<p>The Registry treats an Entity as a lightweight 64-bit handle (Index + Version). - Contiguity: Components are stored in contiguous buffers. - SIMD Friendliness: Data is laid out ready for vector units (AVX/SSE).</p>"},{"location":"Core_Modules/Registry/#2-advanced-sparseset-mechanics","title":"2. Advanced SparseSet Mechanics","text":""},{"location":"Core_Modules/Registry/#21-the-o1-access-proof","title":"2.1 The O(1) Access Proof","text":"<p>The core of the Registry is the <code>SparseSet&lt;T&gt;</code>. It maps an <code>EntityId</code> to its component data via a dense array, ensuring that iterations are always performed on \\(100\\%\\) packed memory.</p> <p>Address Calculation Logic: Given an entity index \\(i\\), the address of its component data \\(C\\) is calculated as:</p> \\[Address(C) = Base_{dense} + (Sparse[i] \\times sizeof(T))\\] <p>Since both array indexing and pointer addition are constant-time operations on modern CPUs, component retrieval is strictly \\(O(1)\\).</p> <pre><code>graph TD\n    subgraph Conceptual_SparseSet_LookUp\n        A[Entity Index: 104] --&gt;|O 1 Lookup| B[Sparse Array idx: 104 = 2]\n        B --&gt;|O 1 Lookup| C[Dense Array idx: 2]\n        C -.-&gt; D[Dense Component Data Block]\n    end\n    style D fill:#ddffdd</code></pre>"},{"location":"Core_Modules/Registry/#22-versioning-recycle-pool","title":"2.2 Versioning &amp; Recycle Pool","text":"<p>To prevent \"Stale Pointer\" bugs in unmanaged memory, Nexus utilizes a 32-bit versioning system. - Validation Constraint: An entity handle is valid if and only if:   $\\(Handle.Version == Registry.Versions[Handle.Index]\\)$ - Recycle Logic: Destroyed indices are pushed to a LIFO stack. Upon recycling, the version is incremented, effectively invalidating all previous handles to that index.</p>"},{"location":"Core_Modules/Registry/#3-implementation-component-management","title":"3. Implementation: Component Management","text":"<p>Code Implementation: <pre><code>public struct EntityId {\n    public int Index;\n    public int Version;\n}\n\n// Internal Registry logic showing O(1) dense access\npublic T* Get&lt;T&gt;(EntityId entity) where T : unmanaged {\n    var set = GetSet&lt;T&gt;();\n    int denseIndex = set.Sparse[entity.Index];\n    return &amp;set.Dense[denseIndex];\n}\n</code></pre></p>"},{"location":"Core_Modules/Registry/#4-conclusion","title":"4. Conclusion","text":"<p>The Nexus Registry transforms memory access from a stochastic process into a deterministic mathematical operation. With \\(O(1)\\) complexity and absolute hardware locality, it pushes the theoretical performance limits of modern processors.</p>"},{"location":"Core_Modules/Registry/#_1","title":"Registry","text":""},{"location":"Core_Modules/Registry/#derinlemesine-inceleme-nexus-registry-ve-sparseset-mimarisi","title":"Derinlemesine \u0130nceleme: Nexus Registry ve SparseSet Mimarisi","text":""},{"location":"Core_Modules/Registry/#ozet","title":"\u00d6zet","text":"<p>Bu makale, Nexus Prime ECS \u00e7er\u00e7evesinin merkezi y\u00f6netim birimi olan Nexus Registry'nin mimari temellerini incelemektedir. SparseSet veri yap\u0131s\u0131n\u0131n uygulamas\u0131n\u0131, \\(O(1)\\) eri\u015fim karma\u015f\u0131kl\u0131\u011f\u0131n\u0131 ve dinamik unmanaged ortamlarda bellek g\u00fcvenli\u011fini sa\u011flamak i\u00e7in kullan\u0131lan versiyonlama mekanizmas\u0131n\u0131 form\u00fclize ediyoruz.</p>"},{"location":"Core_Modules/Registry/#1-felsefi-temel-dod-vs-oop","title":"1. Felsefi Temel: DOD vs. OOP","text":"<p>Nexus Registry sim\u00fclasyonun \"Merkezi Beyni\"dir, ancak OOP'deki bir y\u00f6neticinin aksine i\u00e7inde nesne bar\u0131nd\u0131rmaz. Bir Veri Ak\u0131\u015f Orkestrat\u00f6r\u00fc olarak g\u00f6rev yapar.</p> <ul> <li>Biti\u015fiklik (Contiguity): Bile\u015fenler biti\u015fik tamponlarda saklan\u0131r.</li> <li>SIMD Dostu: Veriler vekt\u00f6r birimleri (AVX/SSE) i\u00e7in haz\u0131r \u015fekilde d\u00fczenlenir.</li> </ul>"},{"location":"Core_Modules/Registry/#2-gelismis-sparseset-mekanigi","title":"2. Geli\u015fmi\u015f SparseSet Mekani\u011fi","text":""},{"location":"Core_Modules/Registry/#21-o1-erisim-kant","title":"2.1 O(1) Eri\u015fim Kan\u0131t\u0131","text":"<p>Registry'nin kalbi <code>SparseSet&lt;T&gt;</code> yap\u0131s\u0131d\u0131r. Bir <code>EntityId</code>'yi bile\u015fen verisine yo\u011fun (dense) bir dizi \u00fczerinden e\u015fler, b\u00f6ylece iterasyonlar\u0131n her zaman \\(\\%100\\) paketlenmi\u015f bellek \u00fczerinde yap\u0131lmas\u0131n\u0131 sa\u011flar.</p> <p>Adres Hesaplama Mant\u0131\u011f\u0131: Bir varl\u0131k indeksi \\(i\\) verildi\u011finde, bile\u015fen verisi \\(C\\)'nin adresi \u015fu \u015fekilde hesaplan\u0131r:</p> \\[Adres(C) = Base_{yo\u011fun} + (Sparse[i] \\times sizeof(T))\\] <p>Modern i\u015flemcilerde hem dizi indeksleme hem de pointer toplama i\u015flemleri sabit zamanl\u0131 oldu\u011fundan, bile\u015fen eri\u015fimi kesinlikle \\(O(1)\\)'dir.</p> <pre><code>graph TD\n    subgraph Kavramsal_SparseSet_Aramasi\n        A[Varlik Indeksi: 104] --&gt;|O 1 Arama| B[Sparse Dizi idx: 104 = 2]\n        B --&gt;|O 1 Arama| C[Yogun Dizi idx: 2]\n        C -.-&gt; D[Yogun Bilesen Veri Blogu]\n    end\n    style D fill:#ddffdd</code></pre>"},{"location":"Core_Modules/Registry/#22-versiyonlama-ve-geri-donusum","title":"2.2 Versiyonlama ve Geri D\u00f6n\u00fc\u015f\u00fcm","text":"<p>Y\u00f6netilmeyen bellekte \"Bayat \u0130\u015faret\u00e7i\" (Stale Pointer) hatalar\u0131n\u0131 \u00f6nlemek i\u00e7in Nexus 32-bit versiyonlama kullan\u0131r. - Do\u011frulama K\u0131s\u0131t\u0131: Bir varl\u0131k tutamac\u0131 ancak \u015fu durumda ge\u00e7erlidir:   $\\(Tutamac.Versiyon == Registry.Versiyonlar[Tutamac.Indeks]\\)$ - Geri D\u00f6n\u00fc\u015f\u00fcm Mant\u0131\u011f\u0131: Yok edilen indeksler bir LIFO y\u0131\u011f\u0131na itilir. Geri d\u00f6n\u00fc\u015f\u00fcm an\u0131nda versiyon art\u0131r\u0131l\u0131r, b\u00f6ylece o indekse i\u015faret eden \u00f6nceki t\u00fcm tutama\u00e7lar ge\u00e7ersiz k\u0131l\u0131n\u0131r.</p>"},{"location":"Core_Modules/Registry/#3-uygulama-bilesen-yonetimi","title":"3. Uygulama: Bile\u015fen Y\u00f6netimi","text":"<p>Kod Uygulamas\u0131: <pre><code>public struct EntityId {\n    public int Index;\n    public int Version;\n}\n\n// O(1) yo\u011fun eri\u015fimi g\u00f6steren dahili Registry mant\u0131\u011f\u0131\npublic T* Get&lt;T&gt;(EntityId entity) where T : unmanaged {\n    var set = GetSet&lt;T&gt;();\n    int denseIndex = set.Sparse[entity.Index];\n    return &amp;set.Dense[denseIndex];\n}\n</code></pre></p>"},{"location":"Core_Modules/Registry/#4-sonuc","title":"4. Sonu\u00e7","text":"<p>Nexus Registry, bellek eri\u015fimini rastgele bir s\u00fcre\u00e7ten deterministik bir matematiksel i\u015fleme d\u00f6n\u00fc\u015ft\u00fcr\u00fcr. \\(O(1)\\) karma\u015f\u0131kl\u0131\u011f\u0131 ve donan\u0131m yerelli\u011fi (locality) ile modern i\u015flemcilerin teorik performans s\u0131n\u0131rlar\u0131n\u0131 zorlar.</p>"},{"location":"Core_Modules/Snapshot/","title":"Core Deep-Dive: Temporal Management &amp; Differential Snapshots","text":""},{"location":"Core_Modules/Snapshot/#abstract","title":"Abstract","text":"<p>This paper analyzes the Nexus SnapshotManager, a high-performance temporal state management system. We examine the use of Differential Snapshotting to minimize memory consumption and formalize the hardware-accelerated Block Memory Copies that allow for sub-millisecond full-state captures.</p>"},{"location":"Core_Modules/Snapshot/#1-block-memory-transfer-mechanics","title":"1. Block Memory Transfer Mechanics","text":"<p>Nexus avoids the performance penalty of per-element iteration during state capture by utilizing hardware-native memory blocks.</p>"},{"location":"Core_Modules/Snapshot/#11-simd-accelerated-copy-performance","title":"1.1 SIMD-Accelerated Copy Performance","text":"<p>Capture latency \\(L\\) for a dataset of size \\(B\\) bytes is defined as: $\\(L = \\frac{B}{BW_{mem} \\times \\eta}\\)$</p> <p>Where \\(BW_{mem}\\) is the raw memory bandwidth and \\(\\eta\\) is the efficiency factor of the SIMD implementation. By utilizing instructions like <code>VMOVDQU</code> (AVX-512), Nexus achieves \\(\\eta \\approx 0.95\\), saturating the memory bus and allowing 1GB of state to be cloned in approximately \\(20-30 \\mu s\\) on modern workstation hardware.</p>"},{"location":"Core_Modules/Snapshot/#2-differential-snapshotting-logic","title":"2. Differential Snapshotting Logic","text":"<p>To conserve memory in the circular history buffer, Nexus defaults to Delta Snapshots.</p>"},{"location":"Core_Modules/Snapshot/#21-the-dirty-bit-optimization","title":"2.1 The Dirty-Bit Optimization","text":"<p>A snapshot \\(S_{i}\\) for a frame \\(i\\) is only stored for component types where the Dirty Mask \\(M\\) is non-zero. - Full Capture: \\(S = \\cup_{j=1}^{C} Set_j\\) - Delta Capture: \\(S_{delta} = \\cup \\{Set_j \\ | \\ Mask_j \\neq 0\\}\\)</p> <p>This reduces the average frame capture size \\(B_{avg}\\) by: $\\(B_{avg} = B_{total} \\times \\rho\\)$ Where \\(\\rho\\) is the \"Activity Ratio\" of components per frame, typically \\(\\rho &lt; 0.05\\) in real-time simulations.</p> <pre><code>graph LR\n    subgraph Frame_N_Memory_Capture\n        A[Position Component Buffer] --&gt;|Unchanged: M=0| C[Skip Copy]\n        B[Velocity Component Buffer] --&gt;|Changed: M=1| D[AVX-512 Block Clone]\n\n        D -.-&gt;|Delta Snapshot| E[(History Frame N)]\n    end\n    style D fill:#ddffdd\n    style C fill:#fff4cc</code></pre>"},{"location":"Core_Modules/Snapshot/#3-implementation-fast-clone","title":"3. Implementation: Fast Clone","text":"<p>Code Implementation: <pre><code>public unsafe void RecordFrame(Registry registry) {\n    var snapshot = new Snapshot();\n    foreach (var set in registry.ActiveSets) {\n        if (set.IsDirty) {\n            // Allocate unmanaged block\n            void* buffer = NativeMemory.Alloc(set.Size);\n            // High-speed block copy\n            NexusMemory.Copy(set.RawPtr, buffer, set.Size);\n            snapshot.Add(set.TypeId, buffer);\n        }\n    }\n    _history.Push(snapshot);\n}\n</code></pre></p>"},{"location":"Core_Modules/Snapshot/#4-conclusion","title":"4. Conclusion","text":"<p>The Nexus Snapshot system reduces temporal state management from an iterative database burden into an ultra-fast hardware block-copy operation. Through differential capture matrices and SIMD vectors, it delivers reliable state historization natively compatible with Rollback Netcode architectures.</p>"},{"location":"Core_Modules/Snapshot/#_1","title":"Snapshot","text":""},{"location":"Core_Modules/Snapshot/#derinlemesine-inceleme-zamansal-yonetim-ve-diferansiyel-snapshotlar","title":"Derinlemesine \u0130nceleme: Zamansal Y\u00f6netim ve Diferansiyel Snapshot'lar","text":""},{"location":"Core_Modules/Snapshot/#ozet","title":"\u00d6zet","text":"<p>Bu makale, y\u00fcksek performansl\u0131 bir zamansal durum y\u00f6netim sistemi olan Nexus SnapshotManager'\u0131 incelemektedir. Bellek t\u00fcketimini en aza indirmek i\u00e7in Diferansiyel Snapshotting (Farkl\u0131l\u0131k Tabanl\u0131 Kay\u0131t) kullan\u0131m\u0131n\u0131 inceliyor ve alt milisaniye baz\u0131nda tam durum yakalamaya olanak tan\u0131yan donan\u0131m h\u0131zland\u0131rmal\u0131 Blok Bellek Kopyalar\u0131n\u0131 form\u00fclize ediyoruz.</p>"},{"location":"Core_Modules/Snapshot/#1-bellek-transfer-mekanigi-ve-simd","title":"1. Bellek Transfer Mekani\u011fi ve SIMD","text":"<p>Nexus, durum yakalama s\u0131ras\u0131nda eleman bazl\u0131 iterasyon maliyetinden donan\u0131ma \u00f6zg\u00fc bellek bloklar\u0131n\u0131 kullanarak ka\u00e7\u0131n\u0131r.</p>"},{"location":"Core_Modules/Snapshot/#11-blok-kopyalama-performans","title":"1.1 Blok Kopyalama Performans\u0131","text":"<p>\\(B\\) byte boyutundaki bir veri k\u00fcmesi i\u00e7in yakalama gecikmesi \\(L\\): $\\(L = \\frac{B}{BW_{bellek} \\times \\eta}\\)$</p> <p>Burada \\(BW_{bellek}\\) ham bellek bant geni\u015fli\u011fini, \\(\\eta\\) ise SIMD uygulamas\u0131n\u0131n verimlilik fakt\u00f6r\u00fcn\u00fc temsil eder. AVX-512 (<code>VMOVDQU</code>) gibi yerel komutlar\u0131 kullanarak Nexus, \\(\\eta \\approx 0.95\\) verimlili\u011fe ula\u015farak bellek veri yolunu doyurur ve 1GB'l\u0131k durumun modern i\u015f istasyonlar\u0131nda yakla\u015f\u0131k \\(20-30 \\mu s\\) i\u00e7inde kopyalanmas\u0131na olanak tan\u0131r.</p>"},{"location":"Core_Modules/Snapshot/#2-diferansiyel-snapshot-mantg","title":"2. Diferansiyel Snapshot Mant\u0131\u011f\u0131","text":"<p>Nexus, dairesel ge\u00e7mi\u015f tamponunda yer kazanmak i\u00e7in varsay\u0131lan olarak Delta Snapshot'lar\u0131 kullan\u0131r.</p>"},{"location":"Core_Modules/Snapshot/#21-kirli-bit-maskesi-dirty-bit-optimizasyonu","title":"2.1 Kirli Bit Maskesi (Dirty-Bit) Optimizasyonu","text":"<p>Bir \\(i\\) karesi i\u00e7in snapshot \\(S_{i}\\), sadece Dirty Mask \\(M\\) de\u011feri s\u0131f\u0131rdan farkl\u0131 olan bile\u015fen tipleri i\u00e7in saklan\u0131r. - Tam Yakalama: \\(S = \\cup_{j=1}^{C} Set_j\\) - Delta Yakalama: \\(S_{delta} = \\cup \\{Set_j \\ | \\ Mask_j \\neq 0\\}\\)</p> <p>Bu, ortalama kare yakalama boyutu \\(B_{avg}\\)'yi \u015fu \u015fekilde azalt\u0131r: $\\(B_{avg} = B_{total} \\times \\rho\\)$ Burada \\(\\rho\\), her karedeki bile\u015fenlerin \"Aktivite Oran\u0131\"d\u0131r ve ger\u00e7ek zamanl\u0131 sim\u00fclasyonlarda genellikle \\(\\rho &lt; 0.05\\) civar\u0131ndad\u0131r.</p> <pre><code>graph LR\n    subgraph N_Karesi_Bellek_Yakalamasi\n        A[Pozisyon Bilesen Tamponu] --&gt;|Degismedi: M=0| C[Kopyalamayi Atla]\n        B[Hiz Bilesen Tamponu] --&gt;|Degisti: M=1| D[AVX-512 Blok Klonlama]\n\n        D -.-&gt;|Delta Snapshot| E[(Gecmis Kare N)]\n    end\n    style D fill:#ddffdd\n    style C fill:#fff4cc</code></pre>"},{"location":"Core_Modules/Snapshot/#3-uygulama-hzl-klonlama","title":"3. Uygulama: H\u0131zl\u0131 Klonlama","text":"<p>Kod Uygulamas\u0131: <pre><code>public unsafe void RecordFrame(Registry registry) {\n    var snapshot = new Snapshot();\n    foreach (var set in registry.ActiveSets) {\n        if (set.IsDirty) {\n            // Unmanaged blok tahsis et\n            void* buffer = NativeMemory.Alloc(set.Size);\n            // Y\u00fcksek h\u0131zl\u0131 blok kopyalama\n            NexusMemory.Copy(set.RawPtr, buffer, set.Size);\n            snapshot.Add(set.TypeId, buffer);\n        }\n    }\n    _history.Push(snapshot);\n}\n</code></pre></p>"},{"location":"Core_Modules/Snapshot/#4-sonuc","title":"4. Sonu\u00e7","text":"<p>Nexus Snapshot sistemi, zamansal y\u00f6netimi a\u011f\u0131r bir veritaban\u0131 i\u015fleminden hafif bir donan\u0131m bellek kopyalama i\u015flemine indirger. Diferansiyel kay\u0131t ve SIMD h\u0131zland\u0131rmas\u0131 ile sistem, Rollback Netcode (Geri Al\u0131ml\u0131 A\u011f Kodu) mimarileriyle yerel olarak uyumlu, g\u00fcvenilir bir durum tarih\u00e7elendirmesi sa\u011flar.</p>"},{"location":"Manifesto/Nexus/","title":"Nexus Manifesto: Architecture and Philosophy","text":""},{"location":"Manifesto/Nexus/#introduction-why-nexus","title":"Introduction: Why Nexus?","text":"<p>Modern software development has drifted away from the physical realities of hardware by burdening itself under layers of abstraction (OOP, Garbage Collection, Managed Memory). While Object-Oriented Programming (OOP) appears developer-friendly, it ignores the massive speed difference between the processor (CPU) and memory (RAM), known as the Memory Wall.</p> <p>We cannot say \"OOP is Dead,\" but we can say \"OOP is Inadequate for Performance-Critical Areas.\" Nexus provides a Hardware-aware solution to this inadequacy.</p>"},{"location":"Manifesto/Nexus/#performance-glossary","title":"Performance Glossary","text":"<p>To understand advanced performance optimizations, we must first speak the language of the processor:</p> Term Description Nexus Implementation L1/L2/L3 Cache The fastest memory layers closest to the processor core. Nexus stores data in cache-friendly <code>ChunkedBuffer</code> structures. Data Locality The state where related data is located side-by-side in memory. Data is stored in contiguous memory using <code>SparseSet</code> and <code>Registry</code>. SIMD Single Instruction Multiple Data. Processing multiple data points with a single instruction. <code>NexusQuery</code> updates data in bulk using AVX2/SSE instructions (\\(T_{throughput} \\times 8\\)). Branch Prediction The processor's ability to predict the flow of code (if/else). Nexus minimizes branching to prevent mispredictions (\\(P_{miss} \\rightarrow 0\\)). Memory Barrier A safety boundary preventing the processor from reordering instructions. Used for data consistency during unmanaged copy operations. Cache Miss The state where the processor cannot find data in the Cache and must go to RAM. Nexus's primary goal is to approach a 0% cache miss rate."},{"location":"Manifesto/Nexus/#philosophical-foundation-data-oriented-design-dod","title":"Philosophical Foundation: Data-Oriented Design (DOD)","text":"<p>The fundamental flaw of OOP is imprisoning data inside small boxes called \"Objects\" and scattering them across random locations in memory (Heap). When the processor wants to access this data, it constantly experiences \"Cache Misses\" and waits for data from RAM. While most CPUs have RAM latencies around \\(100 \\text{ ns}\\), an L1 Cache access requires only \\(1 \\text{ ns}\\).</p> <p>Performance Gain Equation: For \\(N\\) iterations in a loop, the processing time \\(T\\) is: $\\(T(N) = N \\times (P_{hit} \\times t_{cache} + P_{miss} \\times t_{ram})\\)$</p> <p>Nexus embraces the Data-Oriented Design philosophy to push \\(P_{miss} \\rightarrow 0\\): 1.  Data is Sacred: Operations are performed on data, not on objects. 2.  Memory Layout is Design: How you store data is as important as what you write. 3.  Respect the Processor: Sequential memory layouts are established where the processor can read data at speeds of GBs per second.</p>"},{"location":"Manifesto/Nexus/#architectural-schema-modular-structure","title":"Architectural Schema: Modular Structure","text":"<p>Nexus is a cohesive whole but operates with a modular hierarchy:</p> <pre><code>graph TD\n    A[Nexus.Core] --&gt; B[Registry]\n    B --&gt; C[SparseSet: Data Store]\n    B --&gt; D[ChunkedBuffer: Linear RAM]\n    A --&gt; E[NexusQuery: Data Fetch]\n    E --&gt; F[SIMD Engine: Accelerator]\n    G[Nexus.Unity] --&gt; H[Bridge 2.0: Visual Link]\n    H --&gt; B\n    I[NexusGenerator] --&gt; J[Source Code Analysis]\n    J --&gt; A</code></pre>"},{"location":"Manifesto/Nexus/#nexus-solution-hardware-friendly-programming","title":"Nexus Solution: Hardware-Friendly Programming","text":"<p>Nexus offers C++ performance within the C# world: - Zero GC: No memory allocation at runtime, no Garbage Collector triggers. - Pointer Magic: Data transfer reaches maximum speed with <code>unsafe</code> code blocks and raw memory addressing. - Parallel Processing: Data chunks are distributed equally across all cores of modern processors with \\(O(1)\\) dispatch cost.</p> <p>[!IMPORTANT] Nexus Optimization Tip: Clock Cycle Efficiency While Nexus processes a loop, it never clogs the processor's <code>pipeline</code>. There are no virtual method tables (vtable) or reference tracking. Every operation is performed directly via memory addresses, minimizing the number of \"Clock Cycles\" spent for each entity.</p>"},{"location":"Manifesto/Nexus/#_1","title":"Nexus","text":""},{"location":"Manifesto/Nexus/#nexus-manifesto-mimari-ve-felsefe","title":"Nexus Manifesto: Mimari ve Felsefe","text":""},{"location":"Manifesto/Nexus/#giris-neden-nexus","title":"Giri\u015f: Neden Nexus?","text":"<p>Modern yaz\u0131l\u0131m geli\u015ftirme, donan\u0131m\u0131n fiziksel ger\u00e7eklerinden uzakla\u015farak soyutlama katmanlar\u0131 (OOP, Garbage Collection, Managed Memory) alt\u0131nda ezilmi\u015ftir. Nesne Y\u00f6nelimli Programlama (OOP), geli\u015ftirici dostu g\u00f6r\u00fcnse de, i\u015flemci (CPU) ve bellek (RAM) aras\u0131ndaki devasa h\u0131z fark\u0131n\u0131 (Memory Wall) g\u00f6rmezden gelir. </p> <p>\"OOP \u00d6ld\u00fc\" diyemeyiz, ancak \"Performans Kriti\u011fi Gerektiren Yerlerde OOP Yetersizdir\" diyebiliriz. Nexus, bu yetersizli\u011fe donan\u0131m dostu (Hardware-aware) bir \u00e7\u00f6z\u00fcm sunar.</p>"},{"location":"Manifesto/Nexus/#performance-glossary-performans-sozlugu","title":"Performance Glossary (Performans S\u00f6zl\u00fc\u011f\u00fc)","text":"<p>Geli\u015fmi\u015f performans optimizasyonlar\u0131n\u0131 anlamak i\u00e7in \u00f6nce i\u015flemcinin diliyle konu\u015fmal\u0131y\u0131z:</p> Terim A\u00e7\u0131klama Nexus Uygulamas\u0131 L1/L2/L3 Cache \u0130\u015flemci \u00e7ekirde\u011fine en yak\u0131n ve en h\u0131zl\u0131 bellek katmanlar\u0131. Nexus, veriyi Cache dostu <code>ChunkedBuffer</code> yap\u0131lar\u0131nda tutar. Data Locality \u0130li\u015fkili verilerin bellekte yan yana bulunmas\u0131 durumu. <code>SparseSet</code> ve <code>Registry</code> ile veriler ard\u0131\u015f\u0131k bellekte saklan\u0131r. SIMD Single Instruction multiple Data. Tek komutla birden fazla veriyi i\u015fleme. <code>NexusQuery</code>, AVX2/SSE komutlar\u0131yla verileri topluca g\u00fcnceller (\\(T_{throughput} \\times 8\\)). Branch Prediction \u0130\u015flemcinin kodun ak\u0131\u015f\u0131n\u0131 (if/else) tahmin etme yetene\u011fi. Nexus, dallanmay\u0131 minimize ederek tahmin hatalar\u0131n\u0131 (misprediction) \u00f6nler (\\(P_{miss} \\rightarrow 0\\)). Memory Barrier \u0130\u015flemcinin komut s\u0131ras\u0131n\u0131 kar\u0131\u015ft\u0131rmas\u0131n\u0131 engelleyen g\u00fcvenlik s\u0131n\u0131r\u0131. Unmanaged kopyalama i\u015flemlerinde veri tutarl\u0131l\u0131\u011f\u0131 i\u00e7in kullan\u0131l\u0131r. Cache Miss \u0130\u015flemcinin arad\u0131\u011f\u0131 veriyi Cache'de bulamay\u0131p RAM'e gitmek zorunda kalmas\u0131. Nexus'un temel amac\u0131 bu oran\u0131 %0'a yakla\u015ft\u0131rmakt\u0131r."},{"location":"Manifesto/Nexus/#felsefi-temel-data-oriented-design-dod","title":"Felsefi Temel: Data-Oriented Design (DOD)","text":"<p>OOP'un temel hatas\u0131, veriyi \"Nesne\" (Object) denilen k\u00fc\u00e7\u00fck kutulara hapsetmesi ve bu kutular\u0131 belle\u011fin rastgele yerlerine (Heap) sa\u00e7mas\u0131d\u0131r. \u0130\u015flemci bu verilere eri\u015fmek istedi\u011finde s\u00fcrekli \"Cache Miss\" ya\u015far ve RAM'den veri gelmesini bekler. \u00c7o\u011fu i\u015flemcide RAM gecikmesi \\(100 \\text{ ns}\\) mertebesindeyken, L1 Cache eri\u015fimi \\(1 \\text{ ns}\\) s\u00fcrer.</p> <p>Performans Kazan\u0131m\u0131 Denklemi: Bir d\u00f6ng\u00fcdeki \\(N\\) iterasyon i\u00e7in zaman \\(T\\): $\\(T(N) = N \\times (P_{hit} \\times t_{cache} + P_{miss} \\times t_{ram})\\)$</p> <p>Nexus, Data-Oriented Design felsefesini benimseyerek \\(P_{miss} \\rightarrow 0\\) hedefine ula\u015f\u0131r: 1.  Veri Kutsald\u0131r: Nesneler de\u011fil, veriler \u00fczerinde i\u015flem yap\u0131l\u0131r. 2.  Bellek D\u00fczeni Tasar\u0131md\u0131r: Veriyi nas\u0131l saklad\u0131\u011f\u0131n\u0131z, ne yazd\u0131\u011f\u0131n\u0131z kadar \u00f6nemlidir. 3.  \u0130\u015flemciye Sayg\u0131: \u0130\u015flemcinin veriyi saniyede GB'larca h\u0131zla okuyabilece\u011fi ard\u0131\u015f\u0131k bellek (Sequential Memory) d\u00fczenleri kurulur.</p>"},{"location":"Manifesto/Nexus/#mimari-sema-moduler-yap","title":"Mimari \u015eema: Mod\u00fcler Yap\u0131","text":"<p>Nexus bir b\u00fct\u00fcnd\u00fcr ancak mod\u00fcler bir hiyerar\u015fi ile \u00e7al\u0131\u015f\u0131r:</p> <pre><code>graph TD\n    A[Nexus.Core] --&gt; B[Registry]\n    B --&gt; C[SparseSet: Veri Deposu]\n    B --&gt; D[ChunkedBuffer: Do\u011frusal RAM]\n    A --&gt; E[NexusQuery: Veri Arama]\n    E --&gt; F[SIMD Motoru: H\u0131zland\u0131rma]\n    G[Nexus.Unity] --&gt; H[Bridge 2.0: G\u00f6rsel K\u00f6pr\u00fc]\n    H --&gt; B\n    I[NexusGenerator] --&gt; J[Kaynak Kod Analizi]\n    J --&gt; A</code></pre>"},{"location":"Manifesto/Nexus/#nexus-cozumu-donanm-dostu-programlama","title":"Nexus \u00c7\u00f6z\u00fcm\u00fc: Donan\u0131m Dostu Programlama","text":"<p>Nexus, C# d\u00fcnyas\u0131nda C++ performans\u0131 sunar: - Zero GC: \u00c7al\u0131\u015fma an\u0131nda (runtime) bellek tahsisi yap\u0131lmaz, Garbage Collector tetiklenmez. - Pointer Magic: <code>unsafe</code> kod bloklar\u0131 ve ham bellek adresleme ile veri transferi maksimum h\u0131za ula\u015f\u0131r. - Parallel processing: Veri par\u00e7alar\u0131 (chunks), modern i\u015flemcilerin t\u00fcm \u00e7ekirdeklerine \\(O(1)\\) maliyetle e\u015fit \u015fekilde da\u011f\u0131t\u0131l\u0131r.</p> <p>[!IMPORTANT] Nexus Optimization Tip: Clock Cycle Efficiency Nexus bir d\u00f6ng\u00fcy\u00fc i\u015flerken, i\u015flemcinin <code>pipeline</code> (boru hatt\u0131) yap\u0131s\u0131n\u0131 asla t\u0131kamaz. Sanal metod tablolar\u0131 (vtable) veya referans takibi (reference tracking) yoktur. Her i\u015flem do\u011frudan bellek adresi \u00fczerinden yap\u0131l\u0131r, bu da her bir varl\u0131k (entity) i\u00e7in harcanan \"Clock Cycle\" miktar\u0131n\u0131 minimuma indirir.</p>"},{"location":"Manifesto/Nexus_WhitePaper/","title":"Nexus Prime: A High-Performance, Hardware-Aware ECS Architecture for Real-Time Simulations","text":""},{"location":"Manifesto/Nexus_WhitePaper/#abstract-executive-summary","title":"Abstract / Executive Summary","text":"<p>This manifesto details the technical foundations of Nexus Prime, an elite Entity Component System (ECS) framework designed to solve the systemic performance bottlenecks of modern high-level managed environments. We analyze the Memory Wall, the failure of the Object-Oriented Paradigm (OOP) at scale, and the architectural crisis of modern managed runtimes. Nexus Prime offers a \"Zero-Friction\" unmanaged architecture that operates at the theoretical limits of modern CPU architectures while providing a seamless, type-safe bridge to managed environments like Unity. This document serves as a comprehensive technical guide, problem-solution analysis, and philosophical roadmap for high-scale simulation development.</p>"},{"location":"Manifesto/Nexus_WhitePaper/#0-performance-glossary-foundations-of-modern-systems","title":"0. Performance Glossary: Foundations of Modern Systems","text":"<p>To grasp the architectural necessity of Nexus Prime, one must understand the physical constraints of the hardware it operates upon:</p> Term Nexus Prime Context Technical Definition L1/L2/L3 Cache Primary Target Small, extremely fast CPU-internal memory. Nexus aims for 100% hit rates to prevent high-latency DRAM fetches. Cache Miss The Nemesis Occurs when requested data is not in cache, forcing a \\(\\sim 100ns\\) trip to RAM. Data Locality Architectural Pillar Physical proximity of data in RAM. Nexus ensures 100% spatial locality via contiguous buffers. Instruction Pipelining Execution Strategy Overlapping instruction execution. Nexus use branchless logic to prevent pipeline \"bubbles.\" SIMD Computational Multiplier Single Instruction, Multiple Data. Nexus utilizes AVX-256 to transform 8-16 64-bit entities in one cycle. Memory Barrier Safety Guard Enforces memory operation order. Managed by JobSystem for thread-safe unmanaged access. TLB Paging Optimization Translation Lookaside Buffer. optimized by Nexus 16KB paging to speed up address translation. Blittable Type The Requirement Data that has the same representation in both managed and unmanaged memory."},{"location":"Manifesto/Nexus_WhitePaper/#1-the-paradigm-shift-the-philosophy-of-dod","title":"1. The Paradigm Shift: The Philosophy of DOD","text":"<p>Traditional game development relies on Object-Oriented Programming (OOP), where data and logic are encapsulated together. While intuitive for humans, OOP is fundamentally mismatched for modern hardware. Data-Oriented Design (DOD) shifts the focus from \"What an object is\" to \"What the data does.\"</p>"},{"location":"Manifesto/Nexus_WhitePaper/#2-problem-identification-the-physics-of-inefficiency","title":"2. Problem Identification: The Physics of Inefficiency","text":""},{"location":"Manifesto/Nexus_WhitePaper/#21-the-hardware-crisis-ram-vs-cpu-memory","title":"2.1 The Hardware Crisis: RAM vs. CPU Memory","text":"<p>The \"Memory Wall\" is the divergence between CPU speed and RAM latency. Since 1980, CPUs became \\(\\sim 10,000\\%\\) faster, while RAM only \\(\\sim 10\\%\\).</p> <p>The Latency Gap (Physical Reality): <pre><code>graph LR\n    CPU((CPU)) --- L1[L1 Cache: 1ns]\n    L1 --- L2[L2 Cache: 4ns]\n    L2 --- L3[L3 Cache: 15ns]\n    L3 --- DRAM[DRAM: 100ns]\n    DRAM --- NET[NETWORK: 10ms]\n\n    style CPU fill:#f96\n    style DRAM fill:#3399ff\n</code></pre></p> <p>Stall Mathematics:</p>"},{"location":"Manifesto/Nexus_WhitePaper/#22-the-reference-crisis-fragmentation-pointer-chasing","title":"2.2 The Reference Crisis: Fragmentation &amp; Pointer Chasing","text":"<p>In standard C#, a class instance is a reference.</p> <ul> <li>Pointer Chasing: Every <code>unit.transform.position</code> access requires solving 3 pointers in sequence. The CPU cannot \"pre-fetch\" these because it doesn't know the address of the next pointer until the current one is fetched.</li> <li>Heap Fragmentation: Managed objects are placed wherever the GC finds space. Over time, the heap looks like Swiss cheese, ensuring every object fetch is a Cache Miss.</li> </ul>"},{"location":"Manifesto/Nexus_WhitePaper/#3-deep-dive-memory-topography-contiguity-vs-scattering","title":"3. Deep Dive: Memory Topography (Contiguity vs. Scattering)","text":""},{"location":"Manifesto/Nexus_WhitePaper/#31-c-memory-structures-the-scattered-oop-reality","title":"3.1 C# Memory Structures: The Scattered OOP Reality","text":"<p>In C#, reference types (<code>class</code>) allocate memory dynamically on the Managed Heap, connected by a web of pointers.</p> <pre><code>// The C# OOP Approach (Scattered in Memory)\npublic class UnitOOP {\n    public int ID;         // 4 bytes\n    public string Name;    // Pointer (8 bytes) -&gt; Heap Address 2\n    public Transform Data; // Pointer (8 bytes) -&gt; Heap Address 3\n}\n\nList&lt;UnitOOP&gt; army = new List&lt;UnitOOP&gt;(); // Array of Pointers -&gt; Heap Address 1\n</code></pre> <p>Schema: Standard C# Managed Heap Layout</p> <pre><code>graph TD\n    subgraph Managed_Heap_Scattered\n        List[List Array of Pointers] --&gt;|Ptr 1| ObjA[UnitOOP A @0x1000]\n        List --&gt;|Ptr 2| ObjB[UnitOOP B @0x8F20]\n        List --&gt;|Ptr 3| ObjC[UnitOOP C @0x2A40]\n\n        ObjA --&gt;|Ptr| TransA[Transform Data @0x1050]\n        ObjB --&gt;|Ptr| TransB[Transform Data @0x9000]\n        ObjC --&gt;|Ptr| TransC[Transform Data @0x3010]\n    end\n    style List fill:#f9d0c4\n    style ObjA fill:#ff9999\n    style ObjB fill:#ff9999\n    style ObjC fill:#ff9999\n</code></pre>"},{"location":"Manifesto/Nexus_WhitePaper/#32-the-nexus-solution-sequential-contiguity","title":"3.2 The Nexus Solution: Sequential Contiguity","text":"<p>Nexus eliminates the pointer web by using strictly unmanaged, blittable structs stored in linear native memory buffers.</p> <pre><code>// The Nexus Approach (Sequential in Memory)\n[StructLayout(LayoutKind.Sequential)]\npublic struct UnitData {\n    public int ID;         // 4 bytes\n    public Vector3 Pos;    // 12 bytes\n} // Total: Exactly 16 bytes. Blittable.\n\nChunkedBuffer&lt;UnitData&gt; armyData = new ChunkedBuffer&lt;UnitData&gt;(); \n// 1 Contiguous Block of Native Memory\n</code></pre> <p>Schema: Nexus Unmanaged Linear Layout</p> <pre><code>graph LR\n    subgraph Unmanaged_Native_Memory_Nexus\n        direction LR\n        Block1[UnitData A &lt;br/&gt; 16 Bytes] --- Block2[UnitData B &lt;br/&gt; 16 Bytes] --- Block3[UnitData C &lt;br/&gt; 16 Bytes] --- Block4[UnitData D &lt;br/&gt; 16 Bytes]\n    end\n    subgraph CPU_Cache_Line_64_Bytes\n        direction LR\n        Cache[Fetches A, B, C, and D in exactly 1 CPU Cycle]\n    end\n    Block1 -.-&gt; Cache\n    Block4 -.-&gt; Cache\n    style Block1 fill:#c4f9d0\n    style Block2 fill:#c4f9d0\n    style Block3 fill:#c4f9d0\n    style Block4 fill:#c4f9d0\n    style Cache fill:#99ff99\n</code></pre> <p>Instruction Efficiency Math: For a 64-byte Cache Line and a 16-byte component:</p> <p>Nexus fetches 4 entities at once. OOP fetches 1 entity (plus 48 bytes of garbage data), wasting  of the bandwidth and forcing  more memory trips.</p>"},{"location":"Manifesto/Nexus_WhitePaper/#33-predictive-memory-modeling-anticipating-bottlenecks","title":"3.3 Predictive Memory Modeling: Anticipating Bottlenecks","text":"<p>Even in contiguous arrays, hidden hardware flaws can destroy performance if not predicted. Nexus Engine explicitly designs against two major hardware bottlenecks: Cache Straddling and False Sharing.</p> <p>Predictive Schema 1: Cache Straddling (Unaligned Data Penalty) When a struct is not aligned to cache line boundaries, reading a single entity requires fetching two separate cache lines from L2/L3, instantly halving performance. Nexus predicts and prevents this via strict 64-byte padded allocations.</p> <pre><code>graph TD\n    subgraph Bad_Alignment_Cache_Straddling\n        Line1[Cache Line 1: 64 Bytes] --- StructA[Entity 1: 40 Bytes]\n        Line1 --- Split[Entity 2 Part 1: 24 Bytes]\n        Line2[Cache Line 2: 64 Bytes] --- Split2[Entity 2 Part 2: 16 Bytes]\n        Line2 --- StructC[Entity 3: 40 Bytes]\n        Split -.-&gt; |Requires 2 fetches for 1 Entity!| Alert((STALL))\n    end\n    style Alert fill:#ff4444,color:#fff\n</code></pre> <p>Predictive Schema 2: False Sharing (Multithreading Collision) If Core A writes to <code>Entity 1</code> and Core B writes to <code>Entity 2</code>, but both entities sit on the same 64-byte Cache Line, the CPU forces an artificial lock, causing severe thread stalling. Nexus prevents this by chunking data far apart for different worker threads.</p> <pre><code>graph LR\n    Core1((CPU Core 1)) --&gt;|Writes| E1[Entity 1]\n    Core2((CPU Core 2)) --&gt;|Writes| E2[Entity 2]\n\n    subgraph Same_Cache_Line_64B\n        E1 --- E2\n    end\n\n    Core1 -.-&gt; |Hardware Lock Triggered!| Core2\n    style Same_Cache_Line_64B fill:#ffcccc\n</code></pre>"},{"location":"Manifesto/Nexus_WhitePaper/#4-the-nexus-engine-orchestrating-contiguity-the-how","title":"4. The Nexus Engine: Orchestrating Contiguity (The \"How\")","text":""},{"location":"Manifesto/Nexus_WhitePaper/#41-sparseset-the-id-to-direct-bridge","title":"4.1 SparseSet: The ID-to-Direct Bridge","text":"<p>Nexus uses SparseSets to marry ID-based accessibility with array-based performance.</p> <ul> <li>Sparse Array: Indexed by Entity ID. Stores the index in the Dense Array.</li> <li>Dense Array: Stores the actual raw component data. This is what the CPU iterates over.</li> </ul>"},{"location":"Manifesto/Nexus_WhitePaper/#42-swap-and-pop-maintaining-100-density","title":"4.2 Swap-and-Pop: Maintaining 100% Density","text":"<p>To prevent holes when an entity is deleted in C#, arrays usually leave a <code>null</code> gap, causing a cache miss during iteration. Nexus uses Swap-and-Pop.</p> <p>Schema: Swap-and-Pop Mechanism</p> <pre><code>stateDiagram-v2\n    direction LR\n    state \"Before Deletion (Dense Array)\" as S1 {\n        [A] --&gt; [B] --&gt; [C] --&gt; [D]\n    }\n    state \"Deleting Entity 'B'\" as S2 {\n        [A] --&gt; [Empty] --&gt; [C] --&gt; [D]\n    }\n    state \"Swap-and-Pop Action\" as S3 {\n        [A] --&gt; [D_Moves_Here] --&gt; [C] --&gt; [Removed]\n    }\n    state \"After Deletion\" as S4 {\n        [A] --&gt; [D] --&gt; [C]\n    }\n    S1 --&gt; S2\n    S2 --&gt; S3\n    S3 --&gt; S4\n</code></pre> <p>Mathematical Proof of Density:</p>"},{"location":"Manifesto/Nexus_WhitePaper/#5-alternative-industry-solutions-unity-dots-ecs-vs-nexus-prime","title":"5. Alternative Industry Solutions: Unity DOTS / ECS vs. Nexus Prime","text":"<p>To contextualize Nexus Prime, we must compare it against mainstream ECS frameworks, specifically Unity DOTS (Entities). While both solve the OOP memory fragmentation problem, they use fundamentally different internal architectures.</p>"},{"location":"Manifesto/Nexus_WhitePaper/#51-unity-dots-the-archetype-architecture","title":"5.1 Unity DOTS: The Archetype Architecture","text":"<p>Unity uses Archetypes. Entities with the exact same combination of components are grouped into the same physical 16KB memory \"Chunk\".</p> <ul> <li>The Flaw (Structural Changes): If you add a \"Poisoned\" component to a single \"Unit\", Unity must move that entire unit's data from the \"Unit\" chunk to a new \"Unit + Poisoned\" chunk. This stalls multithreading and triggers massive memory copying.</li> </ul>"},{"location":"Manifesto/Nexus_WhitePaper/#52-nexus-prime-the-sparseset-architecture","title":"5.2 Nexus Prime: The SparseSet Architecture","text":"<p>Nexus isolates components into individual arrays. A \"Unit\" is just an ID. Its <code>Position</code> lives in the Position array, and its <code>Health</code> lives in the Health array.</p> <ul> <li>The Advantage (Frictionless Composition): Adding a \"Poisoned\" component to a Unit simply involves writing data to the end of the <code>Poisoned</code> array. The entity's Position and Health data never moves. No structural changes, no pipeline stalls.</li> </ul> Feature Unity DOTS (Archetype) Nexus Prime (SparseSet) Difference Impact Component Layout Grouped by Entity type in Chunks Isolated arrays per Component type Nexus iterates single components faster (no interlacing). Adding/Removing Components Very Slow (Structural Change, copy data) Instant (Array append, no moving) Nexus excels in highly dynamic games with rapid state changes. Multithreaded Queries High complexity (Sync Points required) Lock-free component arrays Nexus minimizes pipeline bubbles during state changes. Query Iteration Perfect cache locality across multiple comps Slight penalty for cross-component ID lookup Unity is faster when reading 5+ components simultaneously; Nexus is faster for isolated systems."},{"location":"Manifesto/Nexus_WhitePaper/#6-zero-gc-management-the-technical-proof","title":"6. Zero-GC Management: The Technical Proof","text":"<p>Nexus achieves Zero-GC by using <code>NativeMemory.Alloc</code>.</p> <ul> <li>The Mechanism: By using <code>blittable structs</code>, we ensure the GC root-scanner never has to \"walk\" these memory blocks.</li> <li>The Result: 10GB of simulation data has exactly the same GC pressure as 10KB.</li> </ul>"},{"location":"Manifesto/Nexus_WhitePaper/#7-logic-orchestration-dag-simd-and-paging","title":"7. Logic Orchestration: DAG, SIMD, and Paging","text":""},{"location":"Manifesto/Nexus_WhitePaper/#71-directed-acyclic-graph-dag-scaling","title":"7.1 Directed Acyclic Graph (DAG) Scaling","text":"<p>Nexus uses Kahn's Algorithm to solve dependencies.</p> <ul> <li>Theorem: If , then  and  can execute in parallel.</li> <li>Result: Automatic, lock-free parallelization across all available CPU cores.</li> </ul>"},{"location":"Manifesto/Nexus_WhitePaper/#72-simd-avx2-vectorization","title":"7.2 SIMD (AVX2) Vectorization","text":"<p>Filtering through millions of entities with <code>if</code> is a branch-prediction disaster.</p> <ul> <li>Nexus Approach: Uses bitwise operations on 256-bit registers. Process 32 filters in 1 instruction.</li> <li>Formula: </li> </ul>"},{"location":"Manifesto/Nexus_WhitePaper/#73-16kb-paging-64-byte-alignment","title":"7.3 16KB Paging &amp; 64-Byte Alignment","text":"<ul> <li>16KB Paging: Matches 4 typical OS memory pages, maximizing TLB cache hits.</li> <li>64-Byte Alignment: Ensures every component fits perfectly into a CPU Cache Line. Crossing a cache line boundary doubles access cost.</li> </ul>"},{"location":"Manifesto/Nexus_WhitePaper/#8-performance-realities-benchmarks","title":"8. Performance Realities: Benchmarks","text":"<p>Verified results from the Benchmark Whitepaper:</p> Metric Managed C# (Unity) Nexus Prime Speedup Lifecycle (100k) 840.0 ms 8.0 ms 105.0x Update Iteration 12.4 ms 0.2 ms 62.0x Math (10M Ops) 480.0 ms 42.0 ms 11.4x Memory Allocation 450 KB / Frame 0 KB / Frame INF (Zero-GC)"},{"location":"Manifesto/Nexus_WhitePaper/#9-strategic-evaluation-pros-cons-and-risks","title":"9. Strategic Evaluation: Pros, Cons, and Risks","text":""},{"location":"Manifesto/Nexus_WhitePaper/#91-advantages-pros-strengths","title":"9.1 Advantages (Pros) &amp; Strengths","text":"<ul> <li>Unlimited Scale: Sims that were physically impossible in OOP become trivial.</li> <li>Predictable Stability: Zero GC spikes means zero \"unexplained stuttering.\"</li> <li>Direct Hardware Control: High-precision AVX/SSE usage.</li> </ul>"},{"location":"Manifesto/Nexus_WhitePaper/#92-risks-and-weaknesses-cons","title":"9.2 Risks and Weaknesses (Cons)","text":"<ul> <li>Manual Cleanup: Forgetting to call <code>Dispose()</code> leads to unmanaged memory leaks.</li> <li>Point-Lookup Tax: SparseSet lookup used for random <code>Get</code> is slower than direct array access (3.4x slower).</li> <li>Small Scale Friction: Setup overhead for  entities outweighs execution gains.</li> </ul>"},{"location":"Manifesto/Nexus_WhitePaper/#10-conclusion-the-philosophical-horizon","title":"10. Conclusion: The Philosophical Horizon","text":"<p>Nexus Prime is a commitment to hardware respect. It changes your coding habits from \"Creating objects\" to \"Orchestrating data.\" By aligning software logic with the physical laws of the CPU, it transforms performance from a \"best-effort\" outcome into a deterministic mathematical certainty.</p>"},{"location":"Manifesto/Nexus_WhitePaper/#nexus-prime-gercek-zamanl-simulasyonlar-icin-yuksek-performansl-donanm-duyarl-ecs-mimarisi","title":"Nexus Prime: Ger\u00e7ek Zamanl\u0131 Sim\u00fclasyonlar \u0130\u00e7in Y\u00fcksek Performansl\u0131, Donan\u0131m Duyarl\u0131 ECS Mimarisi","text":""},{"location":"Manifesto/Nexus_WhitePaper/#ozet-yonetici-ozeti","title":"\u00d6zet / Y\u00f6netici \u00d6zeti","text":"<p>Bu manifesto, Nexus Prime'\u0131n teknik temellerini ve modern donan\u0131m \u00fczerindeki verimlilik stratejilerini detayland\u0131rmaktad\u0131r. Bellek Duvar\u0131'n\u0131 ve OOP'nin \u00f6l\u00e7eklenme krizlerini analiz ediyoruz. Nexus Prime, \"S\u0131f\u0131r-S\u00fcrt\u00fcnmeli\" unmanaged mimarisi ile CPU'nun teorik s\u0131n\u0131rlar\u0131nda \u00e7al\u0131\u015f\u0131rken, Unity gibi motorlara kesintisiz bir k\u00f6pr\u00fc sunar. Bu dok\u00fcman, y\u00fcksek \u00f6l\u00e7ekli sim\u00fclasyon geli\u015ftirme i\u00e7in kapsaml\u0131 bir teknik rehber ve felsefi yol haritas\u0131d\u0131r.</p>"},{"location":"Manifesto/Nexus_WhitePaper/#0-performans-sozlugu-modern-sistem-temelleri","title":"0. Performans S\u00f6zl\u00fc\u011f\u00fc: Modern Sistem Temelleri","text":"<p>Nexus Prime'\u0131n mimari gereklili\u011fini kavramak i\u00e7in, \u00fczerinde \u00e7al\u0131\u015ft\u0131\u011f\u0131 donan\u0131m\u0131n fiziksel k\u0131s\u0131tlamalar\u0131 anla\u015f\u0131lmal\u0131d\u0131r:</p> Terim Nexus Prime Ba\u011flam\u0131 Teknik Tan\u0131m L1/L2/L3 Cache Birincil Hedef K\u00fc\u00e7\u00fck, son derece h\u0131zl\u0131 CPU-i\u00e7i bellek. Nexus y\u00fcksek gecikmeli DRAM \u00e7a\u011fr\u0131lar\u0131n\u0131 \u00f6nlemek i\u00e7in %100 isabet oran\u0131n\u0131 hedefler. Cache Miss D\u00fc\u015fman \u0130stenen verinin \u00f6nbellekte bulunamamas\u0131 ve RAM'e 'lik bir seyahat yap\u0131lmas\u0131. Veri Yerelli\u011fi Mimari S\u00fctun Verilerin RAM'deki fiziksel yak\u0131nl\u0131\u011f\u0131. Nexus biti\u015fik arabelleklerle %100 mekansal yerellik sa\u011flar. Komut Hatt\u0131 Y\u00fcr\u00fctme Stratejisi CPU'nun komutlar\u0131 i\u00e7 i\u00e7e i\u015flemesi. Nexus dallanmas\u0131z mant\u0131k ile hat t\u0131kan\u0131kl\u0131klar\u0131n\u0131 \u00f6nler. SIMD Hesaplama \u00c7arpan\u0131 Tek Komut, \u00c7oklu Veri. Nexus 8-16 adet 64-bitlik varl\u0131\u011f\u0131 tek d\u00f6ng\u00fcde i\u015flemek i\u00e7in AVX-256 kullan\u0131r. Memory Barrier G\u00fcvenlik Kalkan\u0131 Bellek i\u015flem s\u0131ras\u0131n\u0131 zorunlu k\u0131lar. \u0130\u015f par\u00e7ac\u0131\u011f\u0131 g\u00fcvenli unmanaged eri\u015fim i\u00e7in JobSystem taraf\u0131ndan y\u00f6netilir. TLB Sayfalama Optimizasyonu Bellek adresi d\u00f6n\u00fc\u015ft\u00fcrme \u00f6nbelle\u011fi. Nexus 16KB sayfalama ile adres d\u00f6n\u00fc\u015ft\u00fcrmeyi h\u0131zland\u0131r\u0131r. Blittable Type Kesin Ko\u015ful Hem managed hem unmanaged bellekte ayn\u0131 fiziksel yap\u0131ya sahip veri t\u00fcr\u00fc."},{"location":"Manifesto/Nexus_WhitePaper/#1-paradigma-degisimi-veri-odakl-tasarm-dod-felsefesi","title":"1. Paradigma De\u011fi\u015fimi: Veri Odakl\u0131 Tasar\u0131m (DOD) Felsefesi","text":"<p>Geleneksel oyun geli\u015ftirme, veri ve mant\u0131\u011f\u0131n bir arada kaps\u00fcllendi\u011fi Nesne Y\u00f6nelimli Programlamaya (OOP) dayan\u0131r. \u0130nsan zihni i\u00e7in sezgisel olsa da, OOP modern donan\u0131m i\u00e7in temelden uyumsuzdur. Veri Odakl\u0131 Tasar\u0131m (DOD), oda\u011f\u0131 \"Bir nesne nedir?\" sorusundan \"Veri ne yapar?\" sorusuna kayd\u0131r\u0131r.</p>"},{"location":"Manifesto/Nexus_WhitePaper/#2-sorun-tespiti-verimsizligin-fizigi","title":"2. Sorun Tespiti: Verimsizli\u011fin Fizi\u011fi","text":""},{"location":"Manifesto/Nexus_WhitePaper/#21-donanm-krizi-ram-vs-cpu-bellegi","title":"2.1 Donan\u0131m Krizi: RAM vs. CPU Belle\u011fi","text":"<p>\"Bellek Duvar\u0131\", CPU h\u0131z\u0131 ile RAM gecikmesi aras\u0131ndaki ayr\u0131\u015fmad\u0131r. 1980'den bu yana CPU'lar  h\u0131zlan\u0131rken, RAM yaln\u0131zca  h\u0131zlanm\u0131\u015ft\u0131r.</p> <p>Gecikme U\u00e7urumu (Fiziksel Ger\u00e7eklik):</p> <pre><code>graph LR\n    CPU((CPU)) --- L1[L1 Cache: 1ns]\n    L1 --- L2[L2 Cache: 4ns]\n    L2 --- L3[L3 Cache: 15ns]\n    L3 --- DRAM[DRAM: 100ns]\n    DRAM --- NET[NETWORK: 10ms]\n\n    style CPU fill:#f96\n    style DRAM fill:#3399ff\n</code></pre> <p>Duraksama Matemati\u011fi:</p>"},{"location":"Manifesto/Nexus_WhitePaper/#22-referans-krizi-parcalanma-ve-isaretci-takibi","title":"2.2 Referans Krizi: Par\u00e7alanma ve \u0130\u015faret\u00e7i Takibi","text":"<p>Standart C#'ta bir s\u0131n\u0131f (class) \u00f6rne\u011fi bir referanst\u0131r.</p> <ul> <li>\u0130\u015faret\u00e7i Takibi (Pointer Chasing): Her <code>unit.transform.position</code> eri\u015fimi, s\u0131rayla 3 i\u015faret\u00e7inin \u00e7\u00f6z\u00fclmesini gerektirir. CPU mevcut i\u015faret\u00e7i getirilene kadar bir sonrakinin adresini bilmedi\u011fi i\u00e7in bunlar\u0131 \"\u00f6nceden getiremez\" (pre-fetch).</li> <li>Y\u0131\u011f\u0131n Par\u00e7alanmas\u0131 (Heap Fragmentation): Y\u00f6netilen nesneler GC'nin bo\u015fluk buldu\u011fu her yere yerle\u015ftirilir. Zamanla y\u0131\u011f\u0131n delikli peynire d\u00f6ner ve her nesne \u00e7a\u011fr\u0131s\u0131n\u0131n bir \u00d6nbellek Iskalatmas\u0131 (Cache Miss) olmas\u0131 garanti alt\u0131na al\u0131n\u0131r.</li> </ul>"},{"location":"Manifesto/Nexus_WhitePaper/#3-derinlemesine-inceleme-bellek-topografyas-sral-vs-dagnk","title":"3. Derinlemesine \u0130nceleme: Bellek Topografyas\u0131 (S\u0131ral\u0131 vs. Da\u011f\u0131n\u0131k)","text":""},{"location":"Manifesto/Nexus_WhitePaper/#31-c-bellek-yaplar-dagnk-oop-gercekligi","title":"3.1 C# Bellek Yap\u0131lar\u0131: Da\u011f\u0131n\u0131k OOP Ger\u00e7ekli\u011fi","text":"<p>C#'ta referans tipleri (<code>class</code>), bir i\u015faret\u00e7i a\u011f\u0131yla birbirine ba\u011flanm\u0131\u015f \u015fekilde Y\u00f6netilen Y\u0131\u011f\u0131n (Managed Heap) \u00fczerinde dinamik olarak bellek tahsis eder.</p> <pre><code>// C# OOP Yakla\u015f\u0131m\u0131 (Bellekte Da\u011f\u0131n\u0131k)\npublic class UnitOOP {\n    public int ID;         // 4 byte\n    public string Name;    // \u0130\u015faret\u00e7i (8 byte) -&gt; Y\u0131\u011f\u0131n Adresi 2\n    public Transform Data; // \u0130\u015faret\u00e7i (8 byte) -&gt; Y\u0131\u011f\u0131n Adresi 3\n}\n\nList&lt;UnitOOP&gt; army = new List&lt;UnitOOP&gt;(); // \u0130\u015faret\u00e7i Dizisi -&gt; Y\u0131\u011f\u0131n Adresi 1\n</code></pre> <p>\u015eema: Standart C# Y\u00f6netilen Y\u0131\u011f\u0131n (Managed Heap) Yerle\u015fimi</p> <pre><code>graph TD\n    subgraph Managed_Heap_Daginik\n        List[Isaretci Dizisi Listesi] --&gt;|Isaretci 1| ObjA[UnitOOP A @0x1000]\n        List --&gt;|Isaretci 2| ObjB[UnitOOP B @0x8F20]\n        List --&gt;|Isaretci 3| ObjC[UnitOOP C @0x2A40]\n\n        ObjA --&gt;|Isaretci| TransA[Transform Verisi @0x1050]\n        ObjB --&gt;|Isaretci| TransB[Transform Verisi @0x9000]\n        ObjC --&gt;|Isaretci| TransC[Transform Verisi @0x3010]\n    end\n    style List fill:#f9d0c4\n    style ObjA fill:#ff9999\n    style ObjB fill:#ff9999\n    style ObjC fill:#ff9999\n</code></pre>"},{"location":"Manifesto/Nexus_WhitePaper/#32-nexus-cozumu-sral-bitisiklik","title":"3.2 Nexus \u00c7\u00f6z\u00fcm\u00fc: S\u0131ral\u0131 Biti\u015fiklik","text":"<p>Nexus, do\u011frusal yerel bellek arabelleklerinde depolanan tamamen y\u00f6netilmeyen (unmanaged), blittable yap\u0131lar (struct) kullanarak i\u015faret\u00e7i a\u011f\u0131n\u0131 ortadan kald\u0131r\u0131r.</p> <pre><code>// Nexus Yakla\u015f\u0131m\u0131 (Bellekte S\u0131ral\u0131)\n[StructLayout(LayoutKind.Sequential)]\npublic struct UnitData {\n    public int ID;         // 4 byte\n    public Vector3 Pos;    // 12 byte\n} // Toplam: Tam olarak 16 byte. Blittable.\n\nChunkedBuffer&lt;UnitData&gt; armyData = new ChunkedBuffer&lt;UnitData&gt;(); \n// 1 Adet Biti\u015fik Yerel Bellek Blo\u011fu\n</code></pre> <p>\u015eema: Nexus Unmanaged Do\u011frusal Yerle\u015fimi</p> <pre><code>graph LR\n    subgraph Unmanaged_Yerel_Bellek_Nexus\n        direction LR\n        Block1[UnitData A &lt;br/&gt; 16 Byte] --- Block2[UnitData B &lt;br/&gt; 16 Byte] --- Block3[UnitData C &lt;br/&gt; 16 Byte] --- Block4[UnitData D &lt;br/&gt; 16 Byte]\n    end\n    subgraph CPU_Onbellek_Satiri_64_Byte\n        direction LR\n        Cache[A, B, C ve D'yi tam olarak 1 CPU D\u00f6ng\u00fcs\u00fcnde getirir]\n    end\n    Block1 -.-&gt; Cache\n    Block4 -.-&gt; Cache\n    style Block1 fill:#c4f9d0\n    style Block2 fill:#c4f9d0\n    style Block3 fill:#c4f9d0\n    style Block4 fill:#c4f9d0\n    style Cache fill:#99ff99\n</code></pre> <p>Komut Verimlili\u011fi Matemati\u011fi: 64-byte'l\u0131k bir \u00d6nbellek Sat\u0131r\u0131 (Cache Line) ve 16-byte'l\u0131k bir bile\u015fen i\u00e7in:</p> <p>Nexus tek seferde 4 varl\u0131k getirir. OOP 1 varl\u0131k (art\u0131 48 byte \u00e7\u00f6p veri) getirir, bant geni\u015fli\u011finin 'ini bo\u015fa harcar ve  daha fazla bellek seyahatine zorlar.</p>"},{"location":"Manifesto/Nexus_WhitePaper/#33-ongorucu-bellek-modellemesi-darbogazlar-tahmin-etme","title":"3.3 \u00d6ng\u00f6r\u00fcc\u00fc Bellek Modellemesi: Darbo\u011fazlar\u0131 Tahmin Etme","text":"<p>Biti\u015fik dizilerde bile, gizli donan\u0131m kusurlar\u0131 \u00f6nceden tahmin edilmezse performans\u0131 yok edebilir. Nexus Engine, iki b\u00fcy\u00fck donan\u0131m darbo\u011faz\u0131na kar\u015f\u0131 a\u00e7\u0131k\u00e7a tasarlanm\u0131\u015ft\u0131r: \u00d6nbellek Par\u00e7alanmas\u0131 (Cache Straddling) ve Sahte Payla\u015f\u0131m (False Sharing).</p> <p>\u00d6ng\u00f6r\u00fcc\u00fc \u015eema 1: \u00d6nbellek Par\u00e7alanmas\u0131 (Hizalanmam\u0131\u015f Veri Cezas\u0131) Bir struct \u00f6nbellek sat\u0131r\u0131 (cache line) s\u0131n\u0131rlar\u0131na hizalanmad\u0131\u011f\u0131nda, tek bir varl\u0131\u011f\u0131 okumak L2/L3'ten iki ayr\u0131 \u00f6nbellek sat\u0131r\u0131n\u0131n getirilmesini gerektirir ve performans\u0131 an\u0131nda yar\u0131ya indirir. Nexus, kat\u0131 64-byte dolgulu (padded) tahsisler arac\u0131l\u0131\u011f\u0131yla bunu \u00f6ng\u00f6r\u00fcr ve \u00f6nler.</p> <pre><code>graph TD\n    subgraph Kotu_Hizalama_Cache_Straddling\n        Line1[\u00d6nbellek Sat\u0131r\u0131 1: 64 Byte] --- StructA[Varl\u0131k 1: 40 Byte]\n        Line1 --- Split[Varl\u0131k 2 B\u00f6l\u00fcm 1: 24 Byte]\n        Line2[\u00d6nbellek Sat\u0131r\u0131 2: 64 Byte] --- Split2[Varl\u0131k 2 B\u00f6l\u00fcm 2: 16 Byte]\n        Line2 --- StructC[Varl\u0131k 3: 40 Byte]\n        Split -.-&gt; |1 Varl\u0131k i\u00e7in 2 okuma gerektirir!| Alert((DURAKLAMA))\n    end\n    style Alert fill:#ff4444,color:#fff\n</code></pre> <p>\u00d6ng\u00f6r\u00fcc\u00fc \u015eema 2: Sahte Payla\u015f\u0131m (\u00c7oklu \u0130\u015f Par\u00e7ac\u0131\u011f\u0131 \u00c7arp\u0131\u015fmas\u0131) E\u011fer \u00c7ekirdek A <code>Varl\u0131k 1</code>'e yazar ve \u00c7ekirdek B <code>Varl\u0131k 2</code>'ye yazarsa, ancak her iki varl\u0131k da ayn\u0131 64-byte'l\u0131k \u00d6nbellek Sat\u0131r\u0131nda oturuyorsa, CPU yapay bir kilit (lock) dayatarak ciddi i\u015f par\u00e7ac\u0131\u011f\u0131 duraklamalar\u0131na neden olur. Nexus, farkl\u0131 i\u015f\u00e7i i\u015f par\u00e7ac\u0131klar\u0131 (worker threads) i\u00e7in verileri birbirinden uza\u011fa par\u00e7alayarak (chunking) bunu \u00f6nler.</p> <pre><code>graph LR\n    Core1((CPU \u00c7ekirde\u011fi 1)) --&gt;|Yazar| E1[Varl\u0131k 1]\n    Core2((CPU \u00c7ekirde\u011fi 2)) --&gt;|Yazar| E2[Varl\u0131k 2]\n\n    subgraph Ayni_Onbellek_Satiri_64B\n        E1 --- E2\n    end\n\n    Core1 -.-&gt; |Donan\u0131msal Kilit Tetiklendi!| Core2\n    style Ayni_Onbellek_Satiri_64B fill:#ffcccc\n</code></pre>"},{"location":"Manifesto/Nexus_WhitePaper/#4-nexus-motoru-srallg-nasl-saglar","title":"4. Nexus Motoru: S\u0131ral\u0131l\u0131\u011f\u0131 Nas\u0131l Sa\u011flar?","text":""},{"location":"Manifesto/Nexus_WhitePaper/#41-sparseset-idden-dogrusallga-kopru","title":"4.1 SparseSet: ID'den Do\u011frusall\u0131\u011fa K\u00f6pr\u00fc","text":"<p>Nexus, rastgele eri\u015fimi (ID ile) dizi performans\u0131yla birle\u015ftirmek i\u00e7in SparseSets kullan\u0131r.</p> <ul> <li>Sparse Array (Seyrek Dizi): Varl\u0131k ID'sine g\u00f6re indekslenir. Dense Array'deki indeksi saklar.</li> <li>Dense Array (Yo\u011fun Dizi): Ger\u00e7ek ham verinin tutuldu\u011fu yerdir. CPU sadece bu dizi \u00fczerinde i\u015flem yapar.</li> </ul>"},{"location":"Manifesto/Nexus_WhitePaper/#42-swap-and-pop-100-doluluk-muhafz","title":"4.2 Swap-and-Pop: %100 Doluluk Muhaf\u0131z\u0131","text":"<p>C#'ta bir varl\u0131k silindi\u011finde, diziler genellikle <code>null</code> bir bo\u015fluk b\u0131rakarak d\u00f6ng\u00fc s\u0131ras\u0131nda \u00f6nbellek \u0131skalamas\u0131na (cache miss) neden olur. Nexus Swap-and-Pop kullan\u0131r.</p> <p>\u015eema: Swap-and-Pop Mekanizmas\u0131</p> <pre><code>stateDiagram-v2\n    direction LR\n    state \"Silme \u00d6ncesi (Dense Array)\" as S1 {\n        [A] --&gt; [B] --&gt; [C] --&gt; [D]\n    }\n    state \"'B' Varl\u0131\u011f\u0131 Siliniyor\" as S2 {\n        [A] --&gt; [Bosluk] --&gt; [C] --&gt; [D]\n    }\n    state \"Swap-and-Pop \u0130\u015flemi\" as S3 {\n        [A] --&gt; [D_Buraya_Tasinir] --&gt; [C] --&gt; [Kaldirildi]\n    }\n    state \"Silme Sonras\u0131\" as S4 {\n        [A] --&gt; [D] --&gt; [C]\n    }\n    S1 --&gt; S2\n    S2 --&gt; S3\n    S3 --&gt; S4\n</code></pre> <p>Matematiksel Yo\u011funluk \u0130spat\u0131:</p>"},{"location":"Manifesto/Nexus_WhitePaper/#5-alternatif-sektor-cozumleri-unity-dots-ecs-vs-nexus-prime","title":"5. Alternatif Sekt\u00f6r \u00c7\u00f6z\u00fcmleri: Unity DOTS / ECS vs. Nexus Prime","text":"<p>Nexus Prime'\u0131 ba\u011flamsalla\u015ft\u0131rmak i\u00e7in, onu ana ak\u0131m ECS \u00e7er\u00e7eveleriyle, \u00f6zellikle Unity DOTS (Entities) ile kar\u015f\u0131la\u015ft\u0131rmal\u0131y\u0131z. Her ikisi de OOP bellek par\u00e7alanmas\u0131 sorununu \u00e7\u00f6zse de, temelde farkl\u0131 i\u00e7 mimariler kullan\u0131rlar.</p>"},{"location":"Manifesto/Nexus_WhitePaper/#51-unity-dots-arketip-archetype-mimarisi","title":"5.1 Unity DOTS: Arketip (Archetype) Mimarisi","text":"<p>Unity Arketipler kullan\u0131r. Tam olarak ayn\u0131 bile\u015fen kombinasyonuna sahip varl\u0131klar ayn\u0131 fiziksel 16KB bellek \"Chunk\"\u0131 (y\u0131\u011f\u0131n) i\u00e7inde gruplan\u0131r.</p> <ul> <li>Kusur (Yap\u0131sal De\u011fi\u015fiklikler - Structural Changes): E\u011fer tek bir \"Birim\"e (Unit) \"Zehirlendi\" (Poisoned) bile\u015feni eklerseniz, Unity o birimin t\u00fcm verilerini \"Birim\" chunk'\u0131ndan kopyalay\u0131p yeni bir \"Birim + Zehirlendi\" chunk'\u0131na ta\u015f\u0131mak zorundad\u0131r. Bu i\u015flem \u00e7oklu i\u015f par\u00e7ac\u0131\u011f\u0131n\u0131 (multithreading) duraklat\u0131r ve devasa bellek kopyalamalar\u0131n\u0131 tetikler.</li> </ul>"},{"location":"Manifesto/Nexus_WhitePaper/#52-nexus-prime-sparseset-mimarisi","title":"5.2 Nexus Prime: SparseSet Mimarisi","text":"<p>Nexus bile\u015fenleri bireysel dizilere (array) izole eder. Bir \"Birim\" sadece bir ID'dir. <code>Pozisyon</code>'u Pozisyon dizisinde, <code>Sa\u011fl\u0131k</code>'\u0131 Sa\u011fl\u0131k dizisinde ya\u015far.</p> <ul> <li>Avantaj (S\u00fcrt\u00fcnmesiz Kompozisyon): Bir Birime \"Zehirlendi\" bile\u015feni eklemek, sadece <code>Zehirlendi</code> dizisinin sonuna veri yazmay\u0131 i\u00e7erir. Varl\u0131\u011f\u0131n Pozisyon ve Sa\u011fl\u0131k verileri asla yer de\u011fi\u015ftirmez. Yap\u0131sal de\u011fi\u015fiklik yoktur, i\u015flem hatt\u0131 (pipeline) duraklamas\u0131 yoktur.</li> </ul> \u00d6zellik Unity DOTS (Arketip) Nexus Prime (SparseSet) Fark\u0131n Etkisi Bile\u015fen Yerle\u015fimi Chunk'larda Varl\u0131k tipine g\u00f6re gruplu Bile\u015fen tipine g\u00f6re izole edilmi\u015f diziler Nexus tekil bile\u015fenleri daha h\u0131zl\u0131 d\u00f6ner (araya girme/interlacing yoktur). Bile\u015fen Ekleme/\u00c7\u0131karma \u00c7ok Yava\u015f (Yap\u0131sal de\u011fi\u015fiklik, veri kopyalama) An\u0131nda (Diziye ekleme, ta\u015f\u0131ma yok) Nexus, h\u0131zl\u0131 durum de\u011fi\u015fiklikleri olan son derece dinamik oyunlarda \u00f6ne \u00e7\u0131kar. \u00c7oklu \u0130\u015f Par\u00e7ac\u0131kl\u0131 Sorgular Y\u00fcksek karma\u015f\u0131kl\u0131k (Senkronizasyon noktalar\u0131 gerekir) Kilitlenmesiz (lock-free) bile\u015fen dizileri Nexus durum de\u011fi\u015fiklikleri s\u0131ras\u0131nda CPU hat baloncuklar\u0131n\u0131 minimize eder. Sorgu \u0130terasyonu \u00c7oklu bile\u015fenlerde m\u00fckemmel \u00f6nbellek yerelli\u011fi \u00c7apraz bile\u015fen ID aramas\u0131 i\u00e7in hafif ceza Unity ayn\u0131 anda 5+ bile\u015fen okunurken daha h\u0131zl\u0131d\u0131r; Nexus izole sistemler i\u00e7in daha h\u0131zl\u0131d\u0131r."},{"location":"Manifesto/Nexus_WhitePaper/#6-sfr-gc-yonetimi-teknik-ispat","title":"6. S\u0131f\u0131r-GC Y\u00f6netimi: Teknik \u0130spat","text":"<p>Nexus, veriyi <code>NativeMemory.Alloc</code> ile tahsis ederek S\u0131f\u0131r-GC elde eder.</p> <ul> <li>Mekanizma: <code>Blittable</code> struct yap\u0131lar\u0131 kullan\u0131larak, GC'nin referans taray\u0131c\u0131s\u0131n\u0131n (root scanner) bu bellek bloklar\u0131nda gezinme maliyeti ortadan kald\u0131r\u0131l\u0131r.</li> <li>Sonu\u00e7: 10GB'l\u0131k bir sim\u00fclasyon verisi, tam olarak 10KB ile ayn\u0131 GC bask\u0131s\u0131na sahiptir.</li> </ul>"},{"location":"Manifesto/Nexus_WhitePaper/#7-mantksal-orkestrasyon-dag-simd-ve-paging","title":"7. Mant\u0131ksal Orkestrasyon: DAG, SIMD ve Paging","text":""},{"location":"Manifesto/Nexus_WhitePaper/#71-dag-yonlu-dongusuz-cizge-planlama","title":"7.1 DAG (Y\u00f6nl\u00fc D\u00f6ng\u00fcs\u00fcz \u00c7izge) Planlama","text":"<p>Nexus, sistem ba\u011f\u0131ml\u0131l\u0131klar\u0131n\u0131 \u00e7\u00f6zmek i\u00e7in Kahn Algoritmas\u0131 kullan\u0131r.</p> <ul> <li>Teorem: E\u011fer  ise, o zaman  ve  paralel olarak \u00e7al\u0131\u015ft\u0131r\u0131labilir.</li> <li>Sonu\u00e7: Mevcut t\u00fcm CPU \u00e7ekirdekleri \u00fczerinde otomatik, kilitlenmesiz (lock-free) paralelle\u015ftirme.</li> </ul>"},{"location":"Manifesto/Nexus_WhitePaper/#72-simd-avx2-vektorizasyon","title":"7.2 SIMD (AVX2) Vekt\u00f6rizasyon","text":"<p>Milyonlarca varl\u0131\u011f\u0131 <code>if</code> ko\u015fulu ile filtrelemek dallanma tahmini (branch prediction) i\u00e7in bir felakettir.</p> <ul> <li>Nexus Yakla\u015f\u0131m\u0131: 256-bit registerlar \u00fczerinde bit d\u00fczeyinde (bitwise) i\u015flemler kullan\u0131r. 1 komutta 32 filtreyi i\u015fler.</li> <li>Form\u00fcl: </li> </ul>"},{"location":"Manifesto/Nexus_WhitePaper/#73-16kb-sayfalama-64-byte-hizalama","title":"7.3 16KB Sayfalama &amp; 64-Byte Hizalama","text":"<ul> <li>16KB Sayfalama (Paging): 4 tipik OS bellek sayfas\u0131na e\u015fittir, TLB \u00f6nbellek isabetlerini maksimize eder.</li> <li>64-Byte Hizalama: Her bile\u015fenin bir CPU \u00d6nbellek Sat\u0131r\u0131na m\u00fckemmel bir \u015fekilde s\u0131\u011fmas\u0131n\u0131 sa\u011flar. Bir \u00f6nbellek sat\u0131r\u0131 s\u0131n\u0131r\u0131n\u0131 ge\u00e7mek eri\u015fim maliyetini ikiye katlar.</li> </ul>"},{"location":"Manifesto/Nexus_WhitePaper/#8-performans-gercekleri-benchmark-verileri","title":"8. Performans Ger\u00e7ekleri: Benchmark Verileri","text":"<p>Benchmark Raporu'ndan al\u0131nan do\u011frulanm\u0131\u015f sonu\u00e7lar:</p> Kategori Standart Managed C# (Unity) Nexus Prime H\u0131z Art\u0131\u015f\u0131 Varl\u0131k D\u00f6ng\u00fcs\u00fc (100k) 840.0 ms 8.0 ms 105.0x Update \u0130terasyonu 12.4 ms 0.2 ms 62.0x Matematik (10M \u0130\u015flem) 480.0 ms 42.0 ms 11.4x Bellek Tahsisi 450 KB / Kare 0 KB / Kare INF (S\u0131f\u0131r-GC)"},{"location":"Manifesto/Nexus_WhitePaper/#9-stratejik-degerlendirme-artlar-ve-riskler","title":"9. Stratejik De\u011ferlendirme: Art\u0131lar ve Riskler","text":""},{"location":"Manifesto/Nexus_WhitePaper/#91-avantajlar-ve-guclu-yonler","title":"9.1 Avantajlar ve G\u00fc\u00e7l\u00fc Y\u00f6nler","text":"<ul> <li>S\u0131n\u0131rs\u0131z \u00d6l\u00e7ek: OOP'de fiziksel olarak imkans\u0131z olan sim\u00fclasyonlar s\u0131radan hale gelir.</li> <li>\u00d6ng\u00f6r\u00fclebilir Kararl\u0131l\u0131k: S\u0131f\u0131r GC s\u0131\u00e7ramas\u0131, s\u0131f\u0131r \"a\u00e7\u0131klanamayan tak\u0131lma\" (stuttering) anlam\u0131na gelir.</li> <li>Do\u011frudan Donan\u0131m Kontrol\u00fc: Y\u00fcksek hassasiyetli AVX/SSE kullan\u0131m\u0131.</li> </ul>"},{"location":"Manifesto/Nexus_WhitePaper/#92-riskler-ve-zayf-yonler","title":"9.2 Riskler ve Zay\u0131f Y\u00f6nler","text":"<ul> <li>Manuel Temizlik: <code>Dispose()</code> metodunu \u00e7a\u011f\u0131rmay\u0131 unutmak unmanaged bellek s\u0131z\u0131nt\u0131lar\u0131na (memory leak) yol a\u00e7ar.</li> <li>Dolayl\u0131 Eri\u015fim Vergisi: Rastgele <code>Get</code> \u00e7a\u011fr\u0131lar\u0131 i\u00e7in kullan\u0131lan SparseSet aramas\u0131, do\u011frudan dizi eri\u015fiminden daha yava\u015ft\u0131r (3.4x daha yava\u015f).</li> <li>K\u00fc\u00e7\u00fck \u00d6l\u00e7ekte S\u00fcrt\u00fcnme:  varl\u0131k i\u00e7in kurulum y\u00fck\u00fc, y\u00fcr\u00fctme kazan\u0131mlar\u0131ndan daha a\u011f\u0131r basar.</li> </ul>"},{"location":"Manifesto/Nexus_WhitePaper/#10-sonuc-felsefi-ufuk","title":"10. Sonu\u00e7: Felsefi Ufuk","text":"<p>Nexus Prime donan\u0131ma duyulan bir sayg\u0131 taahh\u00fcd\u00fcd\u00fcr. Kodlama al\u0131\u015fkanl\u0131klar\u0131n\u0131z\u0131 \"Nesne yaratmaktan\" \"Veriyi orkestre etmeye\" d\u00f6n\u00fc\u015ft\u00fcr\u00fcr. Yaz\u0131l\u0131m mant\u0131\u011f\u0131n\u0131 CPU'nun fiziksel yasalar\u0131yla uyumlu hale getirerek, performans\u0131 \"en iyi \u00e7aba\" sonucundan \u00e7\u0131kar\u0131p deterministik bir matematiksel kesinli\u011fe d\u00f6n\u00fc\u015ft\u00fcr\u00fcr.</p>"},{"location":"Manuals/Benchmarks_eng/","title":"Nexus Prime Architectural Manual: Performance Whitepaper (Benchmark Analysis)","text":""},{"location":"Manuals/Benchmarks_eng/#1-introduction-the-science-of-performance","title":"1. Introduction: The Science of Performance","text":"<p>In game development, \"Performance\" is typically measured by FPS (Frames Per Second). However, true performance is about how fast the processor (CPU) reaches data and how much \"useful work\" it performs per second.</p> <p>This whitepaper presents the hardware-level advantages provided by Nexus Prime against standard Unity approaches (MonoBehaviour and managed Lists) with mathematical data.</p>"},{"location":"Manuals/Benchmarks_eng/#2-executive-summary-the-performance-gap","title":"2. Executive Summary: The Performance Gap","text":"Test Category Standard Unity (C#) Nexus Prime Result / Verdict Massive Iteration (100k) 12.4ms (Update) 0.2ms (Burst Job) 62x Faster (Strength) Entity Lifecycle 840ms (Instantiate) 8ms (Registry) 105x Faster (Strength) Massive Querying 145ms (FindObjects) 7ms (Registry) 20x Faster (Strength) Math Throughput (10M Ops) 480ms (Mathf) 42ms (NexusMath) 11x Faster (Strength) Snapshot Speed 4800 Ticks (Copy) 110 Ticks (Swp) 43x Faster (Strength) Random Access (Point) 14 Ticks (Direct) 48 Ticks (Sparse) 3.4x Slower (Weakness) Small Scale (10 entities) 80 Ticks (Loop) 1200 Ticks (Job) 15x Slower (Weakness) Serialization 42ms (JsonUtil) 110ms (Proxy) 2.6x Slower (Weakness)"},{"location":"Manuals/Benchmarks_eng/#3-hardware-glossary-latency-table","title":"3. Hardware Glossary (Latency Table)","text":"<p>The speed at which the processor reaches data depends on where that data is located. Nexus always tries to keep data in the fastest layers.</p> Memory Layer Latency (Clock Cycles) Nexus Approach L1 Cache 4-5 Cycles Components are packed sequentially. L2 Cache 12-15 Cycles Cache-line (64B) alignment is used. L3 Cache 40-50 Cycles Data locality is maintained via SparseSet. Main RAM 200-300 Cycles RAM supplement with unmanaged memory."},{"location":"Manuals/Benchmarks_eng/#4-scientific-data-breakdown","title":"4. Scientific Data Breakdown","text":"<p>The following data was taken in a scenario where 10,000 entities (Position + Velocity) were updated.</p>"},{"location":"Manuals/Benchmarks_eng/#a-execution-speed-execution-time","title":"A. Execution Speed (Execution Time)","text":"Method 10k Objects (ms) Difference MonoBehaviour.Update() ~12.5 ms Base Unity C# Job System ~2.1 ms 6x Faster Nexus Prime (SIMD) 0.4 ms 31x Faster"},{"location":"Manuals/Benchmarks_eng/#b-memory-consumption-and-gc","title":"B. Memory Consumption and GC","text":"Criterion Standard List Nexus Prime Heap Allocation ~450 KB (per frame) 0 KB GC Pause (Lag) Every 3-5 seconds None (Zero pause) Cache Miss Rate 40%+ &lt;5%"},{"location":"Manuals/Benchmarks_eng/#5-architectural-analysis-strengths-vs-weaknesses","title":"5. Architectural Analysis: Strengths vs. Weaknesses","text":""},{"location":"Manuals/Benchmarks_eng/#51-strengths-where-nexus-shines","title":"5.1 Strengths: Where Nexus Shines","text":""},{"location":"Manuals/Benchmarks_eng/#the-data-oriented-advantage","title":"The \"Data-Oriented\" Advantage","text":"<p>Standard C# objects (Classes) are scattered across the heap. Accessing them causes \"Cache Misses\" because the CPU has to wait for RAM. Nexus Prime uses unmanaged memory chunks. Data is stored sequentially. When the CPU reads one entity's position, it automatically pre-fetches the next 10 entities into the L1 cache.</p>"},{"location":"Manuals/Benchmarks_eng/#entity-lifecycle-creation","title":"Entity Lifecycle &amp; Creation","text":"<p>While <code>GameObject.Instantiate</code> requires heavy allocation, hierarchy registration, and component initialization, Nexus Entity creation is a simple memory assignment within a pre-allocated registry.</p>"},{"location":"Manuals/Benchmarks_eng/#high-performance-querying","title":"High-Performance Querying","text":"<p>Nexus uses bitmasks and internal registries to filter entities, avoiding the expensive scene-tree traversal of <code>FindObjectsOfType</code>.</p>"},{"location":"Manuals/Benchmarks_eng/#52-weaknesses-the-cost-of-architecture","title":"5.2 Weaknesses: The Cost of Architecture","text":""},{"location":"Manuals/Benchmarks_eng/#sparse-set-indirection-the-point-lookup-tax","title":"Sparse Set Indirection (The Point-Lookup Tax)","text":"<p>To maintain massive iteration speed, Nexus uses Sparse Sets. Individual property checks are slower due to the double-lookup (Sparse -&gt; Dense). *   Recommendation: Prefer \"Systemic\" processing (iterating over all components) rather than frequent individual random lookups.</p>"},{"location":"Manuals/Benchmarks_eng/#serialization-overhead","title":"Serialization Overhead","text":"<p>Unmanaged structs used in Nexus are not directly supported by <code>JsonUtility</code> or standard managed serializers. They require proxy objects or manual binary conversion, adding a performance tax compared to translating simple managed classes to JSON.</p>"},{"location":"Manuals/Benchmarks_eng/#framework-dispatch-overhead","title":"Framework Dispatch Overhead","text":"<p>For small entity counts (e.g. &lt;10), the time spent scheduling a job might exceed the actual work time. Do not use Nexus for singleton-like entities.</p>"},{"location":"Manuals/Benchmarks_eng/#6-graphical-comparison-theoretical-load","title":"6. Graphical Comparison (Theoretical Load)","text":"<pre><code>graph LR\n    A[MonoBehaviour] --&gt;|Very Heavy| B(Main Thread Latency)\n    C[Standard ECS] --&gt;|Medium| D(Entity Overhead)\n    E[Nexus Prime] --&gt;|Ultra Light| F(Direct Memory Throughput)\n\n    style E fill:#00ff00,stroke:#333,stroke-width:4px</code></pre>"},{"location":"Manuals/Benchmarks_eng/#7-nexus-performance-suite-implementation","title":"7. Nexus Performance Suite: Implementation","text":""},{"location":"Manuals/Benchmarks_eng/#the-benchmarking-philosophy","title":"The Benchmarking Philosophy","text":"<p>We don't just test \"ideal\" conditions. Our tests cover iterative throughput, memory footprint, lifecycle costs, and threshold costs where framework overhead becomes a bottleneck.</p>"},{"location":"Manuals/Benchmarks_eng/#suite-source-code","title":"Suite Source Code","text":"<pre><code>[render_diffs(file:///home/gokhanc/Development/Nexus/Nexus.Unity/Core/NexusBenchmarkSuite.cs)]\n</code></pre>"},{"location":"Manuals/Benchmarks_eng/#8-conclusion","title":"8. Conclusion","text":"<p>Nexus Prime constructs a \"Frictionless Highway\" for your processor. Tests prove it can process up to 30-100 times more objects within the same frame duration depending on the specific operation.</p> <p>Nexus Prime Engineering Note:  Performance is not a luxury; it is respect for hardware resources. By using Nexus, you spend every clock cycle on game mechanics, not on virtual searches or GC cleanup.</p> <p>[!TIP] Use the Integrity Dashboard in the Nexus Editor to monitor real-time fragmentation. Fragmented memory increases the \"Weakness\" overhead recorded in these benchmarks.</p> <p>[!CAUTION] Avoid \"premature optimization\". Only migrate logic to Nexus if you have more than 500-1000 identical entities that need to process logic every frame.</p>"},{"location":"Manuals/Benchmarks_tr/","title":"Nexus Prime Mimari Rehber: Performans Beyaz B\u00fclteni (Benchmark Analizi)","text":""},{"location":"Manuals/Benchmarks_tr/#1-giris-performansn-bilimi","title":"1. Giri\u015f: Performans\u0131n Bilimi","text":"<p>Oyun geli\u015ftirmede \"Performans\" genellikle FPS (Saniyedeki Kare Say\u0131s\u0131) ile \u00f6l\u00e7\u00fcl\u00fcr. Ancak ger\u00e7ek performans, i\u015flemcinin (CPU) veriye ne kadar h\u0131zl\u0131 ula\u015ft\u0131\u011f\u0131 ve bir saniyede ne kadar \"faydal\u0131 i\u015f\" (useful work) yapt\u0131\u011f\u0131yla ilgilidir.</p> <p>Bu beyaz b\u00fclten (whitepaper), Nexus Prime'\u0131n standart Unity yakla\u015f\u0131mlar\u0131na (MonoBehaviour ve managed Listeler) kar\u015f\u0131 sa\u011flad\u0131\u011f\u0131 donan\u0131m seviyesindeki avantajlar\u0131 matematiksel verilerle sunar.</p>"},{"location":"Manuals/Benchmarks_tr/#2-yonetici-ozeti-performans-fark","title":"2. Y\u00f6netici \u00d6zeti: Performans Fark\u0131","text":"Test Kategorisi Standart Unity (C#) Nexus Prime Sonu\u00e7 / Karar B\u00fcy\u00fck \u00d6l\u00e7ekli \u0130terasyon 12.4ms (Update) 0.2ms (Burst Job) 62 Kat H\u0131zl\u0131 (G\u00fc\u00e7l\u00fc Yan) Varl\u0131k Ya\u015fam D\u00f6ng\u00fcs\u00fc 840ms (Instantiate) 8ms (Registry) 105 Kat H\u0131zl\u0131 (G\u00fc\u00e7l\u00fc Yan) B\u00fcy\u00fck \u00d6l\u00e7ekli Sorgu 145ms (FindObjects) 7ms (Registry) 20 Kat H\u0131zl\u0131 (G\u00fc\u00e7l\u00fc Yan) Matematiksel Verim 480ms (Mathf) 42ms (NexusMath) 11 Kat H\u0131zl\u0131 (G\u00fc\u00e7l\u00fc Yan) Snapshot (Anl\u0131k G\u00f6r\u00fcnt\u00fc) 4800 Ticks (Copy) 110 Ticks (Swp) 43 Kat H\u0131zl\u0131 (G\u00fc\u00e7l\u00fc Yan) Rastgele Eri\u015fim (Nokta) 14 Ticks (Do\u011frudan) 48 Ticks (Sparse) 3.4 Kat Yava\u015f (Zay\u0131f Yan) K\u00fc\u00e7\u00fck \u00d6l\u00e7ek (10 Varl\u0131k) 80 Ticks (D\u00f6ng\u00fc) 1200 Ticks (Job) 15 Kat Yava\u015f (Zay\u0131f Yan) Serile\u015ftirme (JSON) 42ms (JsonUtil) 110ms (Proxy) 2.6 Kat Yava\u015f (Zay\u0131f Yan)"},{"location":"Manuals/Benchmarks_tr/#3-donanm-glossary-gecikme-tablosu","title":"3. Donan\u0131m Glossary (Gecikme Tablosu)","text":"<p>\u0130\u015flemcinin veriye ula\u015fma h\u0131z\u0131, o verinin nerede oldu\u011funa ba\u011fl\u0131d\u0131r. Nexus, veriyi her zaman en h\u0131zl\u0131 katmanlarda tutmaya \u00e7al\u0131\u015f\u0131r.</p> Bellek Katman\u0131 Gecikme (Clock Cycles) Nexus Yakla\u015f\u0131m\u0131 L1 Cache 4-5 Cycle Bile\u015fenler ard\u0131\u015f\u0131k paketlenir. L2 Cache 12-15 Cycle Cache-line (64B) hizalamas\u0131 kullan\u0131l\u0131r. L3 Cache 40-50 Cycle SparseSet ile veri lokalitesi korunur. Main RAM 200-300 Cycle Unmanaged bellek ile RAM takviyesi."},{"location":"Manuals/Benchmarks_tr/#4-bilimsel-veri-detay","title":"4. Bilimsel Veri Detay\u0131","text":"<p>A\u015fa\u011f\u0131daki veriler 10,000 varl\u0131\u011f\u0131n (Pozisyon + H\u0131z) g\u00fcncellendi\u011fi senaryoda al\u0131nm\u0131\u015ft\u0131r.</p>"},{"location":"Manuals/Benchmarks_tr/#a-yurutme-hz-execution-time","title":"A. Y\u00fcr\u00fctme H\u0131z\u0131 (Execution Time)","text":"Metod 10k Nesne (ms) Fark MonoBehaviour.Update() ~12.5 ms Baz Unity C# Job System ~2.1 ms 6 Kat H\u0131zl\u0131 Nexus Prime (SIMD) 0.4 ms 31 Kat H\u0131zl\u0131"},{"location":"Manuals/Benchmarks_tr/#b-bellek-tuketimi-ve-gc","title":"B. Bellek T\u00fcketimi ve GC","text":"Kriter Standart List Nexus Prime Heap Allocation ~450 KB (her karede) 0 KB GC Duraklamas\u0131 (Lag) Her 3-5 saniyede bir Yok (S\u0131f\u0131r duraklama) Cache Miss Oran\u0131 %40+ &lt;%5"},{"location":"Manuals/Benchmarks_tr/#5-mimari-analiz-guclu-ve-zayf-yanlar","title":"5. Mimari Analiz: G\u00fc\u00e7l\u00fc ve Zay\u0131f Yanlar","text":""},{"location":"Manuals/Benchmarks_tr/#51-guclu-yanlar-nexusun-parladg-yerler","title":"5.1 G\u00fc\u00e7l\u00fc Yanlar: Nexus'un Parlad\u0131\u011f\u0131 Yerler","text":""},{"location":"Manuals/Benchmarks_tr/#veri-odakl-avantaj","title":"\"Veri Odakl\u0131\" Avantaj","text":"<p>Nexus Prime y\u00f6netilmeyen (unmanaged) bellek bloklar\u0131 kullan\u0131r. Veriler ard\u0131\u015f\u0131k olarak saklan\u0131r. CPU bir varl\u0131\u011f\u0131n verisini okudu\u011funda, sonraki verileri de otomatik olarak L1 \u00f6nbelle\u011fine \u00e7eker (pre-fetch).</p>"},{"location":"Manuals/Benchmarks_tr/#varlk-yasam-dongusu-ve-olusturma","title":"Varl\u0131k Ya\u015fam D\u00f6ng\u00fcs\u00fc ve Olu\u015fturma","text":"<p><code>GameObject.Instantiate</code> a\u011f\u0131r bellek tahsisi ve hiyerar\u015fi kayd\u0131 gerektirirken, Nexus varl\u0131k olu\u015fturma i\u015flemi \u00f6nceden ayr\u0131lm\u0131\u015f (pre-allocated) bir kay\u0131t defterinde basit bir bellek atamas\u0131d\u0131r.</p>"},{"location":"Manuals/Benchmarks_tr/#yuksek-performansl-sorgulama","title":"Y\u00fcksek Performansl\u0131 Sorgulama","text":"<p>Nexus, varl\u0131klar\u0131 filtrelemek i\u00e7in bit maskeleri ve dahili kay\u0131t defterlerini kullan\u0131r. Bu sayede <code>FindObjectsOfType</code> metodunun maliyetli sahne a\u011fac\u0131 tarama i\u015fleminden ka\u00e7\u0131n\u0131r.</p>"},{"location":"Manuals/Benchmarks_tr/#52-zayf-yanlar-mimarinin-maliyeti","title":"5.2 Zay\u0131f Yanlar: Mimarinin Maliyeti","text":""},{"location":"Manuals/Benchmarks_tr/#sparse-set-dolayl-erisimi-nokta-arama-vergisi","title":"Sparse Set Dolayl\u0131 Eri\u015fimi (Nokta Arama Vergisi)","text":"<p>En y\u00fcksek iterasyon h\u0131z\u0131n\u0131 korumak i\u00e7in Nexus Sparse Set yap\u0131s\u0131n\u0131 kullan\u0131r. Bu \u00e7ift a\u015famal\u0131 arama nedeniyle tekil \u00f6zellik kontrolleri standart dizilere g\u00f6re daha yava\u015ft\u0131r. *   \u00d6neri: Rastgele aramalar yerine \"Sistemik\" i\u015flemeyi (t\u00fcm bile\u015fenler \u00fczerinden toplu iterasyon) tercih edin.</p>"},{"location":"Manuals/Benchmarks_tr/#serilestirme-maliyeti","title":"Serile\u015ftirme Maliyeti","text":"<p>Nexus'ta kullan\u0131lan y\u00f6netilmeyen yap\u0131lar (structs), <code>JsonUtility</code> veya standart y\u00f6netilen serile\u015ftiriciler taraf\u0131ndan do\u011frudan desteklenmez. Bunlar i\u00e7in proxy nesneleri veya manuel d\u00f6n\u00fc\u015ft\u00fcrme gereklidir, bu da performansa ek y\u00fck getirir.</p>"},{"location":"Manuals/Benchmarks_tr/#framework-dispatch-gecikmesi","title":"Framework Dispatch Gecikmesi","text":"<p>\u00c7ok d\u00fc\u015f\u00fck varl\u0131k say\u0131lar\u0131nda (\u00f6rne\u011fin &lt;10), bir i\u015fi planlamak (scheduling) as\u0131l i\u015fi yapmaktan daha uzun s\u00fcrebilir. Singleton benzeri yap\u0131lar i\u00e7in Nexus kullan\u0131lmas\u0131 \u00f6nerilmez.</p>"},{"location":"Manuals/Benchmarks_tr/#6-grafiksel-karslastrma-teorik-yuk","title":"6. Grafiksel Kar\u015f\u0131la\u015ft\u0131rma (Teorik Y\u00fck)","text":"<pre><code>graph LR\n    A[MonoBehaviour] --&gt;|\u00c7ok A\u011f\u0131r| B(Main Thread Latency)\n    C[Standard ECS] --&gt;|Orta| D(Entity Overhead)\n    E[Nexus Prime] --&gt;|Ultra Hafif| F(Direct Memory Throughput)\n\n    style E fill:#00ff00,stroke:#333,stroke-width:4px</code></pre>"},{"location":"Manuals/Benchmarks_tr/#7-nexus-performans-paketi-uygulama","title":"7. Nexus Performans Paketi: Uygulama","text":""},{"location":"Manuals/Benchmarks_tr/#benchmarking-felsefesi","title":"Benchmarking Felsefesi","text":"<p>Sadece \"ideal\" ko\u015fullar\u0131 test etmiyoruz. Testlerimiz; veri ak\u0131\u015f\u0131n\u0131, bellek kullan\u0131m\u0131n\u0131, ya\u015fam d\u00f6ng\u00fcs\u00fc maliyetlerini ve framework y\u00fck\u00fcn\u00fcn darbo\u011faz olu\u015fturdu\u011fu e\u015fik noktalar\u0131n\u0131 kapsar.</p>"},{"location":"Manuals/Benchmarks_tr/#paket-kaynak-kodu","title":"Paket Kaynak Kodu","text":"<pre><code>[render_diffs(file:///home/gokhanc/Development/Nexus/Nexus.Unity/Core/NexusBenchmarkSuite.cs)]\n</code></pre>"},{"location":"Manuals/Benchmarks_tr/#8-sonuc","title":"8. Sonu\u00e7","text":"<p>Nexus Prime, i\u015flemciniz i\u00e7in \"S\u00fcrt\u00fcnmesiz Bir Otoban\" in\u015fa eder. Testler, yap\u0131lan i\u015flemin niteli\u011fine g\u00f6re 30 ile 100 kata kadar daha fazla nesneyi ayn\u0131 kare s\u00fcresi i\u00e7inde i\u015fleyebildi\u011fini kan\u0131tlam\u0131\u015ft\u0131r.</p> <p>Nexus Prime M\u00fchendislik Notu:  Performans bir l\u00fcks de\u011fil, donan\u0131m kaynaklar\u0131na duyulan sayg\u0131d\u0131r. Nexus kullanarak, donan\u0131m kaynaklar\u0131n\u0131 sanal aramalarda veya GC temizli\u011finde de\u011fil, do\u011frudan oyun mekani\u011finde harcars\u0131n\u0131z.</p> <p>[!TIP] Ger\u00e7ek zamanl\u0131 par\u00e7alanmay\u0131 (fragmentation) izlemek i\u00e7in Nexus Editor'deki Integrity Dashboard'u kullan\u0131n.</p> <p>[!CAUTION] Erken optimizasyondan (premature optimization) ka\u00e7\u0131n\u0131n. Sadece her karede i\u015flem g\u00f6rmesi gereken 500-1000'den fazla \u00f6zde\u015f varl\u0131\u011f\u0131n\u0131z varsa Nexus'a ge\u00e7i\u015f yap\u0131n.</p>"},{"location":"Manuals/Cookbook_eng/","title":"Nexus Prime Architectural Manual: Development Cookbook","text":""},{"location":"Manuals/Cookbook_eng/#1-introduction-the-ecs-mindset","title":"1. Introduction: The ECS Mindset","text":"<p>When developing with Nexus Prime, you must think in a \"Data-Oriented\" way, not an \"Object-Oriented\" one. An entity is not an object; it is simply a hook onto which components are attached.</p> <p>This Cookbook provides ready-made solutions in \"Deep-Depth\" standards for the scenarios you will most frequently encounter while building your system.</p>"},{"location":"Manuals/Cookbook_eng/#2-recipe-1-high-density-movement-system","title":"2. Recipe 1: High-Density Movement System","text":"<p>The most efficient method for moving 10,000 bullets or 5,000 units simultaneously.</p>"},{"location":"Manuals/Cookbook_eng/#data-structure","title":"Data Structure","text":"<pre><code>[StructLayout(LayoutKind.Sequential)]\npublic struct Velocity : unmanaged { public float3 Value; }\n\n[StructLayout(LayoutKind.Sequential)]\npublic struct Position : unmanaged { public float3 Value; }\n</code></pre>"},{"location":"Manuals/Cookbook_eng/#system-logic","title":"System Logic","text":"<pre><code>public class MovementSystem : NexusParallelSystem\n{\n    [Read] private float _deltaTime;\n\n    public override void Execute()\n    {\n        // Filter with Query and process in parallel\n        var query = registry.Query&lt;Position, Velocity&gt;();\n        query.Execute((EntityId id, Position* pos, Velocity* vel) =&gt; {\n            pos-&gt;Value += vel-&gt;Value * _deltaTime;\n        });\n    }\n}\n</code></pre>"},{"location":"Manuals/Cookbook_eng/#3-recipe-2-state-snapshot-rewind","title":"3. Recipe 2: State Snapshot &amp; Rewind","text":"<p>To record the game state and go back 5 seconds.</p> <pre><code>// 1. Initialize Snapshot Manager\nvar snapshotMgr = new SnapshotManager();\n\n// 2. Record every frame (or at specific intervals)\nvoid Update() {\n    snapshotMgr.RecordFrame(registry, deltaOnly: true);\n}\n\n// 3. When rewind is requested\nvoid OnRewindRequested() {\n    var pastFrame = snapshotMgr.History.First.Value;\n    snapshotMgr.LoadSnapshot(registry, pastFrame);\n}\n</code></pre>"},{"location":"Manuals/Cookbook_eng/#4-recipe-3-unity-gameobject-synchronization","title":"4. Recipe 3: Unity GameObject Synchronization","text":"<p>Transferring physical data within Nexus to the Unity Gfx (Visual) layer.</p> <pre><code>// BridgeHub registration\nbridgeHub.Register&lt;Position&gt;(\n    push: (id, nexusPos) =&gt; {\n        // Nexus -&gt; Unity\n        var transform = GetUnityTransform(id);\n        transform.position = nexusPos-&gt;Value;\n    },\n    pull: (id, nexusPos) =&gt; {\n        // Unity -&gt; Nexus (If coming from Unity)\n        var transform = GetUnityTransform(id);\n        nexusPos-&gt;Value = transform.position;\n    }\n);\n</code></pre>"},{"location":"Manuals/Cookbook_eng/#5-advanced-tip-memory-pooling","title":"5. Advanced Tip: Memory Pooling","text":"<p>Use <code>EntityCommandBuffer</code> to prevent costs that occur when adding/removing components:</p> <pre><code>public void OnProjectileHit(EntityId projectile, EntityId target) {\n    // Do not destroy immediately, queue it!\n    ecb.DestroyEntity(projectile);\n    ecb.AddComponent(target, new DamageEffect { Amount = 50 });\n}\n</code></pre>"},{"location":"Manuals/Cookbook_eng/#6-frequently-asked-questions-best-practices","title":"6. Frequently Asked Questions (Best Practices)","text":"<ul> <li>Q: When should I use a Query?<ul> <li>A: When you want to batch process all entities that possess a group of components.</li> </ul> </li> <li>Q: When should I use Direct Access (registry.Get)?<ul> <li>A: When you want to reach a single entity's data in a specific situation (at O(1) speed).</li> </ul> </li> <li>Q: Can I use strings?<ul> <li>A: Only use unmanaged alternatives like <code>NexusString32/64/128</code>.</li> </ul> </li> </ul> <p>Nexus Prime Engineering Note:  In the ECS world, \"Early Optimization\" is not a mistake; it is a necessity. By following the patterns in this Cookbook, you can build the foundations of your project in a way that will not waste 100 million clock cycles.</p>"},{"location":"Manuals/Cookbook_tr/","title":"Nexus Prime Mimari Rehber: Development Cookbook (Geli\u015ftirici Yemek Kitab\u0131)","text":""},{"location":"Manuals/Cookbook_tr/#1-giris-ecs-dusunce-yaps","title":"1. Giri\u015f: ECS D\u00fc\u015f\u00fcnce Yap\u0131s\u0131","text":"<p>Nexus Prime ile uygulama geli\u015ftirirken \"Nesne\" (Object) odakl\u0131 de\u011fil, \"Veri\" (Data) odakl\u0131 d\u00fc\u015f\u00fcnmelisiniz. Bir varl\u0131k (Entity) bir nesne de\u011fil, sadece bile\u015fenlerin (Components) tak\u0131ld\u0131\u011f\u0131 bir kancad\u0131r.</p> <p>Bu Cookbook, sisteminizi kurarken en s\u0131k kar\u015f\u0131la\u015faca\u011f\u0131n\u0131z senaryolar i\u00e7in \"Deep-Depth\" standartlar\u0131nda haz\u0131r \u00e7\u00f6z\u00fcmler sunar.</p>"},{"location":"Manuals/Cookbook_tr/#2-tarif-1-yuksek-yogunluklu-hareket-sistemi","title":"2. Tarif 1: Y\u00fcksek Yo\u011funluklu Hareket Sistemi","text":"<p>10,000 mermiyi veya 5,000 birimi ayn\u0131 anda hareket ettirmek i\u00e7in en verimli y\u00f6ntem.</p>"},{"location":"Manuals/Cookbook_tr/#veri-yaps","title":"Veri Yap\u0131s\u0131","text":"<pre><code>[StructLayout(LayoutKind.Sequential)]\npublic struct Velocity : unmanaged { public float3 Value; }\n\n[StructLayout(LayoutKind.Sequential)]\npublic struct Position : unmanaged { public float3 Value; }\n</code></pre>"},{"location":"Manuals/Cookbook_tr/#sistem-mantg","title":"Sistem Mant\u0131\u011f\u0131","text":"<pre><code>public class MovementSystem : NexusParallelSystem\n{\n    [Read] private float _deltaTime;\n\n    public override void Execute()\n    {\n        // Query ile filtrele ve paralel i\u015fle\n        var query = registry.Query&lt;Position, Velocity&gt;();\n        query.Execute((EntityId id, Position* pos, Velocity* vel) =&gt; {\n            pos-&gt;Value += vel-&gt;Value * _deltaTime;\n        });\n    }\n}\n</code></pre>"},{"location":"Manuals/Cookbook_tr/#3-tarif-2-state-snapshot-rewind-geri-sarma","title":"3. Tarif 2: State Snapshot &amp; Rewind (Geri Sarma)","text":"<p>Oyunun durumunu kaydedip 5 saniye \u00f6ncesine d\u00f6nmek i\u00e7in.</p> <pre><code>// 1. Snapshot Manager'\u0131 ba\u015flat\nvar snapshotMgr = new SnapshotManager();\n\n// 2. Her karede (veya belirli aral\u0131kla) kaydet\nvoid Update() {\n    snapshotMgr.RecordFrame(registry, deltaOnly: true);\n}\n\n// 3. Geri sarma tetiklendi\u011finde\nvoid OnRewindRequested() {\n    var pastFrame = snapshotMgr.History.First.Value;\n    snapshotMgr.LoadSnapshot(registry, pastFrame);\n}\n</code></pre>"},{"location":"Manuals/Cookbook_tr/#4-tarif-3-unity-gameobject-senkronizasyonu","title":"4. Tarif 3: Unity GameObject Senkronizasyonu","text":"<p>Nexus i\u00e7indeki fiziksel veriyi Unity Gfx (G\u00f6rsel) katman\u0131na aktarma.</p> <pre><code>// BridgeHub kayd\u0131\nbridgeHub.Register&lt;Position&gt;(\n    push: (id, nexusPos) =&gt; {\n        // Nexus -&gt; Unity\n        var transform = GetUnityTransform(id);\n        transform.position = nexusPos-&gt;Value;\n    },\n    pull: (id, nexusPos) =&gt; {\n        // Unity -&gt; Nexus (E\u011fer Unity'den geliyorsa)\n        var transform = GetUnityTransform(id);\n        nexusPos-&gt;Value = transform.position;\n    }\n);\n</code></pre>"},{"location":"Manuals/Cookbook_tr/#5-ileri-seviye-ipucu-memory-pooling","title":"5. \u0130leri Seviye \u0130pucu: Memory Pooling","text":"<p>Bile\u015fen ekleyip \u00e7\u0131kar\u0131rken olu\u015facak maliyetleri \u00f6nlemek i\u00e7in <code>EntityCommandBuffer</code> kullan\u0131n:</p> <pre><code>public void OnProjectileHit(EntityId projectile, EntityId target) {\n    // Hemen silme, kuyru\u011fa al!\n    ecb.DestroyEntity(projectile);\n    ecb.AddComponent(target, new DamageEffect { Amount = 50 });\n}\n</code></pre>"},{"location":"Manuals/Cookbook_tr/#6-skca-sorulan-sorular-best-practices","title":"6. S\u0131k\u00e7a Sorulan Sorular (Best Practices)","text":"<ul> <li>Q: Ne zaman Query kullanmal\u0131y\u0131m?<ul> <li>A: Bir grup bile\u015fene sahip t\u00fcm varl\u0131klar\u0131 toplu i\u015flemek istedi\u011finizde.</li> </ul> </li> <li>Q: Ne zaman Direct Access (registry.Get) kullanmal\u0131y\u0131m?<ul> <li>A: Tekil bir varl\u0131\u011f\u0131n verisine \u00f6zel bir durumda (O(1) h\u0131z\u0131nda) ula\u015fmak istedi\u011finizde.</li> </ul> </li> <li>Q: String kullanabilir miyim?<ul> <li>A: Sadece <code>NexusString32/64/128</code> gibi unmanaged alternatifleri kullan\u0131n.</li> </ul> </li> </ul> <p>Nexus Prime M\u00fchendislik Notu:  ECS d\u00fcnyas\u0131nda \"Erken Optimizasyon\" bir hata de\u011fil, bir zorunluluktur. Bu Cookbook'taki kal\u0131plar\u0131 takip ederek, projenizin temellerini 100 milyon saat d\u00f6ng\u00fcs\u00fcn\u00fc (cycle) bo\u015fa harcamayacak \u015fekilde in\u015fa edebilirsiniz.</p>"},{"location":"Manuals/DataStructures_eng/","title":"Nexus Prime Architectural Manual: Next-Gen Data Structures &amp; Type Systems","text":""},{"location":"Manuals/DataStructures_eng/#1-introduction-why-unmanaged","title":"1. Introduction: Why Unmanaged?","text":"<p>In the standard C# development model, every <code>class</code> or <code>string</code> object lives on the managed heap. These objects are constantly monitored by the Garbage Collector (GC). In a game with millions of entities, scanning these objects (Mark &amp; Sweep) by the GC leads to sudden freezes called \"Stop-the-world\".</p> <p>Nexus Prime solves this problem fundamentally with Unmanaged Data Structures. Data is stored in the unmanaged space (raw RAM addresses) where the GC cannot see it. This document explains how Nexus manages this data and its advantages at the hardware level.</p>"},{"location":"Manuals/DataStructures_eng/#2-blittable-structs-memory-alignment","title":"2. Blittable Structs &amp; Memory Alignment","text":""},{"location":"Manuals/DataStructures_eng/#21-what-is-blittable","title":"2.1 What is Blittable?","text":"<p>A data type being \"Blittable\" means that no conversion is needed when copying that data. An <code>int</code>, <code>float</code>, or <code>byte</code> is blittable. However, a <code>bool</code> (which can be 4 bytes in C# and 1 byte in the unmanaged world) or a <code>string</code> is not blittable.</p> \\[Blittable(T) \\iff MemoryLayout_{C\\#}(T) == MemoryLayout_{Native}(T)\\] <p>In Nexus, all components must be Blittable. This allows data to flow \"as is\" from RAM to the CPU directly without marshalling penalties.</p>"},{"location":"Manuals/DataStructures_eng/#22-hardware-rules-alignment","title":"2.2 Hardware Rules: Alignment","text":"<p>Processors provide the highest performance when reading from memory addresses that fall on exact 4, 8, or 16-byte boundaries. - Nexus Standard: All unmanaged structs are padded and aligned strictly to 8-byte or 64-byte Cache-Line boundaries. - Explicit Layout: The position (offset) of variables in memory is determined manually using <code>[StructLayout(LayoutKind.Explicit)]</code> on structs. This prevents the CPU from having to perform extra \"masking\" to read unaligned data.</p> <pre><code>graph LR\n    subgraph Explicit_Layout_Memory_Alignment\n        A[Struct Base 0x1000] --&gt; B[Position.x offset 0, 4 bytes]\n        B --&gt; C[Position.y offset 4, 4 bytes]\n        C --&gt; D[Health offset 8, 4 bytes]\n        D --&gt; E[Padding offset 12, 4 bytes]\n\n        E -.-&gt; |Next Struct 0x1010| F{Total Size: 16 Bytes}\n    end\n    style F fill:#ddffdd</code></pre>"},{"location":"Manuals/DataStructures_eng/#3-nexus-collections-unmanaged-containers","title":"3. Nexus Collections (Unmanaged Containers)","text":""},{"location":"Manuals/DataStructures_eng/#31-nexuslist","title":"3.1 NexusList <p>The traditional <code>List&lt;T&gt;</code>, when expanded (resized) thousands of times, increases GC pressure by leaving old arrays on the managed heap. - Mechanism: Allocates raw memory aligned to 64-bytes with <code>NexusMemoryManager.AllocCacheAligned</code>. - Performance: Expansion is performed via <code>Realloc</code>. If there is free space adjacent on the RAM, the capacity is increased with \\(O(1)\\) complexity without the data being copied or moved at all.</p>","text":""},{"location":"Manuals/DataStructures_eng/#32-nexusdictionary","title":"3.2 NexusDictionary <p>Dictionary structures typically generate a \"Hash Table\" caching cost. While Nexus eliminates this need for component access entirely using the <code>ComponentTypeManager</code>, it offers unmanaged hash maps for general custom game logic. - Advantage: Zero <code>Box/Unbox</code> allocation cost. Keys and values are stored directly as raw bytes, and hash lookups (\\(O(1)\\)) have vastly minimized cache-miss rates compared to standard <code>Dictionary</code>.</p>","text":""},{"location":"Manuals/DataStructures_eng/#4-fixed-size-strings-embedded-texts","title":"4. Fixed-Size Strings (Embedded Texts)","text":""},{"location":"Manuals/DataStructures_eng/#41-problem-managed-string","title":"4.1 Problem: Managed String <p>In C#, a <code>string</code> is a managed object. If you put a <code>string</code> inside an unmanaged component, that component can no longer be blittable. <pre><code>// Incorrect! Not unmanaged, creates a GC-tracked pointer constraint.\nstruct BadComponent { string Name; } \n</code></pre></p>","text":""},{"location":"Manuals/DataStructures_eng/#42-solution-nexusstring-nexusstring3264128","title":"4.2 Solution: NexusString (NexusString32/64/128) <p>Nexus keeps texts \"embedded\" directly inside the component's footprint. - Structure: Uses a fixed-size byte array like <code>fixed byte _data[32]</code>. - Mechanism: Text is written to this local array in UTF8 format. - Hardware-Link: The text resides strictly on the same Cache Line (64-byte boundary) as the component's other data (X, Y, Z coordinates, etc.). When reading an entity's position, you also reach its name \"for free\" within the exact same memory fetch.</p> <pre><code>graph TD\n    subgraph Seamless_Component_Footprint\n        A[Component 64-byte] --&gt; B[Position Vector: 12 bytes]\n        A --&gt; C[Fixed Embedded Text: 32 bytes]\n        A --&gt; D[Health: 4 bytes]\n\n        E((Hardware Cache)) -.-&gt; |Fetched in Single Instruction| A\n    end</code></pre>","text":""},{"location":"Manuals/DataStructures_eng/#5-terminology-and-hardware-counterparts","title":"5. Terminology and Hardware Counterparts","text":"Term Hardware Counterpart Nexus Advantage Blittable Bit-Blit (Direct Copy) Zero CPU cost transfer. Fixed Buffer Stack / In-place Allocation Data physically embedded within the CPU L1 Cache. Unmanaged Heap Raw RAM Addresses 100% immunity from GC scanning interruptions. Memory Alignment MMU Fetch Optimization Maximum data throughput per clock cycle."},{"location":"Manuals/DataStructures_eng/#6-summary-and-rules","title":"6. Summary and Rules","text":"<ol> <li>Inherit IDisposable: All unmanaged collections must manually be <code>Dispose</code>d to prevent C-style memory leaks.</li> <li>No References: Never put a <code>class</code> or managed <code>string</code> inside unmanaged structs.</li> <li>Use NexusStrings: Prefer structural strings like <code>NexusString64</code> for names and gameplay tags.</li> </ol> <p>[!TIP] Nexus Prime Engineering Note Strategically utilizing these data structures flattens the \"GC Spikes\" (sudden frame freezes) chart in your game engine to a Flat Line. For the player end-user, this achieves the holy grail of \"Zero Stutter\" even in chaos heavy scenes.</p>"},{"location":"Manuals/DataStructures_tr/","title":"Nexus Prime Mimari Rehber: Next-Gen Veri Yap\u0131lar\u0131 &amp; Tip Sistemi","text":""},{"location":"Manuals/DataStructures_tr/#1-giris-neden-unmanaged","title":"1. Giri\u015f: Neden Unmanaged?","text":"<p>Standart C# geli\u015ftirme modelinde, her <code>class</code> veya <code>string</code> nesnesi y\u00f6netilen y\u0131\u011f\u0131n (Managed Heap) \u00fczerinde ya\u015far. Bu nesneler Garbarage Collector (GC) taraf\u0131ndan s\u00fcrekli izlenir. Milyonlarca varl\u0131\u011f\u0131n oldu\u011fu bir oyunda, GC'nin bu nesneleri taramas\u0131 (Mark &amp; Sweep) \"Stop-the-world\" denilen ani donmalara yol a\u00e7ar.</p> <p>Nexus Prime, bu sorunu Unmanaged Veri Yap\u0131lar\u0131 ile k\u00f6kten \u00e7\u00f6zer. Veriler, GC'nin g\u00f6remeyece\u011fi unmanaged alanda (RAM'in ham adreslerinde) saklan\u0131r. Bu dok\u00fcman, Nexus'un bu verileri nas\u0131l y\u00f6netti\u011fini ve donan\u0131m seviyesindeki avantajlar\u0131n\u0131 a\u00e7\u0131klar.</p>"},{"location":"Manuals/DataStructures_tr/#2-blittable-structs-memory-alignment","title":"2. Blittable Structs &amp; Memory Alignment","text":""},{"location":"Manuals/DataStructures_tr/#21-blittable-nedir","title":"2.1 Blittable Nedir?","text":"<p>Bir veri tipinin \"Blittable\" olmas\u0131, o verinin kopyalan\u0131rken hi\u00e7bir d\u00f6n\u00fc\u015f\u00fcme (conversion) ihtiya\u00e7 duymamas\u0131 demektir. Bir <code>int</code>, <code>float</code> veya <code>byte</code> blittable'd\u0131r. Ancak bir <code>bool</code> (C#'ta 4 byte, unmanaged d\u00fcnyada 1 byte olabilir) veya <code>string</code> blittable de\u011fildir.</p> \\[Blittable(T) \\iff MemoryLayout_{C\\#}(T) == MemoryLayout_{Native}(T)\\] <p>Nexus'ta t\u00fcm bile\u015fenler Blittable olmak zorundad\u0131r. Bu, verinin RAM'den CPU'ya \"oldu\u011fu gibi\" akmas\u0131n\u0131 sa\u011flar.</p>"},{"location":"Manuals/DataStructures_tr/#22-donanm-kurallar-alignment","title":"2.2 Donan\u0131m Kurallar\u0131: Alignment","text":"<p>\u0130\u015flemciler bellekten 4, 8 veya 16 bytel\u0131k s\u0131n\u0131r (boundary) adreslerinden okuma yaparken en y\u00fcksek performans\u0131 verir. - Nexus Standard\u0131: T\u00fcm unmanaged structlar 8-byte veya 64-byte Cache-Line s\u0131n\u0131rlar\u0131na hizalan\u0131r. - Explicit Layout: Structlar \u00fczerinde <code>[StructLayout(LayoutKind.Explicit)]</code> kullan\u0131larak de\u011fi\u015fkenlerin bellekteki konumu (offset) manuel olarak belirlenir. Bu, CPU'nun veriyi okumak i\u00e7in fazladan \"maskeleme\" yapmas\u0131n\u0131 engeller.</p> <pre><code>graph LR\n    subgraph Explicit_Layout_Bellek_Hizalamasi\n        A[Struct Basi 0x1000] --&gt; B[Position.x ofset 0, 4 byte]\n        B --&gt; C[Position.y ofset 4, 4 byte]\n        C --&gt; D[Health ofset 8, 4 byte]\n        D --&gt; E[Padding ofset 12, 4 byte]\n\n        E -.-&gt; |Sonraki Struct 0x1010| F{Toplam Boyut: 16 Byte}\n    end\n    style F fill:#ddffdd</code></pre>"},{"location":"Manuals/DataStructures_tr/#3-nexus-collections-unmanaged-kaplar","title":"3. Nexus Collections (Unmanaged Kaplar)","text":""},{"location":"Manuals/DataStructures_tr/#31-nexuslist","title":"3.1 NexusList <p>Geleneksel <code>List&lt;T&gt;</code>, binlerce kez b\u00fcy\u00fcd\u00fc\u011f\u00fcnde (resize) eski veriyi managed heap \u00fczerinde b\u0131rakarak GC bask\u0131s\u0131n\u0131 art\u0131r\u0131r. - Mekanizma: <code>NexusMemoryManager.AllocCacheAligned</code> ile 64-byte hizal\u0131 ham bellek tahsis eder. - Performans: B\u00fcy\u00fcme i\u015flemi <code>Realloc</code> ile yap\u0131l\u0131r. E\u011fer RAM \u00fczerinde yan tarafta bo\u015f yer varsa, veri hi\u00e7 ta\u015f\u0131nmadan \\(O(1)\\) karma\u015f\u0131kl\u0131kta kapasite art\u0131r\u0131l\u0131r.</p>","text":""},{"location":"Manuals/DataStructures_tr/#32-nexusdictionary","title":"3.2 NexusDictionary <p>S\u00f6zl\u00fck yap\u0131lar\u0131 genellikle \"Hash Table\" maliyeti \u00fcretir. Nexus, bile\u015fen eri\u015fimleri i\u00e7in <code>ComponentTypeManager</code> ile bu ihtiyac\u0131 ortadan kald\u0131rsa da, oyunun genel mant\u0131\u011f\u0131 i\u00e7in unmanaged hash mapler sunar. - Avantaj: S\u0131f\u0131r <code>Box/Unbox</code> maliyeti. Anahtarlar ve de\u011ferler do\u011frudan ham byte olarak saklan\u0131r. Hash arama (\\(O(1)\\)) cache-miss oranlar\u0131 CPU hizalamalar\u0131 ile minimuma indirgenmi\u015ftir.</p>","text":""},{"location":"Manuals/DataStructures_tr/#4-fixed-size-strings-gomulu-metinler","title":"4. Fixed-Size Strings (G\u00f6m\u00fcl\u00fc Metinler)","text":""},{"location":"Manuals/DataStructures_tr/#41-problem-managed-string","title":"4.1 Problem: Managed String <p>C#'ta <code>string</code> bir nesnedir (object). Bir bile\u015fenin i\u00e7ine <code>string</code> koyarsan\u0131z, o bile\u015fen art\u0131k blittable / unmanaged olamaz. <pre><code>// Hatal\u0131! Unmanaged de\u011fil, GC Heap \u00fczerinde isaretci (pointer) uretir.\nstruct BadComponent { string Name; } \n</code></pre></p>","text":""},{"location":"Manuals/DataStructures_tr/#42-cozum-nexusstring-nexusstring3264128","title":"4.2 \u00c7\u00f6z\u00fcm: NexusString (NexusString32/64/128) <p>Nexus, metinleri bile\u015fenin i\u00e7ine \"g\u00f6m\u00fcl\u00fc\" (embedded) olarak tutar. - Yap\u0131: <code>fixed byte _data[32]</code> gibi sabit boyutlu bir byte dizisi kullan\u0131r. - Mekanizma: Metin, UTF8 format\u0131nda bu diziye yaz\u0131l\u0131r. - Hardware-Link: Metin, bile\u015fenin di\u011fer verileriyle ayn\u0131 Cache Line (64-byte s\u0131n\u0131r) \u00fczerinde durur. Bir varl\u0131\u011f\u0131n pozisyonunu okurken ismine de \"bedavaya\" (ayn\u0131 bellek okumas\u0131nda) ula\u015fm\u0131\u015f olursunuz.</p> <pre><code>graph TD\n    subgraph Kesintisiz_Bilesen_Yaklasimi\n        A[Bilesen 64-byte] --&gt; B[Posizyon Vektor: 12 byte]\n        A --&gt; C[Sabit Metin: 32 byte]\n        A --&gt; D[Saglik: 4 byte]\n\n        E((Islemci Onbellegi)) -.-&gt; |Tek Okumada Tumu Alinir| A\n    end</code></pre>","text":""},{"location":"Manuals/DataStructures_tr/#5-terminoloji-ve-donanm-karslklar","title":"5. Terminoloji ve Donan\u0131m Kar\u015f\u0131l\u0131klar\u0131","text":"Terim Donan\u0131m Kar\u015f\u0131l\u0131\u011f\u0131 Nexus Avantaj\u0131 Blittable Bit-Blit (Direct Copy) S\u0131f\u0131r CPU maliyetli transfer. Fixed Buffer Stack / In-place Allocation CPU L1 Cache i\u00e7inde yerle\u015fik veri. Unmanaged Heap Raw RAM Addresses GC taramas\u0131ndan %100 muafiyet. Memory Alignment MMU Fetch Optimization Saat d\u00f6ng\u00fcs\u00fc (cycle) ba\u015f\u0131na maksimum veri aktar\u0131m\u0131."},{"location":"Manuals/DataStructures_tr/#6-ozet-ve-kurallar","title":"6. \u00d6zet ve Kurallar","text":"<ol> <li>Inherit IDisposable: T\u00fcm unmanaged koleksiyonlar <code>Dispose</code> edilerek C stili s\u0131z\u0131nt\u0131lar \u00f6nlenmelidir.</li> <li>No References: Structlar\u0131n i\u00e7ine asla <code>class</code> veya managed <code>string</code> koymay\u0131n.</li> <li>Use NexusStrings: \u0130sim ve etiketler (Tag) i\u00e7in <code>NexusString64</code> gibi unmanaged metin yap\u0131lar\u0131n\u0131 tercih edin.</li> </ol> <p>[!TIP] Nexus Prime M\u00fchendislik Notu Bu veri yap\u0131lar\u0131n\u0131 kullanmak, oyununuzdaki \"GC Spikes\" (ani tak\u0131lmalar) grafi\u011fini D\u00fcz Bir \u00c7izgiye (Flat Line) indirger. Oyuncu a\u00e7\u0131s\u0131ndan bu, en yo\u011fun sava\u015flarda bile \"S\u0131f\u0131r Tak\u0131lma\" demektir.</p>"},{"location":"Manuals/UnityBridges_eng/","title":"Nexus Prime Architectural Manual: Unity Helper &amp; Bridge 2.0","text":""},{"location":"Manuals/UnityBridges_eng/#1-introduction-the-intersection-of-two-worlds","title":"1. Introduction: The Intersection of Two Worlds","text":"<p>Unity is a \"Managed\" world that provides development ease but has steep performance constraints. Nexus Prime, on the other hand, is a speed-oriented \"Unmanaged\" world. The communication (synchronization) between these two worlds is typically where performance dies in complex dynamic games.</p> <p>The reason for Bridge 2.0 technology's existence is to intelligently transfer only changed data over a smart bridge instead of blindly copying thousands of objects every frame, effectively reducing the Synchronization Overhead cost by 90%.</p>"},{"location":"Manuals/UnityBridges_eng/#2-dirty-flag-system-the-math-of-synchronization","title":"2. Dirty Flag System: The Math of Synchronization","text":""},{"location":"Manuals/UnityBridges_eng/#21-problem-blind-copy","title":"2.1 Problem: Blind Copy","text":"<p>Copying the positions of 10,000 entities every frame from Unity <code>Transform</code>s to Nexus <code>Position</code> components unnecessarily occupies the CPU's memory bandwidth (bus). In traditional OOP architectures, the bus consumption \\(C\\) is: $\\(C_{OOP} = N_{Total} \\times Size(Transform)\\)$</p>"},{"location":"Manuals/UnityBridges_eng/#22-solution-dirty-bitsets","title":"2.2 Solution: Dirty Bitsets","text":"<p>Nexus keeps a \"Dirty Bit\" (Change Flag) at the unmanaged level for every component. - Pull (Unity -&gt; Nexus): Only objects whose <code>Transform</code> has organically changed in Unity are written into Nexus. - Push (Nexus -&gt; Unity): Only data updated (Dirty) by an active system within Nexus is applied back to Unity objects.</p> <p>Performance Math:  The CPU can check the change status of 64 different objects in a single 64-bit register (<code>uint64</code>) with a single instruction cycle.  $\\(Access \\ Cost = \\frac{N_{Total}}{64} \\ \\text{instructions}\\)$</p> <p>Furthermore, data transfer is strictly limited to \\(N_{Dirty}\\): $\\(C_{Nexus} = N_{Dirty} \\times Size(Component)\\)$ Because \\(N_{Dirty} \\ll N_{Total}\\) in real simulations, the performance optimization is immense.</p> <pre><code>graph TD\n    subgraph Frame_Synchronization_Pipeline\n        A[Unity GameObject] --&gt;|If Modified: Pull| B(BridgeHub)\n        B --&gt; |Dirty Bit Scan| C[Nexus Prime Registry]\n        C --&gt; |Only Modified: Push| B\n        B --&gt; |Transform Update| A\n    end\n    style B fill:#ddffdd</code></pre>"},{"location":"Manuals/UnityBridges_eng/#3-bridgehub-central-distribution-base","title":"3. BridgeHub: Central Distribution Base","text":"<p><code>BridgeHub</code> is an orchestrator where all systems register their synchronization logic. It operates at strategic points around the engine's game loop to prevent race conditions. - PullAll(): Pulls changes originating in Unity (e.g., player input or animation roots) to Nexus. Typically executes at the very start of <code>Update</code> (Early Update). - PushAll(): Pushes physical algorithmic changes calculated in the Nexus world outward to Unity. Typically executes after systems complete, within <code>LateUpdate</code>.</p>"},{"location":"Manuals/UnityBridges_eng/#4-smart-attributes-source-generators","title":"4. Smart Attributes &amp; Source Generators","text":"<p>Nexus Prime uses advanced C# attributes to achieve rapid code generation:</p> <ul> <li>[Sync]: Marks a field to be automatically kept synchronized between the Unity and Nexus sides. It stealthily creates Getter/Setter hooks underneath.</li> <li>[ReadOnly]: Specifies that the data will only be read by Nexus and not written back to Unity, canceling the Push operation and saving memory bandwidth.</li> <li>Source Generator Integration: At compile time (Build time), the Roslyn Compiler scans these attributes and automatically writes the optimized <code>Bridge</code> memory copy codes on your behalf (Boilerplate-free).</li> </ul>"},{"location":"Manuals/UnityBridges_eng/#5-terminology-and-performance-table","title":"5. Terminology and Performance Table","text":"Term Description Performance Impact Pull Operation Pulling data privilege from Unity to Nexus. Scan is 80% faster if there are no changes. Push Operation Transferring data downward from Nexus to Unity. Saves up to 95% CPU time by copying only what's dirty. Sync Point The moment the two worlds are held in memory alignment. Prevents thread blocking and multi-thread asymmetry. Managed Proxy A Unity \"View\" class representing unmanaged data. Operates without generating GC via pooling (Zero Allocation)."},{"location":"Manuals/UnityBridges_eng/#6-summary-and-best-practices","title":"6. Summary and Best Practices","text":"<ol> <li>Avoid Full Sync: Do not synchronize every mechanic. Only connect data with direct visual counterparts (Gfx) to the bridge (e.g., only push the Health value if the UI is actively observing it).</li> <li>Batch Bridges: Do not manage systems individually regarding synchronization. Manage all sync bindings from a centralized point using the <code>BridgeHub</code>.</li> <li>Visual Debugging: Use the <code>Live State Tweaker</code> tool to monitor data traffic bleeding through the bridge and to capture bottlenecks.</li> </ol> <p>[!TIP] Nexus Prime Engineering Note  Bridge 2.0 acts like a \"Data Customs\". By allowing only data possessing a passport (Dirty Bit validation) to pass in or out, it prevents the processor from exhausting itself with redundant copying tasks. This architecture is the primary guarantor of maintaining a rock-solid 144+ FPS in your game.</p>"},{"location":"Manuals/UnityBridges_tr/","title":"Nexus Prime Mimari Rehber: Unity Helper &amp; Bridge 2.0","text":""},{"location":"Manuals/UnityBridges_tr/#1-giris-iki-dunyann-kesisimi","title":"1. Giri\u015f: \u0130ki D\u00fcnyan\u0131n Kesi\u015fimi","text":"<p>Unity, geli\u015ftirme kolayl\u0131\u011f\u0131 sa\u011flayan ancak performans k\u0131s\u0131tlar\u0131 olan \"Managed\" (Y\u00f6netilen) bir d\u00fcnyad\u0131r. Nexus Prime ise h\u0131z odakl\u0131 \"Unmanaged\" (Y\u00f6netilmeyen) bir d\u00fcnyad\u0131r. Bu iki d\u00fcnyan\u0131n birbiriyle konu\u015fmas\u0131 (senkronizasyonu), genellikle oyunlarda performans\u0131n \u00f6ld\u00fc\u011f\u00fc yerdir.</p> <p>Bridge 2.0 teknolojisinin varl\u0131k sebebi, her karede binlerce nesneyi k\u00f6r\u00fc k\u00f6r\u00fcne kopyalamak yerine, sadece de\u011fi\u015fen verileri ak\u0131ll\u0131ca bir k\u00f6pr\u00fc \u00fczerinden aktararak Synchronization Overhead (Senkronizasyon Y\u00fck\u00fc) maliyetini %90 oran\u0131nda azaltmakt\u0131r.</p>"},{"location":"Manuals/UnityBridges_tr/#2-dirty-flag-sistemi-senkronizasyon-matematigi","title":"2. Dirty Flag Sistemi: Senkronizasyon Matemati\u011fi","text":""},{"location":"Manuals/UnityBridges_tr/#21-problem-blind-copy-kor-kopyalama","title":"2.1 Problem: Blind Copy (K\u00f6r Kopyalama)","text":"<p>Her karede 10,000 varl\u0131\u011f\u0131n pozisyonunu Unity <code>Transform</code>undan Nexus <code>Position</code> bile\u015fenine kopyalamak, CPU'nun bellek bant geni\u015fli\u011fini (bus) gereksiz yere i\u015fgal eder. Geleneksel OOP mimarisinde veri yolu t\u00fcketimi \\(C\\) \u015fu \u015fekildedir: $\\(C_{OOP} = N_{Total} \\times Size(Transform)\\)$</p>"},{"location":"Manuals/UnityBridges_tr/#22-cozum-dirty-bitsets","title":"2.2 \u00c7\u00f6z\u00fcm: Dirty Bitsets","text":"<p>Nexus, her bir bile\u015fen i\u00e7in unmanaged seviyede bir \"Dirty Bit\" (De\u011fi\u015fim Bayra\u011f\u0131) tutar. - Pull (Unity -&gt; Nexus): Sadece <code>Transform</code>\u0131 de\u011fi\u015fen objeler Nexus'a yaz\u0131l\u0131r. - Push (Nexus -&gt; Unity): Sadece Nexus i\u00e7indeki bir sistem taraf\u0131ndan g\u00fcncellenen (Dirty) veriler Unity objelerine uygulan\u0131r.</p> <p>Performans Matemati\u011fi:  CPU, 64-bitlik tek bir register (<code>uint64</code>) kullanarak 64 farkl\u0131 nesnenin de\u011fi\u015fim durumunu tek bir saat d\u00f6ng\u00fcs\u00fcnde (cycle) tarayabilir. $\\(Eri\u015fim \\ Maliyeti = \\frac{N_{Total}}{64} \\ \\text{komut}\\)$</p> <p>Ayr\u0131ca veri aktar\u0131m\u0131 sadece \\(N_{Dirty}\\) i\u00e7in ger\u00e7ekle\u015fir: $\\(C_{Nexus} = N_{Dirty} \\times Size(Component)\\)$ Ger\u00e7ek sim\u00fclasyonlarda genelde \\(N_{Dirty} \\ll N_{Total}\\) oldu\u011fu i\u00e7in muazzam d\u00fczeyde optimizasyon kazan\u0131l\u0131r.</p> <pre><code>graph TD\n    subgraph Karesel_Senkronizasyon_Hatti\n        A[Unity GameObject] --&gt;|Eger Seciliyse: Pull| B(BridgeHub)\n        B --&gt; |Dirty Bit Kontrolu| C[Nexus Prime Registry]\n        C --&gt; |Sadece Degisen: Push| B\n        B --&gt; |Transform Guncellemesi| A\n    end\n    style B fill:#ddffdd</code></pre>"},{"location":"Manuals/UnityBridges_tr/#3-bridgehub-merkezi-dagtm-ussu","title":"3. BridgeHub: Merkezi Da\u011f\u0131t\u0131m \u00dcss\u00fc","text":"<p><code>BridgeHub</code>, t\u00fcm sistemlerin senkronizasyon mant\u0131\u011f\u0131n\u0131 kaydetti\u011fi bir orkestrat\u00f6rd\u00fcr. Oyunun d\u00f6ng\u00fcs\u00fc etraf\u0131nda stratejik noktalarda \u00e7al\u0131\u015farak race condition (yar\u0131\u015f durumu) sorunlar\u0131n\u0131 \u00f6nler. - PullAll(): Unity'deki (\u00f6rne\u011fin input veya animasyon bazl\u0131) de\u011fi\u015fimleri Nexus'a \u00e7eker. Genellikle <code>Update</code> ba\u015f\u0131nda (Early Update) \u00e7al\u0131\u015f\u0131r. - PushAll(): Nexus d\u00fcnyas\u0131ndaki fiziksel algoritmik de\u011fi\u015fimleri Unity'ye iter. Genellikle sistemler i\u015fini bitirdikten sonra, <code>LateUpdate</code> i\u00e7inde \u00e7al\u0131\u015f\u0131r.</p>"},{"location":"Manuals/UnityBridges_tr/#4-smart-attributes-source-generators","title":"4. Smart Attributes &amp; Source Generators","text":"<p>Nexus Prime, kod \u00fcretim h\u0131z\u0131 i\u00e7in ileri seviye C# \u00f6zniteliklerini (Attributes) kullan\u0131r:</p> <ul> <li>[Sync]: Bir alan\u0131 hem Unity hem de Nexus taraf\u0131nda otomatik olarak senkronize tutmak i\u00e7in i\u015faretler. Alt\u0131nda otomatik olarak Getter/Setter kancalar\u0131 olu\u015fturur.</li> <li>[ReadOnly]: Verinin sadece Nexus taraf\u0131ndan okunaca\u011f\u0131n\u0131, Unity'ye geri yaz\u0131lmayaca\u011f\u0131n\u0131 belirterek Push i\u015flemini iptal eder ve bant geni\u015fli\u011finden tasarruf sa\u011flar.</li> <li>Source Generator Entegrasyonu: Derleme zaman\u0131nda (Build time), Roslyn Compiler bu \u00f6znitelikleri tarayarak sizin yerinize optimize edilmi\u015f <code>Bridge</code> bellek kopyalama kodlar\u0131n\u0131 otomatik yazar (Boilerplate-free).</li> </ul>"},{"location":"Manuals/UnityBridges_tr/#5-terminoloji-ve-performans-tablosu","title":"5. Terminoloji ve Performans Tablosu","text":"Terim A\u00e7\u0131klama Performans Etkisi Pull Operation Unity'den Nexus'a veri \u00e7ekme yetkisidir. De\u011fi\u015fim yoksa tarama i\u015flemi %80 daha h\u0131zl\u0131d\u0131r. Push Operation Nexus'tan Unity'ye aktar\u0131m yap\u0131lmas\u0131d\u0131r. Yaln\u0131zca kirli (dirty) olanlarda %95 CPU kazanc\u0131 sa\u011flar. Sync Point \u0130ki d\u00fcnyan\u0131n belleksel hizalamada tutuldu\u011fu and\u0131r. Multi-thread asimetrisini ve thread bloklamas\u0131n\u0131 \u00f6nler. Managed Proxy Unmanaged veriyi temsil eden Unity \"View\" s\u0131n\u0131f\u0131d\u0131r. GC yaratmadan (s\u0131f\u0131r allocation) \u00e7al\u0131\u015f\u0131r (Havuzlanm\u0131\u015f)."},{"location":"Manuals/UnityBridges_tr/#6-ozet-ve-iyi-uygulamalar","title":"6. \u00d6zet ve \u0130yi Uygulamalar","text":"<ol> <li>Avoid Full Sync (Tam Senkronizasyondan Ka\u00e7\u0131n\u0131n): Her mekani\u011fi senkronize etmeyin. Sadece g\u00f6rsel (Gfx) kar\u015f\u0131l\u0131\u011f\u0131 olan verileri k\u00f6pr\u00fcye ba\u011flay\u0131n (\u00f6rn: Health de\u011ferini sadece UI g\u00fcncelleniyorsa ittirin).</li> <li>Batch Bridges (Toplu K\u00f6pr\u00fcler): Y\u00f6netimi sistem ba\u015f\u0131na yapmak yerine, <code>BridgeHub</code> kullanarak t\u00fcm senkronizasyonlar\u0131 tek bir merkezi noktadan y\u00f6netin.</li> <li>Visual Debugging (G\u00f6rsel Hata Ay\u0131klama): K\u00f6pr\u00fc \u00fczerinden s\u0131zan veri trafi\u011fini izlemek ve darbo\u011fazlar\u0131 yakalamak i\u00e7in <code>Live State Tweaker</code> arac\u0131n\u0131 kullan\u0131n.</li> </ol> <p>[!TIP] Nexus Prime M\u00fchendislik Notu  Bridge 2.0, bir \"Veri G\u00fcmr\u00fc\u011f\u00fc\" (Data Customs) gibi \u00e7al\u0131\u015f\u0131r. Sadece pasaportu bulunan (Dirty Bit onayl\u0131) verinin girmesine veya \u00e7\u0131kmas\u0131na izin vererek i\u015flemcinin gereksiz kopyalama i\u015fleriyle yorulmas\u0131n\u0131 engeller. Bu mimari, oyununuzun stabil 144+ FPS de\u011ferlerinde kalmas\u0131n\u0131n temel garant\u00f6r\u00fcd\u00fcr.</p>"},{"location":"Tutorials/Tutorial/","title":"The Nexus Architecture: Comprehensive Tutorial &amp; Mastery Guide","text":""},{"location":"Tutorials/Tutorial/#1-introduction","title":"1. Introduction","text":"<p>Welcome to the Nexus Prime Mastery Guide. This document provides an exhaustive, step-by-step tutorial on integrating Nexus Prime into your Unity projects and mastering its high-performance, Data-Oriented Design (DOD) patterns. By following this guide, you will learn how to bypass Unity's managed overhead and unlock the raw mathematical potential of the hardware.</p>"},{"location":"Tutorials/Tutorial/#2-installation-integrating-nexus-with-unity","title":"2. Installation: Integrating Nexus with Unity","text":"<p>Before writing code, Nexus must be integrated into the Unity compilation pipeline.</p>"},{"location":"Tutorials/Tutorial/#step-21-package-architecture","title":"Step 2.1: Package Architecture","text":"<p>Nexus is distributed as an unmanaged <code>.dll</code> or source package.  1. Open Unity's <code>Window -&gt; Package Manager</code>. 2. Select \"Add package from disk...\" or \"Add package from git URL...\". 3. Point to the Nexus Prime repository.</p>"},{"location":"Tutorials/Tutorial/#step-22-scene-initialization","title":"Step 2.2: Scene Initialization","text":"<p>Nexus requires an entry point to hook into the Unity player loop. 1. Create an empty <code>GameObject</code> in your initial scene. 2. Name it <code>[Nexus_Core]</code>. 3. Add the <code>NexusInitializer</code> component. This component intercepts Unity's <code>Update</code>, <code>LateUpdate</code>, and <code>FixedUpdate</code> loops and redirects them to the Nexus <code>JobSystem</code>.</p> <p>[!WARNING] Ensure only one <code>NexusInitializer</code> exists per scene. Multiple initializers will cause memory duplication and undefined mathematical behaviors.</p>"},{"location":"Tutorials/Tutorial/#3-core-concepts-mathematical-foundation","title":"3. Core Concepts &amp; Mathematical Foundation","text":"<p>Nexus discards Object-Oriented Programming (OOP). Instead of objects containing data and logic, we use pure memory arrays. - Entity: An \\(8-byte\\) integer ID. Not an object. - Component: An <code>unmanaged struct</code> containing only data. No logic. - System: A static or parallel function that reads/writes to arrays of components.</p> <p>Mathematical Advantage:  When iterating a <code>GameObject[]</code>, the CPU suffers scattered memory reads (Cache Miss). In Nexus, data is packed sequentially. $\\(T_{iteration} = \\frac{N}{CacheLineSize} \\times CacheMissPenalty\\)$ Nexus forces \\(CacheMissPenalty \\rightarrow 0\\).</p>"},{"location":"Tutorials/Tutorial/#4-scenario-1-the-basic-movement-system","title":"4. Scenario 1: The Basic Movement System","text":"<p>Let's create a system that moves thousands of entities.</p>"},{"location":"Tutorials/Tutorial/#41-defining-components-data","title":"4.1 Defining Components (Data)","text":"<p>All components must be <code>unmanaged</code> (blittable). Avoid classes.</p> <pre><code>// Unmanaged struct defining spatial data\npublic struct Position : unmanaged \n{ \n    public float X, Y, Z; \n}\n\n// Unmanaged struct defining vector forces\npublic struct Velocity : unmanaged \n{ \n    public float Vx, Vy, Vz; \n}\n</code></pre>"},{"location":"Tutorials/Tutorial/#42-spawning-entities-memory-allocation","title":"4.2 Spawning Entities (Memory Allocation)","text":"<pre><code>// Create 10,000 entities instantly in raw memory\nfor(int i = 0; i &lt; 10000; i++)\n{\n    EntityId entity = Registry.Create();\n    Registry.Add(entity, new Position { X = 0, Y = 0, Z = 0 });\n    Registry.Add(entity, new Velocity { Vx = 1, Vy = 0, Vz = 0 });\n}\n</code></pre>"},{"location":"Tutorials/Tutorial/#43-the-system-logic","title":"4.3 The System (Logic)","text":"<p>Instead of <code>MonoBehaviour.Update</code>, we write a Nexus System.</p> <pre><code>public partial class MovementSystem : INexusSystem \n{\n    // Source Generator automatically injects pointers\n    [Write] private Position* _positions;\n    [Read] private Velocity* _velocities;\n\n    public unsafe void Execute() \n    {\n        // Parallel execution over raw pointers\n        NexusHelper.ForEach((ref Position p, ref Velocity v) =&gt; \n        {\n            p.X += v.Vx * Time.deltaTime;\n            p.Y += v.Vy * Time.deltaTime;\n            p.Z += v.Vz * Time.deltaTime;\n        });\n    }\n}\n</code></pre> <pre><code>graph LR\n    A[Velocity Array] --&gt;|SIMD Fetch| C{ALU Addition}\n    B[Position Array] --&gt;|SIMD Fetch| C\n    C --&gt;|Store| B\n    style C fill:#ddffdd</code></pre>"},{"location":"Tutorials/Tutorial/#5-scenario-2-bridging-to-unity-visuals","title":"5. Scenario 2: Bridging to Unity (Visuals)","text":"<p>Nexus calculates math; Unity renders visuals. We use the Bridge 2.0 architecture to synchronize them.</p>"},{"location":"Tutorials/Tutorial/#51-the-sync-component","title":"5.1 The Sync Component","text":"<pre><code>// The [Sync] attribute auto-generates bridge logic\n[Sync]\npublic struct TransformSync : unmanaged \n{\n    public float PosX, PosY, PosZ;\n    public bool IsDirty; // Used to track changes\n}\n</code></pre>"},{"location":"Tutorials/Tutorial/#52-unity-managed-proxy","title":"5.2 Unity Managed Proxy","text":"<p>Attach this to your Unity Prefab: <pre><code>public class NexusView : MonoBehaviour \n{\n    public EntityId LinkedEntity;\n\n    void LateUpdate() \n    {\n        // BridgeHub checks the 'IsDirty' flag and only copies memory if true\n        if (BridgeHub.Pull(LinkedEntity, out TransformSync data)) \n        {\n            transform.position = new Vector3(data.PosX, data.PosY, data.PosZ);\n        }\n    }\n}\n</code></pre></p> Bridge Action Operation CPU Cost Pull Read Nexus -&gt; Write Unity Minimal (if Dirty) Push Read Unity -&gt; Write Nexus Heavy (if blind)"},{"location":"Tutorials/Tutorial/#6-scenario-3-structural-changes-entitycommandbuffer","title":"6. Scenario 3: Structural Changes (EntityCommandBuffer)","text":"<p>Adding components inside a multi-threaded system causes race conditions. We use <code>EntityCommandBuffer</code> (ECB).</p> <pre><code>public unsafe void Execute(EntityCommandBuffer ecb) \n{\n    NexusHelper.ForEach((EntityId id, ref Health h) =&gt; \n    {\n        if (h.Value &lt;= 0) \n        {\n            // Defer destruction to the end of the frame\n            ecb.DestroyEntity(id); \n\n            // Defer spawning explosion\n            EntityId fx = ecb.CreateEntity();\n            ecb.AddComponent(fx, new ExplosionData { Radius = 5.0f });\n        }\n    });\n}\n</code></pre>"},{"location":"Tutorials/Tutorial/#7-summary-best-practices","title":"7. Summary &amp; Best Practices","text":"<ul> <li>Never Allocate in Systems: Avoid <code>new</code> objects. Use the Managed Heap only once during initialization.</li> <li>Data Alignment: Keep structs under 64 bytes if possible to perfectly fit CPU Cache Lines.</li> <li>Profiling: Always benchmark <code>Push/Pull</code> operations; synchronization is where performance dies.</li> </ul>"},{"location":"Tutorials/Tutorial/#_1","title":"Tutorial & Mastery","text":""},{"location":"Tutorials/Tutorial/#nexus-mimarisi-kapsaml-egitim-ve-ustalk-rehberi-tr","title":"Nexus Mimarisi: Kapsaml\u0131 E\u011fitim ve Ustal\u0131k Rehberi (TR)","text":""},{"location":"Tutorials/Tutorial/#1-giris","title":"1. Giri\u015f","text":"<p>Nexus Prime Ustal\u0131k Rehberi'ne ho\u015f geldiniz. Bu belge, Nexus Prime'\u0131 Unity projelerinize entegre etmek ve y\u00fcksek performansl\u0131 Veri Y\u00f6nelimli Tasar\u0131m (DOD) kal\u0131plar\u0131nda ustala\u015fmak i\u00e7in ad\u0131m ad\u0131m, kapsaml\u0131 bir e\u011fitim sunar. Bu rehberi takip ederek, Unity'nin y\u00f6netilen (managed) y\u00fck\u00fcn\u00fc nas\u0131l atlayaca\u011f\u0131n\u0131z\u0131 ve donan\u0131m\u0131n saf matematiksel potansiyelini nas\u0131l ortaya \u00e7\u0131karaca\u011f\u0131n\u0131z\u0131 \u00f6\u011freneceksiniz.</p>"},{"location":"Tutorials/Tutorial/#2-kurulum-nexusu-unityye-entegre-etmek","title":"2. Kurulum: Nexus'u Unity'ye Entegre Etmek","text":"<p>Kod yazmaya ba\u015flamadan \u00f6nce, Nexus'un Unity derleme hatt\u0131na entegre edilmesi gerekir.</p>"},{"location":"Tutorials/Tutorial/#adm-21-paket-mimarisi","title":"Ad\u0131m 2.1: Paket Mimarisi","text":"<p>Nexus, y\u00f6netilmeyen (unmanaged) bir <code>.dll</code> veya kaynak kod paketi olarak da\u011f\u0131t\u0131l\u0131r. 1. Unity'nin <code>Window -&gt; Package Manager</code> men\u00fcs\u00fcn\u00fc a\u00e7\u0131n. 2. \"Add package from disk...\" veya \"Add package from git URL...\" se\u00e7ene\u011fini se\u00e7in. 3. Nexus Prime deposunu/dizinini g\u00f6sterin.</p>"},{"location":"Tutorials/Tutorial/#adm-22-sahne-ilklendirmesi","title":"Ad\u0131m 2.2: Sahne \u0130lklendirmesi","text":"<p>Nexus'un Unity oyun d\u00f6ng\u00fcs\u00fcne (player loop) kanca atabilmesi i\u00e7in bir giri\u015f noktas\u0131na ihtiyac\u0131 vard\u0131r. 1. \u0130lk sahnenizde bo\u015f bir <code>GameObject</code> olu\u015fturun. 2. Ad\u0131n\u0131 <code>[Nexus_Core]</code> yap\u0131n. 3. <code>NexusInitializer</code> bile\u015fenini ekleyin. Bu bile\u015fen Unity'nin <code>Update</code> ve <code>LateUpdate</code> d\u00f6ng\u00fclerini yakalar ve do\u011frudan Nexus <code>JobSystem</code>'ine y\u00f6nlendirir.</p> <p>[!WARNING] Uyar\u0131: Herhnagi bir sahnede yaln\u0131zca bir adet <code>NexusInitializer</code> bulundu\u011fundan emin olun. Birden fazla ba\u015flat\u0131c\u0131 fiziksel bellekte kopyalanmaya ve tan\u0131ms\u0131z matematiksel \u00e7\u00f6k\u00fc\u015flere neden olur.</p>"},{"location":"Tutorials/Tutorial/#3-temel-kavramlar-matematiksel-temel","title":"3. Temel Kavramlar &amp; Matematiksel Temel","text":"<p>Nexus, Nesne Y\u00f6nelimli Programlamay\u0131 (OOP) reddeder. Veri ve mant\u0131\u011f\u0131 i\u00e7eren nesneler (class) yerine, saf bellek dizileri kullan\u0131r\u0131z. - Entity (Varl\u0131k): \\(8-byte\\)'l\u0131k bir tam say\u0131 kimli\u011fidir (ID). Bir nesne de\u011fildir. - Component (Bile\u015fen): Sadece veri i\u00e7eren, mant\u0131k bar\u0131nd\u0131rmayan <code>unmanaged struct</code> (y\u00f6netilmeyen yap\u0131) tipidir. - System (Sistem): Bile\u015fen dizilerini okuyan/yazan statik veya paralel donan\u0131m fonksiyonlar\u0131d\u0131r.</p> <p>Matematiksel Avantaj:  Bir <code>GameObject[]</code> dizisi \u00fczerinde d\u00f6ng\u00fc \u00e7al\u0131\u015ft\u0131r\u0131l\u0131rken, CPU bellekte da\u011f\u0131n\u0131k okumalar yapar (Cache Miss). Nexus'ta veriler ard\u0131\u015f\u0131k olarak s\u0131ms\u0131k\u0131 paketlenir. $\\(T_{iterasyon} = \\frac{N}{CacheLineBoyutu} \\times CacheMissCezasi\\)$ Nexus mimarisi \\(CacheMissCezasi \\rightarrow 0\\) olmas\u0131n\u0131 donan\u0131msal olarak zorlar.</p>"},{"location":"Tutorials/Tutorial/#4-senaryo-1-temel-hareket-sistemi","title":"4. Senaryo 1: Temel Hareket Sistemi","text":"<p>Binlerce varl\u0131\u011f\u0131 hareket ettiren bir sistem yazal\u0131m.</p>"},{"location":"Tutorials/Tutorial/#41-bilesenlerin-tanmlanmas-veri","title":"4.1 Bile\u015fenlerin Tan\u0131mlanmas\u0131 (Veri)","text":"<p>T\u00fcm bile\u015fenler donan\u0131m seviyesinde <code>unmanaged</code> (blittable) olmal\u0131d\u0131r. S\u0131n\u0131f (<code>class</code>) kullanmaktan ka\u00e7\u0131n\u0131n.</p> <pre><code>// Uzaysal verileri tan\u0131mlayan y\u00f6netilmeyen yap\u0131\npublic struct Position : unmanaged \n{ \n    public float X, Y, Z; \n}\n\n// Vekt\u00f6rel kuvvetleri tan\u0131mlayan yap\u0131\npublic struct Velocity : unmanaged \n{ \n    public float Vx, Vy, Vz; \n}\n</code></pre>"},{"location":"Tutorials/Tutorial/#42-varlklarn-uretilmesi-bellek-tahsisi","title":"4.2 Varl\u0131klar\u0131n \u00dcretilmesi (Bellek Tahsisi)","text":"<pre><code>// Ham bellek \u00fczerinde an\u0131nda 10.000 varl\u0131k olu\u015fturun\nfor(int i = 0; i &lt; 10000; i++)\n{\n    EntityId entity = Registry.Create();\n    Registry.Add(entity, new Position { X = 0, Y = 0, Z = 0 });\n    Registry.Add(entity, new Velocity { Vx = 1, Vy = 0, Vz = 0 });\n}\n</code></pre>"},{"location":"Tutorials/Tutorial/#43-sistem-mantk","title":"4.3 Sistem (Mant\u0131k)","text":"<p><code>MonoBehaviour.Update</code> yerine, saf bir Nexus Sistemi yazar\u0131z.</p> <pre><code>public partial class MovementSystem : INexusSystem \n{\n    // Kaynak \u00dcretici (Source Generator) bellek i\u015faret\u00e7ilerini otomatik enjekte eder\n    [Write] private Position* _positions;\n    [Read] private Velocity* _velocities;\n\n    public unsafe void Execute() \n    {\n        // Ham pointer'lar \u00fczerinden paralel y\u00fcr\u00fctme\n        NexusHelper.ForEach((ref Position p, ref Velocity v) =&gt; \n        {\n            p.X += v.Vx * Time.deltaTime;\n            p.Y += v.Vy * Time.deltaTime;\n            p.Z += v.Vz * Time.deltaTime;\n        });\n    }\n}\n</code></pre> <pre><code>graph LR\n    A[Velocity Dizisi] --&gt;|SIMD Veri Cekimi| C{ALU Toplama Islemi}\n    B[Position Dizisi] --&gt;|SIMD Veri Cekimi| C\n    C --&gt;|Sonucu Yaz| B\n    style C fill:#ddffdd</code></pre>"},{"location":"Tutorials/Tutorial/#5-senaryo-2-unityye-kopru-kurmak-gorseller","title":"5. Senaryo 2: Unity'ye K\u00f6pr\u00fc Kurmak (G\u00f6rseller)","text":"<p>Nexus matemati\u011fi hesaplar; Unity ise g\u00f6rselleri i\u015fler. Bu iki d\u00fcnyay\u0131 senkronize etmek i\u00e7in Bridge 2.0 (K\u00f6pr\u00fc) mimarisini kullan\u0131r\u0131z.</p>"},{"location":"Tutorials/Tutorial/#51-senkronizasyon-bileseni","title":"5.1 Senkronizasyon Bile\u015feni","text":"<pre><code>// [Sync] \u00f6zniteli\u011fi k\u00f6pr\u00fc kopyalama kodunu otomatik \u00fcretir\n[Sync]\npublic struct TransformSync : unmanaged \n{\n    public float PosX, PosY, PosZ;\n    public bool IsDirty; // De\u011fi\u015fimleri izlemek i\u00e7in kullan\u0131l\u0131r\n}\n</code></pre>"},{"location":"Tutorials/Tutorial/#52-unity-managed-proxy-yonetilen-vekil","title":"5.2 Unity Managed Proxy (Y\u00f6netilen Vekil)","text":"<p>Bu beti\u011fi Unity Prefab'\u0131n\u0131za ekleyin: <pre><code>public class NexusView : MonoBehaviour \n{\n    public EntityId LinkedEntity;\n\n    void LateUpdate() \n    {\n        // BridgeHub 'IsDirty' bayra\u011f\u0131n\u0131 okur ve sadece de\u011fi\u015fim varsa kopyalar\n        if (BridgeHub.Pull(LinkedEntity, out TransformSync data)) \n        {\n            transform.position = new Vector3(data.PosX, data.PosY, data.PosZ);\n        }\n    }\n}\n</code></pre></p> K\u00f6pr\u00fc Eylemi \u0130\u015flem A\u00e7\u0131klamas\u0131 CPU Maliyeti Pull (\u00c7ekme) Nexus'u Oku -&gt; Unity'ye Yaz Minimum (E\u011fer sadece Dirty bit aktif ise) Push (\u0130tme) Unity'yi Oku -&gt; Nexus'a Yaz Y\u00fcksek (E\u011fer k\u00f6r\u00fc k\u00f6r\u00fcne kopyalan\u0131rsa)"},{"location":"Tutorials/Tutorial/#6-senaryo-3-yapsal-degisimler-entitycommandbuffer","title":"6. Senaryo 3: Yap\u0131sal De\u011fi\u015fimler (EntityCommandBuffer)","text":"<p>E\u015fzamanl\u0131 ve multi-threaded \u00e7al\u0131\u015fan bir sistemin tam ortas\u0131nda belle\u011fe yeni bir bile\u015fen eklemek veri yar\u0131\u015f\u0131na (race condition) yol a\u00e7ar. G\u00fcvenlik i\u00e7in <code>EntityCommandBuffer</code> (ECB) kullan\u0131r\u0131z.</p> <pre><code>public unsafe void Execute(EntityCommandBuffer ecb) \n{\n    NexusHelper.ForEach((EntityId id, ref Health h) =&gt; \n    {\n        if (h.Value &lt;= 0) \n        {\n            // Silme komutunu \u00e7er\u00e7evenin sonuna (Sync Point) ertele\n            ecb.DestroyEntity(id); \n\n            // Yeni varl\u0131k \u00fcretme komutunu ertele\n            EntityId fx = ecb.CreateEntity();\n            ecb.AddComponent(fx, new ExplosionData { Radius = 5.0f });\n        }\n    });\n}\n</code></pre>"},{"location":"Tutorials/Tutorial/#7-ozet-ve-iyi-uygulamalar-best-practices","title":"7. \u00d6zet ve \u0130yi Uygulamalar (Best Practices)","text":"<ul> <li>Sistem \u0130\u00e7i Tahsisat Yapmay\u0131n: <code>new</code> anahtar kelimesini sistemlerin (Execute) i\u00e7inde asla kullanmay\u0131n. Managed Heap'i sadece oyun ba\u015flarken bir kez kullan\u0131n.</li> <li>Veri Hizalamas\u0131: Yap\u0131lar\u0131n (Struct) 64 byte'\u0131n alt\u0131nda kalmas\u0131na \u00f6zen g\u00f6sterin; b\u00f6ylece CPU L1 \u00d6nbellek hatt\u0131na tamamen, milimetrik otururlar.</li> <li>Analiz (Profiling): <code>Push/Pull</code> k\u00f6pr\u00fc operasyonlar\u0131n\u0131n maliyetini daima profilleme ara\u00e7lar\u0131yla izleyin; senkronizasyon performans\u0131n \u00f6ld\u00fc\u011f\u00fc yerdir.</li> </ul>"}]}