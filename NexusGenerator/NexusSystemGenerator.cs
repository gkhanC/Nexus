using System.Collections.Immutable;
using System.Text;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace NexusGenerator;

[Generator]
public class NexusSystemGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax { BaseList: not null },
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        context.RegisterSourceOutput(classDeclarations.Collect(), Execute);
    }

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        foreach (var baseType in classDeclaration.BaseList!.Types)
        {
            if (context.SemanticModel.GetSymbolInfo(baseType.Type).Symbol is INamedTypeSymbol symbol &&
                (symbol.Name == "INexusSystem" || symbol.AllInterfaces.Any(i => i.Name == "INexusSystem")))
            {
                return classDeclaration;
            }
        }

        return null;
    }

    private static void Execute(SourceProductionContext context, ImmutableArray<ClassDeclarationSyntax?> classes)
    {
        if (classes.IsDefaultOrEmpty) return;

        foreach (var classDeclaration in classes.Distinct())
        {
            if (classDeclaration is null) continue;

            var model = context.ToString(); // Dummy
            // For now, let's just generate a simple wrapper to verify it works.
            GenerateSystemWrapper(context, classDeclaration);
        }
    }

    private static void GenerateSystemWrapper(SourceProductionContext context, ClassDeclarationSyntax classDeclaration)
    {
        var className = classDeclaration.Identifier.Text;
        var namespaceName = GetNamespace(classDeclaration);
        
        // 1. Identify Component Fields
        var fields = classDeclaration.Members.OfType<FieldDeclarationSyntax>()
            .Where(f => f.AttributeLists.Any(al => al.Attributes.Any(a => a.Name.ToString() == "Read" || a.Name.ToString() == "Write")))
            .ToList();

        var sb = new StringBuilder();
        sb.AppendLine("using Nexus.Registry;");
        sb.AppendLine("using Nexus.Logic;");
        sb.AppendLine("using System.Runtime.Intrinsics;");
        sb.AppendLine("using System.Runtime.Intrinsics.X86;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName}");
        sb.AppendLine("{");
        sb.AppendLine($"    public partial class {className}");
        sb.AppendLine("    {");
        sb.AppendLine("        /// <summary> High-performance execution entry generated by Nexus. </summary>");
        sb.AppendLine("        public unsafe void Run(Registry registry)");
        sb.AppendLine("        {");
        
        // 2. Setup storage pointers
        foreach (var field in fields)
        {
            var type = field.Declaration.Type.ToString().Replace("*", "");
            var fieldName = field.Declaration.Variables.First().Identifier.Text;
            sb.AppendLine($"            var set_{fieldName} = registry.GetSet<{type}>();");
            sb.AppendLine($"            int count = set_{fieldName}.Count;");
            sb.AppendLine($"            {type}* ptr_{fieldName} = ({type}*)set_{fieldName}.GetRawDense(out _);"); // Simplification for demo
        }

        sb.AppendLine();
        sb.AppendLine("            // Optimized SIMD-aware Loop");
        sb.AppendLine("            int i = 0;");
        sb.AppendLine("            if (Avx.IsSupported && count >= 8)");
        sb.AppendLine("            {");
        sb.AppendLine("                for (; i <= count - 8; i += 8)");
        sb.AppendLine("                {");
        sb.AppendLine("                    // SIMD logic for Vector3/4 would be injected here");
        sb.AppendLine("                    // For now, providing the SIMD fast-path skeleton");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            // Remainder/Standard Loop");
        sb.AppendLine("            for (; i < count; i++)");
        sb.AppendLine("            {");
        sb.AppendLine("                Execute(); // Logic call");
        sb.AppendLine("            }");
        
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource($"{className}_Generated.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static string GetNamespace(ClassDeclarationSyntax classDeclaration)
    {
        var parent = classDeclaration.Parent;
        while (parent != null && parent is not NamespaceDeclarationSyntax && parent is not FileScopedNamespaceDeclarationSyntax)
        {
            parent = parent.Parent;
        }

        if (parent is NamespaceDeclarationSyntax namespaceDeclaration)
            return namespaceDeclaration.Name.ToString();
        if (parent is FileScopedNamespaceDeclarationSyntax fileScopedNamespace)
            return fileScopedNamespace.Name.ToString();

        return "Global";
    }
}
